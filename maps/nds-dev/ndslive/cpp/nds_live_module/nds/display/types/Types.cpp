/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/display/types/DisplayPointType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for DisplayPointType enumeration.
constexpr ::std::array<const char*, 25> EnumTraits<::nds::display::types::DisplayPointType>::names;
constexpr ::std::array<::nds::display::types::DisplayPointType, 25> EnumTraits<::nds::display::types::DisplayPointType>::values;
constexpr const char* EnumTraits<::nds::display::types::DisplayPointType>::enumName;

template <>
size_t enumToOrdinal(::nds::display::types::DisplayPointType value)
{
    switch (value)
    {
    case ::nds::display::types::DisplayPointType::DISPLAY_POINT:
        return 0;
    case ::nds::display::types::DisplayPointType::POINT_MUNICIPALITY_CENTER:
        return 1;
    case ::nds::display::types::DisplayPointType::POINT_MUNICIPALITY_SUBDIVISION_CENTER:
        return 2;
    case ::nds::display::types::DisplayPointType::POINT_HAMLET:
        return 3;
    case ::nds::display::types::DisplayPointType::POINT_MOUNTAIN_PEAK:
        return 4;
    case ::nds::display::types::DisplayPointType::POINT_NEIGHBORHOOD:
        return 5;
    case ::nds::display::types::DisplayPointType::POINT_CONTROLLED_ACCESS_EXIT:
        return 6;
    case ::nds::display::types::DisplayPointType::POINT_CONTROLLED_ACCESS_ENTRY:
        return 7;
    case ::nds::display::types::DisplayPointType::POINT_CONTROLLED_ACCESS_INTERSECTION:
        return 8;
    case ::nds::display::types::DisplayPointType::POINT_COUNTRY:
        return 9;
    case ::nds::display::types::DisplayPointType::POINT_SUB_COUNTRY:
        return 10;
    case ::nds::display::types::DisplayPointType::POINT_TRAFFIC_LIGHT:
        return 11;
    case ::nds::display::types::DisplayPointType::POINT_SEA_OCEAN:
        return 12;
    case ::nds::display::types::DisplayPointType::POINT_SUB_COUNTRY_SET:
        return 13;
    case ::nds::display::types::DisplayPointType::POINT_COUNTY:
        return 14;
    case ::nds::display::types::DisplayPointType::POINT_CITY_BLOCK:
        return 15;
    case ::nds::display::types::DisplayPointType::POINT_ISLAND:
        return 16;
    case ::nds::display::types::DisplayPointType::POINT_AUTONOMOUS_REGION:
        return 17;
    case ::nds::display::types::DisplayPointType::POINT_MUNICIPALITY_CENTER_CAPITAL:
        return 18;
    case ::nds::display::types::DisplayPointType::POINT_MUNICIPALITY_CENTER_CAPITAL_COUNTRY:
        return 19;
    case ::nds::display::types::DisplayPointType::POINT_MUNICIPALITY_CENTER_CAPITAL_SUB_COUNTRY:
        return 20;
    case ::nds::display::types::DisplayPointType::POINT_MUNICIPALITY_CENTER_CAPITAL_COUNTY:
        return 21;
    case ::nds::display::types::DisplayPointType::POINT_MUNICIPALITY_CENTER_CAPITAL_COUNTRY_SET:
        return 22;
    case ::nds::display::types::DisplayPointType::POINT_MUNICIPALITY_CENTER_CAPITAL_SUB_COUNTRY_SET:
        return 23;
    case ::nds::display::types::DisplayPointType::POINT_MUNICIPALITY_CENTER_CAPITAL_ZONE:
        return 24;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration DisplayPointType: ") <<
                static_cast<typename ::std::underlying_type<::nds::display::types::DisplayPointType>::type>(value) << "!";
    }
}

template <>
::nds::display::types::DisplayPointType valueToEnum(
        typename ::std::underlying_type<::nds::display::types::DisplayPointType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT16_C(0):
    case UINT16_C(1):
    case UINT16_C(2):
    case UINT16_C(3):
    case UINT16_C(4):
    case UINT16_C(5):
    case UINT16_C(6):
    case UINT16_C(7):
    case UINT16_C(8):
    case UINT16_C(9):
    case UINT16_C(10):
    case UINT16_C(11):
    case UINT16_C(12):
    case UINT16_C(13):
    case UINT16_C(14):
    case UINT16_C(15):
    case UINT16_C(16):
    case UINT16_C(17):
    case UINT16_C(18):
    case UINT16_C(19):
    case UINT16_C(20):
    case UINT16_C(21):
    case UINT16_C(22):
    case UINT16_C(23):
    case UINT16_C(24):
        return static_cast<::nds::display::types::DisplayPointType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration DisplayPointType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::display::types::DisplayPointType>(::nds::display::types::DisplayPointType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::display::types::DisplayPointType value)
{
    context.init<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::display::types::DisplayPointType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::display::types::DisplayPointType value)
{
    return ::zserio::bitSizeOfVarUInt16(::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::display::types::DisplayPointType value)
{
    return context.bitSizeOf<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::display::types::DisplayPointType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::display::types::DisplayPointType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::display::types::DisplayPointType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::display::types::DisplayPointType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::display::types::DisplayPointType>(
            static_cast<typename ::std::underlying_type<::nds::display::types::DisplayPointType>::type>(
                    in.readVarUInt16()));
}

template <>
::nds::display::types::DisplayPointType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::display::types::DisplayPointType>(context.read<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::display::types::DisplayPointType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::display::types::DisplayPointType value)
{
    out.writeVarUInt16(::zserio::enumToValue(value));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::display::types::DisplayPointType value)
{
    context.write<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::display::types::DisplayPointType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/display/types/DisplayLineType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for DisplayLineType enumeration.
constexpr ::std::array<const char*, 44> EnumTraits<::nds::display::types::DisplayLineType>::names;
constexpr ::std::array<::nds::display::types::DisplayLineType, 44> EnumTraits<::nds::display::types::DisplayLineType>::values;
constexpr const char* EnumTraits<::nds::display::types::DisplayLineType>::enumName;

template <>
size_t enumToOrdinal(::nds::display::types::DisplayLineType value)
{
    switch (value)
    {
    case ::nds::display::types::DisplayLineType::DISPLAY_LINE:
        return 0;
    case ::nds::display::types::DisplayLineType::LINE_ROAD:
        return 1;
    case ::nds::display::types::DisplayLineType::LINE_BLOCK_DETAIL:
        return 2;
    case ::nds::display::types::DisplayLineType::LINE_BUILDING_DETAIL:
        return 3;
    case ::nds::display::types::DisplayLineType::LINE_PUBLIC_TRANSPORT:
        return 4;
    case ::nds::display::types::DisplayLineType::LINE_RAILWAY:
        return 5;
    case ::nds::display::types::DisplayLineType::LINE_RAILWAY_LONG_DISTANCE:
        return 6;
    case ::nds::display::types::DisplayLineType::LINE_RAILWAY_REGIONAL:
        return 7;
    case ::nds::display::types::DisplayLineType::LINE_RAILWAY_LOCAL:
        return 8;
    case ::nds::display::types::DisplayLineType::LINE_SUBWAY:
        return 9;
    case ::nds::display::types::DisplayLineType::LINE_TRAM:
        return 10;
    case ::nds::display::types::DisplayLineType::LINE_MONORAIL:
        return 11;
    case ::nds::display::types::DisplayLineType::LINE_BUS:
        return 12;
    case ::nds::display::types::DisplayLineType::LINE_WATER:
        return 13;
    case ::nds::display::types::DisplayLineType::LINE_CREEK:
        return 14;
    case ::nds::display::types::DisplayLineType::LINE_DRAIN:
        return 15;
    case ::nds::display::types::DisplayLineType::LINE_RIVER:
        return 16;
    case ::nds::display::types::DisplayLineType::LINE_WADI:
        return 17;
    case ::nds::display::types::DisplayLineType::LINE_CANAL:
        return 18;
    case ::nds::display::types::DisplayLineType::LINE_BORDER:
        return 19;
    case ::nds::display::types::DisplayLineType::LINE_BORDER_COUNTRY:
        return 20;
    case ::nds::display::types::DisplayLineType::LINE_BORDER_SUB_COUNTRY_SET:
        return 21;
    case ::nds::display::types::DisplayLineType::LINE_BORDER_SUB_COUNTRY:
        return 22;
    case ::nds::display::types::DisplayLineType::LINE_BORDER_COUNTY:
        return 23;
    case ::nds::display::types::DisplayLineType::LINE_BORDER_MUNICIPALITY:
        return 24;
    case ::nds::display::types::DisplayLineType::LINE_BORDER_MUNICIPALITY_SUBDIVISION:
        return 25;
    case ::nds::display::types::DisplayLineType::LINE_BORDER_NEIGHBORHOOD:
        return 26;
    case ::nds::display::types::DisplayLineType::LINE_BORDER_CITY_BLOCK:
        return 27;
    case ::nds::display::types::DisplayLineType::LINE_BORDER_NON_ADMIN:
        return 28;
    case ::nds::display::types::DisplayLineType::LINE_BORDER_PHONE:
        return 29;
    case ::nds::display::types::DisplayLineType::LINE_BORDER_POSTAL:
        return 30;
    case ::nds::display::types::DisplayLineType::LINE_BORDER_POLICE:
        return 31;
    case ::nds::display::types::DisplayLineType::LINE_BORDER_SCHOOL:
        return 32;
    case ::nds::display::types::DisplayLineType::LINE_TIME_ZONE:
        return 33;
    case ::nds::display::types::DisplayLineType::LINE_BORDER_DISPUTED:
        return 34;
    case ::nds::display::types::DisplayLineType::LINE_BORDER_DISPUTED_COUNTRY:
        return 35;
    case ::nds::display::types::DisplayLineType::LINE_BORDER_DISPUTED_SUB_COUNTRY:
        return 36;
    case ::nds::display::types::DisplayLineType::LINE_BORDER_TREATY_LINE:
        return 37;
    case ::nds::display::types::DisplayLineType::LINE_BORDER_TREATY_LINE_COUNTRY:
        return 38;
    case ::nds::display::types::DisplayLineType::LINE_BORDER_TREATY_LINE_SUB_COUNTRY:
        return 39;
    case ::nds::display::types::DisplayLineType::LINE_SEA_BORDER_COUNTRY:
        return 40;
    case ::nds::display::types::DisplayLineType::LINE_SEA_BORDER_SUB_COUNTRY:
        return 41;
    case ::nds::display::types::DisplayLineType::LINE_BORDER_SPECIAL_ADMIN_REGION:
        return 42;
    case ::nds::display::types::DisplayLineType::LINE_SEA_BORDER_SUB_COUNTRY_SET:
        return 43;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration DisplayLineType: ") <<
                static_cast<typename ::std::underlying_type<::nds::display::types::DisplayLineType>::type>(value) << "!";
    }
}

template <>
::nds::display::types::DisplayLineType valueToEnum(
        typename ::std::underlying_type<::nds::display::types::DisplayLineType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT16_C(0):
    case UINT16_C(1):
    case UINT16_C(2):
    case UINT16_C(3):
    case UINT16_C(4):
    case UINT16_C(5):
    case UINT16_C(6):
    case UINT16_C(7):
    case UINT16_C(8):
    case UINT16_C(9):
    case UINT16_C(10):
    case UINT16_C(11):
    case UINT16_C(12):
    case UINT16_C(13):
    case UINT16_C(14):
    case UINT16_C(15):
    case UINT16_C(16):
    case UINT16_C(17):
    case UINT16_C(18):
    case UINT16_C(19):
    case UINT16_C(20):
    case UINT16_C(21):
    case UINT16_C(22):
    case UINT16_C(23):
    case UINT16_C(24):
    case UINT16_C(25):
    case UINT16_C(26):
    case UINT16_C(27):
    case UINT16_C(28):
    case UINT16_C(29):
    case UINT16_C(30):
    case UINT16_C(31):
    case UINT16_C(32):
    case UINT16_C(33):
    case UINT16_C(34):
    case UINT16_C(35):
    case UINT16_C(36):
    case UINT16_C(37):
    case UINT16_C(38):
    case UINT16_C(39):
    case UINT16_C(40):
    case UINT16_C(41):
    case UINT16_C(42):
    case UINT16_C(43):
        return static_cast<::nds::display::types::DisplayLineType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration DisplayLineType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::display::types::DisplayLineType>(::nds::display::types::DisplayLineType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::display::types::DisplayLineType value)
{
    context.init<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::display::types::DisplayLineType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::display::types::DisplayLineType value)
{
    return ::zserio::bitSizeOfVarUInt16(::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::display::types::DisplayLineType value)
{
    return context.bitSizeOf<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::display::types::DisplayLineType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::display::types::DisplayLineType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::display::types::DisplayLineType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::display::types::DisplayLineType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::display::types::DisplayLineType>(
            static_cast<typename ::std::underlying_type<::nds::display::types::DisplayLineType>::type>(
                    in.readVarUInt16()));
}

template <>
::nds::display::types::DisplayLineType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::display::types::DisplayLineType>(context.read<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::display::types::DisplayLineType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::display::types::DisplayLineType value)
{
    out.writeVarUInt16(::zserio::enumToValue(value));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::display::types::DisplayLineType value)
{
    context.write<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::display::types::DisplayLineType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/display/types/DisplayAreaType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for DisplayAreaType enumeration.
constexpr ::std::array<const char*, 213> EnumTraits<::nds::display::types::DisplayAreaType>::names;
constexpr ::std::array<::nds::display::types::DisplayAreaType, 213> EnumTraits<::nds::display::types::DisplayAreaType>::values;
constexpr const char* EnumTraits<::nds::display::types::DisplayAreaType>::enumName;

template <>
size_t enumToOrdinal(::nds::display::types::DisplayAreaType value)
{
    switch (value)
    {
    case ::nds::display::types::DisplayAreaType::DISPLAY_AREA:
        return 0;
    case ::nds::display::types::DisplayAreaType::AREA_BUILDING:
        return 1;
    case ::nds::display::types::DisplayAreaType::AREA_PRIVATE_HOME_RESIDENTIAL:
        return 2;
    case ::nds::display::types::DisplayAreaType::AREA_COMMERCIAL_BUILDING:
        return 3;
    case ::nds::display::types::DisplayAreaType::AREA_CONVENTION_EXHIBITION_CENTER:
        return 4;
    case ::nds::display::types::DisplayAreaType::AREA_RETAIL_BUILDING:
        return 5;
    case ::nds::display::types::DisplayAreaType::AREA_SHOPPING_CENTER:
        return 6;
    case ::nds::display::types::DisplayAreaType::AREA_PETROL_STATION:
        return 7;
    case ::nds::display::types::DisplayAreaType::AREA_RESTAURANT:
        return 8;
    case ::nds::display::types::DisplayAreaType::AREA_HOTEL_OR_MOTEL:
        return 9;
    case ::nds::display::types::DisplayAreaType::AREA_DAM:
        return 10;
    case ::nds::display::types::DisplayAreaType::AREA_LIGHT_HOUSE:
        return 11;
    case ::nds::display::types::DisplayAreaType::AREA_NO_WALLS:
        return 12;
    case ::nds::display::types::DisplayAreaType::AREA_MULTI_STOREY:
        return 13;
    case ::nds::display::types::DisplayAreaType::AREA_OTHER_FACILITY:
        return 14;
    case ::nds::display::types::DisplayAreaType::AREA_TOWER:
        return 15;
    case ::nds::display::types::DisplayAreaType::AREA_INDUSTRIAL_BUILDING:
        return 16;
    case ::nds::display::types::DisplayAreaType::AREA_TRANSPORTATION_BUILDING:
        return 17;
    case ::nds::display::types::DisplayAreaType::AREA_PUBLIC_BUILDING:
        return 18;
    case ::nds::display::types::DisplayAreaType::AREA_POLICE_OFFICE:
        return 19;
    case ::nds::display::types::DisplayAreaType::AREA_FIRE_DEPARTMENT:
        return 20;
    case ::nds::display::types::DisplayAreaType::AREA_POST_OFFICE:
        return 21;
    case ::nds::display::types::DisplayAreaType::AREA_THEATER:
        return 22;
    case ::nds::display::types::DisplayAreaType::AREA_MUSEUM:
        return 23;
    case ::nds::display::types::DisplayAreaType::AREA_LIBRARY:
        return 24;
    case ::nds::display::types::DisplayAreaType::AREA_INSTITUTION:
        return 25;
    case ::nds::display::types::DisplayAreaType::AREA_RELIGIOUS_BUILDING:
        return 26;
    case ::nds::display::types::DisplayAreaType::AREA_CHURCH:
        return 27;
    case ::nds::display::types::DisplayAreaType::AREA_SYNAGOGUE:
        return 28;
    case ::nds::display::types::DisplayAreaType::AREA_MOSQUE:
        return 29;
    case ::nds::display::types::DisplayAreaType::AREA_TEMPLE:
        return 30;
    case ::nds::display::types::DisplayAreaType::AREA_SHRINE:
        return 31;
    case ::nds::display::types::DisplayAreaType::AREA_ABBEY:
        return 32;
    case ::nds::display::types::DisplayAreaType::AREA_MONASTERY:
        return 33;
    case ::nds::display::types::DisplayAreaType::AREA_BUILDING_GROUND:
        return 34;
    case ::nds::display::types::DisplayAreaType::AREA_PAVED:
        return 35;
    case ::nds::display::types::DisplayAreaType::AREA_SAND:
        return 36;
    case ::nds::display::types::DisplayAreaType::AREA_MEMORIAL_GROUND:
        return 37;
    case ::nds::display::types::DisplayAreaType::AREA_MUSEUM_GROUND:
        return 38;
    case ::nds::display::types::DisplayAreaType::AREA_HOSPITAL_GROUND:
        return 39;
    case ::nds::display::types::DisplayAreaType::AREA_LIBRARY_GROUND:
        return 40;
    case ::nds::display::types::DisplayAreaType::AREA_SCHOOL_GROUND:
        return 41;
    case ::nds::display::types::DisplayAreaType::AREA_STADIUM_GROUND:
        return 42;
    case ::nds::display::types::DisplayAreaType::AREA_GOVERNMENT_OFFICE:
        return 43;
    case ::nds::display::types::DisplayAreaType::AREA_GOVERNMENT_BUILDING:
        return 44;
    case ::nds::display::types::DisplayAreaType::AREA_CITY_HALL:
        return 45;
    case ::nds::display::types::DisplayAreaType::AREA_COURTHOUSE:
        return 46;
    case ::nds::display::types::DisplayAreaType::AREA_PRISON:
        return 47;
    case ::nds::display::types::DisplayAreaType::AREA_SUBWAY_PLATFORM:
        return 48;
    case ::nds::display::types::DisplayAreaType::AREA_SUBWAY_STATION:
        return 49;
    case ::nds::display::types::DisplayAreaType::AREA_SCHEMATIC_BUILDING:
        return 50;
    case ::nds::display::types::DisplayAreaType::AREA_URBAN:
        return 51;
    case ::nds::display::types::DisplayAreaType::AREA_URBAN_BRIDGE:
        return 52;
    case ::nds::display::types::DisplayAreaType::AREA_URBAN_CARRIAGEWAY_DIVIDER:
        return 53;
    case ::nds::display::types::DisplayAreaType::AREA_URBAN_RAILWAY_BRIDGE:
        return 54;
    case ::nds::display::types::DisplayAreaType::AREA_URBAN_RAILWAY_CROSSING:
        return 55;
    case ::nds::display::types::DisplayAreaType::AREA_URBAN_TUNNEL:
        return 56;
    case ::nds::display::types::DisplayAreaType::AREA_URBAN_WALKWAY:
        return 57;
    case ::nds::display::types::DisplayAreaType::AREA_CONTINUOUS_URBAN:
        return 58;
    case ::nds::display::types::DisplayAreaType::AREA_DISCONTINUOUS_URBAN:
        return 59;
    case ::nds::display::types::DisplayAreaType::AREA_ARTIFICIAL:
        return 60;
    case ::nds::display::types::DisplayAreaType::AREA_INDUSTRIAL_COMMERCIAL_TRANSPORT:
        return 61;
    case ::nds::display::types::DisplayAreaType::AREA_INDUSTRIAL_COMMERCIAL_UNITS:
        return 62;
    case ::nds::display::types::DisplayAreaType::AREA_MILITARY_BASE:
        return 63;
    case ::nds::display::types::DisplayAreaType::AREA_TRAFFIC:
        return 64;
    case ::nds::display::types::DisplayAreaType::AREA_TRAFFIC_PEDESTRIAN:
        return 65;
    case ::nds::display::types::DisplayAreaType::AREA_TRAFFIC_ROAD:
        return 66;
    case ::nds::display::types::DisplayAreaType::AREA_TRAFFIC_RAILWAY:
        return 67;
    case ::nds::display::types::DisplayAreaType::AREA_TRAFFIC_PARKING:
        return 68;
    case ::nds::display::types::DisplayAreaType::AREA_TRAFFIC_PARKING_GARAGE:
        return 69;
    case ::nds::display::types::DisplayAreaType::AREA_TRAFFIC_PARKING_LOT:
        return 70;
    case ::nds::display::types::DisplayAreaType::AREA_CAR_RACETRACK:
        return 71;
    case ::nds::display::types::DisplayAreaType::AREA_UNDERPASS:
        return 72;
    case ::nds::display::types::DisplayAreaType::AREA_CENTER:
        return 73;
    case ::nds::display::types::DisplayAreaType::AREA_CITY_MAP_COVERAGE:
        return 74;
    case ::nds::display::types::DisplayAreaType::AREA_PERIPHERY:
        return 75;
    case ::nds::display::types::DisplayAreaType::AREA_POSTAL_DISTRICT:
        return 76;
    case ::nds::display::types::DisplayAreaType::AREA_GARDEN_PATH:
        return 77;
    case ::nds::display::types::DisplayAreaType::AREA_PORT_FACILITIES:
        return 78;
    case ::nds::display::types::DisplayAreaType::AREA_AIRPORT:
        return 79;
    case ::nds::display::types::DisplayAreaType::AREA_AIRPORT_RUNWAY:
        return 80;
    case ::nds::display::types::DisplayAreaType::AREA_MINE_DUMP:
        return 81;
    case ::nds::display::types::DisplayAreaType::AREA_MINERAL_EXTRACTION_SITE:
        return 82;
    case ::nds::display::types::DisplayAreaType::AREA_DUMP:
        return 83;
    case ::nds::display::types::DisplayAreaType::AREA_CONSTRUCTION:
        return 84;
    case ::nds::display::types::DisplayAreaType::AREA_VEGETATED:
        return 85;
    case ::nds::display::types::DisplayAreaType::AREA_GREEN_URBAN:
        return 86;
    case ::nds::display::types::DisplayAreaType::AREA_PARK:
        return 87;
    case ::nds::display::types::DisplayAreaType::AREA_CEMETERY:
        return 88;
    case ::nds::display::types::DisplayAreaType::AREA_SPORT_LEISURE:
        return 89;
    case ::nds::display::types::DisplayAreaType::AREA_SPORTS_COMPLEX:
        return 90;
    case ::nds::display::types::DisplayAreaType::AREA_AMUSEMENT_PARK:
        return 91;
    case ::nds::display::types::DisplayAreaType::AREA_ARTS_CENTER:
        return 92;
    case ::nds::display::types::DisplayAreaType::AREA_CAMPING_SITE:
        return 93;
    case ::nds::display::types::DisplayAreaType::AREA_GOLF_COURSE:
        return 94;
    case ::nds::display::types::DisplayAreaType::AREA_HIPPODROME:
        return 95;
    case ::nds::display::types::DisplayAreaType::AREA_HOLIDAY:
        return 96;
    case ::nds::display::types::DisplayAreaType::AREA_RECREATIONAL:
        return 97;
    case ::nds::display::types::DisplayAreaType::AREA_REST_AREA:
        return 98;
    case ::nds::display::types::DisplayAreaType::AREA_SPORTS_HALL:
        return 99;
    case ::nds::display::types::DisplayAreaType::AREA_STADIUM:
        return 100;
    case ::nds::display::types::DisplayAreaType::AREA_WALKING_TERRAIN:
        return 101;
    case ::nds::display::types::DisplayAreaType::AREA_ZOO:
        return 102;
    case ::nds::display::types::DisplayAreaType::AREA_SKI:
        return 103;
    case ::nds::display::types::DisplayAreaType::AREA_SWIMMING_POOL:
        return 104;
    case ::nds::display::types::DisplayAreaType::AREA_RAILWAY_STATION:
        return 105;
    case ::nds::display::types::DisplayAreaType::AREA_FERRY_TERMINAL:
        return 106;
    case ::nds::display::types::DisplayAreaType::AREA_BUS_STATION:
        return 107;
    case ::nds::display::types::DisplayAreaType::AREA_MARINA:
        return 108;
    case ::nds::display::types::DisplayAreaType::AREA_AGRICULTURAL:
        return 109;
    case ::nds::display::types::DisplayAreaType::AREA_ARABLE:
        return 110;
    case ::nds::display::types::DisplayAreaType::AREA_NON_IRRIGATED:
        return 111;
    case ::nds::display::types::DisplayAreaType::AREA_PERMANENTLY_IRRIGATED:
        return 112;
    case ::nds::display::types::DisplayAreaType::AREA_RICE_FIELD:
        return 113;
    case ::nds::display::types::DisplayAreaType::AREA_PERMANENT_CROP:
        return 114;
    case ::nds::display::types::DisplayAreaType::AREA_TREE_BERRY_PLANTATION:
        return 115;
    case ::nds::display::types::DisplayAreaType::AREA_VINEYARD:
        return 116;
    case ::nds::display::types::DisplayAreaType::AREA_OLIVE_GROVES:
        return 117;
    case ::nds::display::types::DisplayAreaType::AREA_HETEROGENEOUS:
        return 118;
    case ::nds::display::types::DisplayAreaType::AREA_COMPLEX_CULTIVATION:
        return 119;
    case ::nds::display::types::DisplayAreaType::AREA_ANNUAL_PERMANENT:
        return 120;
    case ::nds::display::types::DisplayAreaType::AREA_AGRO_FORESTRY:
        return 121;
    case ::nds::display::types::DisplayAreaType::AREA_AGRICULTURAL_AND_NATURAL:
        return 122;
    case ::nds::display::types::DisplayAreaType::AREA_PASTURE_RANGELAND:
        return 123;
    case ::nds::display::types::DisplayAreaType::AREA_PASTURE:
        return 124;
    case ::nds::display::types::DisplayAreaType::AREA_RANGELAND:
        return 125;
    case ::nds::display::types::DisplayAreaType::AREA_FOREST_SEMI_NATURAL:
        return 126;
    case ::nds::display::types::DisplayAreaType::AREA_FOREST:
        return 127;
    case ::nds::display::types::DisplayAreaType::AREA_LEAVED_FOREST:
        return 128;
    case ::nds::display::types::DisplayAreaType::AREA_CONIFEROUS:
        return 129;
    case ::nds::display::types::DisplayAreaType::AREA_MIXED_FOREST:
        return 130;
    case ::nds::display::types::DisplayAreaType::AREA_SCRUB:
        return 131;
    case ::nds::display::types::DisplayAreaType::AREA_GRASSLAND:
        return 132;
    case ::nds::display::types::DisplayAreaType::AREA_MOOR_HEATH:
        return 133;
    case ::nds::display::types::DisplayAreaType::AREA_SCLEROPHYLLOUS:
        return 134;
    case ::nds::display::types::DisplayAreaType::AREA_WOODLAND:
        return 135;
    case ::nds::display::types::DisplayAreaType::AREA_OPEN_SPACE:
        return 136;
    case ::nds::display::types::DisplayAreaType::AREA_ROCK:
        return 137;
    case ::nds::display::types::DisplayAreaType::AREA_GLACIER:
        return 138;
    case ::nds::display::types::DisplayAreaType::AREA_BURNT:
        return 139;
    case ::nds::display::types::DisplayAreaType::AREA_SPARSELY_VEGETATED:
        return 140;
    case ::nds::display::types::DisplayAreaType::AREA_BEACH_DUNE:
        return 141;
    case ::nds::display::types::DisplayAreaType::AREA_WETLAND:
        return 142;
    case ::nds::display::types::DisplayAreaType::AREA_INLAND_WETLAND:
        return 143;
    case ::nds::display::types::DisplayAreaType::AREA_INLAND_MARSH:
        return 144;
    case ::nds::display::types::DisplayAreaType::AREA_PEATBOG:
        return 145;
    case ::nds::display::types::DisplayAreaType::AREA_FORESTED_WETLAND:
        return 146;
    case ::nds::display::types::DisplayAreaType::AREA_COASTAL_WETLAND:
        return 147;
    case ::nds::display::types::DisplayAreaType::AREA_SALT_MARSH:
        return 148;
    case ::nds::display::types::DisplayAreaType::AREA_SALINE:
        return 149;
    case ::nds::display::types::DisplayAreaType::AREA_INTERTIDAL_FLAT:
        return 150;
    case ::nds::display::types::DisplayAreaType::AREA_ISLAND:
        return 151;
    case ::nds::display::types::DisplayAreaType::AREA_WATER:
        return 152;
    case ::nds::display::types::DisplayAreaType::AREA_INLAND_WATER:
        return 153;
    case ::nds::display::types::DisplayAreaType::AREA_RIVER:
        return 154;
    case ::nds::display::types::DisplayAreaType::AREA_CANAL:
        return 155;
    case ::nds::display::types::DisplayAreaType::AREA_LAKE:
        return 156;
    case ::nds::display::types::DisplayAreaType::AREA_RESERVOIR:
        return 157;
    case ::nds::display::types::DisplayAreaType::AREA_BASIN:
        return 158;
    case ::nds::display::types::DisplayAreaType::AREA_WADI:
        return 159;
    case ::nds::display::types::DisplayAreaType::AREA_MARINE_WATER:
        return 160;
    case ::nds::display::types::DisplayAreaType::AREA_SEA_OCEAN:
        return 161;
    case ::nds::display::types::DisplayAreaType::AREA_COASTAL_LAGOON:
        return 162;
    case ::nds::display::types::DisplayAreaType::AREA_ESTUARY:
        return 163;
    case ::nds::display::types::DisplayAreaType::AREA_ADMIN:
        return 164;
    case ::nds::display::types::DisplayAreaType::AREA_COUNTRY:
        return 165;
    case ::nds::display::types::DisplayAreaType::AREA_SUB_COUNTRY_SET:
        return 166;
    case ::nds::display::types::DisplayAreaType::AREA_SUB_COUNTRY:
        return 167;
    case ::nds::display::types::DisplayAreaType::AREA_COUNTY:
        return 168;
    case ::nds::display::types::DisplayAreaType::AREA_MUNICIPALITY:
        return 169;
    case ::nds::display::types::DisplayAreaType::AREA_MUNICIPALITY_SUBDIVISION:
        return 170;
    case ::nds::display::types::DisplayAreaType::AREA_NEIGHBORHOOD:
        return 171;
    case ::nds::display::types::DisplayAreaType::AREA_CITY_BLOCK:
        return 172;
    case ::nds::display::types::DisplayAreaType::AREA_ADMIN_AUTONOMOUS:
        return 173;
    case ::nds::display::types::DisplayAreaType::AREA_NATIVE_TRIBE_RESERVATION:
        return 174;
    case ::nds::display::types::DisplayAreaType::AREA_CONTOUR:
        return 175;
    case ::nds::display::types::DisplayAreaType::AREA_NATIONAL_PARK:
        return 176;
    case ::nds::display::types::DisplayAreaType::AREA_ENVIRONMENTAL_ZONE:
        return 177;
    case ::nds::display::types::DisplayAreaType::AREA_TOLL_ZONE:
        return 178;
    case ::nds::display::types::DisplayAreaType::AREA_EDUCATION_BUILDING:
        return 179;
    case ::nds::display::types::DisplayAreaType::AREA_SCHOOL:
        return 180;
    case ::nds::display::types::DisplayAreaType::AREA_UNIVERSITY_OR_COLLEGE:
        return 181;
    case ::nds::display::types::DisplayAreaType::AREA_MEDICAL_BUILDING:
        return 182;
    case ::nds::display::types::DisplayAreaType::AREA_HOSPITAL:
        return 183;
    case ::nds::display::types::DisplayAreaType::AREA_EMERGENCY_SERVICE:
        return 184;
    case ::nds::display::types::DisplayAreaType::AREA_CULTURE_BUILDING:
        return 185;
    case ::nds::display::types::DisplayAreaType::AREA_HISTORICAL_BUILDING:
        return 186;
    case ::nds::display::types::DisplayAreaType::AREA_TOURIST_BUILDING:
        return 187;
    case ::nds::display::types::DisplayAreaType::AREA_CASTLE:
        return 188;
    case ::nds::display::types::DisplayAreaType::AREA_FORTRESS:
        return 189;
    case ::nds::display::types::DisplayAreaType::AREA_MONUMENT:
        return 190;
    case ::nds::display::types::DisplayAreaType::AREA_VIEW:
        return 191;
    case ::nds::display::types::DisplayAreaType::AREA_WATERMILL:
        return 192;
    case ::nds::display::types::DisplayAreaType::AREA_WINDMILL:
        return 193;
    case ::nds::display::types::DisplayAreaType::AREA_LEISURE_BUILDING:
        return 194;
    case ::nds::display::types::DisplayAreaType::AREA_SPORT_BUILDING:
        return 195;
    case ::nds::display::types::DisplayAreaType::AREA_TERRAIN:
        return 196;
    case ::nds::display::types::DisplayAreaType::AREA_TRAFFIC_ROAD_PEDESTRIAN_CROSSING:
        return 197;
    case ::nds::display::types::DisplayAreaType::AREA_TRAFFIC_ROAD_STOP_ZONE:
        return 198;
    case ::nds::display::types::DisplayAreaType::AREA_TRAFFIC_ROAD_DECORATION:
        return 199;
    case ::nds::display::types::DisplayAreaType::AREA_TRAFFIC_ROAD_STOP_LINE:
        return 200;
    case ::nds::display::types::DisplayAreaType::AREA_TRAFFIC_ROAD_RESTRICTION:
        return 201;
    case ::nds::display::types::DisplayAreaType::AREA_TRAFFIC_LANE:
        return 202;
    case ::nds::display::types::DisplayAreaType::AREA_TRAFFIC_LANE_MARKING:
        return 203;
    case ::nds::display::types::DisplayAreaType::AREA_TRAFFIC_LANE_SEPARATOR_MARKING:
        return 204;
    case ::nds::display::types::DisplayAreaType::AREA_TRAFFIC_LANE_BICYCLE:
        return 205;
    case ::nds::display::types::DisplayAreaType::AREA_TRAFFIC_LANE_BUS:
        return 206;
    case ::nds::display::types::DisplayAreaType::AREA_TRAFFIC_LANE_TAXI:
        return 207;
    case ::nds::display::types::DisplayAreaType::AREA_TRAFFIC_LANE_HOV:
        return 208;
    case ::nds::display::types::DisplayAreaType::AREA_TRAFFIC_LANE_TOLL:
        return 209;
    case ::nds::display::types::DisplayAreaType::AREA_TRAFFIC_LANE_TOLL_ETC:
        return 210;
    case ::nds::display::types::DisplayAreaType::AREA_TRAFFIC_PARKING_ROW:
        return 211;
    case ::nds::display::types::DisplayAreaType::AREA_TRAFFIC_PARKING_SPOT:
        return 212;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration DisplayAreaType: ") <<
                static_cast<typename ::std::underlying_type<::nds::display::types::DisplayAreaType>::type>(value) << "!";
    }
}

template <>
::nds::display::types::DisplayAreaType valueToEnum(
        typename ::std::underlying_type<::nds::display::types::DisplayAreaType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT16_C(0):
    case UINT16_C(1):
    case UINT16_C(2):
    case UINT16_C(3):
    case UINT16_C(4):
    case UINT16_C(5):
    case UINT16_C(6):
    case UINT16_C(7):
    case UINT16_C(8):
    case UINT16_C(9):
    case UINT16_C(10):
    case UINT16_C(11):
    case UINT16_C(12):
    case UINT16_C(13):
    case UINT16_C(14):
    case UINT16_C(15):
    case UINT16_C(16):
    case UINT16_C(17):
    case UINT16_C(18):
    case UINT16_C(19):
    case UINT16_C(20):
    case UINT16_C(21):
    case UINT16_C(22):
    case UINT16_C(23):
    case UINT16_C(24):
    case UINT16_C(25):
    case UINT16_C(26):
    case UINT16_C(27):
    case UINT16_C(28):
    case UINT16_C(29):
    case UINT16_C(30):
    case UINT16_C(31):
    case UINT16_C(32):
    case UINT16_C(33):
    case UINT16_C(34):
    case UINT16_C(35):
    case UINT16_C(36):
    case UINT16_C(37):
    case UINT16_C(38):
    case UINT16_C(39):
    case UINT16_C(40):
    case UINT16_C(41):
    case UINT16_C(42):
    case UINT16_C(43):
    case UINT16_C(44):
    case UINT16_C(45):
    case UINT16_C(46):
    case UINT16_C(47):
    case UINT16_C(48):
    case UINT16_C(49):
    case UINT16_C(50):
    case UINT16_C(51):
    case UINT16_C(52):
    case UINT16_C(53):
    case UINT16_C(54):
    case UINT16_C(55):
    case UINT16_C(56):
    case UINT16_C(57):
    case UINT16_C(58):
    case UINT16_C(59):
    case UINT16_C(60):
    case UINT16_C(61):
    case UINT16_C(62):
    case UINT16_C(63):
    case UINT16_C(64):
    case UINT16_C(65):
    case UINT16_C(66):
    case UINT16_C(67):
    case UINT16_C(68):
    case UINT16_C(69):
    case UINT16_C(70):
    case UINT16_C(71):
    case UINT16_C(72):
    case UINT16_C(73):
    case UINT16_C(74):
    case UINT16_C(75):
    case UINT16_C(76):
    case UINT16_C(77):
    case UINT16_C(78):
    case UINT16_C(79):
    case UINT16_C(80):
    case UINT16_C(81):
    case UINT16_C(82):
    case UINT16_C(83):
    case UINT16_C(84):
    case UINT16_C(85):
    case UINT16_C(86):
    case UINT16_C(87):
    case UINT16_C(88):
    case UINT16_C(89):
    case UINT16_C(90):
    case UINT16_C(91):
    case UINT16_C(92):
    case UINT16_C(93):
    case UINT16_C(94):
    case UINT16_C(95):
    case UINT16_C(96):
    case UINT16_C(97):
    case UINT16_C(98):
    case UINT16_C(99):
    case UINT16_C(100):
    case UINT16_C(101):
    case UINT16_C(102):
    case UINT16_C(103):
    case UINT16_C(104):
    case UINT16_C(105):
    case UINT16_C(106):
    case UINT16_C(107):
    case UINT16_C(108):
    case UINT16_C(109):
    case UINT16_C(110):
    case UINT16_C(111):
    case UINT16_C(112):
    case UINT16_C(113):
    case UINT16_C(114):
    case UINT16_C(115):
    case UINT16_C(116):
    case UINT16_C(117):
    case UINT16_C(118):
    case UINT16_C(119):
    case UINT16_C(120):
    case UINT16_C(121):
    case UINT16_C(122):
    case UINT16_C(123):
    case UINT16_C(124):
    case UINT16_C(125):
    case UINT16_C(126):
    case UINT16_C(127):
    case UINT16_C(128):
    case UINT16_C(129):
    case UINT16_C(130):
    case UINT16_C(131):
    case UINT16_C(132):
    case UINT16_C(133):
    case UINT16_C(134):
    case UINT16_C(135):
    case UINT16_C(136):
    case UINT16_C(137):
    case UINT16_C(138):
    case UINT16_C(139):
    case UINT16_C(140):
    case UINT16_C(141):
    case UINT16_C(142):
    case UINT16_C(143):
    case UINT16_C(144):
    case UINT16_C(145):
    case UINT16_C(146):
    case UINT16_C(147):
    case UINT16_C(148):
    case UINT16_C(149):
    case UINT16_C(150):
    case UINT16_C(151):
    case UINT16_C(152):
    case UINT16_C(153):
    case UINT16_C(154):
    case UINT16_C(155):
    case UINT16_C(156):
    case UINT16_C(157):
    case UINT16_C(158):
    case UINT16_C(159):
    case UINT16_C(160):
    case UINT16_C(161):
    case UINT16_C(162):
    case UINT16_C(163):
    case UINT16_C(164):
    case UINT16_C(165):
    case UINT16_C(166):
    case UINT16_C(167):
    case UINT16_C(168):
    case UINT16_C(169):
    case UINT16_C(170):
    case UINT16_C(171):
    case UINT16_C(172):
    case UINT16_C(173):
    case UINT16_C(174):
    case UINT16_C(175):
    case UINT16_C(176):
    case UINT16_C(177):
    case UINT16_C(178):
    case UINT16_C(179):
    case UINT16_C(180):
    case UINT16_C(181):
    case UINT16_C(182):
    case UINT16_C(183):
    case UINT16_C(184):
    case UINT16_C(185):
    case UINT16_C(186):
    case UINT16_C(187):
    case UINT16_C(188):
    case UINT16_C(189):
    case UINT16_C(190):
    case UINT16_C(191):
    case UINT16_C(192):
    case UINT16_C(193):
    case UINT16_C(194):
    case UINT16_C(195):
    case UINT16_C(196):
    case UINT16_C(197):
    case UINT16_C(198):
    case UINT16_C(199):
    case UINT16_C(200):
    case UINT16_C(201):
    case UINT16_C(202):
    case UINT16_C(203):
    case UINT16_C(204):
    case UINT16_C(205):
    case UINT16_C(206):
    case UINT16_C(207):
    case UINT16_C(208):
    case UINT16_C(209):
    case UINT16_C(210):
    case UINT16_C(211):
    case UINT16_C(212):
        return static_cast<::nds::display::types::DisplayAreaType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration DisplayAreaType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::display::types::DisplayAreaType>(::nds::display::types::DisplayAreaType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::display::types::DisplayAreaType value)
{
    context.init<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::display::types::DisplayAreaType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::display::types::DisplayAreaType value)
{
    return ::zserio::bitSizeOfVarUInt16(::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::display::types::DisplayAreaType value)
{
    return context.bitSizeOf<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::display::types::DisplayAreaType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::display::types::DisplayAreaType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::display::types::DisplayAreaType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::display::types::DisplayAreaType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::display::types::DisplayAreaType>(
            static_cast<typename ::std::underlying_type<::nds::display::types::DisplayAreaType>::type>(
                    in.readVarUInt16()));
}

template <>
::nds::display::types::DisplayAreaType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::display::types::DisplayAreaType>(context.read<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::display::types::DisplayAreaType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::display::types::DisplayAreaType value)
{
    out.writeVarUInt16(::zserio::enumToValue(value));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::display::types::DisplayAreaType value)
{
    context.write<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::display::types::DisplayAreaType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/display/types/DisplayMesh3dType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for DisplayMesh3dType enumeration.
constexpr ::std::array<const char*, 213> EnumTraits<::nds::display::types::DisplayMesh3dType>::names;
constexpr ::std::array<::nds::display::types::DisplayMesh3dType, 213> EnumTraits<::nds::display::types::DisplayMesh3dType>::values;
constexpr const char* EnumTraits<::nds::display::types::DisplayMesh3dType>::enumName;

template <>
size_t enumToOrdinal(::nds::display::types::DisplayMesh3dType value)
{
    switch (value)
    {
    case ::nds::display::types::DisplayMesh3dType::MESH_3D:
        return 0;
    case ::nds::display::types::DisplayMesh3dType::BUILDING:
        return 1;
    case ::nds::display::types::DisplayMesh3dType::PRIVATE_HOME_RESIDENTIAL:
        return 2;
    case ::nds::display::types::DisplayMesh3dType::COMMERCIAL_BUILDING:
        return 3;
    case ::nds::display::types::DisplayMesh3dType::CONVENTION_EXHIBITION_CENTER:
        return 4;
    case ::nds::display::types::DisplayMesh3dType::RETAIL_BUILDING:
        return 5;
    case ::nds::display::types::DisplayMesh3dType::SHOPPING_CENTER:
        return 6;
    case ::nds::display::types::DisplayMesh3dType::PETROL_STATION:
        return 7;
    case ::nds::display::types::DisplayMesh3dType::RESTAURANT:
        return 8;
    case ::nds::display::types::DisplayMesh3dType::HOTEL_OR_MOTEL:
        return 9;
    case ::nds::display::types::DisplayMesh3dType::DAM:
        return 10;
    case ::nds::display::types::DisplayMesh3dType::LIGHT_HOUSE:
        return 11;
    case ::nds::display::types::DisplayMesh3dType::NO_WALLS:
        return 12;
    case ::nds::display::types::DisplayMesh3dType::MULTI_STOREY:
        return 13;
    case ::nds::display::types::DisplayMesh3dType::OTHER_FACILITY:
        return 14;
    case ::nds::display::types::DisplayMesh3dType::TOWER:
        return 15;
    case ::nds::display::types::DisplayMesh3dType::INDUSTRIAL_BUILDING:
        return 16;
    case ::nds::display::types::DisplayMesh3dType::TRANSPORTATION_BUILDING:
        return 17;
    case ::nds::display::types::DisplayMesh3dType::PUBLIC_BUILDING:
        return 18;
    case ::nds::display::types::DisplayMesh3dType::POLICE_OFFICE:
        return 19;
    case ::nds::display::types::DisplayMesh3dType::FIRE_DEPARTMENT:
        return 20;
    case ::nds::display::types::DisplayMesh3dType::POST_OFFICE:
        return 21;
    case ::nds::display::types::DisplayMesh3dType::THEATER:
        return 22;
    case ::nds::display::types::DisplayMesh3dType::MUSEUM:
        return 23;
    case ::nds::display::types::DisplayMesh3dType::LIBRARY:
        return 24;
    case ::nds::display::types::DisplayMesh3dType::INSTITUTION:
        return 25;
    case ::nds::display::types::DisplayMesh3dType::RELIGIOUS_BUILDING:
        return 26;
    case ::nds::display::types::DisplayMesh3dType::CHURCH:
        return 27;
    case ::nds::display::types::DisplayMesh3dType::SYNAGOGUE:
        return 28;
    case ::nds::display::types::DisplayMesh3dType::MOSQUE:
        return 29;
    case ::nds::display::types::DisplayMesh3dType::TEMPLE:
        return 30;
    case ::nds::display::types::DisplayMesh3dType::SHRINE:
        return 31;
    case ::nds::display::types::DisplayMesh3dType::ABBEY:
        return 32;
    case ::nds::display::types::DisplayMesh3dType::MONASTERY:
        return 33;
    case ::nds::display::types::DisplayMesh3dType::BUILDING_GROUND:
        return 34;
    case ::nds::display::types::DisplayMesh3dType::PAVED:
        return 35;
    case ::nds::display::types::DisplayMesh3dType::SAND:
        return 36;
    case ::nds::display::types::DisplayMesh3dType::MEMORIAL_GROUND:
        return 37;
    case ::nds::display::types::DisplayMesh3dType::MUSEUM_GROUND:
        return 38;
    case ::nds::display::types::DisplayMesh3dType::HOSPITAL_GROUND:
        return 39;
    case ::nds::display::types::DisplayMesh3dType::LIBRARY_GROUND:
        return 40;
    case ::nds::display::types::DisplayMesh3dType::SCHOOL_GROUND:
        return 41;
    case ::nds::display::types::DisplayMesh3dType::STADIUM_GROUND:
        return 42;
    case ::nds::display::types::DisplayMesh3dType::GOVERNMENT_OFFICE:
        return 43;
    case ::nds::display::types::DisplayMesh3dType::GOVERNMENT_BUILDING:
        return 44;
    case ::nds::display::types::DisplayMesh3dType::CITY_HALL:
        return 45;
    case ::nds::display::types::DisplayMesh3dType::COURTHOUSE:
        return 46;
    case ::nds::display::types::DisplayMesh3dType::PRISON:
        return 47;
    case ::nds::display::types::DisplayMesh3dType::SUBWAY_PLATFORM:
        return 48;
    case ::nds::display::types::DisplayMesh3dType::SUBWAY_STATION:
        return 49;
    case ::nds::display::types::DisplayMesh3dType::SCHEMATIC_BUILDING:
        return 50;
    case ::nds::display::types::DisplayMesh3dType::URBAN:
        return 51;
    case ::nds::display::types::DisplayMesh3dType::URBAN_BRIDGE:
        return 52;
    case ::nds::display::types::DisplayMesh3dType::URBAN_CARRIAGEWAY_DIVIDER:
        return 53;
    case ::nds::display::types::DisplayMesh3dType::URBAN_RAILWAY_BRIDGE:
        return 54;
    case ::nds::display::types::DisplayMesh3dType::URBAN_RAILWAY_CROSSING:
        return 55;
    case ::nds::display::types::DisplayMesh3dType::URBAN_TUNNEL:
        return 56;
    case ::nds::display::types::DisplayMesh3dType::URBAN_WALKWAY:
        return 57;
    case ::nds::display::types::DisplayMesh3dType::CONTINUOUS_URBAN:
        return 58;
    case ::nds::display::types::DisplayMesh3dType::DISCONTINUOUS_URBAN:
        return 59;
    case ::nds::display::types::DisplayMesh3dType::ARTIFICIAL:
        return 60;
    case ::nds::display::types::DisplayMesh3dType::INDUSTRIAL_COMMERCIAL_TRANSPORT:
        return 61;
    case ::nds::display::types::DisplayMesh3dType::INDUSTRIAL_COMMERCIAL_UNITS:
        return 62;
    case ::nds::display::types::DisplayMesh3dType::MILITARY_BASE:
        return 63;
    case ::nds::display::types::DisplayMesh3dType::TRAFFIC:
        return 64;
    case ::nds::display::types::DisplayMesh3dType::TRAFFIC_PEDESTRIAN:
        return 65;
    case ::nds::display::types::DisplayMesh3dType::TRAFFIC_ROAD:
        return 66;
    case ::nds::display::types::DisplayMesh3dType::TRAFFIC_RAILWAY:
        return 67;
    case ::nds::display::types::DisplayMesh3dType::TRAFFIC_PARKING:
        return 68;
    case ::nds::display::types::DisplayMesh3dType::TRAFFIC_PARKING_GARAGE:
        return 69;
    case ::nds::display::types::DisplayMesh3dType::TRAFFIC_PARKING_LOT:
        return 70;
    case ::nds::display::types::DisplayMesh3dType::CAR_RACETRACK:
        return 71;
    case ::nds::display::types::DisplayMesh3dType::UNDERPASS:
        return 72;
    case ::nds::display::types::DisplayMesh3dType::CENTER:
        return 73;
    case ::nds::display::types::DisplayMesh3dType::CITY_MAP_COVERAGE:
        return 74;
    case ::nds::display::types::DisplayMesh3dType::PERIPHERY:
        return 75;
    case ::nds::display::types::DisplayMesh3dType::POSTAL_DISTRICT:
        return 76;
    case ::nds::display::types::DisplayMesh3dType::GARDEN_PATH:
        return 77;
    case ::nds::display::types::DisplayMesh3dType::PORT_FACILITIES:
        return 78;
    case ::nds::display::types::DisplayMesh3dType::AIRPORT:
        return 79;
    case ::nds::display::types::DisplayMesh3dType::AIRPORT_RUNWAY:
        return 80;
    case ::nds::display::types::DisplayMesh3dType::MINE_DUMP:
        return 81;
    case ::nds::display::types::DisplayMesh3dType::MINERAL_EXTRACTION_SITE:
        return 82;
    case ::nds::display::types::DisplayMesh3dType::DUMP:
        return 83;
    case ::nds::display::types::DisplayMesh3dType::CONSTRUCTION:
        return 84;
    case ::nds::display::types::DisplayMesh3dType::VEGETATED:
        return 85;
    case ::nds::display::types::DisplayMesh3dType::GREEN_URBAN:
        return 86;
    case ::nds::display::types::DisplayMesh3dType::PARK:
        return 87;
    case ::nds::display::types::DisplayMesh3dType::CEMETERY:
        return 88;
    case ::nds::display::types::DisplayMesh3dType::SPORT_LEISURE:
        return 89;
    case ::nds::display::types::DisplayMesh3dType::SPORTS_COMPLEX:
        return 90;
    case ::nds::display::types::DisplayMesh3dType::AMUSEMENT_PARK:
        return 91;
    case ::nds::display::types::DisplayMesh3dType::ARTS_CENTER:
        return 92;
    case ::nds::display::types::DisplayMesh3dType::CAMPING_SITE:
        return 93;
    case ::nds::display::types::DisplayMesh3dType::GOLF_COURSE:
        return 94;
    case ::nds::display::types::DisplayMesh3dType::HIPPODROME:
        return 95;
    case ::nds::display::types::DisplayMesh3dType::HOLIDAY:
        return 96;
    case ::nds::display::types::DisplayMesh3dType::RECREATIONAL:
        return 97;
    case ::nds::display::types::DisplayMesh3dType::REST_AREA:
        return 98;
    case ::nds::display::types::DisplayMesh3dType::SPORTS_HALL:
        return 99;
    case ::nds::display::types::DisplayMesh3dType::STADIUM:
        return 100;
    case ::nds::display::types::DisplayMesh3dType::WALKING_TERRAIN:
        return 101;
    case ::nds::display::types::DisplayMesh3dType::ZOO:
        return 102;
    case ::nds::display::types::DisplayMesh3dType::SKI:
        return 103;
    case ::nds::display::types::DisplayMesh3dType::SWIMMING_POOL:
        return 104;
    case ::nds::display::types::DisplayMesh3dType::RAILWAY_STATION:
        return 105;
    case ::nds::display::types::DisplayMesh3dType::FERRY_TERMINAL:
        return 106;
    case ::nds::display::types::DisplayMesh3dType::BUS_STATION:
        return 107;
    case ::nds::display::types::DisplayMesh3dType::MARINA:
        return 108;
    case ::nds::display::types::DisplayMesh3dType::AGRICULTURAL:
        return 109;
    case ::nds::display::types::DisplayMesh3dType::ARABLE:
        return 110;
    case ::nds::display::types::DisplayMesh3dType::NON_IRRIGATED:
        return 111;
    case ::nds::display::types::DisplayMesh3dType::PERMANENTLY_IRRIGATED:
        return 112;
    case ::nds::display::types::DisplayMesh3dType::RICE_FIELD:
        return 113;
    case ::nds::display::types::DisplayMesh3dType::PERMANENT_CROP:
        return 114;
    case ::nds::display::types::DisplayMesh3dType::TREE_BERRY_PLANTATION:
        return 115;
    case ::nds::display::types::DisplayMesh3dType::VINEYARD:
        return 116;
    case ::nds::display::types::DisplayMesh3dType::OLIVE_GROVES:
        return 117;
    case ::nds::display::types::DisplayMesh3dType::HETEROGENEOUS:
        return 118;
    case ::nds::display::types::DisplayMesh3dType::COMPLEX_CULTIVATION:
        return 119;
    case ::nds::display::types::DisplayMesh3dType::ANNUAL_PERMANENT:
        return 120;
    case ::nds::display::types::DisplayMesh3dType::AGRO_FORESTRY:
        return 121;
    case ::nds::display::types::DisplayMesh3dType::AGRICULTURAL_AND_NATURAL:
        return 122;
    case ::nds::display::types::DisplayMesh3dType::PASTURE_RANGELAND:
        return 123;
    case ::nds::display::types::DisplayMesh3dType::PASTURE:
        return 124;
    case ::nds::display::types::DisplayMesh3dType::RANGELAND:
        return 125;
    case ::nds::display::types::DisplayMesh3dType::FOREST_SEMI_NATURAL:
        return 126;
    case ::nds::display::types::DisplayMesh3dType::FOREST:
        return 127;
    case ::nds::display::types::DisplayMesh3dType::LEAVED_FOREST:
        return 128;
    case ::nds::display::types::DisplayMesh3dType::CONIFEROUS:
        return 129;
    case ::nds::display::types::DisplayMesh3dType::MIXED_FOREST:
        return 130;
    case ::nds::display::types::DisplayMesh3dType::SCRUB:
        return 131;
    case ::nds::display::types::DisplayMesh3dType::GRASSLAND:
        return 132;
    case ::nds::display::types::DisplayMesh3dType::MOOR_HEATH:
        return 133;
    case ::nds::display::types::DisplayMesh3dType::SCLEROPHYLLOUS:
        return 134;
    case ::nds::display::types::DisplayMesh3dType::WOODLAND:
        return 135;
    case ::nds::display::types::DisplayMesh3dType::OPEN_SPACE:
        return 136;
    case ::nds::display::types::DisplayMesh3dType::ROCK:
        return 137;
    case ::nds::display::types::DisplayMesh3dType::GLACIER:
        return 138;
    case ::nds::display::types::DisplayMesh3dType::BURNT:
        return 139;
    case ::nds::display::types::DisplayMesh3dType::SPARSELY_VEGETATED:
        return 140;
    case ::nds::display::types::DisplayMesh3dType::BEACH_DUNE:
        return 141;
    case ::nds::display::types::DisplayMesh3dType::WETLAND:
        return 142;
    case ::nds::display::types::DisplayMesh3dType::INLAND_WETLAND:
        return 143;
    case ::nds::display::types::DisplayMesh3dType::INLAND_MARSH:
        return 144;
    case ::nds::display::types::DisplayMesh3dType::PEATBOG:
        return 145;
    case ::nds::display::types::DisplayMesh3dType::FORESTED_WETLAND:
        return 146;
    case ::nds::display::types::DisplayMesh3dType::COASTAL_WETLAND:
        return 147;
    case ::nds::display::types::DisplayMesh3dType::SALT_MARSH:
        return 148;
    case ::nds::display::types::DisplayMesh3dType::SALINE:
        return 149;
    case ::nds::display::types::DisplayMesh3dType::INTERTIDAL_FLAT:
        return 150;
    case ::nds::display::types::DisplayMesh3dType::ISLAND:
        return 151;
    case ::nds::display::types::DisplayMesh3dType::WATER:
        return 152;
    case ::nds::display::types::DisplayMesh3dType::INLAND_WATER:
        return 153;
    case ::nds::display::types::DisplayMesh3dType::RIVER:
        return 154;
    case ::nds::display::types::DisplayMesh3dType::CANAL:
        return 155;
    case ::nds::display::types::DisplayMesh3dType::LAKE:
        return 156;
    case ::nds::display::types::DisplayMesh3dType::RESERVOIR:
        return 157;
    case ::nds::display::types::DisplayMesh3dType::BASIN:
        return 158;
    case ::nds::display::types::DisplayMesh3dType::WADI:
        return 159;
    case ::nds::display::types::DisplayMesh3dType::MARINE_WATER:
        return 160;
    case ::nds::display::types::DisplayMesh3dType::SEA_OCEAN:
        return 161;
    case ::nds::display::types::DisplayMesh3dType::COASTAL_LAGOON:
        return 162;
    case ::nds::display::types::DisplayMesh3dType::ESTUARY:
        return 163;
    case ::nds::display::types::DisplayMesh3dType::ADMIN:
        return 164;
    case ::nds::display::types::DisplayMesh3dType::COUNTRY:
        return 165;
    case ::nds::display::types::DisplayMesh3dType::SUB_COUNTRY_SET:
        return 166;
    case ::nds::display::types::DisplayMesh3dType::SUB_COUNTRY:
        return 167;
    case ::nds::display::types::DisplayMesh3dType::COUNTY:
        return 168;
    case ::nds::display::types::DisplayMesh3dType::MUNICIPALITY:
        return 169;
    case ::nds::display::types::DisplayMesh3dType::MUNICIPALITY_SUBDIVISION:
        return 170;
    case ::nds::display::types::DisplayMesh3dType::NEIGHBORHOOD:
        return 171;
    case ::nds::display::types::DisplayMesh3dType::CITY_BLOCK:
        return 172;
    case ::nds::display::types::DisplayMesh3dType::ADMIN_AUTONOMOUS:
        return 173;
    case ::nds::display::types::DisplayMesh3dType::NATIVE_TRIBE_RESERVATION:
        return 174;
    case ::nds::display::types::DisplayMesh3dType::CONTOUR:
        return 175;
    case ::nds::display::types::DisplayMesh3dType::NATIONAL_PARK:
        return 176;
    case ::nds::display::types::DisplayMesh3dType::ENVIRONMENTAL_ZONE:
        return 177;
    case ::nds::display::types::DisplayMesh3dType::TOLL_ZONE:
        return 178;
    case ::nds::display::types::DisplayMesh3dType::EDUCATION_BUILDING:
        return 179;
    case ::nds::display::types::DisplayMesh3dType::SCHOOL:
        return 180;
    case ::nds::display::types::DisplayMesh3dType::UNIVERSITY_OR_COLLEGE:
        return 181;
    case ::nds::display::types::DisplayMesh3dType::MEDICAL_BUILDING:
        return 182;
    case ::nds::display::types::DisplayMesh3dType::HOSPITAL:
        return 183;
    case ::nds::display::types::DisplayMesh3dType::EMERGENCY_SERVICE:
        return 184;
    case ::nds::display::types::DisplayMesh3dType::CULTURE_BUILDING:
        return 185;
    case ::nds::display::types::DisplayMesh3dType::HISTORICAL_BUILDING:
        return 186;
    case ::nds::display::types::DisplayMesh3dType::TOURIST_BUILDING:
        return 187;
    case ::nds::display::types::DisplayMesh3dType::CASTLE:
        return 188;
    case ::nds::display::types::DisplayMesh3dType::FORTRESS:
        return 189;
    case ::nds::display::types::DisplayMesh3dType::MONUMENT:
        return 190;
    case ::nds::display::types::DisplayMesh3dType::VIEW:
        return 191;
    case ::nds::display::types::DisplayMesh3dType::WATERMILL:
        return 192;
    case ::nds::display::types::DisplayMesh3dType::WINDMILL:
        return 193;
    case ::nds::display::types::DisplayMesh3dType::LEISURE_BUILDING:
        return 194;
    case ::nds::display::types::DisplayMesh3dType::SPORT_BUILDING:
        return 195;
    case ::nds::display::types::DisplayMesh3dType::TERRAIN:
        return 196;
    case ::nds::display::types::DisplayMesh3dType::TRAFFIC_ROAD_PEDESTRIAN_CROSSING:
        return 197;
    case ::nds::display::types::DisplayMesh3dType::TRAFFIC_ROAD_STOP_ZONE:
        return 198;
    case ::nds::display::types::DisplayMesh3dType::TRAFFIC_ROAD_DECORATION:
        return 199;
    case ::nds::display::types::DisplayMesh3dType::TRAFFIC_ROAD_STOP_LINE:
        return 200;
    case ::nds::display::types::DisplayMesh3dType::TRAFFIC_ROAD_RESTRICTION:
        return 201;
    case ::nds::display::types::DisplayMesh3dType::TRAFFIC_LANE:
        return 202;
    case ::nds::display::types::DisplayMesh3dType::TRAFFIC_LANE_MARKING:
        return 203;
    case ::nds::display::types::DisplayMesh3dType::TRAFFIC_LANE_SEPARATOR_MARKING:
        return 204;
    case ::nds::display::types::DisplayMesh3dType::TRAFFIC_LANE_BICYCLE:
        return 205;
    case ::nds::display::types::DisplayMesh3dType::TRAFFIC_LANE_BUS:
        return 206;
    case ::nds::display::types::DisplayMesh3dType::TRAFFIC_LANE_TAXI:
        return 207;
    case ::nds::display::types::DisplayMesh3dType::TRAFFIC_LANE_HOV:
        return 208;
    case ::nds::display::types::DisplayMesh3dType::TRAFFIC_LANE_TOLL:
        return 209;
    case ::nds::display::types::DisplayMesh3dType::TRAFFIC_LANE_TOLL_ETC:
        return 210;
    case ::nds::display::types::DisplayMesh3dType::TRAFFIC_PARKING_ROW:
        return 211;
    case ::nds::display::types::DisplayMesh3dType::TRAFFIC_PARKING_SPOT:
        return 212;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration DisplayMesh3dType: ") <<
                static_cast<typename ::std::underlying_type<::nds::display::types::DisplayMesh3dType>::type>(value) << "!";
    }
}

template <>
::nds::display::types::DisplayMesh3dType valueToEnum(
        typename ::std::underlying_type<::nds::display::types::DisplayMesh3dType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT16_C(0):
    case UINT16_C(1):
    case UINT16_C(2):
    case UINT16_C(3):
    case UINT16_C(4):
    case UINT16_C(5):
    case UINT16_C(6):
    case UINT16_C(7):
    case UINT16_C(8):
    case UINT16_C(9):
    case UINT16_C(10):
    case UINT16_C(11):
    case UINT16_C(12):
    case UINT16_C(13):
    case UINT16_C(14):
    case UINT16_C(15):
    case UINT16_C(16):
    case UINT16_C(17):
    case UINT16_C(18):
    case UINT16_C(19):
    case UINT16_C(20):
    case UINT16_C(21):
    case UINT16_C(22):
    case UINT16_C(23):
    case UINT16_C(24):
    case UINT16_C(25):
    case UINT16_C(26):
    case UINT16_C(27):
    case UINT16_C(28):
    case UINT16_C(29):
    case UINT16_C(30):
    case UINT16_C(31):
    case UINT16_C(32):
    case UINT16_C(33):
    case UINT16_C(34):
    case UINT16_C(35):
    case UINT16_C(36):
    case UINT16_C(37):
    case UINT16_C(38):
    case UINT16_C(39):
    case UINT16_C(40):
    case UINT16_C(41):
    case UINT16_C(42):
    case UINT16_C(43):
    case UINT16_C(44):
    case UINT16_C(45):
    case UINT16_C(46):
    case UINT16_C(47):
    case UINT16_C(48):
    case UINT16_C(49):
    case UINT16_C(50):
    case UINT16_C(51):
    case UINT16_C(52):
    case UINT16_C(53):
    case UINT16_C(54):
    case UINT16_C(55):
    case UINT16_C(56):
    case UINT16_C(57):
    case UINT16_C(58):
    case UINT16_C(59):
    case UINT16_C(60):
    case UINT16_C(61):
    case UINT16_C(62):
    case UINT16_C(63):
    case UINT16_C(64):
    case UINT16_C(65):
    case UINT16_C(66):
    case UINT16_C(67):
    case UINT16_C(68):
    case UINT16_C(69):
    case UINT16_C(70):
    case UINT16_C(71):
    case UINT16_C(72):
    case UINT16_C(73):
    case UINT16_C(74):
    case UINT16_C(75):
    case UINT16_C(76):
    case UINT16_C(77):
    case UINT16_C(78):
    case UINT16_C(79):
    case UINT16_C(80):
    case UINT16_C(81):
    case UINT16_C(82):
    case UINT16_C(83):
    case UINT16_C(84):
    case UINT16_C(85):
    case UINT16_C(86):
    case UINT16_C(87):
    case UINT16_C(88):
    case UINT16_C(89):
    case UINT16_C(90):
    case UINT16_C(91):
    case UINT16_C(92):
    case UINT16_C(93):
    case UINT16_C(94):
    case UINT16_C(95):
    case UINT16_C(96):
    case UINT16_C(97):
    case UINT16_C(98):
    case UINT16_C(99):
    case UINT16_C(100):
    case UINT16_C(101):
    case UINT16_C(102):
    case UINT16_C(103):
    case UINT16_C(104):
    case UINT16_C(105):
    case UINT16_C(106):
    case UINT16_C(107):
    case UINT16_C(108):
    case UINT16_C(109):
    case UINT16_C(110):
    case UINT16_C(111):
    case UINT16_C(112):
    case UINT16_C(113):
    case UINT16_C(114):
    case UINT16_C(115):
    case UINT16_C(116):
    case UINT16_C(117):
    case UINT16_C(118):
    case UINT16_C(119):
    case UINT16_C(120):
    case UINT16_C(121):
    case UINT16_C(122):
    case UINT16_C(123):
    case UINT16_C(124):
    case UINT16_C(125):
    case UINT16_C(126):
    case UINT16_C(127):
    case UINT16_C(128):
    case UINT16_C(129):
    case UINT16_C(130):
    case UINT16_C(131):
    case UINT16_C(132):
    case UINT16_C(133):
    case UINT16_C(134):
    case UINT16_C(135):
    case UINT16_C(136):
    case UINT16_C(137):
    case UINT16_C(138):
    case UINT16_C(139):
    case UINT16_C(140):
    case UINT16_C(141):
    case UINT16_C(142):
    case UINT16_C(143):
    case UINT16_C(144):
    case UINT16_C(145):
    case UINT16_C(146):
    case UINT16_C(147):
    case UINT16_C(148):
    case UINT16_C(149):
    case UINT16_C(150):
    case UINT16_C(151):
    case UINT16_C(152):
    case UINT16_C(153):
    case UINT16_C(154):
    case UINT16_C(155):
    case UINT16_C(156):
    case UINT16_C(157):
    case UINT16_C(158):
    case UINT16_C(159):
    case UINT16_C(160):
    case UINT16_C(161):
    case UINT16_C(162):
    case UINT16_C(163):
    case UINT16_C(164):
    case UINT16_C(165):
    case UINT16_C(166):
    case UINT16_C(167):
    case UINT16_C(168):
    case UINT16_C(169):
    case UINT16_C(170):
    case UINT16_C(171):
    case UINT16_C(172):
    case UINT16_C(173):
    case UINT16_C(174):
    case UINT16_C(175):
    case UINT16_C(176):
    case UINT16_C(177):
    case UINT16_C(178):
    case UINT16_C(179):
    case UINT16_C(180):
    case UINT16_C(181):
    case UINT16_C(182):
    case UINT16_C(183):
    case UINT16_C(184):
    case UINT16_C(185):
    case UINT16_C(186):
    case UINT16_C(187):
    case UINT16_C(188):
    case UINT16_C(189):
    case UINT16_C(190):
    case UINT16_C(191):
    case UINT16_C(192):
    case UINT16_C(193):
    case UINT16_C(194):
    case UINT16_C(195):
    case UINT16_C(196):
    case UINT16_C(197):
    case UINT16_C(198):
    case UINT16_C(199):
    case UINT16_C(200):
    case UINT16_C(201):
    case UINT16_C(202):
    case UINT16_C(203):
    case UINT16_C(204):
    case UINT16_C(205):
    case UINT16_C(206):
    case UINT16_C(207):
    case UINT16_C(208):
    case UINT16_C(209):
    case UINT16_C(210):
    case UINT16_C(211):
    case UINT16_C(212):
        return static_cast<::nds::display::types::DisplayMesh3dType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration DisplayMesh3dType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::display::types::DisplayMesh3dType>(::nds::display::types::DisplayMesh3dType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::display::types::DisplayMesh3dType value)
{
    context.init<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::display::types::DisplayMesh3dType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::display::types::DisplayMesh3dType value)
{
    return ::zserio::bitSizeOfVarUInt16(::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::display::types::DisplayMesh3dType value)
{
    return context.bitSizeOf<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::display::types::DisplayMesh3dType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::display::types::DisplayMesh3dType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::display::types::DisplayMesh3dType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::display::types::DisplayMesh3dType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::display::types::DisplayMesh3dType>(
            static_cast<typename ::std::underlying_type<::nds::display::types::DisplayMesh3dType>::type>(
                    in.readVarUInt16()));
}

template <>
::nds::display::types::DisplayMesh3dType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::display::types::DisplayMesh3dType>(context.read<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::display::types::DisplayMesh3dType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::display::types::DisplayMesh3dType value)
{
    out.writeVarUInt16(::zserio::enumToValue(value));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::display::types::DisplayMesh3dType value)
{
    context.write<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::display::types::DisplayMesh3dType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/display/types/GltfVersion.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for GltfVersion enumeration.
constexpr ::std::array<const char*, 1> EnumTraits<::nds::display::types::GltfVersion>::names;
constexpr ::std::array<::nds::display::types::GltfVersion, 1> EnumTraits<::nds::display::types::GltfVersion>::values;
constexpr const char* EnumTraits<::nds::display::types::GltfVersion>::enumName;

template <>
size_t enumToOrdinal(::nds::display::types::GltfVersion value)
{
    switch (value)
    {
    case ::nds::display::types::GltfVersion::GLTF_V20:
        return 0;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration GltfVersion: ") <<
                static_cast<typename ::std::underlying_type<::nds::display::types::GltfVersion>::type>(value) << "!";
    }
}

template <>
::nds::display::types::GltfVersion valueToEnum(
        typename ::std::underlying_type<::nds::display::types::GltfVersion>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
        return static_cast<::nds::display::types::GltfVersion>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration GltfVersion: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::display::types::GltfVersion>(::nds::display::types::GltfVersion value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::display::types::GltfVersion value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::display::types::GltfVersion>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::display::types::GltfVersion)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::display::types::GltfVersion value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::display::types::GltfVersion>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::display::types::GltfVersion value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::display::types::GltfVersion value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::display::types::GltfVersion read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::display::types::GltfVersion>(
            static_cast<typename ::std::underlying_type<::nds::display::types::GltfVersion>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::display::types::GltfVersion read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::display::types::GltfVersion>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::display::types::GltfVersion>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::display::types::GltfVersion value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::display::types::GltfVersion value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::display::types::GltfVersion>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/display/types/TextureCoordsUsageType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for TextureCoordsUsageType enumeration.
constexpr ::std::array<const char*, 3> EnumTraits<::nds::display::types::TextureCoordsUsageType>::names;
constexpr ::std::array<::nds::display::types::TextureCoordsUsageType, 3> EnumTraits<::nds::display::types::TextureCoordsUsageType>::values;
constexpr const char* EnumTraits<::nds::display::types::TextureCoordsUsageType>::enumName;

template <>
size_t enumToOrdinal(::nds::display::types::TextureCoordsUsageType value)
{
    switch (value)
    {
    case ::nds::display::types::TextureCoordsUsageType::CLAMP:
        return 0;
    case ::nds::display::types::TextureCoordsUsageType::REPEAT:
        return 1;
    case ::nds::display::types::TextureCoordsUsageType::MIRROR:
        return 2;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration TextureCoordsUsageType: ") <<
                static_cast<typename ::std::underlying_type<::nds::display::types::TextureCoordsUsageType>::type>(value) << "!";
    }
}

template <>
::nds::display::types::TextureCoordsUsageType valueToEnum(
        typename ::std::underlying_type<::nds::display::types::TextureCoordsUsageType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
        return static_cast<::nds::display::types::TextureCoordsUsageType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration TextureCoordsUsageType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::display::types::TextureCoordsUsageType>(::nds::display::types::TextureCoordsUsageType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::display::types::TextureCoordsUsageType value)
{
    context.init<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::display::types::TextureCoordsUsageType>::type, UINT8_C(2)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::display::types::TextureCoordsUsageType)
{
    return UINT8_C(2);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::display::types::TextureCoordsUsageType value)
{
    return context.bitSizeOf<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::display::types::TextureCoordsUsageType>::type, UINT8_C(2)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::display::types::TextureCoordsUsageType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::display::types::TextureCoordsUsageType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::display::types::TextureCoordsUsageType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::display::types::TextureCoordsUsageType>(
            static_cast<typename ::std::underlying_type<::nds::display::types::TextureCoordsUsageType>::type>(
                    in.readBits(UINT8_C(2))));
}

template <>
::nds::display::types::TextureCoordsUsageType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::display::types::TextureCoordsUsageType>(context.read<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::display::types::TextureCoordsUsageType>::type, UINT8_C(2)>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::display::types::TextureCoordsUsageType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(2));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::display::types::TextureCoordsUsageType value)
{
    context.write<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::display::types::TextureCoordsUsageType>::type, UINT8_C(2)>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/display/types/TextureRenderingUsageType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for TextureRenderingUsageType enumeration.
constexpr ::std::array<const char*, 3> EnumTraits<::nds::display::types::TextureRenderingUsageType>::names;
constexpr ::std::array<::nds::display::types::TextureRenderingUsageType, 3> EnumTraits<::nds::display::types::TextureRenderingUsageType>::values;
constexpr const char* EnumTraits<::nds::display::types::TextureRenderingUsageType>::enumName;

template <>
size_t enumToOrdinal(::nds::display::types::TextureRenderingUsageType value)
{
    switch (value)
    {
    case ::nds::display::types::TextureRenderingUsageType::COLOR_TEXTURE:
        return 0;
    case ::nds::display::types::TextureRenderingUsageType::NORMAL_MAP:
        return 1;
    case ::nds::display::types::TextureRenderingUsageType::BUMP_MAP:
        return 2;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration TextureRenderingUsageType: ") <<
                static_cast<typename ::std::underlying_type<::nds::display::types::TextureRenderingUsageType>::type>(value) << "!";
    }
}

template <>
::nds::display::types::TextureRenderingUsageType valueToEnum(
        typename ::std::underlying_type<::nds::display::types::TextureRenderingUsageType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
        return static_cast<::nds::display::types::TextureRenderingUsageType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration TextureRenderingUsageType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::display::types::TextureRenderingUsageType>(::nds::display::types::TextureRenderingUsageType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::display::types::TextureRenderingUsageType value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::display::types::TextureRenderingUsageType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::display::types::TextureRenderingUsageType)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::display::types::TextureRenderingUsageType value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::display::types::TextureRenderingUsageType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::display::types::TextureRenderingUsageType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::display::types::TextureRenderingUsageType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::display::types::TextureRenderingUsageType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::display::types::TextureRenderingUsageType>(
            static_cast<typename ::std::underlying_type<::nds::display::types::TextureRenderingUsageType>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::display::types::TextureRenderingUsageType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::display::types::TextureRenderingUsageType>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::display::types::TextureRenderingUsageType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::display::types::TextureRenderingUsageType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::display::types::TextureRenderingUsageType value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::display::types::TextureRenderingUsageType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/display/types/TextureFormat.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for TextureFormat enumeration.
constexpr ::std::array<const char*, 5> EnumTraits<::nds::display::types::TextureFormat>::names;
constexpr ::std::array<::nds::display::types::TextureFormat, 5> EnumTraits<::nds::display::types::TextureFormat>::values;
constexpr const char* EnumTraits<::nds::display::types::TextureFormat>::enumName;

template <>
size_t enumToOrdinal(::nds::display::types::TextureFormat value)
{
    switch (value)
    {
    case ::nds::display::types::TextureFormat::PNG:
        return 0;
    case ::nds::display::types::TextureFormat::JPG:
        return 1;
    case ::nds::display::types::TextureFormat::DDS:
        return 2;
    case ::nds::display::types::TextureFormat::PVR:
        return 3;
    case ::nds::display::types::TextureFormat::KTX:
        return 4;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration TextureFormat: ") <<
                static_cast<typename ::std::underlying_type<::nds::display::types::TextureFormat>::type>(value) << "!";
    }
}

template <>
::nds::display::types::TextureFormat valueToEnum(
        typename ::std::underlying_type<::nds::display::types::TextureFormat>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
    case UINT8_C(3):
    case UINT8_C(4):
        return static_cast<::nds::display::types::TextureFormat>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration TextureFormat: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::display::types::TextureFormat>(::nds::display::types::TextureFormat value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::display::types::TextureFormat value)
{
    context.init<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::display::types::TextureFormat>::type, UINT8_C(4)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::display::types::TextureFormat)
{
    return UINT8_C(4);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::display::types::TextureFormat value)
{
    return context.bitSizeOf<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::display::types::TextureFormat>::type, UINT8_C(4)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::display::types::TextureFormat value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::display::types::TextureFormat value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::display::types::TextureFormat read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::display::types::TextureFormat>(
            static_cast<typename ::std::underlying_type<::nds::display::types::TextureFormat>::type>(
                    in.readBits(UINT8_C(4))));
}

template <>
::nds::display::types::TextureFormat read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::display::types::TextureFormat>(context.read<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::display::types::TextureFormat>::type, UINT8_C(4)>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::display::types::TextureFormat value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(4));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::display::types::TextureFormat value)
{
    context.write<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::display::types::TextureFormat>::type, UINT8_C(4)>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/display/types/ColorMode.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for ColorMode enumeration.
constexpr ::std::array<const char*, 3> EnumTraits<::nds::display::types::ColorMode>::names;
constexpr ::std::array<::nds::display::types::ColorMode, 3> EnumTraits<::nds::display::types::ColorMode>::values;
constexpr const char* EnumTraits<::nds::display::types::ColorMode>::enumName;

template <>
size_t enumToOrdinal(::nds::display::types::ColorMode value)
{
    switch (value)
    {
    case ::nds::display::types::ColorMode::NO_COLOR:
        return 0;
    case ::nds::display::types::ColorMode::COLOR_PER_RENDER_GROUP:
        return 1;
    case ::nds::display::types::ColorMode::COLOR_PER_VERTEX:
        return 2;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration ColorMode: ") <<
                static_cast<typename ::std::underlying_type<::nds::display::types::ColorMode>::type>(value) << "!";
    }
}

template <>
::nds::display::types::ColorMode valueToEnum(
        typename ::std::underlying_type<::nds::display::types::ColorMode>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
        return static_cast<::nds::display::types::ColorMode>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration ColorMode: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::display::types::ColorMode>(::nds::display::types::ColorMode value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::display::types::ColorMode value)
{
    context.init<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::display::types::ColorMode>::type, UINT8_C(2)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::display::types::ColorMode)
{
    return UINT8_C(2);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::display::types::ColorMode value)
{
    return context.bitSizeOf<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::display::types::ColorMode>::type, UINT8_C(2)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::display::types::ColorMode value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::display::types::ColorMode value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::display::types::ColorMode read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::display::types::ColorMode>(
            static_cast<typename ::std::underlying_type<::nds::display::types::ColorMode>::type>(
                    in.readBits(UINT8_C(2))));
}

template <>
::nds::display::types::ColorMode read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::display::types::ColorMode>(context.read<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::display::types::ColorMode>::type, UINT8_C(2)>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::display::types::ColorMode value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(2));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::display::types::ColorMode value)
{
    context.write<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::display::types::ColorMode>::type, UINT8_C(2)>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/display/types/OrthoImageContentType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for OrthoImageContentType enumeration.
constexpr ::std::array<const char*, 2> EnumTraits<::nds::display::types::OrthoImageContentType>::names;
constexpr ::std::array<::nds::display::types::OrthoImageContentType, 2> EnumTraits<::nds::display::types::OrthoImageContentType>::values;
constexpr const char* EnumTraits<::nds::display::types::OrthoImageContentType>::enumName;

template <>
size_t enumToOrdinal(::nds::display::types::OrthoImageContentType value)
{
    switch (value)
    {
    case ::nds::display::types::OrthoImageContentType::AERIAL:
        return 0;
    case ::nds::display::types::OrthoImageContentType::SATELLITE:
        return 1;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration OrthoImageContentType: ") <<
                static_cast<typename ::std::underlying_type<::nds::display::types::OrthoImageContentType>::type>(value) << "!";
    }
}

template <>
::nds::display::types::OrthoImageContentType valueToEnum(
        typename ::std::underlying_type<::nds::display::types::OrthoImageContentType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
        return static_cast<::nds::display::types::OrthoImageContentType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration OrthoImageContentType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::display::types::OrthoImageContentType>(::nds::display::types::OrthoImageContentType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::display::types::OrthoImageContentType value)
{
    context.init<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::display::types::OrthoImageContentType>::type, UINT8_C(4)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::display::types::OrthoImageContentType)
{
    return UINT8_C(4);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::display::types::OrthoImageContentType value)
{
    return context.bitSizeOf<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::display::types::OrthoImageContentType>::type, UINT8_C(4)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::display::types::OrthoImageContentType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::display::types::OrthoImageContentType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::display::types::OrthoImageContentType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::display::types::OrthoImageContentType>(
            static_cast<typename ::std::underlying_type<::nds::display::types::OrthoImageContentType>::type>(
                    in.readBits(UINT8_C(4))));
}

template <>
::nds::display::types::OrthoImageContentType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::display::types::OrthoImageContentType>(context.read<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::display::types::OrthoImageContentType>::type, UINT8_C(4)>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::display::types::OrthoImageContentType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(4));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::display::types::OrthoImageContentType value)
{
    context.write<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::display::types::OrthoImageContentType>::type, UINT8_C(4)>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/HashCodeUtil.h>
#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/display/types/TextureConditionUsageType.h>

namespace nds
{
namespace display
{
namespace types
{

TextureConditionUsageType::TextureConditionUsageType(::zserio::BitStreamReader& in) :
        m_value(readValue(in))
{}

TextureConditionUsageType::TextureConditionUsageType(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in) :
        m_value(readValue(context, in))
{}

TextureConditionUsageType::TextureConditionUsageType(underlying_type value) :
        m_value(value)
{
    if (m_value > UINT64_C(144115188075855871))
        throw ::zserio::CppRuntimeException("Value for bitmask 'TextureConditionUsageType' out of bounds: ") << value << "!";
}

void TextureConditionUsageType::initPackingContext(::zserio::DeltaContext& context) const
{
    context.init<::zserio::VarIntNNArrayTraits<::nds::display::types::TextureConditionUsageType::underlying_type>>(m_value);
}

size_t TextureConditionUsageType::bitSizeOf(size_t) const
{
    return ::zserio::bitSizeOfVarUInt64(m_value);
}

size_t TextureConditionUsageType::bitSizeOf(::zserio::DeltaContext& context, size_t) const
{
    return context.bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::display::types::TextureConditionUsageType::underlying_type>>(m_value);
}

size_t TextureConditionUsageType::initializeOffsets(size_t bitPosition) const
{
    return bitPosition + bitSizeOf(bitPosition);
}

size_t TextureConditionUsageType::initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition) const
{
    return bitPosition + bitSizeOf(context, bitPosition);
}

uint32_t TextureConditionUsageType::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, m_value);
    return result;
}

void TextureConditionUsageType::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt64(m_value);
}

void TextureConditionUsageType::write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out) const
{
    context.write<::zserio::VarIntNNArrayTraits<::nds::display::types::TextureConditionUsageType::underlying_type>>(out, m_value);
}

::zserio::string<> TextureConditionUsageType::toString(const ::zserio::string<>::allocator_type& allocator) const
{
    ::zserio::string<> result(allocator);
    if ((*this & TextureConditionUsageType::Values::TIME_DAY) == TextureConditionUsageType::Values::TIME_DAY)
        result += result.empty() ? "TIME_DAY" : " | TIME_DAY";
    if ((*this & TextureConditionUsageType::Values::TIME_NIGHT) == TextureConditionUsageType::Values::TIME_NIGHT)
        result += result.empty() ? "TIME_NIGHT" : " | TIME_NIGHT";
    if ((*this & TextureConditionUsageType::Values::WEATHER_RAINY) == TextureConditionUsageType::Values::WEATHER_RAINY)
        result += result.empty() ? "WEATHER_RAINY" : " | WEATHER_RAINY";
    if ((*this & TextureConditionUsageType::Values::WEATHER_CLOUDY) == TextureConditionUsageType::Values::WEATHER_CLOUDY)
        result += result.empty() ? "WEATHER_CLOUDY" : " | WEATHER_CLOUDY";
    if ((*this & TextureConditionUsageType::Values::WEATHER_SUNNY) == TextureConditionUsageType::Values::WEATHER_SUNNY)
        result += result.empty() ? "WEATHER_SUNNY" : " | WEATHER_SUNNY";
    if ((*this & TextureConditionUsageType::Values::WEATHER_SNOWY) == TextureConditionUsageType::Values::WEATHER_SNOWY)
        result += result.empty() ? "WEATHER_SNOWY" : " | WEATHER_SNOWY";
    if ((*this & TextureConditionUsageType::Values::SEASONAL_WINTER) == TextureConditionUsageType::Values::SEASONAL_WINTER)
        result += result.empty() ? "SEASONAL_WINTER" : " | SEASONAL_WINTER";
    if ((*this & TextureConditionUsageType::Values::SEASONAL_SPRING) == TextureConditionUsageType::Values::SEASONAL_SPRING)
        result += result.empty() ? "SEASONAL_SPRING" : " | SEASONAL_SPRING";
    if ((*this & TextureConditionUsageType::Values::SEASONAL_SUMMER) == TextureConditionUsageType::Values::SEASONAL_SUMMER)
        result += result.empty() ? "SEASONAL_SUMMER" : " | SEASONAL_SUMMER";
    if ((*this & TextureConditionUsageType::Values::SEASONAL_FALL) == TextureConditionUsageType::Values::SEASONAL_FALL)
        result += result.empty() ? "SEASONAL_FALL" : " | SEASONAL_FALL";

    return ::zserio::toString<::zserio::string<>::allocator_type>(m_value, allocator) + "[" + result + "]";
}

TextureConditionUsageType::underlying_type TextureConditionUsageType::readValue(::zserio::BitStreamReader& in)
{
    return static_cast<underlying_type>(in.readVarUInt64());
}

TextureConditionUsageType::underlying_type TextureConditionUsageType::readValue(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return context.read<::zserio::VarIntNNArrayTraits<::nds::display::types::TextureConditionUsageType::underlying_type>>(
            in);
}

} // namespace types
} // namespace display
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/HashCodeUtil.h>
#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/display/types/UsedColorModes.h>

namespace nds
{
namespace display
{
namespace types
{

UsedColorModes::UsedColorModes(::zserio::BitStreamReader& in) :
        m_value(readValue(in))
{}

UsedColorModes::UsedColorModes(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in) :
        m_value(readValue(context, in))
{}

UsedColorModes::UsedColorModes(underlying_type value) :
        m_value(value)
{
    if (m_value > UINT8_C(15))
        throw ::zserio::CppRuntimeException("Value for bitmask 'UsedColorModes' out of bounds: ") << value << "!";
}

void UsedColorModes::initPackingContext(::zserio::DeltaContext& context) const
{
    context.init<::zserio::BitFieldArrayTraits<::nds::display::types::UsedColorModes::underlying_type, UINT8_C(4)>>(m_value);
}

size_t UsedColorModes::bitSizeOf(size_t) const
{
    return UINT8_C(4);
}

size_t UsedColorModes::bitSizeOf(::zserio::DeltaContext& context, size_t) const
{
    return context.bitSizeOf<::zserio::BitFieldArrayTraits<::nds::display::types::UsedColorModes::underlying_type, UINT8_C(4)>>(m_value);
}

size_t UsedColorModes::initializeOffsets(size_t bitPosition) const
{
    return bitPosition + bitSizeOf(bitPosition);
}

size_t UsedColorModes::initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition) const
{
    return bitPosition + bitSizeOf(context, bitPosition);
}

uint32_t UsedColorModes::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, m_value);
    return result;
}

void UsedColorModes::write(::zserio::BitStreamWriter& out) const
{
    out.writeBits(m_value, UINT8_C(4));
}

void UsedColorModes::write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out) const
{
    context.write<::zserio::BitFieldArrayTraits<::nds::display::types::UsedColorModes::underlying_type, UINT8_C(4)>>(out, m_value);
}

::zserio::string<> UsedColorModes::toString(const ::zserio::string<>::allocator_type& allocator) const
{
    ::zserio::string<> result(allocator);
    if ((*this & UsedColorModes::Values::COLOR_PER_RENDER_GROUP) == UsedColorModes::Values::COLOR_PER_RENDER_GROUP)
        result += result.empty() ? "COLOR_PER_RENDER_GROUP" : " | COLOR_PER_RENDER_GROUP";
    if ((*this & UsedColorModes::Values::COLOR_PER_VERTEX) == UsedColorModes::Values::COLOR_PER_VERTEX)
        result += result.empty() ? "COLOR_PER_VERTEX" : " | COLOR_PER_VERTEX";

    return ::zserio::toString<::zserio::string<>::allocator_type>(m_value, allocator) + "[" + result + "]";
}

UsedColorModes::underlying_type UsedColorModes::readValue(::zserio::BitStreamReader& in)
{
    return static_cast<underlying_type>(in.readBits(UINT8_C(4)));
}

UsedColorModes::underlying_type UsedColorModes::readValue(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return context.read<::zserio::BitFieldArrayTraits<::nds::display::types::UsedColorModes::underlying_type, UINT8_C(4)>>(
            in);
}

} // namespace types
} // namespace display
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/HashCodeUtil.h>
#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/display/types/TerrainOptimizationType.h>

namespace nds
{
namespace display
{
namespace types
{

TerrainOptimizationType::TerrainOptimizationType(::zserio::BitStreamReader& in) :
        m_value(readValue(in))
{}

TerrainOptimizationType::TerrainOptimizationType(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in) :
        m_value(readValue(context, in))
{}

TerrainOptimizationType::TerrainOptimizationType(underlying_type value) :
        m_value(value)
{
    if (m_value > UINT32_C(536870911))
        throw ::zserio::CppRuntimeException("Value for bitmask 'TerrainOptimizationType' out of bounds: ") << value << "!";
}

void TerrainOptimizationType::initPackingContext(::zserio::DeltaContext& context) const
{
    context.init<::zserio::VarIntNNArrayTraits<::nds::display::types::TerrainOptimizationType::underlying_type>>(m_value);
}

size_t TerrainOptimizationType::bitSizeOf(size_t) const
{
    return ::zserio::bitSizeOfVarUInt32(m_value);
}

size_t TerrainOptimizationType::bitSizeOf(::zserio::DeltaContext& context, size_t) const
{
    return context.bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::display::types::TerrainOptimizationType::underlying_type>>(m_value);
}

size_t TerrainOptimizationType::initializeOffsets(size_t bitPosition) const
{
    return bitPosition + bitSizeOf(bitPosition);
}

size_t TerrainOptimizationType::initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition) const
{
    return bitPosition + bitSizeOf(context, bitPosition);
}

uint32_t TerrainOptimizationType::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, m_value);
    return result;
}

void TerrainOptimizationType::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt32(m_value);
}

void TerrainOptimizationType::write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out) const
{
    context.write<::zserio::VarIntNNArrayTraits<::nds::display::types::TerrainOptimizationType::underlying_type>>(out, m_value);
}

::zserio::string<> TerrainOptimizationType::toString(const ::zserio::string<>::allocator_type& allocator) const
{
    ::zserio::string<> result(allocator);
    if ((*this & TerrainOptimizationType::Values::CITY_MODEL_FITTED) == TerrainOptimizationType::Values::CITY_MODEL_FITTED)
        result += result.empty() ? "CITY_MODEL_FITTED" : " | CITY_MODEL_FITTED";
    if ((*this & TerrainOptimizationType::Values::JUNCTION_VIEW_FITTED) == TerrainOptimizationType::Values::JUNCTION_VIEW_FITTED)
        result += result.empty() ? "JUNCTION_VIEW_FITTED" : " | JUNCTION_VIEW_FITTED";

    return ::zserio::toString<::zserio::string<>::allocator_type>(m_value, allocator) + "[" + result + "]";
}

TerrainOptimizationType::underlying_type TerrainOptimizationType::readValue(::zserio::BitStreamReader& in)
{
    return static_cast<underlying_type>(in.readVarUInt32());
}

TerrainOptimizationType::underlying_type TerrainOptimizationType::readValue(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return context.read<::zserio::VarIntNNArrayTraits<::nds::display::types::TerrainOptimizationType::underlying_type>>(
            in);
}

} // namespace types
} // namespace display
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ConstraintException.h>

#include <nds/display/types/ClippingEdgeList.h>

namespace nds
{
namespace display
{
namespace types
{

ClippingEdgeList::ClippingEdgeList(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_shift_(::nds::core::geometry::CoordShift()),
        m_numEdges_(uint32_t()),
        m_edges_(allocator)
{
}

ClippingEdgeList::ClippingEdgeList(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_shift_(readShift(in)),
        m_numEdges_(readNumEdges(in)),
        m_edges_(readEdges(in, allocator))
{
}

ClippingEdgeList::ClippingEdgeList(ClippingEdgeList::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_shift_(readShift(context, in)),
        m_numEdges_(readNumEdges(context, in)),
        m_edges_(readEdges(context, in, allocator))
{
}

ClippingEdgeList::ClippingEdgeList(const ClippingEdgeList& other) :
        m_shift_(other.m_shift_),
        m_numEdges_(other.m_numEdges_),
        m_edges_(other.m_edges_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

ClippingEdgeList& ClippingEdgeList::operator=(const ClippingEdgeList& other)
{
    m_shift_ = other.m_shift_;
    m_numEdges_ = other.m_numEdges_;
    m_edges_ = other.m_edges_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

ClippingEdgeList::ClippingEdgeList(ClippingEdgeList&& other) :
        m_shift_(::std::move(other.m_shift_)),
        m_numEdges_(::std::move(other.m_numEdges_)),
        m_edges_(::std::move(other.m_edges_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

ClippingEdgeList& ClippingEdgeList::operator=(ClippingEdgeList&& other)
{
    m_shift_ = ::std::move(other.m_shift_);
    m_numEdges_ = ::std::move(other.m_numEdges_);
    m_edges_ = ::std::move(other.m_edges_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

ClippingEdgeList::ClippingEdgeList(::zserio::PropagateAllocatorT,
        const ClippingEdgeList& other, const allocator_type& allocator) :
        m_shift_(::zserio::allocatorPropagatingCopy(other.m_shift_, allocator)),
        m_numEdges_(::zserio::allocatorPropagatingCopy(other.m_numEdges_, allocator)),
        m_edges_(::zserio::allocatorPropagatingCopy(other.m_edges_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void ClippingEdgeList::initializeChildren()
{
    m_edges_.initializeElements(*this);

    m_areChildrenInitialized = true;
}

::nds::core::geometry::CoordShift ClippingEdgeList::getShift() const
{
    return m_shift_;
}

void ClippingEdgeList::setShift(::nds::core::geometry::CoordShift shift_)
{
    m_shift_ = shift_;
}

uint32_t ClippingEdgeList::getNumEdges() const
{
    return m_numEdges_;
}

void ClippingEdgeList::setNumEdges(uint32_t numEdges_)
{
    m_numEdges_ = numEdges_;
}

::zserio::vector<::nds::display::types::ClippingEdge>& ClippingEdgeList::getEdges()
{
    return m_edges_.getRawArray();
}

const ::zserio::vector<::nds::display::types::ClippingEdge>& ClippingEdgeList::getEdges() const
{
    return m_edges_.getRawArray();
}

void ClippingEdgeList::setEdges(const ::zserio::vector<::nds::display::types::ClippingEdge>& edges_)
{
    m_edges_ = ZserioArrayType_edges(edges_);
}

void ClippingEdgeList::setEdges(::zserio::vector<::nds::display::types::ClippingEdge>&& edges_)
{
    m_edges_ = ZserioArrayType_edges(std::move(edges_));
}

void ClippingEdgeList::initPackingContext(ClippingEdgeList::ZserioPackingContext& context) const
{
    context.getShift().init<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(m_shift_);
    context.getNumEdges().init<::zserio::VarSizeArrayTraits>(m_numEdges_);
}

size_t ClippingEdgeList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(5);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_numEdges_);
    endBitPosition += m_edges_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ClippingEdgeList::bitSizeOf(ClippingEdgeList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getShift().bitSizeOf<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(m_shift_);
    endBitPosition += context.getNumEdges().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numEdges_);
    endBitPosition += m_edges_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ClippingEdgeList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(5);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_numEdges_);
    endBitPosition = m_edges_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t ClippingEdgeList::initializeOffsets(ClippingEdgeList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getShift().bitSizeOf<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(m_shift_);
    endBitPosition += context.getNumEdges().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numEdges_);
    endBitPosition = m_edges_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool ClippingEdgeList::operator==(const ClippingEdgeList& other) const
{
    if (this != &other)
    {
        return
                (m_shift_ == other.m_shift_) &&
                (m_numEdges_ == other.m_numEdges_) &&
                (m_edges_ == other.m_edges_);
    }

    return true;
}

uint32_t ClippingEdgeList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_shift_);
    result = ::zserio::calcHashCode(result, m_numEdges_);
    result = ::zserio::calcHashCode(result, m_edges_);

    return result;
}

void ClippingEdgeList::write(::zserio::BitStreamWriter& out) const
{
    out.writeBits(m_shift_, UINT8_C(5));

    // check constraint
    if (!(getNumEdges() > 0))
        throw ::zserio::ConstraintException("Write: Constraint violated at ClippingEdgeList.numEdges!");
    out.writeVarSize(m_numEdges_);

    // check array length
    if (m_edges_.getRawArray().size() != static_cast<size_t>(getNumEdges()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ClippingEdgeList.edges: ") <<
                m_edges_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumEdges()) << "!";
    }
    m_edges_.write(*this, out);
}

void ClippingEdgeList::write(ClippingEdgeList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getShift().write<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(out, m_shift_);

    // check constraint
    if (!(getNumEdges() > 0))
        throw ::zserio::ConstraintException("Write: Constraint violated at ClippingEdgeList.numEdges!");
    context.getNumEdges().write<::zserio::VarSizeArrayTraits>(out, m_numEdges_);

    // check array length
    if (m_edges_.getRawArray().size() != static_cast<size_t>(getNumEdges()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ClippingEdgeList.edges: ") <<
                m_edges_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumEdges()) << "!";
    }
    m_edges_.writePacked(*this, out);
}

void ClippingEdgeList::ZserioArrayExpressions_edges::initializeElement(ClippingEdgeList& owner,
        ::nds::display::types::ClippingEdge& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getShift()));
}

void ClippingEdgeList::ZserioElementFactory_edges::create(ClippingEdgeList&         owner,
        ::zserio::vector<::nds::display::types::ClippingEdge>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getShift()), array.get_allocator());
}

void ClippingEdgeList::ZserioElementFactory_edges::create(ClippingEdgeList&         owner,
        ::zserio::vector<::nds::display::types::ClippingEdge>& array,
        ::nds::display::types::ClippingEdge::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getShift()), array.get_allocator());
}

::nds::core::geometry::CoordShift ClippingEdgeList::readShift(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::geometry::CoordShift>(in.readBits(UINT8_C(5)));
}

::nds::core::geometry::CoordShift ClippingEdgeList::readShift(ClippingEdgeList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getShift().read<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(in);
}
uint32_t ClippingEdgeList::readNumEdges(::zserio::BitStreamReader& in)
{
    uint32_t readField = static_cast<uint32_t>(in.readVarSize());
    // check constraint
    if (!(readField > 0))
        throw ::zserio::ConstraintException("Read: Constraint violated at ClippingEdgeList.numEdges!");

    return readField;
}

uint32_t ClippingEdgeList::readNumEdges(ClippingEdgeList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    uint32_t readField = context.getNumEdges().read<::zserio::VarSizeArrayTraits>(in);
    // check constraint
    if (!(readField > 0))
        throw ::zserio::ConstraintException("Read: Constraint violated at ClippingEdgeList.numEdges!");

    return readField;
}
ClippingEdgeList::ZserioArrayType_edges ClippingEdgeList::readEdges(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_edges readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getNumEdges()));

    return readField;
}

ClippingEdgeList::ZserioArrayType_edges ClippingEdgeList::readEdges(ClippingEdgeList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_edges readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumEdges()));

    return readField;
}

} // namespace types
} // namespace display
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/display/types/ClippingEdge.h>

namespace nds
{
namespace display
{
namespace types
{

ClippingEdge::ClippingEdge(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_startPosition_(allocator),
        m_endPosition_(allocator)
{
}

ClippingEdge::ClippingEdge(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift shift_, const allocator_type& allocator) :
        m_shift_(shift_),
        m_isInitialized(true),
        m_startPosition_(readStartPosition(in, allocator)),
        m_endPosition_(readEndPosition(in, allocator))
{
}

ClippingEdge::ClippingEdge(ClippingEdge::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift shift_, const allocator_type& allocator) :
        m_shift_(shift_),
        m_isInitialized(true),
        m_startPosition_(readStartPosition(context, in, allocator)),
        m_endPosition_(readEndPosition(context, in, allocator))
{
}

ClippingEdge::ClippingEdge(const ClippingEdge& other) :
        m_startPosition_(other.m_startPosition_),
        m_endPosition_(other.m_endPosition_)
{
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;
}

ClippingEdge& ClippingEdge::operator=(const ClippingEdge& other)
{
    m_startPosition_ = other.m_startPosition_;
    m_endPosition_ = other.m_endPosition_;
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;

    return *this;
}

ClippingEdge::ClippingEdge(ClippingEdge&& other) :
        m_startPosition_(::std::move(other.m_startPosition_)),
        m_endPosition_(::std::move(other.m_endPosition_))
{
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;
}

ClippingEdge& ClippingEdge::operator=(ClippingEdge&& other)
{
    m_startPosition_ = ::std::move(other.m_startPosition_);
    m_endPosition_ = ::std::move(other.m_endPosition_);
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;

    return *this;
}

ClippingEdge::ClippingEdge(::zserio::PropagateAllocatorT,
        const ClippingEdge& other, const allocator_type& allocator) :
        m_startPosition_(::zserio::allocatorPropagatingCopy(other.m_startPosition_, allocator)),
        m_endPosition_(::zserio::allocatorPropagatingCopy(other.m_endPosition_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;
}

void ClippingEdge::initialize(
        ::nds::core::geometry::CoordShift shift_)
{
    m_shift_ = shift_;
    m_isInitialized = true;

    initializeChildren();
}

bool ClippingEdge::isInitialized() const
{
    return m_isInitialized;
}

void ClippingEdge::initializeChildren()
{
    m_startPosition_.initialize(static_cast<::nds::core::geometry::CoordShift>(getShift()));
    m_endPosition_.initialize(static_cast<::nds::core::geometry::CoordShift>(getShift()));
}

::nds::core::geometry::CoordShift ClippingEdge::getShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'shift' of compound 'ClippingEdge' is not initialized!");

    return m_shift_;
}

::nds::core::geometry::Position2D& ClippingEdge::getStartPosition()
{
    return m_startPosition_;
}

const ::nds::core::geometry::Position2D& ClippingEdge::getStartPosition() const
{
    return m_startPosition_;
}

void ClippingEdge::setStartPosition(const ::nds::core::geometry::Position2D& startPosition_)
{
    m_startPosition_ = startPosition_;
}

void ClippingEdge::setStartPosition(::nds::core::geometry::Position2D&& startPosition_)
{
    m_startPosition_ = ::std::move(startPosition_);
}

::nds::core::geometry::Position2D& ClippingEdge::getEndPosition()
{
    return m_endPosition_;
}

const ::nds::core::geometry::Position2D& ClippingEdge::getEndPosition() const
{
    return m_endPosition_;
}

void ClippingEdge::setEndPosition(const ::nds::core::geometry::Position2D& endPosition_)
{
    m_endPosition_ = endPosition_;
}

void ClippingEdge::setEndPosition(::nds::core::geometry::Position2D&& endPosition_)
{
    m_endPosition_ = ::std::move(endPosition_);
}

void ClippingEdge::initPackingContext(ClippingEdge::ZserioPackingContext& context) const
{
    m_startPosition_.initPackingContext(context.getStartPosition());
    m_endPosition_.initPackingContext(context.getEndPosition());
}

size_t ClippingEdge::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_startPosition_.bitSizeOf(endBitPosition);
    endBitPosition += m_endPosition_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ClippingEdge::bitSizeOf(ClippingEdge::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_startPosition_.bitSizeOf(context.getStartPosition(), endBitPosition);
    endBitPosition += m_endPosition_.bitSizeOf(context.getEndPosition(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ClippingEdge::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_startPosition_.initializeOffsets(endBitPosition);
    endBitPosition = m_endPosition_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t ClippingEdge::initializeOffsets(ClippingEdge::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_startPosition_.initializeOffsets(context.getStartPosition(), endBitPosition);
    endBitPosition = m_endPosition_.initializeOffsets(context.getEndPosition(), endBitPosition);

    return endBitPosition;
}

bool ClippingEdge::operator==(const ClippingEdge& other) const
{
    if (this != &other)
    {
        return
                (getShift() == other.getShift()) &&
                (m_startPosition_ == other.m_startPosition_) &&
                (m_endPosition_ == other.m_endPosition_);
    }

    return true;
}

uint32_t ClippingEdge::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getShift());
    result = ::zserio::calcHashCode(result, m_startPosition_);
    result = ::zserio::calcHashCode(result, m_endPosition_);

    return result;
}

void ClippingEdge::write(::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_startPosition_.getShift() != static_cast<::nds::core::geometry::CoordShift>(getShift()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field ClippingEdge.startPosition: ") <<
                m_startPosition_.getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShift()) << "!";
    }
    m_startPosition_.write(out);

    // check parameters
    if (m_endPosition_.getShift() != static_cast<::nds::core::geometry::CoordShift>(getShift()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field ClippingEdge.endPosition: ") <<
                m_endPosition_.getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShift()) << "!";
    }
    m_endPosition_.write(out);
}

void ClippingEdge::write(ClippingEdge::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_startPosition_.getShift() != static_cast<::nds::core::geometry::CoordShift>(getShift()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field ClippingEdge.startPosition: ") <<
                m_startPosition_.getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShift()) << "!";
    }
    m_startPosition_.write(context.getStartPosition(), out);

    // check parameters
    if (m_endPosition_.getShift() != static_cast<::nds::core::geometry::CoordShift>(getShift()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field ClippingEdge.endPosition: ") <<
                m_endPosition_.getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShift()) << "!";
    }
    m_endPosition_.write(context.getEndPosition(), out);
}

::nds::core::geometry::Position2D ClippingEdge::readStartPosition(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::geometry::Position2D(in, static_cast<::nds::core::geometry::CoordShift>(getShift()), allocator);
}

::nds::core::geometry::Position2D ClippingEdge::readStartPosition(ClippingEdge::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::geometry::Position2D(context.getStartPosition(), in, static_cast<::nds::core::geometry::CoordShift>(getShift()), allocator);
}
::nds::core::geometry::Position2D ClippingEdge::readEndPosition(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::geometry::Position2D(in, static_cast<::nds::core::geometry::CoordShift>(getShift()), allocator);
}

::nds::core::geometry::Position2D ClippingEdge::readEndPosition(ClippingEdge::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::geometry::Position2D(context.getEndPosition(), in, static_cast<::nds::core::geometry::CoordShift>(getShift()), allocator);
}

} // namespace types
} // namespace display
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/display/types/GenericIconSetMap.h>

namespace nds
{
namespace display
{
namespace types
{

GenericIconSetMap::GenericIconSetMap(const allocator_type& allocator) noexcept :
        m_moduleName_(allocator),
        m_moduleVersion_(allocator),
        m_numElements_(uint32_t()),
        m_elements_(allocator)
{
}

GenericIconSetMap::GenericIconSetMap(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_moduleName_(readModuleName(in, allocator)),
        m_moduleVersion_(readModuleVersion(in, allocator)),
        m_numElements_(readNumElements(in)),
        m_elements_(readElements(in, allocator))
{
}

GenericIconSetMap::GenericIconSetMap(GenericIconSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_moduleName_(readModuleName(in, allocator)),
        m_moduleVersion_(readModuleVersion(in, allocator)),
        m_numElements_(readNumElements(context, in)),
        m_elements_(readElements(context, in, allocator))
{
}

GenericIconSetMap::GenericIconSetMap(::zserio::PropagateAllocatorT,
        const GenericIconSetMap& other, const allocator_type& allocator) :
        m_moduleName_(::zserio::allocatorPropagatingCopy(other.m_moduleName_, allocator)),
        m_moduleVersion_(::zserio::allocatorPropagatingCopy(other.m_moduleVersion_, allocator)),
        m_numElements_(::zserio::allocatorPropagatingCopy(other.m_numElements_, allocator)),
        m_elements_(::zserio::allocatorPropagatingCopy(other.m_elements_, allocator))
{
}

::nds::system::types::ModuleName& GenericIconSetMap::getModuleName()
{
    return m_moduleName_;
}

const ::nds::system::types::ModuleName& GenericIconSetMap::getModuleName() const
{
    return m_moduleName_;
}

void GenericIconSetMap::setModuleName(const ::nds::system::types::ModuleName& moduleName_)
{
    m_moduleName_ = moduleName_;
}

void GenericIconSetMap::setModuleName(::nds::system::types::ModuleName&& moduleName_)
{
    m_moduleName_ = ::std::move(moduleName_);
}

::nds::system::types::ModuleVersion& GenericIconSetMap::getModuleVersion()
{
    return m_moduleVersion_;
}

const ::nds::system::types::ModuleVersion& GenericIconSetMap::getModuleVersion() const
{
    return m_moduleVersion_;
}

void GenericIconSetMap::setModuleVersion(const ::nds::system::types::ModuleVersion& moduleVersion_)
{
    m_moduleVersion_ = moduleVersion_;
}

void GenericIconSetMap::setModuleVersion(::nds::system::types::ModuleVersion&& moduleVersion_)
{
    m_moduleVersion_ = ::std::move(moduleVersion_);
}

uint32_t GenericIconSetMap::getNumElements() const
{
    return m_numElements_;
}

void GenericIconSetMap::setNumElements(uint32_t numElements_)
{
    m_numElements_ = numElements_;
}

::zserio::vector<::nds::display::types::GenericIconSetMapElement>& GenericIconSetMap::getElements()
{
    return m_elements_.getRawArray();
}

const ::zserio::vector<::nds::display::types::GenericIconSetMapElement>& GenericIconSetMap::getElements() const
{
    return m_elements_.getRawArray();
}

void GenericIconSetMap::setElements(const ::zserio::vector<::nds::display::types::GenericIconSetMapElement>& elements_)
{
    m_elements_ = ZserioArrayType_elements(elements_);
}

void GenericIconSetMap::setElements(::zserio::vector<::nds::display::types::GenericIconSetMapElement>&& elements_)
{
    m_elements_ = ZserioArrayType_elements(std::move(elements_));
}

void GenericIconSetMap::initPackingContext(GenericIconSetMap::ZserioPackingContext& context) const
{
    context.getNumElements().init<::zserio::VarSizeArrayTraits>(m_numElements_);
}

size_t GenericIconSetMap::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfString(m_moduleName_);
    endBitPosition += ::zserio::bitSizeOfString(m_moduleVersion_);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_numElements_);
    endBitPosition += m_elements_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t GenericIconSetMap::bitSizeOf(GenericIconSetMap::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfString(m_moduleName_);
    endBitPosition += ::zserio::bitSizeOfString(m_moduleVersion_);
    endBitPosition += context.getNumElements().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numElements_);
    endBitPosition += m_elements_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t GenericIconSetMap::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfString(m_moduleName_);
    endBitPosition += ::zserio::bitSizeOfString(m_moduleVersion_);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_numElements_);
    endBitPosition = m_elements_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t GenericIconSetMap::initializeOffsets(GenericIconSetMap::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfString(m_moduleName_);
    endBitPosition += ::zserio::bitSizeOfString(m_moduleVersion_);
    endBitPosition += context.getNumElements().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numElements_);
    endBitPosition = m_elements_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool GenericIconSetMap::operator==(const GenericIconSetMap& other) const
{
    if (this != &other)
    {
        return
                (m_moduleName_ == other.m_moduleName_) &&
                (m_moduleVersion_ == other.m_moduleVersion_) &&
                (m_numElements_ == other.m_numElements_) &&
                (m_elements_ == other.m_elements_);
    }

    return true;
}

uint32_t GenericIconSetMap::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_moduleName_);
    result = ::zserio::calcHashCode(result, m_moduleVersion_);
    result = ::zserio::calcHashCode(result, m_numElements_);
    result = ::zserio::calcHashCode(result, m_elements_);

    return result;
}

void GenericIconSetMap::write(::zserio::BitStreamWriter& out) const
{
    out.writeString(m_moduleName_);

    out.writeString(m_moduleVersion_);

    out.writeVarSize(m_numElements_);

    // check array length
    if (m_elements_.getRawArray().size() != static_cast<size_t>(getNumElements()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field GenericIconSetMap.elements: ") <<
                m_elements_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumElements()) << "!";
    }
    m_elements_.writePacked(*this, out);
}

void GenericIconSetMap::write(GenericIconSetMap::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    out.writeString(m_moduleName_);

    out.writeString(m_moduleVersion_);

    context.getNumElements().write<::zserio::VarSizeArrayTraits>(out, m_numElements_);

    // check array length
    if (m_elements_.getRawArray().size() != static_cast<size_t>(getNumElements()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field GenericIconSetMap.elements: ") <<
                m_elements_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumElements()) << "!";
    }
    m_elements_.writePacked(*this, out);
}

void GenericIconSetMap::ZserioElementFactory_elements::create(GenericIconSetMap&        ,
        ::zserio::vector<::nds::display::types::GenericIconSetMapElement>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void GenericIconSetMap::ZserioElementFactory_elements::create(GenericIconSetMap&        ,
        ::zserio::vector<::nds::display::types::GenericIconSetMapElement>& array,
        ::nds::display::types::GenericIconSetMapElement::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::system::types::ModuleName GenericIconSetMap::readModuleName(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return static_cast<::nds::system::types::ModuleName>(in.readString(allocator));
}
::nds::system::types::ModuleVersion GenericIconSetMap::readModuleVersion(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return static_cast<::nds::system::types::ModuleVersion>(in.readString(allocator));
}
uint32_t GenericIconSetMap::readNumElements(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t GenericIconSetMap::readNumElements(GenericIconSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumElements().read<::zserio::VarSizeArrayTraits>(in);
}
GenericIconSetMap::ZserioArrayType_elements GenericIconSetMap::readElements(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_elements readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumElements()));

    return readField;
}

GenericIconSetMap::ZserioArrayType_elements GenericIconSetMap::readElements(GenericIconSetMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_elements readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumElements()));

    return readField;
}

} // namespace types
} // namespace display
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/display/types/GenericIconSetMapElement.h>

namespace nds
{
namespace display
{
namespace types
{

GenericIconSetMapElement::GenericIconSetMapElement(const allocator_type& allocator) noexcept :
        m_id_(::nds::core::icons::IconSetId()),
        m_descriptor_(allocator),
        m_targetEnumValue_(::zserio::NullOpt)
{
}

GenericIconSetMapElement::GenericIconSetMapElement(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_id_(readId(in)),
        m_descriptor_(readDescriptor(in, allocator)),
        m_targetEnumValue_(readTargetEnumValue(in))
{
}

GenericIconSetMapElement::GenericIconSetMapElement(GenericIconSetMapElement::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_id_(readId(context, in)),
        m_descriptor_(readDescriptor(in, allocator)),
        m_targetEnumValue_(readTargetEnumValue(context, in))
{
}

GenericIconSetMapElement::GenericIconSetMapElement(::zserio::PropagateAllocatorT,
        const GenericIconSetMapElement& other, const allocator_type& allocator) :
        m_id_(::zserio::allocatorPropagatingCopy(other.m_id_, allocator)),
        m_descriptor_(::zserio::allocatorPropagatingCopy(other.m_descriptor_, allocator)),
        m_targetEnumValue_(::zserio::allocatorPropagatingCopy(other.m_targetEnumValue_, allocator))
{
}

::nds::core::icons::IconSetId GenericIconSetMapElement::getId() const
{
    return m_id_;
}

void GenericIconSetMapElement::setId(::nds::core::icons::IconSetId id_)
{
    m_id_ = id_;
}

::nds::system::types::ModuleExtern& GenericIconSetMapElement::getDescriptor()
{
    return m_descriptor_;
}

const ::nds::system::types::ModuleExtern& GenericIconSetMapElement::getDescriptor() const
{
    return m_descriptor_;
}

void GenericIconSetMapElement::setDescriptor(const ::nds::system::types::ModuleExtern& descriptor_)
{
    m_descriptor_ = descriptor_;
}

void GenericIconSetMapElement::setDescriptor(::nds::system::types::ModuleExtern&& descriptor_)
{
    m_descriptor_ = ::std::move(descriptor_);
}

int64_t GenericIconSetMapElement::getTargetEnumValue() const
{
    return m_targetEnumValue_.value();
}

void GenericIconSetMapElement::setTargetEnumValue(int64_t targetEnumValue_)
{
    m_targetEnumValue_ = targetEnumValue_;
}

bool GenericIconSetMapElement::isTargetEnumValueUsed() const
{
    return (isTargetEnumValueSet());
}

bool GenericIconSetMapElement::isTargetEnumValueSet() const
{
    return m_targetEnumValue_.hasValue();
}

void GenericIconSetMapElement::resetTargetEnumValue()
{
    m_targetEnumValue_.reset();
}

void GenericIconSetMapElement::initPackingContext(GenericIconSetMapElement::ZserioPackingContext& context) const
{
    context.getId().init<::zserio::VarIntArrayTraits<::nds::core::icons::IconSetId>>(m_id_);
    if (isTargetEnumValueSet())
    {
        context.getTargetEnumValue().init<::zserio::VarIntArrayTraits<int64_t>>(m_targetEnumValue_.value());
    }
}

size_t GenericIconSetMapElement::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt(m_id_);
    endBitPosition += ::zserio::bitSizeOfString(m_descriptor_);
    endBitPosition += 1;
    if (isTargetEnumValueSet())
    {
        endBitPosition += ::zserio::bitSizeOfVarInt(m_targetEnumValue_.value());
    }

    return endBitPosition - bitPosition;
}

size_t GenericIconSetMapElement::bitSizeOf(GenericIconSetMapElement::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getId().bitSizeOf<::zserio::VarIntArrayTraits<::nds::core::icons::IconSetId>>(m_id_);
    endBitPosition += ::zserio::bitSizeOfString(m_descriptor_);
    endBitPosition += 1;
    if (isTargetEnumValueSet())
    {
        endBitPosition += context.getTargetEnumValue().bitSizeOf<::zserio::VarIntArrayTraits<int64_t>>(m_targetEnumValue_.value());
    }

    return endBitPosition - bitPosition;
}

size_t GenericIconSetMapElement::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt(m_id_);
    endBitPosition += ::zserio::bitSizeOfString(m_descriptor_);
    endBitPosition += 1;
    if (isTargetEnumValueSet())
    {
        endBitPosition += ::zserio::bitSizeOfVarInt(m_targetEnumValue_.value());
    }

    return endBitPosition;
}

size_t GenericIconSetMapElement::initializeOffsets(GenericIconSetMapElement::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getId().bitSizeOf<::zserio::VarIntArrayTraits<::nds::core::icons::IconSetId>>(m_id_);
    endBitPosition += ::zserio::bitSizeOfString(m_descriptor_);
    endBitPosition += 1;
    if (isTargetEnumValueSet())
    {
        endBitPosition += context.getTargetEnumValue().bitSizeOf<::zserio::VarIntArrayTraits<int64_t>>(m_targetEnumValue_.value());
    }

    return endBitPosition;
}

bool GenericIconSetMapElement::operator==(const GenericIconSetMapElement& other) const
{
    if (this != &other)
    {
        return
                (m_id_ == other.m_id_) &&
                (m_descriptor_ == other.m_descriptor_) &&
                (!isTargetEnumValueUsed() ? !other.isTargetEnumValueUsed() : (m_targetEnumValue_ == other.m_targetEnumValue_));
    }

    return true;
}

uint32_t GenericIconSetMapElement::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_id_);
    result = ::zserio::calcHashCode(result, m_descriptor_);
    if (isTargetEnumValueUsed())
        result = ::zserio::calcHashCode(result, m_targetEnumValue_);

    return result;
}

void GenericIconSetMapElement::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt(m_id_);
    out.writeString(m_descriptor_);
    if (isTargetEnumValueSet())
    {
        out.writeBool(true);
        out.writeVarInt(m_targetEnumValue_.value());
    }
    else
    {
        out.writeBool(false);
    }
}

void GenericIconSetMapElement::write(GenericIconSetMapElement::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getId().write<::zserio::VarIntArrayTraits<::nds::core::icons::IconSetId>>(out, m_id_);
    out.writeString(m_descriptor_);
    if (isTargetEnumValueSet())
    {
        out.writeBool(true);
        context.getTargetEnumValue().write<::zserio::VarIntArrayTraits<int64_t>>(out, m_targetEnumValue_.value());
    }
    else
    {
        out.writeBool(false);
    }
}

::nds::core::icons::IconSetId GenericIconSetMapElement::readId(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::icons::IconSetId>(in.readVarUInt());
}

::nds::core::icons::IconSetId GenericIconSetMapElement::readId(GenericIconSetMapElement::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getId().read<::zserio::VarIntArrayTraits<::nds::core::icons::IconSetId>>(in);
}
::nds::system::types::ModuleExtern GenericIconSetMapElement::readDescriptor(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return static_cast<::nds::system::types::ModuleExtern>(in.readString(allocator));
}
::zserio::InplaceOptionalHolder<int64_t> GenericIconSetMapElement::readTargetEnumValue(::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<int64_t>(static_cast<int64_t>(in.readVarInt()));
    }

    return ::zserio::InplaceOptionalHolder<int64_t>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<int64_t> GenericIconSetMapElement::readTargetEnumValue(GenericIconSetMapElement::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<int64_t>(context.getTargetEnumValue().read<::zserio::VarIntArrayTraits<int64_t>>(in));
    }

    return ::zserio::InplaceOptionalHolder<int64_t>(::zserio::NullOpt);
}

} // namespace types
} // namespace display
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ConstraintException.h>
#include <zserio/ArrayTraits.h>

#include <nds/display/types/Mesh3DRenderLayerHeader.h>
#include <nds/display/types/UsedColorModes.h>

namespace nds
{
namespace display
{
namespace types
{

Mesh3DRenderLayerHeader::Mesh3DRenderLayerHeader(const allocator_type&) noexcept :
        m_colorModes_(::nds::display::types::UsedColorModes()),
        m_numColorIds_(::zserio::NullOpt),
        m_hasNormals_(bool()),
        m_numNormals_(::zserio::NullOpt),
        m_hasTextureCoords_(bool()),
        m_numTextureCoords_(::zserio::NullOpt),
        m_hasTextureCoordsAdditional_(bool()),
        m_numTextureCoordsAdditional_(::zserio::NullOpt)
{
}

Mesh3DRenderLayerHeader::Mesh3DRenderLayerHeader(::zserio::BitStreamReader& in, const allocator_type&) :
        m_colorModes_(readColorModes(in)),
        m_numColorIds_(readNumColorIds(in)),
        m_hasNormals_(readHasNormals(in)),
        m_numNormals_(readNumNormals(in)),
        m_hasTextureCoords_(readHasTextureCoords(in)),
        m_numTextureCoords_(readNumTextureCoords(in)),
        m_hasTextureCoordsAdditional_(readHasTextureCoordsAdditional(in)),
        m_numTextureCoordsAdditional_(readNumTextureCoordsAdditional(in))
{
}

Mesh3DRenderLayerHeader::Mesh3DRenderLayerHeader(Mesh3DRenderLayerHeader::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type&) :
        m_colorModes_(readColorModes(context, in)),
        m_numColorIds_(readNumColorIds(context, in)),
        m_hasNormals_(readHasNormals(in)),
        m_numNormals_(readNumNormals(context, in)),
        m_hasTextureCoords_(readHasTextureCoords(in)),
        m_numTextureCoords_(readNumTextureCoords(context, in)),
        m_hasTextureCoordsAdditional_(readHasTextureCoordsAdditional(in)),
        m_numTextureCoordsAdditional_(readNumTextureCoordsAdditional(context, in))
{
}

Mesh3DRenderLayerHeader::Mesh3DRenderLayerHeader(::zserio::PropagateAllocatorT,
        const Mesh3DRenderLayerHeader& other, const allocator_type& allocator) :
        m_colorModes_(::zserio::allocatorPropagatingCopy(other.m_colorModes_, allocator)),
        m_numColorIds_(::zserio::allocatorPropagatingCopy(other.m_numColorIds_, allocator)),
        m_hasNormals_(::zserio::allocatorPropagatingCopy(other.m_hasNormals_, allocator)),
        m_numNormals_(::zserio::allocatorPropagatingCopy(other.m_numNormals_, allocator)),
        m_hasTextureCoords_(::zserio::allocatorPropagatingCopy(other.m_hasTextureCoords_, allocator)),
        m_numTextureCoords_(::zserio::allocatorPropagatingCopy(other.m_numTextureCoords_, allocator)),
        m_hasTextureCoordsAdditional_(::zserio::allocatorPropagatingCopy(other.m_hasTextureCoordsAdditional_, allocator)),
        m_numTextureCoordsAdditional_(::zserio::allocatorPropagatingCopy(other.m_numTextureCoordsAdditional_, allocator))
{
}

::nds::display::types::UsedColorModes Mesh3DRenderLayerHeader::getColorModes() const
{
    return m_colorModes_;
}

void Mesh3DRenderLayerHeader::setColorModes(::nds::display::types::UsedColorModes colorModes_)
{
    m_colorModes_ = colorModes_;
}

uint16_t Mesh3DRenderLayerHeader::getNumColorIds() const
{
    return m_numColorIds_.value();
}

void Mesh3DRenderLayerHeader::setNumColorIds(uint16_t numColorIds_)
{
    m_numColorIds_ = numColorIds_;
}

bool Mesh3DRenderLayerHeader::isNumColorIdsUsed() const
{
    return ((funcHasColorPerVertex() == true));
}

bool Mesh3DRenderLayerHeader::isNumColorIdsSet() const
{
    return m_numColorIds_.hasValue();
}

void Mesh3DRenderLayerHeader::resetNumColorIds()
{
    m_numColorIds_.reset();
}

bool Mesh3DRenderLayerHeader::getHasNormals() const
{
    return m_hasNormals_;
}

void Mesh3DRenderLayerHeader::setHasNormals(bool hasNormals_)
{
    m_hasNormals_ = hasNormals_;
}

uint32_t Mesh3DRenderLayerHeader::getNumNormals() const
{
    return m_numNormals_.value();
}

void Mesh3DRenderLayerHeader::setNumNormals(uint32_t numNormals_)
{
    m_numNormals_ = numNormals_;
}

bool Mesh3DRenderLayerHeader::isNumNormalsUsed() const
{
    return (getHasNormals() == true);
}

bool Mesh3DRenderLayerHeader::isNumNormalsSet() const
{
    return m_numNormals_.hasValue();
}

void Mesh3DRenderLayerHeader::resetNumNormals()
{
    m_numNormals_.reset();
}

bool Mesh3DRenderLayerHeader::getHasTextureCoords() const
{
    return m_hasTextureCoords_;
}

void Mesh3DRenderLayerHeader::setHasTextureCoords(bool hasTextureCoords_)
{
    m_hasTextureCoords_ = hasTextureCoords_;
}

uint32_t Mesh3DRenderLayerHeader::getNumTextureCoords() const
{
    return m_numTextureCoords_.value();
}

void Mesh3DRenderLayerHeader::setNumTextureCoords(uint32_t numTextureCoords_)
{
    m_numTextureCoords_ = numTextureCoords_;
}

bool Mesh3DRenderLayerHeader::isNumTextureCoordsUsed() const
{
    return (getHasTextureCoords());
}

bool Mesh3DRenderLayerHeader::isNumTextureCoordsSet() const
{
    return m_numTextureCoords_.hasValue();
}

void Mesh3DRenderLayerHeader::resetNumTextureCoords()
{
    m_numTextureCoords_.reset();
}

bool Mesh3DRenderLayerHeader::getHasTextureCoordsAdditional() const
{
    return m_hasTextureCoordsAdditional_;
}

void Mesh3DRenderLayerHeader::setHasTextureCoordsAdditional(bool hasTextureCoordsAdditional_)
{
    m_hasTextureCoordsAdditional_ = hasTextureCoordsAdditional_;
}

uint32_t Mesh3DRenderLayerHeader::getNumTextureCoordsAdditional() const
{
    return m_numTextureCoordsAdditional_.value();
}

void Mesh3DRenderLayerHeader::setNumTextureCoordsAdditional(uint32_t numTextureCoordsAdditional_)
{
    m_numTextureCoordsAdditional_ = numTextureCoordsAdditional_;
}

bool Mesh3DRenderLayerHeader::isNumTextureCoordsAdditionalUsed() const
{
    return (getHasTextureCoordsAdditional());
}

bool Mesh3DRenderLayerHeader::isNumTextureCoordsAdditionalSet() const
{
    return m_numTextureCoordsAdditional_.hasValue();
}

void Mesh3DRenderLayerHeader::resetNumTextureCoordsAdditional()
{
    m_numTextureCoordsAdditional_.reset();
}

bool Mesh3DRenderLayerHeader::funcUsesColors() const
{
    return static_cast<bool>(static_cast<::nds::display::types::UsedColorModes::underlying_type>(getColorModes()) > 0);
}

bool Mesh3DRenderLayerHeader::funcHasColorPerVertex() const
{
    return static_cast<bool>((getColorModes() & ::nds::display::types::UsedColorModes::Values::COLOR_PER_VERTEX) == ::nds::display::types::UsedColorModes::Values::COLOR_PER_VERTEX);
}

uint16_t Mesh3DRenderLayerHeader::funcNumOfColorIds() const
{
    return static_cast<uint16_t>(((getColorModes() & ::nds::display::types::UsedColorModes::Values::COLOR_PER_VERTEX) == ::nds::display::types::UsedColorModes::Values::COLOR_PER_VERTEX) ? getNumColorIds() : 0);
}

uint32_t Mesh3DRenderLayerHeader::funcNumOfNormals() const
{
    return static_cast<uint32_t>((getHasNormals()) ? getNumNormals() : 0);
}

uint32_t Mesh3DRenderLayerHeader::funcNumOfTextureCoords() const
{
    return static_cast<uint32_t>((getHasTextureCoords()) ? getNumTextureCoords() : 0);
}

uint32_t Mesh3DRenderLayerHeader::funcNumOfTextureCoordsAdditional() const
{
    return static_cast<uint32_t>((getHasTextureCoordsAdditional()) ? getNumTextureCoordsAdditional() : 0);
}

void Mesh3DRenderLayerHeader::initPackingContext(Mesh3DRenderLayerHeader::ZserioPackingContext& context) const
{
    m_colorModes_.initPackingContext(context.getColorModes());
    if ((funcHasColorPerVertex() == true))
    {
        context.getNumColorIds().init<::zserio::StdIntArrayTraits<uint16_t>>(m_numColorIds_.value());
    }
    if (getHasNormals() == true)
    {
        context.getNumNormals().init<::zserio::VarSizeArrayTraits>(m_numNormals_.value());
    }
    if (getHasTextureCoords())
    {
        context.getNumTextureCoords().init<::zserio::VarSizeArrayTraits>(m_numTextureCoords_.value());
    }
    if (getHasTextureCoordsAdditional())
    {
        context.getNumTextureCoordsAdditional().init<::zserio::VarSizeArrayTraits>(m_numTextureCoordsAdditional_.value());
    }
}

size_t Mesh3DRenderLayerHeader::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_colorModes_.bitSizeOf(endBitPosition);
    if ((funcHasColorPerVertex() == true))
    {
        endBitPosition += UINT8_C(16);
    }
    endBitPosition += UINT8_C(1);
    if (getHasNormals() == true)
    {
        endBitPosition += ::zserio::bitSizeOfVarSize(m_numNormals_.value());
    }
    endBitPosition += UINT8_C(1);
    if (getHasTextureCoords())
    {
        endBitPosition += ::zserio::bitSizeOfVarSize(m_numTextureCoords_.value());
    }
    endBitPosition += UINT8_C(1);
    if (getHasTextureCoordsAdditional())
    {
        endBitPosition += ::zserio::bitSizeOfVarSize(m_numTextureCoordsAdditional_.value());
    }

    return endBitPosition - bitPosition;
}

size_t Mesh3DRenderLayerHeader::bitSizeOf(Mesh3DRenderLayerHeader::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_colorModes_.bitSizeOf(context.getColorModes(), endBitPosition);
    if ((funcHasColorPerVertex() == true))
    {
        endBitPosition += context.getNumColorIds().bitSizeOf<::zserio::StdIntArrayTraits<uint16_t>>(m_numColorIds_.value());
    }
    endBitPosition += UINT8_C(1);
    if (getHasNormals() == true)
    {
        endBitPosition += context.getNumNormals().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numNormals_.value());
    }
    endBitPosition += UINT8_C(1);
    if (getHasTextureCoords())
    {
        endBitPosition += context.getNumTextureCoords().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numTextureCoords_.value());
    }
    endBitPosition += UINT8_C(1);
    if (getHasTextureCoordsAdditional())
    {
        endBitPosition += context.getNumTextureCoordsAdditional().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numTextureCoordsAdditional_.value());
    }

    return endBitPosition - bitPosition;
}

size_t Mesh3DRenderLayerHeader::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_colorModes_.initializeOffsets(endBitPosition);
    if ((funcHasColorPerVertex() == true))
    {
        endBitPosition += UINT8_C(16);
    }
    endBitPosition += UINT8_C(1);
    if (getHasNormals() == true)
    {
        endBitPosition += ::zserio::bitSizeOfVarSize(m_numNormals_.value());
    }
    endBitPosition += UINT8_C(1);
    if (getHasTextureCoords())
    {
        endBitPosition += ::zserio::bitSizeOfVarSize(m_numTextureCoords_.value());
    }
    endBitPosition += UINT8_C(1);
    if (getHasTextureCoordsAdditional())
    {
        endBitPosition += ::zserio::bitSizeOfVarSize(m_numTextureCoordsAdditional_.value());
    }

    return endBitPosition;
}

size_t Mesh3DRenderLayerHeader::initializeOffsets(Mesh3DRenderLayerHeader::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_colorModes_.initializeOffsets(context.getColorModes(), endBitPosition);
    if ((funcHasColorPerVertex() == true))
    {
        endBitPosition += context.getNumColorIds().bitSizeOf<::zserio::StdIntArrayTraits<uint16_t>>(m_numColorIds_.value());
    }
    endBitPosition += UINT8_C(1);
    if (getHasNormals() == true)
    {
        endBitPosition += context.getNumNormals().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numNormals_.value());
    }
    endBitPosition += UINT8_C(1);
    if (getHasTextureCoords())
    {
        endBitPosition += context.getNumTextureCoords().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numTextureCoords_.value());
    }
    endBitPosition += UINT8_C(1);
    if (getHasTextureCoordsAdditional())
    {
        endBitPosition += context.getNumTextureCoordsAdditional().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numTextureCoordsAdditional_.value());
    }

    return endBitPosition;
}

bool Mesh3DRenderLayerHeader::operator==(const Mesh3DRenderLayerHeader& other) const
{
    if (this != &other)
    {
        return
                (m_colorModes_ == other.m_colorModes_) &&
                (!isNumColorIdsUsed() ? !other.isNumColorIdsUsed() : (m_numColorIds_ == other.m_numColorIds_)) &&
                (m_hasNormals_ == other.m_hasNormals_) &&
                (!isNumNormalsUsed() ? !other.isNumNormalsUsed() : (m_numNormals_ == other.m_numNormals_)) &&
                (m_hasTextureCoords_ == other.m_hasTextureCoords_) &&
                (!isNumTextureCoordsUsed() ? !other.isNumTextureCoordsUsed() : (m_numTextureCoords_ == other.m_numTextureCoords_)) &&
                (m_hasTextureCoordsAdditional_ == other.m_hasTextureCoordsAdditional_) &&
                (!isNumTextureCoordsAdditionalUsed() ? !other.isNumTextureCoordsAdditionalUsed() : (m_numTextureCoordsAdditional_ == other.m_numTextureCoordsAdditional_));
    }

    return true;
}

uint32_t Mesh3DRenderLayerHeader::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_colorModes_);
    if (isNumColorIdsUsed())
        result = ::zserio::calcHashCode(result, m_numColorIds_);
    result = ::zserio::calcHashCode(result, m_hasNormals_);
    if (isNumNormalsUsed())
        result = ::zserio::calcHashCode(result, m_numNormals_);
    result = ::zserio::calcHashCode(result, m_hasTextureCoords_);
    if (isNumTextureCoordsUsed())
        result = ::zserio::calcHashCode(result, m_numTextureCoords_);
    result = ::zserio::calcHashCode(result, m_hasTextureCoordsAdditional_);
    if (isNumTextureCoordsAdditionalUsed())
        result = ::zserio::calcHashCode(result, m_numTextureCoordsAdditional_);

    return result;
}

void Mesh3DRenderLayerHeader::write(::zserio::BitStreamWriter& out) const
{
    m_colorModes_.write(out);

    if ((funcHasColorPerVertex() == true))
    {
        out.writeBits(m_numColorIds_.value(), UINT8_C(16));
    }

    out.writeBool(m_hasNormals_);

    if (getHasNormals() == true)
    {
        // check constraint
        if (!(getNumNormals() > 0))
            throw ::zserio::ConstraintException("Write: Constraint violated at Mesh3DRenderLayerHeader.numNormals!");
        out.writeVarSize(m_numNormals_.value());
    }

    out.writeBool(m_hasTextureCoords_);

    if (getHasTextureCoords())
    {
        // check constraint
        if (!(getNumTextureCoords() > 0))
            throw ::zserio::ConstraintException("Write: Constraint violated at Mesh3DRenderLayerHeader.numTextureCoords!");
        out.writeVarSize(m_numTextureCoords_.value());
    }

    out.writeBool(m_hasTextureCoordsAdditional_);

    if (getHasTextureCoordsAdditional())
    {
        // check constraint
        if (!(getNumTextureCoordsAdditional() > 0))
            throw ::zserio::ConstraintException("Write: Constraint violated at Mesh3DRenderLayerHeader.numTextureCoordsAdditional!");
        out.writeVarSize(m_numTextureCoordsAdditional_.value());
    }
}

void Mesh3DRenderLayerHeader::write(Mesh3DRenderLayerHeader::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_colorModes_.write(context.getColorModes(), out);

    if ((funcHasColorPerVertex() == true))
    {
        context.getNumColorIds().write<::zserio::StdIntArrayTraits<uint16_t>>(out, m_numColorIds_.value());
    }

    out.writeBool(m_hasNormals_);

    if (getHasNormals() == true)
    {
        // check constraint
        if (!(getNumNormals() > 0))
            throw ::zserio::ConstraintException("Write: Constraint violated at Mesh3DRenderLayerHeader.numNormals!");
        context.getNumNormals().write<::zserio::VarSizeArrayTraits>(out, m_numNormals_.value());
    }

    out.writeBool(m_hasTextureCoords_);

    if (getHasTextureCoords())
    {
        // check constraint
        if (!(getNumTextureCoords() > 0))
            throw ::zserio::ConstraintException("Write: Constraint violated at Mesh3DRenderLayerHeader.numTextureCoords!");
        context.getNumTextureCoords().write<::zserio::VarSizeArrayTraits>(out, m_numTextureCoords_.value());
    }

    out.writeBool(m_hasTextureCoordsAdditional_);

    if (getHasTextureCoordsAdditional())
    {
        // check constraint
        if (!(getNumTextureCoordsAdditional() > 0))
            throw ::zserio::ConstraintException("Write: Constraint violated at Mesh3DRenderLayerHeader.numTextureCoordsAdditional!");
        context.getNumTextureCoordsAdditional().write<::zserio::VarSizeArrayTraits>(out, m_numTextureCoordsAdditional_.value());
    }
}

::nds::display::types::UsedColorModes Mesh3DRenderLayerHeader::readColorModes(::zserio::BitStreamReader& in)
{
    return ::nds::display::types::UsedColorModes(in);
}

::nds::display::types::UsedColorModes Mesh3DRenderLayerHeader::readColorModes(Mesh3DRenderLayerHeader::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::nds::display::types::UsedColorModes(context.getColorModes(), in);
}
::zserio::InplaceOptionalHolder<uint16_t> Mesh3DRenderLayerHeader::readNumColorIds(::zserio::BitStreamReader& in)
{
    if ((funcHasColorPerVertex() == true))
    {
        return ::zserio::InplaceOptionalHolder<uint16_t>(static_cast<uint16_t>(in.readBits(UINT8_C(16))));
    }

    return ::zserio::InplaceOptionalHolder<uint16_t>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<uint16_t> Mesh3DRenderLayerHeader::readNumColorIds(Mesh3DRenderLayerHeader::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if ((funcHasColorPerVertex() == true))
    {
        return ::zserio::InplaceOptionalHolder<uint16_t>(context.getNumColorIds().read<::zserio::StdIntArrayTraits<uint16_t>>(in));
    }

    return ::zserio::InplaceOptionalHolder<uint16_t>(::zserio::NullOpt);
}
bool Mesh3DRenderLayerHeader::readHasNormals(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
::zserio::InplaceOptionalHolder<uint32_t> Mesh3DRenderLayerHeader::readNumNormals(::zserio::BitStreamReader& in)
{
    if (getHasNormals() == true)
    {
        uint32_t readField = static_cast<uint32_t>(in.readVarSize());
        // check constraint
        if (!(readField > 0))
            throw ::zserio::ConstraintException("Read: Constraint violated at Mesh3DRenderLayerHeader.numNormals!");

        return ::zserio::InplaceOptionalHolder<uint32_t>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<uint32_t>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<uint32_t> Mesh3DRenderLayerHeader::readNumNormals(Mesh3DRenderLayerHeader::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (getHasNormals() == true)
    {
        uint32_t readField = context.getNumNormals().read<::zserio::VarSizeArrayTraits>(in);
        // check constraint
        if (!(readField > 0))
            throw ::zserio::ConstraintException("Read: Constraint violated at Mesh3DRenderLayerHeader.numNormals!");

        return ::zserio::InplaceOptionalHolder<uint32_t>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<uint32_t>(::zserio::NullOpt);
}
bool Mesh3DRenderLayerHeader::readHasTextureCoords(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
::zserio::InplaceOptionalHolder<uint32_t> Mesh3DRenderLayerHeader::readNumTextureCoords(::zserio::BitStreamReader& in)
{
    if (getHasTextureCoords())
    {
        uint32_t readField = static_cast<uint32_t>(in.readVarSize());
        // check constraint
        if (!(readField > 0))
            throw ::zserio::ConstraintException("Read: Constraint violated at Mesh3DRenderLayerHeader.numTextureCoords!");

        return ::zserio::InplaceOptionalHolder<uint32_t>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<uint32_t>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<uint32_t> Mesh3DRenderLayerHeader::readNumTextureCoords(Mesh3DRenderLayerHeader::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (getHasTextureCoords())
    {
        uint32_t readField = context.getNumTextureCoords().read<::zserio::VarSizeArrayTraits>(in);
        // check constraint
        if (!(readField > 0))
            throw ::zserio::ConstraintException("Read: Constraint violated at Mesh3DRenderLayerHeader.numTextureCoords!");

        return ::zserio::InplaceOptionalHolder<uint32_t>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<uint32_t>(::zserio::NullOpt);
}
bool Mesh3DRenderLayerHeader::readHasTextureCoordsAdditional(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
::zserio::InplaceOptionalHolder<uint32_t> Mesh3DRenderLayerHeader::readNumTextureCoordsAdditional(::zserio::BitStreamReader& in)
{
    if (getHasTextureCoordsAdditional())
    {
        uint32_t readField = static_cast<uint32_t>(in.readVarSize());
        // check constraint
        if (!(readField > 0))
            throw ::zserio::ConstraintException("Read: Constraint violated at Mesh3DRenderLayerHeader.numTextureCoordsAdditional!");

        return ::zserio::InplaceOptionalHolder<uint32_t>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<uint32_t>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<uint32_t> Mesh3DRenderLayerHeader::readNumTextureCoordsAdditional(Mesh3DRenderLayerHeader::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (getHasTextureCoordsAdditional())
    {
        uint32_t readField = context.getNumTextureCoordsAdditional().read<::zserio::VarSizeArrayTraits>(in);
        // check constraint
        if (!(readField > 0))
            throw ::zserio::ConstraintException("Read: Constraint violated at Mesh3DRenderLayerHeader.numTextureCoordsAdditional!");

        return ::zserio::InplaceOptionalHolder<uint32_t>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<uint32_t>(::zserio::NullOpt);
}

} // namespace types
} // namespace display
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/display/types/NormalSphere.h>

namespace nds
{
namespace display
{
namespace types
{

NormalSphere::NormalSphere(const allocator_type&) noexcept :
        m_theta_(uint8_t()),
        m_phi_(uint8_t())
{
}

NormalSphere::NormalSphere(::zserio::BitStreamReader& in, const allocator_type&) :
        m_theta_(readTheta(in)),
        m_phi_(readPhi(in))
{
}

NormalSphere::NormalSphere(NormalSphere::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type&) :
        m_theta_(readTheta(context, in)),
        m_phi_(readPhi(context, in))
{
}

NormalSphere::NormalSphere(::zserio::PropagateAllocatorT,
        const NormalSphere& other, const allocator_type& allocator) :
        m_theta_(::zserio::allocatorPropagatingCopy(other.m_theta_, allocator)),
        m_phi_(::zserio::allocatorPropagatingCopy(other.m_phi_, allocator))
{
}

uint8_t NormalSphere::getTheta() const
{
    return m_theta_;
}

void NormalSphere::setTheta(uint8_t theta_)
{
    m_theta_ = theta_;
}

uint8_t NormalSphere::getPhi() const
{
    return m_phi_;
}

void NormalSphere::setPhi(uint8_t phi_)
{
    m_phi_ = phi_;
}

void NormalSphere::initPackingContext(NormalSphere::ZserioPackingContext& context) const
{
    context.getTheta().init<::zserio::StdIntArrayTraits<uint8_t>>(m_theta_);
    context.getPhi().init<::zserio::StdIntArrayTraits<uint8_t>>(m_phi_);
}

size_t NormalSphere::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(8);
    endBitPosition += UINT8_C(8);

    return endBitPosition - bitPosition;
}

size_t NormalSphere::bitSizeOf(NormalSphere::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getTheta().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_theta_);
    endBitPosition += context.getPhi().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_phi_);

    return endBitPosition - bitPosition;
}

size_t NormalSphere::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(8);
    endBitPosition += UINT8_C(8);

    return endBitPosition;
}

size_t NormalSphere::initializeOffsets(NormalSphere::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getTheta().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_theta_);
    endBitPosition += context.getPhi().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_phi_);

    return endBitPosition;
}

bool NormalSphere::operator==(const NormalSphere& other) const
{
    if (this != &other)
    {
        return
                (m_theta_ == other.m_theta_) &&
                (m_phi_ == other.m_phi_);
    }

    return true;
}

uint32_t NormalSphere::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_theta_);
    result = ::zserio::calcHashCode(result, m_phi_);

    return result;
}

void NormalSphere::write(::zserio::BitStreamWriter& out) const
{
    out.writeBits(m_theta_, UINT8_C(8));
    out.writeBits(m_phi_, UINT8_C(8));
}

void NormalSphere::write(NormalSphere::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getTheta().write<::zserio::StdIntArrayTraits<uint8_t>>(out, m_theta_);
    context.getPhi().write<::zserio::StdIntArrayTraits<uint8_t>>(out, m_phi_);
}

uint8_t NormalSphere::readTheta(::zserio::BitStreamReader& in)
{
    return static_cast<uint8_t>(in.readBits(UINT8_C(8)));
}

uint8_t NormalSphere::readTheta(NormalSphere::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getTheta().read<::zserio::StdIntArrayTraits<uint8_t>>(in);
}
uint8_t NormalSphere::readPhi(::zserio::BitStreamReader& in)
{
    return static_cast<uint8_t>(in.readBits(UINT8_C(8)));
}

uint8_t NormalSphere::readPhi(NormalSphere::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getPhi().read<::zserio::StdIntArrayTraits<uint8_t>>(in);
}

} // namespace types
} // namespace display
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ArrayTraits.h>

#include <nds/display/types/Mesh3DRenderConfiguration.h>
#include <nds/display/types/ColorMode.h>

namespace nds
{
namespace display
{
namespace types
{

Mesh3DRenderConfiguration::Mesh3DRenderConfiguration(const allocator_type&) noexcept :
        m_isInitialized(false),
        m_colorMode_(::nds::display::types::ColorMode()),
        m_hasTextureCoords_(bool()),
        m_hasTextureCoordsAdditional_(bool()),
        m_hasNormals_(bool())
{
}

Mesh3DRenderConfiguration::Mesh3DRenderConfiguration(::zserio::BitStreamReader& in,
        ::nds::display::types::Mesh3DRenderLayerHeader& header_, const allocator_type&) :
        m_header_(&header_),
        m_isInitialized(true),
        m_colorMode_(readColorMode(in)),
        m_hasTextureCoords_(readHasTextureCoords(in)),
        m_hasTextureCoordsAdditional_(readHasTextureCoordsAdditional(in)),
        m_hasNormals_(readHasNormals(in))
{
}

Mesh3DRenderConfiguration::Mesh3DRenderConfiguration(Mesh3DRenderConfiguration::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::display::types::Mesh3DRenderLayerHeader& header_, const allocator_type&) :
        m_header_(&header_),
        m_isInitialized(true),
        m_colorMode_(readColorMode(context, in)),
        m_hasTextureCoords_(readHasTextureCoords(in)),
        m_hasTextureCoordsAdditional_(readHasTextureCoordsAdditional(in)),
        m_hasNormals_(readHasNormals(in))
{
}

Mesh3DRenderConfiguration::Mesh3DRenderConfiguration(const Mesh3DRenderConfiguration& other) :
        m_colorMode_(other.m_colorMode_),
        m_hasTextureCoords_(other.m_hasTextureCoords_),
        m_hasTextureCoordsAdditional_(other.m_hasTextureCoordsAdditional_),
        m_hasNormals_(other.m_hasNormals_)
{
    if (other.m_isInitialized)
        initialize(*(other.m_header_));
    else
        m_isInitialized = false;
}

Mesh3DRenderConfiguration& Mesh3DRenderConfiguration::operator=(const Mesh3DRenderConfiguration& other)
{
    m_colorMode_ = other.m_colorMode_;
    m_hasTextureCoords_ = other.m_hasTextureCoords_;
    m_hasTextureCoordsAdditional_ = other.m_hasTextureCoordsAdditional_;
    m_hasNormals_ = other.m_hasNormals_;
    if (other.m_isInitialized)
        initialize(*(other.m_header_));
    else
        m_isInitialized = false;

    return *this;
}

Mesh3DRenderConfiguration::Mesh3DRenderConfiguration(Mesh3DRenderConfiguration&& other) :
        m_colorMode_(::std::move(other.m_colorMode_)),
        m_hasTextureCoords_(::std::move(other.m_hasTextureCoords_)),
        m_hasTextureCoordsAdditional_(::std::move(other.m_hasTextureCoordsAdditional_)),
        m_hasNormals_(::std::move(other.m_hasNormals_))
{
    if (other.m_isInitialized)
        initialize(*(other.m_header_));
    else
        m_isInitialized = false;
}

Mesh3DRenderConfiguration& Mesh3DRenderConfiguration::operator=(Mesh3DRenderConfiguration&& other)
{
    m_colorMode_ = ::std::move(other.m_colorMode_);
    m_hasTextureCoords_ = ::std::move(other.m_hasTextureCoords_);
    m_hasTextureCoordsAdditional_ = ::std::move(other.m_hasTextureCoordsAdditional_);
    m_hasNormals_ = ::std::move(other.m_hasNormals_);
    if (other.m_isInitialized)
        initialize(*(other.m_header_));
    else
        m_isInitialized = false;

    return *this;
}

Mesh3DRenderConfiguration::Mesh3DRenderConfiguration(::zserio::PropagateAllocatorT,
        const Mesh3DRenderConfiguration& other, const allocator_type& allocator) :
        m_colorMode_(::zserio::allocatorPropagatingCopy(other.m_colorMode_, allocator)),
        m_hasTextureCoords_(::zserio::allocatorPropagatingCopy(other.m_hasTextureCoords_, allocator)),
        m_hasTextureCoordsAdditional_(::zserio::allocatorPropagatingCopy(other.m_hasTextureCoordsAdditional_, allocator)),
        m_hasNormals_(::zserio::allocatorPropagatingCopy(other.m_hasNormals_, allocator))
{
    if (other.m_isInitialized)
        initialize(*(other.m_header_));
    else
        m_isInitialized = false;
}

void Mesh3DRenderConfiguration::initialize(
        ::nds::display::types::Mesh3DRenderLayerHeader& header_)
{
    m_header_ = &header_;
    m_isInitialized = true;
}

bool Mesh3DRenderConfiguration::isInitialized() const
{
    return m_isInitialized;
}

::nds::display::types::Mesh3DRenderLayerHeader& Mesh3DRenderConfiguration::getHeader()
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'header' of compound 'Mesh3DRenderConfiguration' is not initialized!");

    return *m_header_;
}

const ::nds::display::types::Mesh3DRenderLayerHeader& Mesh3DRenderConfiguration::getHeader() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'header' of compound 'Mesh3DRenderConfiguration' is not initialized!");

    return *m_header_;
}

::nds::display::types::ColorMode Mesh3DRenderConfiguration::getColorMode() const
{
    return m_colorMode_;
}

void Mesh3DRenderConfiguration::setColorMode(::nds::display::types::ColorMode colorMode_)
{
    m_colorMode_ = colorMode_;
}

bool Mesh3DRenderConfiguration::getHasTextureCoords() const
{
    return m_hasTextureCoords_;
}

void Mesh3DRenderConfiguration::setHasTextureCoords(bool hasTextureCoords_)
{
    m_hasTextureCoords_ = hasTextureCoords_;
}

bool Mesh3DRenderConfiguration::getHasTextureCoordsAdditional() const
{
    return m_hasTextureCoordsAdditional_;
}

void Mesh3DRenderConfiguration::setHasTextureCoordsAdditional(bool hasTextureCoordsAdditional_)
{
    m_hasTextureCoordsAdditional_ = hasTextureCoordsAdditional_;
}

bool Mesh3DRenderConfiguration::getHasNormals() const
{
    return m_hasNormals_;
}

void Mesh3DRenderConfiguration::setHasNormals(bool hasNormals_)
{
    m_hasNormals_ = hasNormals_;
}

bool Mesh3DRenderConfiguration::funcUsesColorPerVertex() const
{
    return static_cast<bool>(getHeader().funcUsesColors() && getColorMode() == ::nds::display::types::ColorMode::COLOR_PER_VERTEX);
}

bool Mesh3DRenderConfiguration::funcUsesColorPerRenderGroup() const
{
    return static_cast<bool>(getHeader().funcUsesColors() && getColorMode() == ::nds::display::types::ColorMode::COLOR_PER_RENDER_GROUP);
}

void Mesh3DRenderConfiguration::initPackingContext(Mesh3DRenderConfiguration::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getColorMode(), m_colorMode_);
}

size_t Mesh3DRenderConfiguration::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_colorMode_);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);

    return endBitPosition - bitPosition;
}

size_t Mesh3DRenderConfiguration::bitSizeOf(Mesh3DRenderConfiguration::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getColorMode(), m_colorMode_);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);

    return endBitPosition - bitPosition;
}

size_t Mesh3DRenderConfiguration::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_colorMode_);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);

    return endBitPosition;
}

size_t Mesh3DRenderConfiguration::initializeOffsets(Mesh3DRenderConfiguration::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getColorMode(), endBitPosition,
        m_colorMode_);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);

    return endBitPosition;
}

bool Mesh3DRenderConfiguration::operator==(const Mesh3DRenderConfiguration& other) const
{
    if (this != &other)
    {
        return
                (getHeader() == other.getHeader()) &&
                (m_colorMode_ == other.m_colorMode_) &&
                (m_hasTextureCoords_ == other.m_hasTextureCoords_) &&
                (m_hasTextureCoordsAdditional_ == other.m_hasTextureCoordsAdditional_) &&
                (m_hasNormals_ == other.m_hasNormals_);
    }

    return true;
}

uint32_t Mesh3DRenderConfiguration::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getHeader());
    result = ::zserio::calcHashCode(result, m_colorMode_);
    result = ::zserio::calcHashCode(result, m_hasTextureCoords_);
    result = ::zserio::calcHashCode(result, m_hasTextureCoordsAdditional_);
    result = ::zserio::calcHashCode(result, m_hasNormals_);

    return result;
}

void Mesh3DRenderConfiguration::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_colorMode_);
    out.writeBool(m_hasTextureCoords_);
    out.writeBool(m_hasTextureCoordsAdditional_);
    out.writeBool(m_hasNormals_);
}

void Mesh3DRenderConfiguration::write(Mesh3DRenderConfiguration::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getColorMode(), out, m_colorMode_);
    out.writeBool(m_hasTextureCoords_);
    out.writeBool(m_hasTextureCoordsAdditional_);
    out.writeBool(m_hasNormals_);
}

::nds::display::types::ColorMode Mesh3DRenderConfiguration::readColorMode(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::display::types::ColorMode>(in);
}

::nds::display::types::ColorMode Mesh3DRenderConfiguration::readColorMode(Mesh3DRenderConfiguration::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::display::types::ColorMode>(context.getColorMode(), in);
}
bool Mesh3DRenderConfiguration::readHasTextureCoords(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
bool Mesh3DRenderConfiguration::readHasTextureCoordsAdditional(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
bool Mesh3DRenderConfiguration::readHasNormals(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}

} // namespace types
} // namespace display
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ConstraintException.h>

#include <nds/display/types/Mesh3DRenderData.h>

namespace nds
{
namespace display
{
namespace types
{

Mesh3DRenderData::Mesh3DRenderData(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_mesh3DRenderConfiguration_(allocator),
        m_startIndexNormals_(::zserio::NullOpt),
        m_startIndexColors_(::zserio::NullOpt),
        m_startIndexTextureCoords_(::zserio::NullOpt),
        m_startIndexTextureCoordsAdditional_(::zserio::NullOpt),
        m_renderGroups_(allocator)
{
}

Mesh3DRenderData::Mesh3DRenderData(::zserio::BitStreamReader& in,
        ::nds::core::geometry::PolyMesh3D& mesh_,
        ::nds::display::types::Mesh3DRenderLayerHeader& header_, const allocator_type& allocator) :
        m_mesh_(&mesh_),
        m_header_(&header_),
        m_isInitialized(true),
        m_mesh3DRenderConfiguration_(readMesh3DRenderConfiguration(in, allocator)),
        m_startIndexNormals_(readStartIndexNormals(in)),
        m_startIndexColors_(readStartIndexColors(in)),
        m_startIndexTextureCoords_(readStartIndexTextureCoords(in)),
        m_startIndexTextureCoordsAdditional_(readStartIndexTextureCoordsAdditional(in)),
        m_renderGroups_(readRenderGroups(in, allocator))
{
}

Mesh3DRenderData::Mesh3DRenderData(Mesh3DRenderData::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::PolyMesh3D& mesh_,
        ::nds::display::types::Mesh3DRenderLayerHeader& header_, const allocator_type& allocator) :
        m_mesh_(&mesh_),
        m_header_(&header_),
        m_isInitialized(true),
        m_mesh3DRenderConfiguration_(readMesh3DRenderConfiguration(context, in, allocator)),
        m_startIndexNormals_(readStartIndexNormals(context, in)),
        m_startIndexColors_(readStartIndexColors(context, in)),
        m_startIndexTextureCoords_(readStartIndexTextureCoords(context, in)),
        m_startIndexTextureCoordsAdditional_(readStartIndexTextureCoordsAdditional(context, in)),
        m_renderGroups_(readRenderGroups(context, in, allocator))
{
}

Mesh3DRenderData::Mesh3DRenderData(const Mesh3DRenderData& other) :
        m_mesh3DRenderConfiguration_(other.m_mesh3DRenderConfiguration_),
        m_startIndexNormals_(other.m_startIndexNormals_),
        m_startIndexColors_(other.m_startIndexColors_),
        m_startIndexTextureCoords_(other.m_startIndexTextureCoords_),
        m_startIndexTextureCoordsAdditional_(other.m_startIndexTextureCoordsAdditional_),
        m_renderGroups_(other.m_renderGroups_)
{
    if (other.m_isInitialized)
        initialize(*(other.m_mesh_), *(other.m_header_));
    else
        m_isInitialized = false;
}

Mesh3DRenderData& Mesh3DRenderData::operator=(const Mesh3DRenderData& other)
{
    m_mesh3DRenderConfiguration_ = other.m_mesh3DRenderConfiguration_;
    m_startIndexNormals_ = other.m_startIndexNormals_;
    m_startIndexColors_ = other.m_startIndexColors_;
    m_startIndexTextureCoords_ = other.m_startIndexTextureCoords_;
    m_startIndexTextureCoordsAdditional_ = other.m_startIndexTextureCoordsAdditional_;
    m_renderGroups_ = other.m_renderGroups_;
    if (other.m_isInitialized)
        initialize(*(other.m_mesh_), *(other.m_header_));
    else
        m_isInitialized = false;

    return *this;
}

Mesh3DRenderData::Mesh3DRenderData(Mesh3DRenderData&& other) :
        m_mesh3DRenderConfiguration_(::std::move(other.m_mesh3DRenderConfiguration_)),
        m_startIndexNormals_(::std::move(other.m_startIndexNormals_)),
        m_startIndexColors_(::std::move(other.m_startIndexColors_)),
        m_startIndexTextureCoords_(::std::move(other.m_startIndexTextureCoords_)),
        m_startIndexTextureCoordsAdditional_(::std::move(other.m_startIndexTextureCoordsAdditional_)),
        m_renderGroups_(::std::move(other.m_renderGroups_))
{
    if (other.m_isInitialized)
        initialize(*(other.m_mesh_), *(other.m_header_));
    else
        m_isInitialized = false;
}

Mesh3DRenderData& Mesh3DRenderData::operator=(Mesh3DRenderData&& other)
{
    m_mesh3DRenderConfiguration_ = ::std::move(other.m_mesh3DRenderConfiguration_);
    m_startIndexNormals_ = ::std::move(other.m_startIndexNormals_);
    m_startIndexColors_ = ::std::move(other.m_startIndexColors_);
    m_startIndexTextureCoords_ = ::std::move(other.m_startIndexTextureCoords_);
    m_startIndexTextureCoordsAdditional_ = ::std::move(other.m_startIndexTextureCoordsAdditional_);
    m_renderGroups_ = ::std::move(other.m_renderGroups_);
    if (other.m_isInitialized)
        initialize(*(other.m_mesh_), *(other.m_header_));
    else
        m_isInitialized = false;

    return *this;
}

Mesh3DRenderData::Mesh3DRenderData(::zserio::PropagateAllocatorT,
        const Mesh3DRenderData& other, const allocator_type& allocator) :
        m_mesh3DRenderConfiguration_(::zserio::allocatorPropagatingCopy(other.m_mesh3DRenderConfiguration_, allocator)),
        m_startIndexNormals_(::zserio::allocatorPropagatingCopy(other.m_startIndexNormals_, allocator)),
        m_startIndexColors_(::zserio::allocatorPropagatingCopy(other.m_startIndexColors_, allocator)),
        m_startIndexTextureCoords_(::zserio::allocatorPropagatingCopy(other.m_startIndexTextureCoords_, allocator)),
        m_startIndexTextureCoordsAdditional_(::zserio::allocatorPropagatingCopy(other.m_startIndexTextureCoordsAdditional_, allocator)),
        m_renderGroups_(::zserio::allocatorPropagatingCopy(other.m_renderGroups_, allocator))
{
    if (other.m_isInitialized)
        initialize(*(other.m_mesh_), *(other.m_header_));
    else
        m_isInitialized = false;
}

void Mesh3DRenderData::initialize(
        ::nds::core::geometry::PolyMesh3D& mesh_,
        ::nds::display::types::Mesh3DRenderLayerHeader& header_)
{
    m_mesh_ = &mesh_;
    m_header_ = &header_;
    m_isInitialized = true;

    initializeChildren();
}

bool Mesh3DRenderData::isInitialized() const
{
    return m_isInitialized;
}

void Mesh3DRenderData::initializeChildren()
{
    m_mesh3DRenderConfiguration_.initialize(getHeader());
    m_renderGroups_.initializeElements(*this);
}

::nds::core::geometry::PolyMesh3D& Mesh3DRenderData::getMesh()
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'mesh' of compound 'Mesh3DRenderData' is not initialized!");

    return *m_mesh_;
}

const ::nds::core::geometry::PolyMesh3D& Mesh3DRenderData::getMesh() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'mesh' of compound 'Mesh3DRenderData' is not initialized!");

    return *m_mesh_;
}

::nds::display::types::Mesh3DRenderLayerHeader& Mesh3DRenderData::getHeader()
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'header' of compound 'Mesh3DRenderData' is not initialized!");

    return *m_header_;
}

const ::nds::display::types::Mesh3DRenderLayerHeader& Mesh3DRenderData::getHeader() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'header' of compound 'Mesh3DRenderData' is not initialized!");

    return *m_header_;
}

::nds::display::types::Mesh3DRenderConfiguration& Mesh3DRenderData::getMesh3DRenderConfiguration()
{
    return m_mesh3DRenderConfiguration_;
}

const ::nds::display::types::Mesh3DRenderConfiguration& Mesh3DRenderData::getMesh3DRenderConfiguration() const
{
    return m_mesh3DRenderConfiguration_;
}

void Mesh3DRenderData::setMesh3DRenderConfiguration(const ::nds::display::types::Mesh3DRenderConfiguration& mesh3DRenderConfiguration_)
{
    m_mesh3DRenderConfiguration_ = mesh3DRenderConfiguration_;
}

void Mesh3DRenderData::setMesh3DRenderConfiguration(::nds::display::types::Mesh3DRenderConfiguration&& mesh3DRenderConfiguration_)
{
    m_mesh3DRenderConfiguration_ = ::std::move(mesh3DRenderConfiguration_);
}

uint32_t Mesh3DRenderData::getStartIndexNormals() const
{
    return m_startIndexNormals_.value();
}

void Mesh3DRenderData::setStartIndexNormals(uint32_t startIndexNormals_)
{
    m_startIndexNormals_ = startIndexNormals_;
}

bool Mesh3DRenderData::isStartIndexNormalsUsed() const
{
    return (getMesh3DRenderConfiguration().getHasNormals());
}

bool Mesh3DRenderData::isStartIndexNormalsSet() const
{
    return m_startIndexNormals_.hasValue();
}

void Mesh3DRenderData::resetStartIndexNormals()
{
    m_startIndexNormals_.reset();
}

uint32_t Mesh3DRenderData::getStartIndexColors() const
{
    return m_startIndexColors_.value();
}

void Mesh3DRenderData::setStartIndexColors(uint32_t startIndexColors_)
{
    m_startIndexColors_ = startIndexColors_;
}

bool Mesh3DRenderData::isStartIndexColorsUsed() const
{
    return (getMesh3DRenderConfiguration().funcUsesColorPerVertex());
}

bool Mesh3DRenderData::isStartIndexColorsSet() const
{
    return m_startIndexColors_.hasValue();
}

void Mesh3DRenderData::resetStartIndexColors()
{
    m_startIndexColors_.reset();
}

uint32_t Mesh3DRenderData::getStartIndexTextureCoords() const
{
    return m_startIndexTextureCoords_.value();
}

void Mesh3DRenderData::setStartIndexTextureCoords(uint32_t startIndexTextureCoords_)
{
    m_startIndexTextureCoords_ = startIndexTextureCoords_;
}

bool Mesh3DRenderData::isStartIndexTextureCoordsUsed() const
{
    return (getMesh3DRenderConfiguration().getHasTextureCoords());
}

bool Mesh3DRenderData::isStartIndexTextureCoordsSet() const
{
    return m_startIndexTextureCoords_.hasValue();
}

void Mesh3DRenderData::resetStartIndexTextureCoords()
{
    m_startIndexTextureCoords_.reset();
}

uint32_t Mesh3DRenderData::getStartIndexTextureCoordsAdditional() const
{
    return m_startIndexTextureCoordsAdditional_.value();
}

void Mesh3DRenderData::setStartIndexTextureCoordsAdditional(uint32_t startIndexTextureCoordsAdditional_)
{
    m_startIndexTextureCoordsAdditional_ = startIndexTextureCoordsAdditional_;
}

bool Mesh3DRenderData::isStartIndexTextureCoordsAdditionalUsed() const
{
    return (getMesh3DRenderConfiguration().getHasTextureCoordsAdditional());
}

bool Mesh3DRenderData::isStartIndexTextureCoordsAdditionalSet() const
{
    return m_startIndexTextureCoordsAdditional_.hasValue();
}

void Mesh3DRenderData::resetStartIndexTextureCoordsAdditional()
{
    m_startIndexTextureCoordsAdditional_.reset();
}

::zserio::vector<::nds::display::types::RenderGroup>& Mesh3DRenderData::getRenderGroups()
{
    return m_renderGroups_.getRawArray();
}

const ::zserio::vector<::nds::display::types::RenderGroup>& Mesh3DRenderData::getRenderGroups() const
{
    return m_renderGroups_.getRawArray();
}

void Mesh3DRenderData::setRenderGroups(const ::zserio::vector<::nds::display::types::RenderGroup>& renderGroups_)
{
    m_renderGroups_ = ZserioArrayType_renderGroups(renderGroups_);
}

void Mesh3DRenderData::setRenderGroups(::zserio::vector<::nds::display::types::RenderGroup>&& renderGroups_)
{
    m_renderGroups_ = ZserioArrayType_renderGroups(std::move(renderGroups_));
}

void Mesh3DRenderData::initPackingContext(Mesh3DRenderData::ZserioPackingContext& context) const
{
    m_mesh3DRenderConfiguration_.initPackingContext(context.getMesh3DRenderConfiguration());
    if (getMesh3DRenderConfiguration().getHasNormals())
    {
        context.getStartIndexNormals().init<::zserio::VarSizeArrayTraits>(m_startIndexNormals_.value());
    }
    if (getMesh3DRenderConfiguration().funcUsesColorPerVertex())
    {
        context.getStartIndexColors().init<::zserio::VarSizeArrayTraits>(m_startIndexColors_.value());
    }
    if (getMesh3DRenderConfiguration().getHasTextureCoords())
    {
        context.getStartIndexTextureCoords().init<::zserio::VarSizeArrayTraits>(m_startIndexTextureCoords_.value());
    }
    if (getMesh3DRenderConfiguration().getHasTextureCoordsAdditional())
    {
        context.getStartIndexTextureCoordsAdditional().init<::zserio::VarSizeArrayTraits>(m_startIndexTextureCoordsAdditional_.value());
    }
}

size_t Mesh3DRenderData::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_mesh3DRenderConfiguration_.bitSizeOf(endBitPosition);
    if (getMesh3DRenderConfiguration().getHasNormals())
    {
        endBitPosition += ::zserio::bitSizeOfVarSize(m_startIndexNormals_.value());
    }
    if (getMesh3DRenderConfiguration().funcUsesColorPerVertex())
    {
        endBitPosition += ::zserio::bitSizeOfVarSize(m_startIndexColors_.value());
    }
    if (getMesh3DRenderConfiguration().getHasTextureCoords())
    {
        endBitPosition += ::zserio::bitSizeOfVarSize(m_startIndexTextureCoords_.value());
    }
    if (getMesh3DRenderConfiguration().getHasTextureCoordsAdditional())
    {
        endBitPosition += ::zserio::bitSizeOfVarSize(m_startIndexTextureCoordsAdditional_.value());
    }
    endBitPosition += m_renderGroups_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t Mesh3DRenderData::bitSizeOf(Mesh3DRenderData::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_mesh3DRenderConfiguration_.bitSizeOf(context.getMesh3DRenderConfiguration(), endBitPosition);
    if (getMesh3DRenderConfiguration().getHasNormals())
    {
        endBitPosition += context.getStartIndexNormals().bitSizeOf<::zserio::VarSizeArrayTraits>(m_startIndexNormals_.value());
    }
    if (getMesh3DRenderConfiguration().funcUsesColorPerVertex())
    {
        endBitPosition += context.getStartIndexColors().bitSizeOf<::zserio::VarSizeArrayTraits>(m_startIndexColors_.value());
    }
    if (getMesh3DRenderConfiguration().getHasTextureCoords())
    {
        endBitPosition += context.getStartIndexTextureCoords().bitSizeOf<::zserio::VarSizeArrayTraits>(m_startIndexTextureCoords_.value());
    }
    if (getMesh3DRenderConfiguration().getHasTextureCoordsAdditional())
    {
        endBitPosition += context.getStartIndexTextureCoordsAdditional().bitSizeOf<::zserio::VarSizeArrayTraits>(m_startIndexTextureCoordsAdditional_.value());
    }
    endBitPosition += m_renderGroups_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t Mesh3DRenderData::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_mesh3DRenderConfiguration_.initializeOffsets(endBitPosition);
    if (getMesh3DRenderConfiguration().getHasNormals())
    {
        endBitPosition += ::zserio::bitSizeOfVarSize(m_startIndexNormals_.value());
    }
    if (getMesh3DRenderConfiguration().funcUsesColorPerVertex())
    {
        endBitPosition += ::zserio::bitSizeOfVarSize(m_startIndexColors_.value());
    }
    if (getMesh3DRenderConfiguration().getHasTextureCoords())
    {
        endBitPosition += ::zserio::bitSizeOfVarSize(m_startIndexTextureCoords_.value());
    }
    if (getMesh3DRenderConfiguration().getHasTextureCoordsAdditional())
    {
        endBitPosition += ::zserio::bitSizeOfVarSize(m_startIndexTextureCoordsAdditional_.value());
    }
    endBitPosition = m_renderGroups_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t Mesh3DRenderData::initializeOffsets(Mesh3DRenderData::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_mesh3DRenderConfiguration_.initializeOffsets(context.getMesh3DRenderConfiguration(), endBitPosition);
    if (getMesh3DRenderConfiguration().getHasNormals())
    {
        endBitPosition += context.getStartIndexNormals().bitSizeOf<::zserio::VarSizeArrayTraits>(m_startIndexNormals_.value());
    }
    if (getMesh3DRenderConfiguration().funcUsesColorPerVertex())
    {
        endBitPosition += context.getStartIndexColors().bitSizeOf<::zserio::VarSizeArrayTraits>(m_startIndexColors_.value());
    }
    if (getMesh3DRenderConfiguration().getHasTextureCoords())
    {
        endBitPosition += context.getStartIndexTextureCoords().bitSizeOf<::zserio::VarSizeArrayTraits>(m_startIndexTextureCoords_.value());
    }
    if (getMesh3DRenderConfiguration().getHasTextureCoordsAdditional())
    {
        endBitPosition += context.getStartIndexTextureCoordsAdditional().bitSizeOf<::zserio::VarSizeArrayTraits>(m_startIndexTextureCoordsAdditional_.value());
    }
    endBitPosition = m_renderGroups_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool Mesh3DRenderData::operator==(const Mesh3DRenderData& other) const
{
    if (this != &other)
    {
        return
                (getMesh() == other.getMesh()) &&
                (getHeader() == other.getHeader()) &&
                (m_mesh3DRenderConfiguration_ == other.m_mesh3DRenderConfiguration_) &&
                (!isStartIndexNormalsUsed() ? !other.isStartIndexNormalsUsed() : (m_startIndexNormals_ == other.m_startIndexNormals_)) &&
                (!isStartIndexColorsUsed() ? !other.isStartIndexColorsUsed() : (m_startIndexColors_ == other.m_startIndexColors_)) &&
                (!isStartIndexTextureCoordsUsed() ? !other.isStartIndexTextureCoordsUsed() : (m_startIndexTextureCoords_ == other.m_startIndexTextureCoords_)) &&
                (!isStartIndexTextureCoordsAdditionalUsed() ? !other.isStartIndexTextureCoordsAdditionalUsed() : (m_startIndexTextureCoordsAdditional_ == other.m_startIndexTextureCoordsAdditional_)) &&
                (m_renderGroups_ == other.m_renderGroups_);
    }

    return true;
}

uint32_t Mesh3DRenderData::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getMesh());
    result = ::zserio::calcHashCode(result, getHeader());
    result = ::zserio::calcHashCode(result, m_mesh3DRenderConfiguration_);
    if (isStartIndexNormalsUsed())
        result = ::zserio::calcHashCode(result, m_startIndexNormals_);
    if (isStartIndexColorsUsed())
        result = ::zserio::calcHashCode(result, m_startIndexColors_);
    if (isStartIndexTextureCoordsUsed())
        result = ::zserio::calcHashCode(result, m_startIndexTextureCoords_);
    if (isStartIndexTextureCoordsAdditionalUsed())
        result = ::zserio::calcHashCode(result, m_startIndexTextureCoordsAdditional_);
    result = ::zserio::calcHashCode(result, m_renderGroups_);

    return result;
}

void Mesh3DRenderData::write(::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (&(m_mesh3DRenderConfiguration_.getHeader()) != &(getHeader()))
    {
        throw ::zserio::CppRuntimeException("Write: Inconsistent parameter header for field Mesh3DRenderData.mesh3DRenderConfiguration!");
    }
    m_mesh3DRenderConfiguration_.write(out);

    if (getMesh3DRenderConfiguration().getHasNormals())
    {
        out.writeVarSize(m_startIndexNormals_.value());
    }

    if (getMesh3DRenderConfiguration().funcUsesColorPerVertex())
    {
        out.writeVarSize(m_startIndexColors_.value());
    }

    if (getMesh3DRenderConfiguration().getHasTextureCoords())
    {
        out.writeVarSize(m_startIndexTextureCoords_.value());
    }

    if (getMesh3DRenderConfiguration().getHasTextureCoordsAdditional())
    {
        out.writeVarSize(m_startIndexTextureCoordsAdditional_.value());
    }

    // check constraint
    if (!(getRenderGroups().size() > 0))
        throw ::zserio::ConstraintException("Write: Constraint violated at Mesh3DRenderData.renderGroups!");
    m_renderGroups_.write(*this, out);
}

void Mesh3DRenderData::write(Mesh3DRenderData::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (&(m_mesh3DRenderConfiguration_.getHeader()) != &(getHeader()))
    {
        throw ::zserio::CppRuntimeException("Write: Inconsistent parameter header for field Mesh3DRenderData.mesh3DRenderConfiguration!");
    }
    m_mesh3DRenderConfiguration_.write(context.getMesh3DRenderConfiguration(), out);

    if (getMesh3DRenderConfiguration().getHasNormals())
    {
        context.getStartIndexNormals().write<::zserio::VarSizeArrayTraits>(out, m_startIndexNormals_.value());
    }

    if (getMesh3DRenderConfiguration().funcUsesColorPerVertex())
    {
        context.getStartIndexColors().write<::zserio::VarSizeArrayTraits>(out, m_startIndexColors_.value());
    }

    if (getMesh3DRenderConfiguration().getHasTextureCoords())
    {
        context.getStartIndexTextureCoords().write<::zserio::VarSizeArrayTraits>(out, m_startIndexTextureCoords_.value());
    }

    if (getMesh3DRenderConfiguration().getHasTextureCoordsAdditional())
    {
        context.getStartIndexTextureCoordsAdditional().write<::zserio::VarSizeArrayTraits>(out, m_startIndexTextureCoordsAdditional_.value());
    }

    // check constraint
    if (!(getRenderGroups().size() > 0))
        throw ::zserio::ConstraintException("Write: Constraint violated at Mesh3DRenderData.renderGroups!");
    m_renderGroups_.writePacked(*this, out);
}

void Mesh3DRenderData::ZserioArrayExpressions_renderGroups::initializeElement(Mesh3DRenderData& owner,
        ::nds::display::types::RenderGroup& element, size_t)
{
    element.initialize(owner.getMesh(), owner.getMesh3DRenderConfiguration());
}

void Mesh3DRenderData::ZserioElementFactory_renderGroups::create(Mesh3DRenderData&         owner,
        ::zserio::vector<::nds::display::types::RenderGroup>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, owner.getMesh(), owner.getMesh3DRenderConfiguration(), array.get_allocator());
}

void Mesh3DRenderData::ZserioElementFactory_renderGroups::create(Mesh3DRenderData&         owner,
        ::zserio::vector<::nds::display::types::RenderGroup>& array,
        ::nds::display::types::RenderGroup::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, owner.getMesh(), owner.getMesh3DRenderConfiguration(), array.get_allocator());
}

::nds::display::types::Mesh3DRenderConfiguration Mesh3DRenderData::readMesh3DRenderConfiguration(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::display::types::Mesh3DRenderConfiguration(in, getHeader(), allocator);
}

::nds::display::types::Mesh3DRenderConfiguration Mesh3DRenderData::readMesh3DRenderConfiguration(Mesh3DRenderData::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::display::types::Mesh3DRenderConfiguration(context.getMesh3DRenderConfiguration(), in, getHeader(), allocator);
}
::zserio::InplaceOptionalHolder<uint32_t> Mesh3DRenderData::readStartIndexNormals(::zserio::BitStreamReader& in)
{
    if (getMesh3DRenderConfiguration().getHasNormals())
    {
        return ::zserio::InplaceOptionalHolder<uint32_t>(static_cast<uint32_t>(in.readVarSize()));
    }

    return ::zserio::InplaceOptionalHolder<uint32_t>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<uint32_t> Mesh3DRenderData::readStartIndexNormals(Mesh3DRenderData::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (getMesh3DRenderConfiguration().getHasNormals())
    {
        return ::zserio::InplaceOptionalHolder<uint32_t>(context.getStartIndexNormals().read<::zserio::VarSizeArrayTraits>(in));
    }

    return ::zserio::InplaceOptionalHolder<uint32_t>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<uint32_t> Mesh3DRenderData::readStartIndexColors(::zserio::BitStreamReader& in)
{
    if (getMesh3DRenderConfiguration().funcUsesColorPerVertex())
    {
        return ::zserio::InplaceOptionalHolder<uint32_t>(static_cast<uint32_t>(in.readVarSize()));
    }

    return ::zserio::InplaceOptionalHolder<uint32_t>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<uint32_t> Mesh3DRenderData::readStartIndexColors(Mesh3DRenderData::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (getMesh3DRenderConfiguration().funcUsesColorPerVertex())
    {
        return ::zserio::InplaceOptionalHolder<uint32_t>(context.getStartIndexColors().read<::zserio::VarSizeArrayTraits>(in));
    }

    return ::zserio::InplaceOptionalHolder<uint32_t>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<uint32_t> Mesh3DRenderData::readStartIndexTextureCoords(::zserio::BitStreamReader& in)
{
    if (getMesh3DRenderConfiguration().getHasTextureCoords())
    {
        return ::zserio::InplaceOptionalHolder<uint32_t>(static_cast<uint32_t>(in.readVarSize()));
    }

    return ::zserio::InplaceOptionalHolder<uint32_t>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<uint32_t> Mesh3DRenderData::readStartIndexTextureCoords(Mesh3DRenderData::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (getMesh3DRenderConfiguration().getHasTextureCoords())
    {
        return ::zserio::InplaceOptionalHolder<uint32_t>(context.getStartIndexTextureCoords().read<::zserio::VarSizeArrayTraits>(in));
    }

    return ::zserio::InplaceOptionalHolder<uint32_t>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<uint32_t> Mesh3DRenderData::readStartIndexTextureCoordsAdditional(::zserio::BitStreamReader& in)
{
    if (getMesh3DRenderConfiguration().getHasTextureCoordsAdditional())
    {
        return ::zserio::InplaceOptionalHolder<uint32_t>(static_cast<uint32_t>(in.readVarSize()));
    }

    return ::zserio::InplaceOptionalHolder<uint32_t>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<uint32_t> Mesh3DRenderData::readStartIndexTextureCoordsAdditional(Mesh3DRenderData::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (getMesh3DRenderConfiguration().getHasTextureCoordsAdditional())
    {
        return ::zserio::InplaceOptionalHolder<uint32_t>(context.getStartIndexTextureCoordsAdditional().read<::zserio::VarSizeArrayTraits>(in));
    }

    return ::zserio::InplaceOptionalHolder<uint32_t>(::zserio::NullOpt);
}
Mesh3DRenderData::ZserioArrayType_renderGroups Mesh3DRenderData::readRenderGroups(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_renderGroups readField(allocator);
    readField.read(*this, in);
    // check constraint
    if (!(readField.getRawArray().size() > 0))
        throw ::zserio::ConstraintException("Read: Constraint violated at Mesh3DRenderData.renderGroups!");

    return readField;
}

Mesh3DRenderData::ZserioArrayType_renderGroups Mesh3DRenderData::readRenderGroups(Mesh3DRenderData::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_renderGroups readField(allocator);
    readField.readPacked(*this, in);
    // check constraint
    if (!(readField.getRawArray().size() > 0))
        throw ::zserio::ConstraintException("Read: Constraint violated at Mesh3DRenderData.renderGroups!");

    return readField;
}

} // namespace types
} // namespace display
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ArrayTraits.h>

#include <nds/display/types/RenderGroup.h>
#include <nds/core/geometry/IndexType.h>

namespace nds
{
namespace display
{
namespace types
{

RenderGroup::RenderGroup(const allocator_type&) noexcept :
        m_isInitialized(false),
        m_colorId_(::zserio::NullOpt),
        m_triangleStrip_(::zserio::NullOpt),
        m_triangles_(::zserio::NullOpt),
        m_material_(::zserio::NullOpt),
        m_materialAdditional_(::zserio::NullOpt)
{
}

RenderGroup::RenderGroup(::zserio::BitStreamReader& in,
        ::nds::core::geometry::PolyMesh3D& mesh_,
        ::nds::display::types::Mesh3DRenderConfiguration& config_, const allocator_type& allocator) :
        m_mesh_(&mesh_),
        m_config_(&config_),
        m_isInitialized(true),
        m_colorId_(readColorId(in)),
        m_triangleStrip_(readTriangleStrip(in, allocator)),
        m_triangles_(readTriangles(in, allocator)),
        m_material_(readMaterial(in, allocator)),
        m_materialAdditional_(readMaterialAdditional(in, allocator))
{
}

RenderGroup::RenderGroup(RenderGroup::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::PolyMesh3D& mesh_,
        ::nds::display::types::Mesh3DRenderConfiguration& config_, const allocator_type& allocator) :
        m_mesh_(&mesh_),
        m_config_(&config_),
        m_isInitialized(true),
        m_colorId_(readColorId(context, in)),
        m_triangleStrip_(readTriangleStrip(context, in, allocator)),
        m_triangles_(readTriangles(context, in, allocator)),
        m_material_(readMaterial(context, in, allocator)),
        m_materialAdditional_(readMaterialAdditional(context, in, allocator))
{
}

RenderGroup::RenderGroup(const RenderGroup& other) :
        m_colorId_(other.m_colorId_),
        m_triangleStrip_(other.m_triangleStrip_),
        m_triangles_(other.m_triangles_),
        m_material_(other.m_material_),
        m_materialAdditional_(other.m_materialAdditional_)
{
    if (other.m_isInitialized)
        initialize(*(other.m_mesh_), *(other.m_config_));
    else
        m_isInitialized = false;
}

RenderGroup& RenderGroup::operator=(const RenderGroup& other)
{
    m_colorId_ = other.m_colorId_;
    m_triangleStrip_ = other.m_triangleStrip_;
    m_triangles_ = other.m_triangles_;
    m_material_ = other.m_material_;
    m_materialAdditional_ = other.m_materialAdditional_;
    if (other.m_isInitialized)
        initialize(*(other.m_mesh_), *(other.m_config_));
    else
        m_isInitialized = false;

    return *this;
}

RenderGroup::RenderGroup(RenderGroup&& other) :
        m_colorId_(::std::move(other.m_colorId_)),
        m_triangleStrip_(::std::move(other.m_triangleStrip_)),
        m_triangles_(::std::move(other.m_triangles_)),
        m_material_(::std::move(other.m_material_)),
        m_materialAdditional_(::std::move(other.m_materialAdditional_))
{
    if (other.m_isInitialized)
        initialize(*(other.m_mesh_), *(other.m_config_));
    else
        m_isInitialized = false;
}

RenderGroup& RenderGroup::operator=(RenderGroup&& other)
{
    m_colorId_ = ::std::move(other.m_colorId_);
    m_triangleStrip_ = ::std::move(other.m_triangleStrip_);
    m_triangles_ = ::std::move(other.m_triangles_);
    m_material_ = ::std::move(other.m_material_);
    m_materialAdditional_ = ::std::move(other.m_materialAdditional_);
    if (other.m_isInitialized)
        initialize(*(other.m_mesh_), *(other.m_config_));
    else
        m_isInitialized = false;

    return *this;
}

RenderGroup::RenderGroup(::zserio::PropagateAllocatorT,
        const RenderGroup& other, const allocator_type& allocator) :
        m_colorId_(::zserio::allocatorPropagatingCopy(other.m_colorId_, allocator)),
        m_triangleStrip_(::zserio::allocatorPropagatingCopy(other.m_triangleStrip_, allocator)),
        m_triangles_(::zserio::allocatorPropagatingCopy(other.m_triangles_, allocator)),
        m_material_(::zserio::allocatorPropagatingCopy(other.m_material_, allocator)),
        m_materialAdditional_(::zserio::allocatorPropagatingCopy(other.m_materialAdditional_, allocator))
{
    if (other.m_isInitialized)
        initialize(*(other.m_mesh_), *(other.m_config_));
    else
        m_isInitialized = false;
}

void RenderGroup::initialize(
        ::nds::core::geometry::PolyMesh3D& mesh_,
        ::nds::display::types::Mesh3DRenderConfiguration& config_)
{
    m_mesh_ = &mesh_;
    m_config_ = &config_;
    m_isInitialized = true;

    initializeChildren();
}

bool RenderGroup::isInitialized() const
{
    return m_isInitialized;
}

void RenderGroup::initializeChildren()
{
    if (getMesh().getIndexType() == ::nds::core::geometry::IndexType::TRIANGLE_STRIP)
        m_triangleStrip_.value().initialize(getMesh(), getConfig());
    if (getMesh().getIndexType() == ::nds::core::geometry::IndexType::TRIANGLES)
        m_triangles_.value().initialize(getMesh(), getConfig());
}

::nds::core::geometry::PolyMesh3D& RenderGroup::getMesh()
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'mesh' of compound 'RenderGroup' is not initialized!");

    return *m_mesh_;
}

const ::nds::core::geometry::PolyMesh3D& RenderGroup::getMesh() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'mesh' of compound 'RenderGroup' is not initialized!");

    return *m_mesh_;
}

::nds::display::types::Mesh3DRenderConfiguration& RenderGroup::getConfig()
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'config' of compound 'RenderGroup' is not initialized!");

    return *m_config_;
}

const ::nds::display::types::Mesh3DRenderConfiguration& RenderGroup::getConfig() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'config' of compound 'RenderGroup' is not initialized!");

    return *m_config_;
}

::nds::display::types::ColorId RenderGroup::getColorId() const
{
    return m_colorId_.value();
}

void RenderGroup::setColorId(::nds::display::types::ColorId colorId_)
{
    m_colorId_ = colorId_;
}

bool RenderGroup::isColorIdUsed() const
{
    return (getConfig().funcUsesColorPerRenderGroup());
}

bool RenderGroup::isColorIdSet() const
{
    return m_colorId_.hasValue();
}

void RenderGroup::resetColorId()
{
    m_colorId_.reset();
}

::nds::display::types::RenderGroupTriangleStrip& RenderGroup::getTriangleStrip()
{
    return m_triangleStrip_.value();
}

const ::nds::display::types::RenderGroupTriangleStrip& RenderGroup::getTriangleStrip() const
{
    return m_triangleStrip_.value();
}

void RenderGroup::setTriangleStrip(const ::nds::display::types::RenderGroupTriangleStrip& triangleStrip_)
{
    m_triangleStrip_ = triangleStrip_;
}

void RenderGroup::setTriangleStrip(::nds::display::types::RenderGroupTriangleStrip&& triangleStrip_)
{
    m_triangleStrip_ = ::std::move(triangleStrip_);
}

bool RenderGroup::isTriangleStripUsed() const
{
    return (getMesh().getIndexType() == ::nds::core::geometry::IndexType::TRIANGLE_STRIP);
}

bool RenderGroup::isTriangleStripSet() const
{
    return m_triangleStrip_.hasValue();
}

void RenderGroup::resetTriangleStrip()
{
    m_triangleStrip_.reset();
}

::nds::display::types::RenderGroupTriangles& RenderGroup::getTriangles()
{
    return m_triangles_.value();
}

const ::nds::display::types::RenderGroupTriangles& RenderGroup::getTriangles() const
{
    return m_triangles_.value();
}

void RenderGroup::setTriangles(const ::nds::display::types::RenderGroupTriangles& triangles_)
{
    m_triangles_ = triangles_;
}

void RenderGroup::setTriangles(::nds::display::types::RenderGroupTriangles&& triangles_)
{
    m_triangles_ = ::std::move(triangles_);
}

bool RenderGroup::isTrianglesUsed() const
{
    return (getMesh().getIndexType() == ::nds::core::geometry::IndexType::TRIANGLES);
}

bool RenderGroup::isTrianglesSet() const
{
    return m_triangles_.hasValue();
}

void RenderGroup::resetTriangles()
{
    m_triangles_.reset();
}

::nds::display::types::Material& RenderGroup::getMaterial()
{
    return m_material_.value();
}

const ::nds::display::types::Material& RenderGroup::getMaterial() const
{
    return m_material_.value();
}

void RenderGroup::setMaterial(const ::nds::display::types::Material& material_)
{
    m_material_ = material_;
}

void RenderGroup::setMaterial(::nds::display::types::Material&& material_)
{
    m_material_ = ::std::move(material_);
}

bool RenderGroup::isMaterialUsed() const
{
    return (getConfig().getHasTextureCoords() == true);
}

bool RenderGroup::isMaterialSet() const
{
    return m_material_.hasValue();
}

void RenderGroup::resetMaterial()
{
    m_material_.reset();
}

::nds::display::types::Material& RenderGroup::getMaterialAdditional()
{
    return m_materialAdditional_.value();
}

const ::nds::display::types::Material& RenderGroup::getMaterialAdditional() const
{
    return m_materialAdditional_.value();
}

void RenderGroup::setMaterialAdditional(const ::nds::display::types::Material& materialAdditional_)
{
    m_materialAdditional_ = materialAdditional_;
}

void RenderGroup::setMaterialAdditional(::nds::display::types::Material&& materialAdditional_)
{
    m_materialAdditional_ = ::std::move(materialAdditional_);
}

bool RenderGroup::isMaterialAdditionalUsed() const
{
    return (getConfig().getHasTextureCoordsAdditional() == true);
}

bool RenderGroup::isMaterialAdditionalSet() const
{
    return m_materialAdditional_.hasValue();
}

void RenderGroup::resetMaterialAdditional()
{
    m_materialAdditional_.reset();
}

void RenderGroup::initPackingContext(RenderGroup::ZserioPackingContext& context) const
{
    if (getConfig().funcUsesColorPerRenderGroup())
    {
        context.getColorId().init<::zserio::VarIntNNArrayTraits<::nds::display::types::ColorId>>(m_colorId_.value());
    }
    if (getMesh().getIndexType() == ::nds::core::geometry::IndexType::TRIANGLE_STRIP)
    {
        m_triangleStrip_.value().initPackingContext(context.getTriangleStrip());
    }
    if (getMesh().getIndexType() == ::nds::core::geometry::IndexType::TRIANGLES)
    {
        m_triangles_.value().initPackingContext(context.getTriangles());
    }
    if (getConfig().getHasTextureCoords() == true)
    {
        m_material_.value().initPackingContext(context.getMaterial());
    }
    if (getConfig().getHasTextureCoordsAdditional() == true)
    {
        m_materialAdditional_.value().initPackingContext(context.getMaterialAdditional());
    }
}

size_t RenderGroup::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    if (getConfig().funcUsesColorPerRenderGroup())
    {
        endBitPosition += ::zserio::bitSizeOfVarUInt16(m_colorId_.value());
    }
    if (getMesh().getIndexType() == ::nds::core::geometry::IndexType::TRIANGLE_STRIP)
    {
        endBitPosition += m_triangleStrip_.value().bitSizeOf(endBitPosition);
    }
    if (getMesh().getIndexType() == ::nds::core::geometry::IndexType::TRIANGLES)
    {
        endBitPosition += m_triangles_.value().bitSizeOf(endBitPosition);
    }
    if (getConfig().getHasTextureCoords() == true)
    {
        endBitPosition += m_material_.value().bitSizeOf(endBitPosition);
    }
    if (getConfig().getHasTextureCoordsAdditional() == true)
    {
        endBitPosition += m_materialAdditional_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t RenderGroup::bitSizeOf(RenderGroup::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    if (getConfig().funcUsesColorPerRenderGroup())
    {
        endBitPosition += context.getColorId().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::display::types::ColorId>>(m_colorId_.value());
    }
    if (getMesh().getIndexType() == ::nds::core::geometry::IndexType::TRIANGLE_STRIP)
    {
        endBitPosition += m_triangleStrip_.value().bitSizeOf(context.getTriangleStrip(), endBitPosition);
    }
    if (getMesh().getIndexType() == ::nds::core::geometry::IndexType::TRIANGLES)
    {
        endBitPosition += m_triangles_.value().bitSizeOf(context.getTriangles(), endBitPosition);
    }
    if (getConfig().getHasTextureCoords() == true)
    {
        endBitPosition += m_material_.value().bitSizeOf(context.getMaterial(), endBitPosition);
    }
    if (getConfig().getHasTextureCoordsAdditional() == true)
    {
        endBitPosition += m_materialAdditional_.value().bitSizeOf(context.getMaterialAdditional(), endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t RenderGroup::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    if (getConfig().funcUsesColorPerRenderGroup())
    {
        endBitPosition += ::zserio::bitSizeOfVarUInt16(m_colorId_.value());
    }
    if (getMesh().getIndexType() == ::nds::core::geometry::IndexType::TRIANGLE_STRIP)
    {
        endBitPosition = m_triangleStrip_.value().initializeOffsets(endBitPosition);
    }
    if (getMesh().getIndexType() == ::nds::core::geometry::IndexType::TRIANGLES)
    {
        endBitPosition = m_triangles_.value().initializeOffsets(endBitPosition);
    }
    if (getConfig().getHasTextureCoords() == true)
    {
        endBitPosition = m_material_.value().initializeOffsets(endBitPosition);
    }
    if (getConfig().getHasTextureCoordsAdditional() == true)
    {
        endBitPosition = m_materialAdditional_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

size_t RenderGroup::initializeOffsets(RenderGroup::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    if (getConfig().funcUsesColorPerRenderGroup())
    {
        endBitPosition += context.getColorId().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::display::types::ColorId>>(m_colorId_.value());
    }
    if (getMesh().getIndexType() == ::nds::core::geometry::IndexType::TRIANGLE_STRIP)
    {
        endBitPosition = m_triangleStrip_.value().initializeOffsets(context.getTriangleStrip(), endBitPosition);
    }
    if (getMesh().getIndexType() == ::nds::core::geometry::IndexType::TRIANGLES)
    {
        endBitPosition = m_triangles_.value().initializeOffsets(context.getTriangles(), endBitPosition);
    }
    if (getConfig().getHasTextureCoords() == true)
    {
        endBitPosition = m_material_.value().initializeOffsets(context.getMaterial(), endBitPosition);
    }
    if (getConfig().getHasTextureCoordsAdditional() == true)
    {
        endBitPosition = m_materialAdditional_.value().initializeOffsets(context.getMaterialAdditional(), endBitPosition);
    }

    return endBitPosition;
}

bool RenderGroup::operator==(const RenderGroup& other) const
{
    if (this != &other)
    {
        return
                (getMesh() == other.getMesh()) &&
                (getConfig() == other.getConfig()) &&
                (!isColorIdUsed() ? !other.isColorIdUsed() : (m_colorId_ == other.m_colorId_)) &&
                (!isTriangleStripUsed() ? !other.isTriangleStripUsed() : (m_triangleStrip_ == other.m_triangleStrip_)) &&
                (!isTrianglesUsed() ? !other.isTrianglesUsed() : (m_triangles_ == other.m_triangles_)) &&
                (!isMaterialUsed() ? !other.isMaterialUsed() : (m_material_ == other.m_material_)) &&
                (!isMaterialAdditionalUsed() ? !other.isMaterialAdditionalUsed() : (m_materialAdditional_ == other.m_materialAdditional_));
    }

    return true;
}

uint32_t RenderGroup::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getMesh());
    result = ::zserio::calcHashCode(result, getConfig());
    if (isColorIdUsed())
        result = ::zserio::calcHashCode(result, m_colorId_);
    if (isTriangleStripUsed())
        result = ::zserio::calcHashCode(result, m_triangleStrip_);
    if (isTrianglesUsed())
        result = ::zserio::calcHashCode(result, m_triangles_);
    if (isMaterialUsed())
        result = ::zserio::calcHashCode(result, m_material_);
    if (isMaterialAdditionalUsed())
        result = ::zserio::calcHashCode(result, m_materialAdditional_);

    return result;
}

void RenderGroup::write(::zserio::BitStreamWriter& out) const
{
    if (getConfig().funcUsesColorPerRenderGroup())
    {
        out.writeVarUInt16(m_colorId_.value());
    }

    if (getMesh().getIndexType() == ::nds::core::geometry::IndexType::TRIANGLE_STRIP)
    {
        // check parameters
        if (&(m_triangleStrip_.value().getMesh()) != &(getMesh()))
        {
            throw ::zserio::CppRuntimeException("Write: Inconsistent parameter mesh for field RenderGroup.triangleStrip!");
        }
        if (&(m_triangleStrip_.value().getConfig()) != &(getConfig()))
        {
            throw ::zserio::CppRuntimeException("Write: Inconsistent parameter config for field RenderGroup.triangleStrip!");
        }
        m_triangleStrip_.value().write(out);
    }

    if (getMesh().getIndexType() == ::nds::core::geometry::IndexType::TRIANGLES)
    {
        // check parameters
        if (&(m_triangles_.value().getMesh()) != &(getMesh()))
        {
            throw ::zserio::CppRuntimeException("Write: Inconsistent parameter mesh for field RenderGroup.triangles!");
        }
        if (&(m_triangles_.value().getConfig()) != &(getConfig()))
        {
            throw ::zserio::CppRuntimeException("Write: Inconsistent parameter config for field RenderGroup.triangles!");
        }
        m_triangles_.value().write(out);
    }

    if (getConfig().getHasTextureCoords() == true)
    {
        m_material_.value().write(out);
    }

    if (getConfig().getHasTextureCoordsAdditional() == true)
    {
        m_materialAdditional_.value().write(out);
    }
}

void RenderGroup::write(RenderGroup::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    if (getConfig().funcUsesColorPerRenderGroup())
    {
        context.getColorId().write<::zserio::VarIntNNArrayTraits<::nds::display::types::ColorId>>(out, m_colorId_.value());
    }

    if (getMesh().getIndexType() == ::nds::core::geometry::IndexType::TRIANGLE_STRIP)
    {
        // check parameters
        if (&(m_triangleStrip_.value().getMesh()) != &(getMesh()))
        {
            throw ::zserio::CppRuntimeException("Write: Inconsistent parameter mesh for field RenderGroup.triangleStrip!");
        }
        if (&(m_triangleStrip_.value().getConfig()) != &(getConfig()))
        {
            throw ::zserio::CppRuntimeException("Write: Inconsistent parameter config for field RenderGroup.triangleStrip!");
        }
        m_triangleStrip_.value().write(context.getTriangleStrip(), out);
    }

    if (getMesh().getIndexType() == ::nds::core::geometry::IndexType::TRIANGLES)
    {
        // check parameters
        if (&(m_triangles_.value().getMesh()) != &(getMesh()))
        {
            throw ::zserio::CppRuntimeException("Write: Inconsistent parameter mesh for field RenderGroup.triangles!");
        }
        if (&(m_triangles_.value().getConfig()) != &(getConfig()))
        {
            throw ::zserio::CppRuntimeException("Write: Inconsistent parameter config for field RenderGroup.triangles!");
        }
        m_triangles_.value().write(context.getTriangles(), out);
    }

    if (getConfig().getHasTextureCoords() == true)
    {
        m_material_.value().write(context.getMaterial(), out);
    }

    if (getConfig().getHasTextureCoordsAdditional() == true)
    {
        m_materialAdditional_.value().write(context.getMaterialAdditional(), out);
    }
}

::zserio::InplaceOptionalHolder<::nds::display::types::ColorId> RenderGroup::readColorId(::zserio::BitStreamReader& in)
{
    if (getConfig().funcUsesColorPerRenderGroup())
    {
        return ::zserio::InplaceOptionalHolder<::nds::display::types::ColorId>(static_cast<::nds::display::types::ColorId>(in.readVarUInt16()));
    }

    return ::zserio::InplaceOptionalHolder<::nds::display::types::ColorId>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::display::types::ColorId> RenderGroup::readColorId(RenderGroup::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (getConfig().funcUsesColorPerRenderGroup())
    {
        return ::zserio::InplaceOptionalHolder<::nds::display::types::ColorId>(context.getColorId().read<::zserio::VarIntNNArrayTraits<::nds::display::types::ColorId>>(in));
    }

    return ::zserio::InplaceOptionalHolder<::nds::display::types::ColorId>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::display::types::RenderGroupTriangleStrip> RenderGroup::readTriangleStrip(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getMesh().getIndexType() == ::nds::core::geometry::IndexType::TRIANGLE_STRIP)
    {
        return ::zserio::InplaceOptionalHolder<::nds::display::types::RenderGroupTriangleStrip>(::nds::display::types::RenderGroupTriangleStrip(in, getMesh(), getConfig(), allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::display::types::RenderGroupTriangleStrip>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::display::types::RenderGroupTriangleStrip> RenderGroup::readTriangleStrip(RenderGroup::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getMesh().getIndexType() == ::nds::core::geometry::IndexType::TRIANGLE_STRIP)
    {
        return ::zserio::InplaceOptionalHolder<::nds::display::types::RenderGroupTriangleStrip>(::nds::display::types::RenderGroupTriangleStrip(context.getTriangleStrip(), in, getMesh(), getConfig(), allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::display::types::RenderGroupTriangleStrip>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::display::types::RenderGroupTriangles> RenderGroup::readTriangles(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getMesh().getIndexType() == ::nds::core::geometry::IndexType::TRIANGLES)
    {
        return ::zserio::InplaceOptionalHolder<::nds::display::types::RenderGroupTriangles>(::nds::display::types::RenderGroupTriangles(in, getMesh(), getConfig(), allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::display::types::RenderGroupTriangles>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::display::types::RenderGroupTriangles> RenderGroup::readTriangles(RenderGroup::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getMesh().getIndexType() == ::nds::core::geometry::IndexType::TRIANGLES)
    {
        return ::zserio::InplaceOptionalHolder<::nds::display::types::RenderGroupTriangles>(::nds::display::types::RenderGroupTriangles(context.getTriangles(), in, getMesh(), getConfig(), allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::display::types::RenderGroupTriangles>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::display::types::Material> RenderGroup::readMaterial(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getConfig().getHasTextureCoords() == true)
    {
        return ::zserio::InplaceOptionalHolder<::nds::display::types::Material>(::nds::display::types::Material(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::display::types::Material>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::display::types::Material> RenderGroup::readMaterial(RenderGroup::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getConfig().getHasTextureCoords() == true)
    {
        return ::zserio::InplaceOptionalHolder<::nds::display::types::Material>(::nds::display::types::Material(context.getMaterial(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::display::types::Material>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::display::types::Material> RenderGroup::readMaterialAdditional(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getConfig().getHasTextureCoordsAdditional() == true)
    {
        return ::zserio::InplaceOptionalHolder<::nds::display::types::Material>(::nds::display::types::Material(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::display::types::Material>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::display::types::Material> RenderGroup::readMaterialAdditional(RenderGroup::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getConfig().getHasTextureCoordsAdditional() == true)
    {
        return ::zserio::InplaceOptionalHolder<::nds::display::types::Material>(::nds::display::types::Material(context.getMaterialAdditional(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::display::types::Material>(::zserio::NullOpt);
}

} // namespace types
} // namespace display
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/display/types/RenderGroupTriangleStrip.h>

namespace nds
{
namespace display
{
namespace types
{

RenderGroupTriangleStrip::RenderGroupTriangleStrip(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_consecutiveQuads_(uint16_t()),
        m_vertIndices_(allocator)
{
}

RenderGroupTriangleStrip::RenderGroupTriangleStrip(::zserio::BitStreamReader& in,
        ::nds::core::geometry::PolyMesh3D& mesh_,
        ::nds::display::types::Mesh3DRenderConfiguration& config_, const allocator_type& allocator) :
        m_mesh_(&mesh_),
        m_config_(&config_),
        m_isInitialized(true),
        m_consecutiveQuads_(readConsecutiveQuads(in)),
        m_vertIndices_(readVertIndices(in, allocator))
{
}

RenderGroupTriangleStrip::RenderGroupTriangleStrip(RenderGroupTriangleStrip::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::PolyMesh3D& mesh_,
        ::nds::display::types::Mesh3DRenderConfiguration& config_, const allocator_type& allocator) :
        m_mesh_(&mesh_),
        m_config_(&config_),
        m_isInitialized(true),
        m_consecutiveQuads_(readConsecutiveQuads(context, in)),
        m_vertIndices_(readVertIndices(context, in, allocator))
{
}

RenderGroupTriangleStrip::RenderGroupTriangleStrip(const RenderGroupTriangleStrip& other) :
        m_consecutiveQuads_(other.m_consecutiveQuads_),
        m_vertIndices_(other.m_vertIndices_)
{
    if (other.m_isInitialized)
        initialize(*(other.m_mesh_), *(other.m_config_));
    else
        m_isInitialized = false;
}

RenderGroupTriangleStrip& RenderGroupTriangleStrip::operator=(const RenderGroupTriangleStrip& other)
{
    m_consecutiveQuads_ = other.m_consecutiveQuads_;
    m_vertIndices_ = other.m_vertIndices_;
    if (other.m_isInitialized)
        initialize(*(other.m_mesh_), *(other.m_config_));
    else
        m_isInitialized = false;

    return *this;
}

RenderGroupTriangleStrip::RenderGroupTriangleStrip(RenderGroupTriangleStrip&& other) :
        m_consecutiveQuads_(::std::move(other.m_consecutiveQuads_)),
        m_vertIndices_(::std::move(other.m_vertIndices_))
{
    if (other.m_isInitialized)
        initialize(*(other.m_mesh_), *(other.m_config_));
    else
        m_isInitialized = false;
}

RenderGroupTriangleStrip& RenderGroupTriangleStrip::operator=(RenderGroupTriangleStrip&& other)
{
    m_consecutiveQuads_ = ::std::move(other.m_consecutiveQuads_);
    m_vertIndices_ = ::std::move(other.m_vertIndices_);
    if (other.m_isInitialized)
        initialize(*(other.m_mesh_), *(other.m_config_));
    else
        m_isInitialized = false;

    return *this;
}

RenderGroupTriangleStrip::RenderGroupTriangleStrip(::zserio::PropagateAllocatorT,
        const RenderGroupTriangleStrip& other, const allocator_type& allocator) :
        m_consecutiveQuads_(::zserio::allocatorPropagatingCopy(other.m_consecutiveQuads_, allocator)),
        m_vertIndices_(::zserio::allocatorPropagatingCopy(other.m_vertIndices_, allocator))
{
    if (other.m_isInitialized)
        initialize(*(other.m_mesh_), *(other.m_config_));
    else
        m_isInitialized = false;
}

void RenderGroupTriangleStrip::initialize(
        ::nds::core::geometry::PolyMesh3D& mesh_,
        ::nds::display::types::Mesh3DRenderConfiguration& config_)
{
    m_mesh_ = &mesh_;
    m_config_ = &config_;
    m_isInitialized = true;

    initializeChildren();
}

bool RenderGroupTriangleStrip::isInitialized() const
{
    return m_isInitialized;
}

void RenderGroupTriangleStrip::initializeChildren()
{
    m_vertIndices_.initializeElements(*this);
}

::nds::core::geometry::PolyMesh3D& RenderGroupTriangleStrip::getMesh()
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'mesh' of compound 'RenderGroupTriangleStrip' is not initialized!");

    return *m_mesh_;
}

const ::nds::core::geometry::PolyMesh3D& RenderGroupTriangleStrip::getMesh() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'mesh' of compound 'RenderGroupTriangleStrip' is not initialized!");

    return *m_mesh_;
}

::nds::display::types::Mesh3DRenderConfiguration& RenderGroupTriangleStrip::getConfig()
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'config' of compound 'RenderGroupTriangleStrip' is not initialized!");

    return *m_config_;
}

const ::nds::display::types::Mesh3DRenderConfiguration& RenderGroupTriangleStrip::getConfig() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'config' of compound 'RenderGroupTriangleStrip' is not initialized!");

    return *m_config_;
}

uint16_t RenderGroupTriangleStrip::getConsecutiveQuads() const
{
    return m_consecutiveQuads_;
}

void RenderGroupTriangleStrip::setConsecutiveQuads(uint16_t consecutiveQuads_)
{
    m_consecutiveQuads_ = consecutiveQuads_;
}

::zserio::vector<::nds::display::types::MeshRangeIndex>& RenderGroupTriangleStrip::getVertIndices()
{
    return m_vertIndices_.getRawArray();
}

const ::zserio::vector<::nds::display::types::MeshRangeIndex>& RenderGroupTriangleStrip::getVertIndices() const
{
    return m_vertIndices_.getRawArray();
}

void RenderGroupTriangleStrip::setVertIndices(const ::zserio::vector<::nds::display::types::MeshRangeIndex>& vertIndices_)
{
    m_vertIndices_ = ZserioArrayType_vertIndices(vertIndices_);
}

void RenderGroupTriangleStrip::setVertIndices(::zserio::vector<::nds::display::types::MeshRangeIndex>&& vertIndices_)
{
    m_vertIndices_ = ZserioArrayType_vertIndices(std::move(vertIndices_));
}

uint16_t RenderGroupTriangleStrip::funcNumIndicesTriangleStrip() const
{
    return static_cast<uint16_t>((4 + 2 * getConsecutiveQuads()));
}

uint32_t RenderGroupTriangleStrip::funcMaxMeshIndex() const
{
    return static_cast<uint32_t>(getMesh().getNumPositions());
}

void RenderGroupTriangleStrip::initPackingContext(RenderGroupTriangleStrip::ZserioPackingContext& context) const
{
    context.getConsecutiveQuads().init<::zserio::VarIntNNArrayTraits<uint16_t>>(m_consecutiveQuads_);
}

size_t RenderGroupTriangleStrip::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_consecutiveQuads_);
    endBitPosition += m_vertIndices_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RenderGroupTriangleStrip::bitSizeOf(RenderGroupTriangleStrip::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getConsecutiveQuads().bitSizeOf<::zserio::VarIntNNArrayTraits<uint16_t>>(m_consecutiveQuads_);
    endBitPosition += m_vertIndices_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RenderGroupTriangleStrip::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_consecutiveQuads_);
    endBitPosition = m_vertIndices_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t RenderGroupTriangleStrip::initializeOffsets(RenderGroupTriangleStrip::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getConsecutiveQuads().bitSizeOf<::zserio::VarIntNNArrayTraits<uint16_t>>(m_consecutiveQuads_);
    endBitPosition = m_vertIndices_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RenderGroupTriangleStrip::operator==(const RenderGroupTriangleStrip& other) const
{
    if (this != &other)
    {
        return
                (getMesh() == other.getMesh()) &&
                (getConfig() == other.getConfig()) &&
                (m_consecutiveQuads_ == other.m_consecutiveQuads_) &&
                (m_vertIndices_ == other.m_vertIndices_);
    }

    return true;
}

uint32_t RenderGroupTriangleStrip::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getMesh());
    result = ::zserio::calcHashCode(result, getConfig());
    result = ::zserio::calcHashCode(result, m_consecutiveQuads_);
    result = ::zserio::calcHashCode(result, m_vertIndices_);

    return result;
}

void RenderGroupTriangleStrip::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt16(m_consecutiveQuads_);

    // check array length
    if (m_vertIndices_.getRawArray().size() != static_cast<size_t>(funcNumIndicesTriangleStrip()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RenderGroupTriangleStrip.vertIndices: ") <<
                m_vertIndices_.getRawArray().size() << " != " <<
                static_cast<size_t>(funcNumIndicesTriangleStrip()) << "!";
    }
    m_vertIndices_.write(*this, out);
}

void RenderGroupTriangleStrip::write(RenderGroupTriangleStrip::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getConsecutiveQuads().write<::zserio::VarIntNNArrayTraits<uint16_t>>(out, m_consecutiveQuads_);

    // check array length
    if (m_vertIndices_.getRawArray().size() != static_cast<size_t>(funcNumIndicesTriangleStrip()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RenderGroupTriangleStrip.vertIndices: ") <<
                m_vertIndices_.getRawArray().size() << " != " <<
                static_cast<size_t>(funcNumIndicesTriangleStrip()) << "!";
    }
    m_vertIndices_.writePacked(*this, out);
}

void RenderGroupTriangleStrip::ZserioArrayExpressions_vertIndices::initializeElement(RenderGroupTriangleStrip& owner,
        ::nds::display::types::MeshRangeIndex& element, size_t)
{
    element.initialize(static_cast<uint32_t>(owner.funcMaxMeshIndex()));
}

void RenderGroupTriangleStrip::ZserioElementFactory_vertIndices::create(RenderGroupTriangleStrip&         owner,
        ::zserio::vector<::nds::display::types::MeshRangeIndex>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<uint32_t>(owner.funcMaxMeshIndex()), array.get_allocator());
}

void RenderGroupTriangleStrip::ZserioElementFactory_vertIndices::create(RenderGroupTriangleStrip&         owner,
        ::zserio::vector<::nds::display::types::MeshRangeIndex>& array,
        ::nds::display::types::MeshRangeIndex::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<uint32_t>(owner.funcMaxMeshIndex()), array.get_allocator());
}

uint16_t RenderGroupTriangleStrip::readConsecutiveQuads(::zserio::BitStreamReader& in)
{
    return static_cast<uint16_t>(in.readVarUInt16());
}

uint16_t RenderGroupTriangleStrip::readConsecutiveQuads(RenderGroupTriangleStrip::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getConsecutiveQuads().read<::zserio::VarIntNNArrayTraits<uint16_t>>(in);
}
RenderGroupTriangleStrip::ZserioArrayType_vertIndices RenderGroupTriangleStrip::readVertIndices(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_vertIndices readField(allocator);
    readField.read(*this, in, static_cast<size_t>(funcNumIndicesTriangleStrip()));

    return readField;
}

RenderGroupTriangleStrip::ZserioArrayType_vertIndices RenderGroupTriangleStrip::readVertIndices(RenderGroupTriangleStrip::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_vertIndices readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(funcNumIndicesTriangleStrip()));

    return readField;
}

} // namespace types
} // namespace display
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/display/types/RenderGroupTriangles.h>

namespace nds
{
namespace display
{
namespace types
{

RenderGroupTriangles::RenderGroupTriangles(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numberOfTriangles_(uint16_t()),
        m_vertIndices_(allocator)
{
}

RenderGroupTriangles::RenderGroupTriangles(::zserio::BitStreamReader& in,
        ::nds::core::geometry::PolyMesh3D& mesh_,
        ::nds::display::types::Mesh3DRenderConfiguration& config_, const allocator_type& allocator) :
        m_mesh_(&mesh_),
        m_config_(&config_),
        m_isInitialized(true),
        m_numberOfTriangles_(readNumberOfTriangles(in)),
        m_vertIndices_(readVertIndices(in, allocator))
{
}

RenderGroupTriangles::RenderGroupTriangles(RenderGroupTriangles::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::PolyMesh3D& mesh_,
        ::nds::display::types::Mesh3DRenderConfiguration& config_, const allocator_type& allocator) :
        m_mesh_(&mesh_),
        m_config_(&config_),
        m_isInitialized(true),
        m_numberOfTriangles_(readNumberOfTriangles(context, in)),
        m_vertIndices_(readVertIndices(context, in, allocator))
{
}

RenderGroupTriangles::RenderGroupTriangles(const RenderGroupTriangles& other) :
        m_numberOfTriangles_(other.m_numberOfTriangles_),
        m_vertIndices_(other.m_vertIndices_)
{
    if (other.m_isInitialized)
        initialize(*(other.m_mesh_), *(other.m_config_));
    else
        m_isInitialized = false;
}

RenderGroupTriangles& RenderGroupTriangles::operator=(const RenderGroupTriangles& other)
{
    m_numberOfTriangles_ = other.m_numberOfTriangles_;
    m_vertIndices_ = other.m_vertIndices_;
    if (other.m_isInitialized)
        initialize(*(other.m_mesh_), *(other.m_config_));
    else
        m_isInitialized = false;

    return *this;
}

RenderGroupTriangles::RenderGroupTriangles(RenderGroupTriangles&& other) :
        m_numberOfTriangles_(::std::move(other.m_numberOfTriangles_)),
        m_vertIndices_(::std::move(other.m_vertIndices_))
{
    if (other.m_isInitialized)
        initialize(*(other.m_mesh_), *(other.m_config_));
    else
        m_isInitialized = false;
}

RenderGroupTriangles& RenderGroupTriangles::operator=(RenderGroupTriangles&& other)
{
    m_numberOfTriangles_ = ::std::move(other.m_numberOfTriangles_);
    m_vertIndices_ = ::std::move(other.m_vertIndices_);
    if (other.m_isInitialized)
        initialize(*(other.m_mesh_), *(other.m_config_));
    else
        m_isInitialized = false;

    return *this;
}

RenderGroupTriangles::RenderGroupTriangles(::zserio::PropagateAllocatorT,
        const RenderGroupTriangles& other, const allocator_type& allocator) :
        m_numberOfTriangles_(::zserio::allocatorPropagatingCopy(other.m_numberOfTriangles_, allocator)),
        m_vertIndices_(::zserio::allocatorPropagatingCopy(other.m_vertIndices_, allocator))
{
    if (other.m_isInitialized)
        initialize(*(other.m_mesh_), *(other.m_config_));
    else
        m_isInitialized = false;
}

void RenderGroupTriangles::initialize(
        ::nds::core::geometry::PolyMesh3D& mesh_,
        ::nds::display::types::Mesh3DRenderConfiguration& config_)
{
    m_mesh_ = &mesh_;
    m_config_ = &config_;
    m_isInitialized = true;

    initializeChildren();
}

bool RenderGroupTriangles::isInitialized() const
{
    return m_isInitialized;
}

void RenderGroupTriangles::initializeChildren()
{
    m_vertIndices_.initializeElements(*this);
}

::nds::core::geometry::PolyMesh3D& RenderGroupTriangles::getMesh()
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'mesh' of compound 'RenderGroupTriangles' is not initialized!");

    return *m_mesh_;
}

const ::nds::core::geometry::PolyMesh3D& RenderGroupTriangles::getMesh() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'mesh' of compound 'RenderGroupTriangles' is not initialized!");

    return *m_mesh_;
}

::nds::display::types::Mesh3DRenderConfiguration& RenderGroupTriangles::getConfig()
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'config' of compound 'RenderGroupTriangles' is not initialized!");

    return *m_config_;
}

const ::nds::display::types::Mesh3DRenderConfiguration& RenderGroupTriangles::getConfig() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'config' of compound 'RenderGroupTriangles' is not initialized!");

    return *m_config_;
}

uint16_t RenderGroupTriangles::getNumberOfTriangles() const
{
    return m_numberOfTriangles_;
}

void RenderGroupTriangles::setNumberOfTriangles(uint16_t numberOfTriangles_)
{
    m_numberOfTriangles_ = numberOfTriangles_;
}

::zserio::vector<::nds::display::types::MeshRangeIndex>& RenderGroupTriangles::getVertIndices()
{
    return m_vertIndices_.getRawArray();
}

const ::zserio::vector<::nds::display::types::MeshRangeIndex>& RenderGroupTriangles::getVertIndices() const
{
    return m_vertIndices_.getRawArray();
}

void RenderGroupTriangles::setVertIndices(const ::zserio::vector<::nds::display::types::MeshRangeIndex>& vertIndices_)
{
    m_vertIndices_ = ZserioArrayType_vertIndices(vertIndices_);
}

void RenderGroupTriangles::setVertIndices(::zserio::vector<::nds::display::types::MeshRangeIndex>&& vertIndices_)
{
    m_vertIndices_ = ZserioArrayType_vertIndices(std::move(vertIndices_));
}

uint16_t RenderGroupTriangles::funcNumIndicesTriangle() const
{
    return static_cast<uint16_t>((3 * getNumberOfTriangles()));
}

uint8_t RenderGroupTriangles::funcMaxMeshIndex() const
{
    return static_cast<uint8_t>(getMesh().getNumPositions());
}

void RenderGroupTriangles::initPackingContext(RenderGroupTriangles::ZserioPackingContext& context) const
{
    context.getNumberOfTriangles().init<::zserio::VarIntNNArrayTraits<uint16_t>>(m_numberOfTriangles_);
}

size_t RenderGroupTriangles::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_numberOfTriangles_);
    endBitPosition += m_vertIndices_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RenderGroupTriangles::bitSizeOf(RenderGroupTriangles::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumberOfTriangles().bitSizeOf<::zserio::VarIntNNArrayTraits<uint16_t>>(m_numberOfTriangles_);
    endBitPosition += m_vertIndices_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RenderGroupTriangles::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_numberOfTriangles_);
    endBitPosition = m_vertIndices_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t RenderGroupTriangles::initializeOffsets(RenderGroupTriangles::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumberOfTriangles().bitSizeOf<::zserio::VarIntNNArrayTraits<uint16_t>>(m_numberOfTriangles_);
    endBitPosition = m_vertIndices_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RenderGroupTriangles::operator==(const RenderGroupTriangles& other) const
{
    if (this != &other)
    {
        return
                (getMesh() == other.getMesh()) &&
                (getConfig() == other.getConfig()) &&
                (m_numberOfTriangles_ == other.m_numberOfTriangles_) &&
                (m_vertIndices_ == other.m_vertIndices_);
    }

    return true;
}

uint32_t RenderGroupTriangles::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getMesh());
    result = ::zserio::calcHashCode(result, getConfig());
    result = ::zserio::calcHashCode(result, m_numberOfTriangles_);
    result = ::zserio::calcHashCode(result, m_vertIndices_);

    return result;
}

void RenderGroupTriangles::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt16(m_numberOfTriangles_);

    // check array length
    if (m_vertIndices_.getRawArray().size() != static_cast<size_t>(funcNumIndicesTriangle()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RenderGroupTriangles.vertIndices: ") <<
                m_vertIndices_.getRawArray().size() << " != " <<
                static_cast<size_t>(funcNumIndicesTriangle()) << "!";
    }
    m_vertIndices_.write(*this, out);
}

void RenderGroupTriangles::write(RenderGroupTriangles::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumberOfTriangles().write<::zserio::VarIntNNArrayTraits<uint16_t>>(out, m_numberOfTriangles_);

    // check array length
    if (m_vertIndices_.getRawArray().size() != static_cast<size_t>(funcNumIndicesTriangle()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RenderGroupTriangles.vertIndices: ") <<
                m_vertIndices_.getRawArray().size() << " != " <<
                static_cast<size_t>(funcNumIndicesTriangle()) << "!";
    }
    m_vertIndices_.writePacked(*this, out);
}

void RenderGroupTriangles::ZserioArrayExpressions_vertIndices::initializeElement(RenderGroupTriangles& owner,
        ::nds::display::types::MeshRangeIndex& element, size_t)
{
    element.initialize(static_cast<uint32_t>(owner.funcMaxMeshIndex()));
}

void RenderGroupTriangles::ZserioElementFactory_vertIndices::create(RenderGroupTriangles&         owner,
        ::zserio::vector<::nds::display::types::MeshRangeIndex>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<uint32_t>(owner.funcMaxMeshIndex()), array.get_allocator());
}

void RenderGroupTriangles::ZserioElementFactory_vertIndices::create(RenderGroupTriangles&         owner,
        ::zserio::vector<::nds::display::types::MeshRangeIndex>& array,
        ::nds::display::types::MeshRangeIndex::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<uint32_t>(owner.funcMaxMeshIndex()), array.get_allocator());
}

uint16_t RenderGroupTriangles::readNumberOfTriangles(::zserio::BitStreamReader& in)
{
    return static_cast<uint16_t>(in.readVarUInt16());
}

uint16_t RenderGroupTriangles::readNumberOfTriangles(RenderGroupTriangles::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumberOfTriangles().read<::zserio::VarIntNNArrayTraits<uint16_t>>(in);
}
RenderGroupTriangles::ZserioArrayType_vertIndices RenderGroupTriangles::readVertIndices(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_vertIndices readField(allocator);
    readField.read(*this, in, static_cast<size_t>(funcNumIndicesTriangle()));

    return readField;
}

RenderGroupTriangles::ZserioArrayType_vertIndices RenderGroupTriangles::readVertIndices(RenderGroupTriangles::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_vertIndices readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(funcNumIndicesTriangle()));

    return readField;
}

} // namespace types
} // namespace display
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/display/types/Material.h>

namespace nds
{
namespace display
{
namespace types
{

Material::Material(const allocator_type& allocator) noexcept :
        m_content_(allocator),
        m_ambient_(::zserio::NullOpt),
        m_diffuse_(::zserio::NullOpt),
        m_specular_(::zserio::NullOpt),
        m_shininess_(::zserio::NullOpt),
        m_texture_(::zserio::NullOpt)
{
}

Material::Material(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_content_(readContent(in, allocator)),
        m_ambient_(readAmbient(in)),
        m_diffuse_(readDiffuse(in)),
        m_specular_(readSpecular(in)),
        m_shininess_(readShininess(in)),
        m_texture_(readTexture(in, allocator))
{
}

Material::Material(Material::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_content_(readContent(context, in, allocator)),
        m_ambient_(readAmbient(context, in)),
        m_diffuse_(readDiffuse(context, in)),
        m_specular_(readSpecular(context, in)),
        m_shininess_(readShininess(context, in)),
        m_texture_(readTexture(context, in, allocator))
{
}

Material::Material(::zserio::PropagateAllocatorT,
        const Material& other, const allocator_type& allocator) :
        m_content_(::zserio::allocatorPropagatingCopy(other.m_content_, allocator)),
        m_ambient_(::zserio::allocatorPropagatingCopy(other.m_ambient_, allocator)),
        m_diffuse_(::zserio::allocatorPropagatingCopy(other.m_diffuse_, allocator)),
        m_specular_(::zserio::allocatorPropagatingCopy(other.m_specular_, allocator)),
        m_shininess_(::zserio::allocatorPropagatingCopy(other.m_shininess_, allocator)),
        m_texture_(::zserio::allocatorPropagatingCopy(other.m_texture_, allocator))
{
}

::nds::display::types::MaterialContent& Material::getContent()
{
    return m_content_;
}

const ::nds::display::types::MaterialContent& Material::getContent() const
{
    return m_content_;
}

void Material::setContent(const ::nds::display::types::MaterialContent& content_)
{
    m_content_ = content_;
}

void Material::setContent(::nds::display::types::MaterialContent&& content_)
{
    m_content_ = ::std::move(content_);
}

::nds::display::types::ColorId Material::getAmbient() const
{
    return m_ambient_.value();
}

void Material::setAmbient(::nds::display::types::ColorId ambient_)
{
    m_ambient_ = ambient_;
}

bool Material::isAmbientUsed() const
{
    return (getContent().getHasAmbientAndDiffuseColor() == true);
}

bool Material::isAmbientSet() const
{
    return m_ambient_.hasValue();
}

void Material::resetAmbient()
{
    m_ambient_.reset();
}

::nds::display::types::ColorId Material::getDiffuse() const
{
    return m_diffuse_.value();
}

void Material::setDiffuse(::nds::display::types::ColorId diffuse_)
{
    m_diffuse_ = diffuse_;
}

bool Material::isDiffuseUsed() const
{
    return (getContent().getHasAmbientAndDiffuseColor() == true);
}

bool Material::isDiffuseSet() const
{
    return m_diffuse_.hasValue();
}

void Material::resetDiffuse()
{
    m_diffuse_.reset();
}

::nds::display::types::ColorId Material::getSpecular() const
{
    return m_specular_.value();
}

void Material::setSpecular(::nds::display::types::ColorId specular_)
{
    m_specular_ = specular_;
}

bool Material::isSpecularUsed() const
{
    return (getContent().getHasSpecularAndShininessColor() == true);
}

bool Material::isSpecularSet() const
{
    return m_specular_.hasValue();
}

void Material::resetSpecular()
{
    m_specular_.reset();
}

uint8_t Material::getShininess() const
{
    return m_shininess_.value();
}

void Material::setShininess(uint8_t shininess_)
{
    m_shininess_ = shininess_;
}

bool Material::isShininessUsed() const
{
    return (getContent().getHasSpecularAndShininessColor() == true);
}

bool Material::isShininessSet() const
{
    return m_shininess_.hasValue();
}

void Material::resetShininess()
{
    m_shininess_.reset();
}

::nds::display::reference::types::TextureReference& Material::getTexture()
{
    return m_texture_.value();
}

const ::nds::display::reference::types::TextureReference& Material::getTexture() const
{
    return m_texture_.value();
}

void Material::setTexture(const ::nds::display::reference::types::TextureReference& texture_)
{
    m_texture_ = texture_;
}

void Material::setTexture(::nds::display::reference::types::TextureReference&& texture_)
{
    m_texture_ = ::std::move(texture_);
}

bool Material::isTextureUsed() const
{
    return (getContent().getUsesTextures() == true);
}

bool Material::isTextureSet() const
{
    return m_texture_.hasValue();
}

void Material::resetTexture()
{
    m_texture_.reset();
}

void Material::initPackingContext(Material::ZserioPackingContext& context) const
{
    m_content_.initPackingContext(context.getContent());
    if (getContent().getHasAmbientAndDiffuseColor() == true)
    {
        context.getAmbient().init<::zserio::VarIntNNArrayTraits<::nds::display::types::ColorId>>(m_ambient_.value());
    }
    if (getContent().getHasAmbientAndDiffuseColor() == true)
    {
        context.getDiffuse().init<::zserio::VarIntNNArrayTraits<::nds::display::types::ColorId>>(m_diffuse_.value());
    }
    if (getContent().getHasSpecularAndShininessColor() == true)
    {
        context.getSpecular().init<::zserio::VarIntNNArrayTraits<::nds::display::types::ColorId>>(m_specular_.value());
    }
    if (getContent().getHasSpecularAndShininessColor() == true)
    {
        context.getShininess().init<::zserio::StdIntArrayTraits<uint8_t>>(m_shininess_.value());
    }
    if (getContent().getUsesTextures() == true)
    {
        m_texture_.value().initPackingContext(context.getTexture());
    }
}

size_t Material::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_content_.bitSizeOf(endBitPosition);
    if (getContent().getHasAmbientAndDiffuseColor() == true)
    {
        endBitPosition += ::zserio::bitSizeOfVarUInt16(m_ambient_.value());
    }
    if (getContent().getHasAmbientAndDiffuseColor() == true)
    {
        endBitPosition += ::zserio::bitSizeOfVarUInt16(m_diffuse_.value());
    }
    if (getContent().getHasSpecularAndShininessColor() == true)
    {
        endBitPosition += ::zserio::bitSizeOfVarUInt16(m_specular_.value());
    }
    if (getContent().getHasSpecularAndShininessColor() == true)
    {
        endBitPosition += UINT8_C(8);
    }
    if (getContent().getUsesTextures() == true)
    {
        endBitPosition += m_texture_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t Material::bitSizeOf(Material::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_content_.bitSizeOf(context.getContent(), endBitPosition);
    if (getContent().getHasAmbientAndDiffuseColor() == true)
    {
        endBitPosition += context.getAmbient().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::display::types::ColorId>>(m_ambient_.value());
    }
    if (getContent().getHasAmbientAndDiffuseColor() == true)
    {
        endBitPosition += context.getDiffuse().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::display::types::ColorId>>(m_diffuse_.value());
    }
    if (getContent().getHasSpecularAndShininessColor() == true)
    {
        endBitPosition += context.getSpecular().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::display::types::ColorId>>(m_specular_.value());
    }
    if (getContent().getHasSpecularAndShininessColor() == true)
    {
        endBitPosition += context.getShininess().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_shininess_.value());
    }
    if (getContent().getUsesTextures() == true)
    {
        endBitPosition += m_texture_.value().bitSizeOf(context.getTexture(), endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t Material::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_content_.initializeOffsets(endBitPosition);
    if (getContent().getHasAmbientAndDiffuseColor() == true)
    {
        endBitPosition += ::zserio::bitSizeOfVarUInt16(m_ambient_.value());
    }
    if (getContent().getHasAmbientAndDiffuseColor() == true)
    {
        endBitPosition += ::zserio::bitSizeOfVarUInt16(m_diffuse_.value());
    }
    if (getContent().getHasSpecularAndShininessColor() == true)
    {
        endBitPosition += ::zserio::bitSizeOfVarUInt16(m_specular_.value());
    }
    if (getContent().getHasSpecularAndShininessColor() == true)
    {
        endBitPosition += UINT8_C(8);
    }
    if (getContent().getUsesTextures() == true)
    {
        endBitPosition = m_texture_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

size_t Material::initializeOffsets(Material::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_content_.initializeOffsets(context.getContent(), endBitPosition);
    if (getContent().getHasAmbientAndDiffuseColor() == true)
    {
        endBitPosition += context.getAmbient().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::display::types::ColorId>>(m_ambient_.value());
    }
    if (getContent().getHasAmbientAndDiffuseColor() == true)
    {
        endBitPosition += context.getDiffuse().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::display::types::ColorId>>(m_diffuse_.value());
    }
    if (getContent().getHasSpecularAndShininessColor() == true)
    {
        endBitPosition += context.getSpecular().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::display::types::ColorId>>(m_specular_.value());
    }
    if (getContent().getHasSpecularAndShininessColor() == true)
    {
        endBitPosition += context.getShininess().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_shininess_.value());
    }
    if (getContent().getUsesTextures() == true)
    {
        endBitPosition = m_texture_.value().initializeOffsets(context.getTexture(), endBitPosition);
    }

    return endBitPosition;
}

bool Material::operator==(const Material& other) const
{
    if (this != &other)
    {
        return
                (m_content_ == other.m_content_) &&
                (!isAmbientUsed() ? !other.isAmbientUsed() : (m_ambient_ == other.m_ambient_)) &&
                (!isDiffuseUsed() ? !other.isDiffuseUsed() : (m_diffuse_ == other.m_diffuse_)) &&
                (!isSpecularUsed() ? !other.isSpecularUsed() : (m_specular_ == other.m_specular_)) &&
                (!isShininessUsed() ? !other.isShininessUsed() : (m_shininess_ == other.m_shininess_)) &&
                (!isTextureUsed() ? !other.isTextureUsed() : (m_texture_ == other.m_texture_));
    }

    return true;
}

uint32_t Material::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_content_);
    if (isAmbientUsed())
        result = ::zserio::calcHashCode(result, m_ambient_);
    if (isDiffuseUsed())
        result = ::zserio::calcHashCode(result, m_diffuse_);
    if (isSpecularUsed())
        result = ::zserio::calcHashCode(result, m_specular_);
    if (isShininessUsed())
        result = ::zserio::calcHashCode(result, m_shininess_);
    if (isTextureUsed())
        result = ::zserio::calcHashCode(result, m_texture_);

    return result;
}

void Material::write(::zserio::BitStreamWriter& out) const
{
    m_content_.write(out);
    if (getContent().getHasAmbientAndDiffuseColor() == true)
    {
        out.writeVarUInt16(m_ambient_.value());
    }
    if (getContent().getHasAmbientAndDiffuseColor() == true)
    {
        out.writeVarUInt16(m_diffuse_.value());
    }
    if (getContent().getHasSpecularAndShininessColor() == true)
    {
        out.writeVarUInt16(m_specular_.value());
    }
    if (getContent().getHasSpecularAndShininessColor() == true)
    {
        out.writeBits(m_shininess_.value(), UINT8_C(8));
    }
    if (getContent().getUsesTextures() == true)
    {
        m_texture_.value().write(out);
    }
}

void Material::write(Material::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_content_.write(context.getContent(), out);
    if (getContent().getHasAmbientAndDiffuseColor() == true)
    {
        context.getAmbient().write<::zserio::VarIntNNArrayTraits<::nds::display::types::ColorId>>(out, m_ambient_.value());
    }
    if (getContent().getHasAmbientAndDiffuseColor() == true)
    {
        context.getDiffuse().write<::zserio::VarIntNNArrayTraits<::nds::display::types::ColorId>>(out, m_diffuse_.value());
    }
    if (getContent().getHasSpecularAndShininessColor() == true)
    {
        context.getSpecular().write<::zserio::VarIntNNArrayTraits<::nds::display::types::ColorId>>(out, m_specular_.value());
    }
    if (getContent().getHasSpecularAndShininessColor() == true)
    {
        context.getShininess().write<::zserio::StdIntArrayTraits<uint8_t>>(out, m_shininess_.value());
    }
    if (getContent().getUsesTextures() == true)
    {
        m_texture_.value().write(context.getTexture(), out);
    }
}

::nds::display::types::MaterialContent Material::readContent(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::display::types::MaterialContent(in, allocator);
}

::nds::display::types::MaterialContent Material::readContent(Material::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::display::types::MaterialContent(context.getContent(), in, allocator);
}
::zserio::InplaceOptionalHolder<::nds::display::types::ColorId> Material::readAmbient(::zserio::BitStreamReader& in)
{
    if (getContent().getHasAmbientAndDiffuseColor() == true)
    {
        return ::zserio::InplaceOptionalHolder<::nds::display::types::ColorId>(static_cast<::nds::display::types::ColorId>(in.readVarUInt16()));
    }

    return ::zserio::InplaceOptionalHolder<::nds::display::types::ColorId>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::display::types::ColorId> Material::readAmbient(Material::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (getContent().getHasAmbientAndDiffuseColor() == true)
    {
        return ::zserio::InplaceOptionalHolder<::nds::display::types::ColorId>(context.getAmbient().read<::zserio::VarIntNNArrayTraits<::nds::display::types::ColorId>>(in));
    }

    return ::zserio::InplaceOptionalHolder<::nds::display::types::ColorId>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::display::types::ColorId> Material::readDiffuse(::zserio::BitStreamReader& in)
{
    if (getContent().getHasAmbientAndDiffuseColor() == true)
    {
        return ::zserio::InplaceOptionalHolder<::nds::display::types::ColorId>(static_cast<::nds::display::types::ColorId>(in.readVarUInt16()));
    }

    return ::zserio::InplaceOptionalHolder<::nds::display::types::ColorId>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::display::types::ColorId> Material::readDiffuse(Material::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (getContent().getHasAmbientAndDiffuseColor() == true)
    {
        return ::zserio::InplaceOptionalHolder<::nds::display::types::ColorId>(context.getDiffuse().read<::zserio::VarIntNNArrayTraits<::nds::display::types::ColorId>>(in));
    }

    return ::zserio::InplaceOptionalHolder<::nds::display::types::ColorId>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::display::types::ColorId> Material::readSpecular(::zserio::BitStreamReader& in)
{
    if (getContent().getHasSpecularAndShininessColor() == true)
    {
        return ::zserio::InplaceOptionalHolder<::nds::display::types::ColorId>(static_cast<::nds::display::types::ColorId>(in.readVarUInt16()));
    }

    return ::zserio::InplaceOptionalHolder<::nds::display::types::ColorId>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::display::types::ColorId> Material::readSpecular(Material::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (getContent().getHasSpecularAndShininessColor() == true)
    {
        return ::zserio::InplaceOptionalHolder<::nds::display::types::ColorId>(context.getSpecular().read<::zserio::VarIntNNArrayTraits<::nds::display::types::ColorId>>(in));
    }

    return ::zserio::InplaceOptionalHolder<::nds::display::types::ColorId>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<uint8_t> Material::readShininess(::zserio::BitStreamReader& in)
{
    if (getContent().getHasSpecularAndShininessColor() == true)
    {
        return ::zserio::InplaceOptionalHolder<uint8_t>(static_cast<uint8_t>(in.readBits(UINT8_C(8))));
    }

    return ::zserio::InplaceOptionalHolder<uint8_t>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<uint8_t> Material::readShininess(Material::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (getContent().getHasSpecularAndShininessColor() == true)
    {
        return ::zserio::InplaceOptionalHolder<uint8_t>(context.getShininess().read<::zserio::StdIntArrayTraits<uint8_t>>(in));
    }

    return ::zserio::InplaceOptionalHolder<uint8_t>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::display::reference::types::TextureReference> Material::readTexture(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getContent().getUsesTextures() == true)
    {
        return ::zserio::InplaceOptionalHolder<::nds::display::reference::types::TextureReference>(::nds::display::reference::types::TextureReference(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::display::reference::types::TextureReference>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::display::reference::types::TextureReference> Material::readTexture(Material::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getContent().getUsesTextures() == true)
    {
        return ::zserio::InplaceOptionalHolder<::nds::display::reference::types::TextureReference>(::nds::display::reference::types::TextureReference(context.getTexture(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::display::reference::types::TextureReference>(::zserio::NullOpt);
}

} // namespace types
} // namespace display
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/display/types/MaterialContent.h>

namespace nds
{
namespace display
{
namespace types
{

MaterialContent::MaterialContent(const allocator_type&) noexcept :
        m_hasAmbientAndDiffuseColor_(bool()),
        m_hasSpecularAndShininessColor_(bool()),
        m_isTransparent_(bool()),
        m_isLightEmitting_(bool()),
        m_usesTextures_(bool()),
        m_textureCoordUsageType_(::zserio::NullOpt)
{
}

MaterialContent::MaterialContent(::zserio::BitStreamReader& in, const allocator_type&) :
        m_hasAmbientAndDiffuseColor_(readHasAmbientAndDiffuseColor(in)),
        m_hasSpecularAndShininessColor_(readHasSpecularAndShininessColor(in)),
        m_isTransparent_(readIsTransparent(in)),
        m_isLightEmitting_(readIsLightEmitting(in)),
        m_usesTextures_(readUsesTextures(in)),
        m_textureCoordUsageType_(readTextureCoordUsageType(in))
{
}

MaterialContent::MaterialContent(MaterialContent::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type&) :
        m_hasAmbientAndDiffuseColor_(readHasAmbientAndDiffuseColor(in)),
        m_hasSpecularAndShininessColor_(readHasSpecularAndShininessColor(in)),
        m_isTransparent_(readIsTransparent(in)),
        m_isLightEmitting_(readIsLightEmitting(in)),
        m_usesTextures_(readUsesTextures(in)),
        m_textureCoordUsageType_(readTextureCoordUsageType(context, in))
{
}

MaterialContent::MaterialContent(::zserio::PropagateAllocatorT,
        const MaterialContent& other, const allocator_type& allocator) :
        m_hasAmbientAndDiffuseColor_(::zserio::allocatorPropagatingCopy(other.m_hasAmbientAndDiffuseColor_, allocator)),
        m_hasSpecularAndShininessColor_(::zserio::allocatorPropagatingCopy(other.m_hasSpecularAndShininessColor_, allocator)),
        m_isTransparent_(::zserio::allocatorPropagatingCopy(other.m_isTransparent_, allocator)),
        m_isLightEmitting_(::zserio::allocatorPropagatingCopy(other.m_isLightEmitting_, allocator)),
        m_usesTextures_(::zserio::allocatorPropagatingCopy(other.m_usesTextures_, allocator)),
        m_textureCoordUsageType_(::zserio::allocatorPropagatingCopy(other.m_textureCoordUsageType_, allocator))
{
}

bool MaterialContent::getHasAmbientAndDiffuseColor() const
{
    return m_hasAmbientAndDiffuseColor_;
}

void MaterialContent::setHasAmbientAndDiffuseColor(bool hasAmbientAndDiffuseColor_)
{
    m_hasAmbientAndDiffuseColor_ = hasAmbientAndDiffuseColor_;
}

bool MaterialContent::getHasSpecularAndShininessColor() const
{
    return m_hasSpecularAndShininessColor_;
}

void MaterialContent::setHasSpecularAndShininessColor(bool hasSpecularAndShininessColor_)
{
    m_hasSpecularAndShininessColor_ = hasSpecularAndShininessColor_;
}

bool MaterialContent::getIsTransparent() const
{
    return m_isTransparent_;
}

void MaterialContent::setIsTransparent(bool isTransparent_)
{
    m_isTransparent_ = isTransparent_;
}

bool MaterialContent::getIsLightEmitting() const
{
    return m_isLightEmitting_;
}

void MaterialContent::setIsLightEmitting(bool isLightEmitting_)
{
    m_isLightEmitting_ = isLightEmitting_;
}

bool MaterialContent::getUsesTextures() const
{
    return m_usesTextures_;
}

void MaterialContent::setUsesTextures(bool usesTextures_)
{
    m_usesTextures_ = usesTextures_;
}

::nds::display::types::TextureCoordsUsageType MaterialContent::getTextureCoordUsageType() const
{
    return m_textureCoordUsageType_.value();
}

void MaterialContent::setTextureCoordUsageType(::nds::display::types::TextureCoordsUsageType textureCoordUsageType_)
{
    m_textureCoordUsageType_ = textureCoordUsageType_;
}

bool MaterialContent::isTextureCoordUsageTypeUsed() const
{
    return (getUsesTextures());
}

bool MaterialContent::isTextureCoordUsageTypeSet() const
{
    return m_textureCoordUsageType_.hasValue();
}

void MaterialContent::resetTextureCoordUsageType()
{
    m_textureCoordUsageType_.reset();
}

void MaterialContent::initPackingContext(MaterialContent::ZserioPackingContext& context) const
{
    if (getUsesTextures())
    {
        ::zserio::initPackingContext(context.getTextureCoordUsageType(), m_textureCoordUsageType_.value());
    }
}

size_t MaterialContent::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    if (getUsesTextures())
    {
        endBitPosition += ::zserio::bitSizeOf(m_textureCoordUsageType_.value());
    }

    return endBitPosition - bitPosition;
}

size_t MaterialContent::bitSizeOf(MaterialContent::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    if (getUsesTextures())
    {
        endBitPosition += ::zserio::bitSizeOf(context.getTextureCoordUsageType(), m_textureCoordUsageType_.value());
    }

    return endBitPosition - bitPosition;
}

size_t MaterialContent::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    if (getUsesTextures())
    {
        endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_textureCoordUsageType_.value());
    }

    return endBitPosition;
}

size_t MaterialContent::initializeOffsets(MaterialContent::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);
    if (getUsesTextures())
    {
        endBitPosition = ::zserio::initializeOffsets(context.getTextureCoordUsageType(), endBitPosition,
        m_textureCoordUsageType_.value());
    }

    return endBitPosition;
}

bool MaterialContent::operator==(const MaterialContent& other) const
{
    if (this != &other)
    {
        return
                (m_hasAmbientAndDiffuseColor_ == other.m_hasAmbientAndDiffuseColor_) &&
                (m_hasSpecularAndShininessColor_ == other.m_hasSpecularAndShininessColor_) &&
                (m_isTransparent_ == other.m_isTransparent_) &&
                (m_isLightEmitting_ == other.m_isLightEmitting_) &&
                (m_usesTextures_ == other.m_usesTextures_) &&
                (!isTextureCoordUsageTypeUsed() ? !other.isTextureCoordUsageTypeUsed() : (m_textureCoordUsageType_ == other.m_textureCoordUsageType_));
    }

    return true;
}

uint32_t MaterialContent::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_hasAmbientAndDiffuseColor_);
    result = ::zserio::calcHashCode(result, m_hasSpecularAndShininessColor_);
    result = ::zserio::calcHashCode(result, m_isTransparent_);
    result = ::zserio::calcHashCode(result, m_isLightEmitting_);
    result = ::zserio::calcHashCode(result, m_usesTextures_);
    if (isTextureCoordUsageTypeUsed())
        result = ::zserio::calcHashCode(result, m_textureCoordUsageType_);

    return result;
}

void MaterialContent::write(::zserio::BitStreamWriter& out) const
{
    out.writeBool(m_hasAmbientAndDiffuseColor_);
    out.writeBool(m_hasSpecularAndShininessColor_);
    out.writeBool(m_isTransparent_);
    out.writeBool(m_isLightEmitting_);
    out.writeBool(m_usesTextures_);
    if (getUsesTextures())
    {
        ::zserio::write(out, m_textureCoordUsageType_.value());
    }
}

void MaterialContent::write(MaterialContent::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    out.writeBool(m_hasAmbientAndDiffuseColor_);
    out.writeBool(m_hasSpecularAndShininessColor_);
    out.writeBool(m_isTransparent_);
    out.writeBool(m_isLightEmitting_);
    out.writeBool(m_usesTextures_);
    if (getUsesTextures())
    {
        ::zserio::write(context.getTextureCoordUsageType(), out, m_textureCoordUsageType_.value());
    }
}

bool MaterialContent::readHasAmbientAndDiffuseColor(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
bool MaterialContent::readHasSpecularAndShininessColor(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
bool MaterialContent::readIsTransparent(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
bool MaterialContent::readIsLightEmitting(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
bool MaterialContent::readUsesTextures(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
::zserio::InplaceOptionalHolder<::nds::display::types::TextureCoordsUsageType> MaterialContent::readTextureCoordUsageType(::zserio::BitStreamReader& in)
{
    if (getUsesTextures())
    {
        return ::zserio::InplaceOptionalHolder<::nds::display::types::TextureCoordsUsageType>(::zserio::read<::nds::display::types::TextureCoordsUsageType>(in));
    }

    return ::zserio::InplaceOptionalHolder<::nds::display::types::TextureCoordsUsageType>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::display::types::TextureCoordsUsageType> MaterialContent::readTextureCoordUsageType(MaterialContent::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (getUsesTextures())
    {
        return ::zserio::InplaceOptionalHolder<::nds::display::types::TextureCoordsUsageType>(::zserio::read<::nds::display::types::TextureCoordsUsageType>(context.getTextureCoordUsageType(), in));
    }

    return ::zserio::InplaceOptionalHolder<::nds::display::types::TextureCoordsUsageType>(::zserio::NullOpt);
}

} // namespace types
} // namespace display
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/display/types/TextureCoords.h>

namespace nds
{
namespace display
{
namespace types
{

TextureCoords::TextureCoords(const allocator_type&) noexcept :
        m_u_(float()),
        m_v_(float())
{
}

TextureCoords::TextureCoords(::zserio::BitStreamReader& in, const allocator_type&) :
        m_u_(readU(in)),
        m_v_(readV(in))
{
}

TextureCoords::TextureCoords(::zserio::PropagateAllocatorT,
        const TextureCoords& other, const allocator_type& allocator) :
        m_u_(::zserio::allocatorPropagatingCopy(other.m_u_, allocator)),
        m_v_(::zserio::allocatorPropagatingCopy(other.m_v_, allocator))
{
}

float TextureCoords::getU() const
{
    return m_u_;
}

void TextureCoords::setU(float u_)
{
    m_u_ = u_;
}

float TextureCoords::getV() const
{
    return m_v_;
}

void TextureCoords::setV(float v_)
{
    m_v_ = v_;
}

size_t TextureCoords::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(16);
    endBitPosition += UINT8_C(16);

    return endBitPosition - bitPosition;
}

size_t TextureCoords::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(16);
    endBitPosition += UINT8_C(16);

    return endBitPosition;
}

bool TextureCoords::operator==(const TextureCoords& other) const
{
    if (this != &other)
    {
        return
                (m_u_ == other.m_u_) &&
                (m_v_ == other.m_v_);
    }

    return true;
}

uint32_t TextureCoords::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_u_);
    result = ::zserio::calcHashCode(result, m_v_);

    return result;
}

void TextureCoords::write(::zserio::BitStreamWriter& out) const
{
    out.writeFloat16(m_u_);
    out.writeFloat16(m_v_);
}

float TextureCoords::readU(::zserio::BitStreamReader& in)
{
    return static_cast<float>(in.readFloat16());
}
float TextureCoords::readV(::zserio::BitStreamReader& in)
{
    return static_cast<float>(in.readFloat16());
}

} // namespace types
} // namespace display
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ConstraintException.h>

#include <nds/display/types/Texture.h>

namespace nds
{
namespace display
{
namespace types
{

Texture::Texture(const allocator_type& allocator) noexcept :
        m_textureId_(::nds::display::reference::types::TextureId()),
        m_textureRenderingUsageType_(::nds::display::types::TextureRenderingUsageType()),
        m_format_(::nds::display::types::TextureFormat()),
        m_doubleSided_(bool()),
        m_textureConditionUsageType_(allocator),
        m_textureData_(allocator)
{
}

Texture::Texture(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_textureId_(readTextureId(in)),
        m_textureRenderingUsageType_(readTextureRenderingUsageType(in)),
        m_format_(readFormat(in)),
        m_doubleSided_(readDoubleSided(in)),
        m_textureConditionUsageType_(readTextureConditionUsageType(in, allocator)),
        m_textureData_(readTextureData(in, allocator))
{
}

Texture::Texture(Texture::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_textureId_(readTextureId(context, in)),
        m_textureRenderingUsageType_(readTextureRenderingUsageType(context, in)),
        m_format_(readFormat(context, in)),
        m_doubleSided_(readDoubleSided(in)),
        m_textureConditionUsageType_(readTextureConditionUsageType(context, in, allocator)),
        m_textureData_(readTextureData(context, in, allocator))
{
}

Texture::Texture(::zserio::PropagateAllocatorT,
        const Texture& other, const allocator_type& allocator) :
        m_textureId_(::zserio::allocatorPropagatingCopy(other.m_textureId_, allocator)),
        m_textureRenderingUsageType_(::zserio::allocatorPropagatingCopy(other.m_textureRenderingUsageType_, allocator)),
        m_format_(::zserio::allocatorPropagatingCopy(other.m_format_, allocator)),
        m_doubleSided_(::zserio::allocatorPropagatingCopy(other.m_doubleSided_, allocator)),
        m_textureConditionUsageType_(::zserio::allocatorPropagatingCopy(other.m_textureConditionUsageType_, allocator)),
        m_textureData_(::zserio::allocatorPropagatingCopy(other.m_textureData_, allocator))
{
}

::nds::display::reference::types::TextureId Texture::getTextureId() const
{
    return m_textureId_;
}

void Texture::setTextureId(::nds::display::reference::types::TextureId textureId_)
{
    m_textureId_ = textureId_;
}

::nds::display::types::TextureRenderingUsageType Texture::getTextureRenderingUsageType() const
{
    return m_textureRenderingUsageType_;
}

void Texture::setTextureRenderingUsageType(::nds::display::types::TextureRenderingUsageType textureRenderingUsageType_)
{
    m_textureRenderingUsageType_ = textureRenderingUsageType_;
}

::nds::display::types::TextureFormat Texture::getFormat() const
{
    return m_format_;
}

void Texture::setFormat(::nds::display::types::TextureFormat format_)
{
    m_format_ = format_;
}

bool Texture::getDoubleSided() const
{
    return m_doubleSided_;
}

void Texture::setDoubleSided(bool doubleSided_)
{
    m_doubleSided_ = doubleSided_;
}

::zserio::vector<::nds::display::types::TextureConditionUsageType>& Texture::getTextureConditionUsageType()
{
    return m_textureConditionUsageType_.getRawArray();
}

const ::zserio::vector<::nds::display::types::TextureConditionUsageType>& Texture::getTextureConditionUsageType() const
{
    return m_textureConditionUsageType_.getRawArray();
}

void Texture::setTextureConditionUsageType(const ::zserio::vector<::nds::display::types::TextureConditionUsageType>& textureConditionUsageType_)
{
    m_textureConditionUsageType_ = ZserioArrayType_textureConditionUsageType(textureConditionUsageType_);
}

void Texture::setTextureConditionUsageType(::zserio::vector<::nds::display::types::TextureConditionUsageType>&& textureConditionUsageType_)
{
    m_textureConditionUsageType_ = ZserioArrayType_textureConditionUsageType(std::move(textureConditionUsageType_));
}

::zserio::vector<::nds::display::types::TextureData>& Texture::getTextureData()
{
    return m_textureData_.getRawArray();
}

const ::zserio::vector<::nds::display::types::TextureData>& Texture::getTextureData() const
{
    return m_textureData_.getRawArray();
}

void Texture::setTextureData(const ::zserio::vector<::nds::display::types::TextureData>& textureData_)
{
    m_textureData_ = ZserioArrayType_textureData(textureData_);
}

void Texture::setTextureData(::zserio::vector<::nds::display::types::TextureData>&& textureData_)
{
    m_textureData_ = ZserioArrayType_textureData(std::move(textureData_));
}

void Texture::initPackingContext(Texture::ZserioPackingContext& context) const
{
    context.getTextureId().init<::zserio::VarIntNNArrayTraits<::nds::display::reference::types::TextureId>>(m_textureId_);
    ::zserio::initPackingContext(context.getTextureRenderingUsageType(), m_textureRenderingUsageType_);
    ::zserio::initPackingContext(context.getFormat(), m_format_);
}

size_t Texture::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_textureId_);
    endBitPosition += ::zserio::bitSizeOf(m_textureRenderingUsageType_);
    endBitPosition += ::zserio::bitSizeOf(m_format_);
    endBitPosition += UINT8_C(1);
    endBitPosition += m_textureConditionUsageType_.bitSizeOf(endBitPosition);
    endBitPosition += m_textureData_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t Texture::bitSizeOf(Texture::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getTextureId().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::display::reference::types::TextureId>>(m_textureId_);
    endBitPosition += ::zserio::bitSizeOf(context.getTextureRenderingUsageType(), m_textureRenderingUsageType_);
    endBitPosition += ::zserio::bitSizeOf(context.getFormat(), m_format_);
    endBitPosition += UINT8_C(1);
    endBitPosition += m_textureConditionUsageType_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_textureData_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t Texture::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_textureId_);
    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_textureRenderingUsageType_);
    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_format_);
    endBitPosition += UINT8_C(1);
    endBitPosition = m_textureConditionUsageType_.initializeOffsets(endBitPosition);
    endBitPosition = m_textureData_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t Texture::initializeOffsets(Texture::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getTextureId().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::display::reference::types::TextureId>>(m_textureId_);
    endBitPosition = ::zserio::initializeOffsets(context.getTextureRenderingUsageType(), endBitPosition,
        m_textureRenderingUsageType_);
    endBitPosition = ::zserio::initializeOffsets(context.getFormat(), endBitPosition,
        m_format_);
    endBitPosition += UINT8_C(1);
    endBitPosition = m_textureConditionUsageType_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_textureData_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool Texture::operator==(const Texture& other) const
{
    if (this != &other)
    {
        return
                (m_textureId_ == other.m_textureId_) &&
                (m_textureRenderingUsageType_ == other.m_textureRenderingUsageType_) &&
                (m_format_ == other.m_format_) &&
                (m_doubleSided_ == other.m_doubleSided_) &&
                (m_textureConditionUsageType_ == other.m_textureConditionUsageType_) &&
                (m_textureData_ == other.m_textureData_);
    }

    return true;
}

uint32_t Texture::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_textureId_);
    result = ::zserio::calcHashCode(result, m_textureRenderingUsageType_);
    result = ::zserio::calcHashCode(result, m_format_);
    result = ::zserio::calcHashCode(result, m_doubleSided_);
    result = ::zserio::calcHashCode(result, m_textureConditionUsageType_);
    result = ::zserio::calcHashCode(result, m_textureData_);

    return result;
}

void Texture::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt32(m_textureId_);

    ::zserio::write(out, m_textureRenderingUsageType_);

    ::zserio::write(out, m_format_);

    out.writeBool(m_doubleSided_);

    m_textureConditionUsageType_.write(out);

    // check constraint
    if (!(getTextureData().size() == getTextureConditionUsageType().size()))
        throw ::zserio::ConstraintException("Write: Constraint violated at Texture.textureData!");
    m_textureData_.write(*this, out);
}

void Texture::write(Texture::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getTextureId().write<::zserio::VarIntNNArrayTraits<::nds::display::reference::types::TextureId>>(out, m_textureId_);

    ::zserio::write(context.getTextureRenderingUsageType(), out, m_textureRenderingUsageType_);

    ::zserio::write(context.getFormat(), out, m_format_);

    out.writeBool(m_doubleSided_);

    m_textureConditionUsageType_.writePacked(out);

    // check constraint
    if (!(getTextureData().size() == getTextureConditionUsageType().size()))
        throw ::zserio::ConstraintException("Write: Constraint violated at Texture.textureData!");
    m_textureData_.writePacked(*this, out);
}

void Texture::ZserioElementFactory_textureData::create(Texture&        ,
        ::zserio::vector<::nds::display::types::TextureData>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void Texture::ZserioElementFactory_textureData::create(Texture&        ,
        ::zserio::vector<::nds::display::types::TextureData>& array,
        ::nds::display::types::TextureData::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::display::reference::types::TextureId Texture::readTextureId(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::display::reference::types::TextureId>(in.readVarUInt32());
}

::nds::display::reference::types::TextureId Texture::readTextureId(Texture::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getTextureId().read<::zserio::VarIntNNArrayTraits<::nds::display::reference::types::TextureId>>(in);
}
::nds::display::types::TextureRenderingUsageType Texture::readTextureRenderingUsageType(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::display::types::TextureRenderingUsageType>(in);
}

::nds::display::types::TextureRenderingUsageType Texture::readTextureRenderingUsageType(Texture::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::display::types::TextureRenderingUsageType>(context.getTextureRenderingUsageType(), in);
}
::nds::display::types::TextureFormat Texture::readFormat(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::display::types::TextureFormat>(in);
}

::nds::display::types::TextureFormat Texture::readFormat(Texture::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::display::types::TextureFormat>(context.getFormat(), in);
}
bool Texture::readDoubleSided(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
Texture::ZserioArrayType_textureConditionUsageType Texture::readTextureConditionUsageType(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_textureConditionUsageType readField(allocator);
    readField.read(in);

    return readField;
}

Texture::ZserioArrayType_textureConditionUsageType Texture::readTextureConditionUsageType(Texture::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_textureConditionUsageType readField(allocator);
    readField.readPacked(in);

    return readField;
}
Texture::ZserioArrayType_textureData Texture::readTextureData(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_textureData readField(allocator);
    readField.read(*this, in);
    // check constraint
    if (!(readField.getRawArray().size() == getTextureConditionUsageType().size()))
        throw ::zserio::ConstraintException("Read: Constraint violated at Texture.textureData!");

    return readField;
}

Texture::ZserioArrayType_textureData Texture::readTextureData(Texture::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_textureData readField(allocator);
    readField.readPacked(*this, in);
    // check constraint
    if (!(readField.getRawArray().size() == getTextureConditionUsageType().size()))
        throw ::zserio::ConstraintException("Read: Constraint violated at Texture.textureData!");

    return readField;
}

} // namespace types
} // namespace display
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/display/types/TextureData.h>

namespace nds
{
namespace display
{
namespace types
{

TextureData::TextureData(const allocator_type& allocator) noexcept :
        m_textureData_(allocator),
        m_TextureSectionArray_(allocator)
{
}

TextureData::TextureData(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_textureData_(readTextureData(in, allocator)),
        m_TextureSectionArray_(readTextureSectionArray(in, allocator))
{
}

TextureData::TextureData(TextureData::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_textureData_(readTextureData(in, allocator)),
        m_TextureSectionArray_(readTextureSectionArray(context, in, allocator))
{
}

TextureData::TextureData(::zserio::PropagateAllocatorT,
        const TextureData& other, const allocator_type& allocator) :
        m_textureData_(::zserio::allocatorPropagatingCopy(other.m_textureData_, allocator)),
        m_TextureSectionArray_(::zserio::allocatorPropagatingCopy(other.m_TextureSectionArray_, allocator))
{
}

::zserio::BitBuffer& TextureData::getTextureData()
{
    return m_textureData_;
}

const ::zserio::BitBuffer& TextureData::getTextureData() const
{
    return m_textureData_;
}

void TextureData::setTextureData(const ::zserio::BitBuffer& textureData_)
{
    m_textureData_ = textureData_;
}

void TextureData::setTextureData(::zserio::BitBuffer&& textureData_)
{
    m_textureData_ = ::std::move(textureData_);
}

::nds::display::types::TextureSectionArray& TextureData::getTextureSectionArray()
{
    return m_TextureSectionArray_;
}

const ::nds::display::types::TextureSectionArray& TextureData::getTextureSectionArray() const
{
    return m_TextureSectionArray_;
}

void TextureData::setTextureSectionArray(const ::nds::display::types::TextureSectionArray& TextureSectionArray_)
{
    m_TextureSectionArray_ = TextureSectionArray_;
}

void TextureData::setTextureSectionArray(::nds::display::types::TextureSectionArray&& TextureSectionArray_)
{
    m_TextureSectionArray_ = ::std::move(TextureSectionArray_);
}

void TextureData::initPackingContext(TextureData::ZserioPackingContext& context) const
{
    m_TextureSectionArray_.initPackingContext(context.getTextureSectionArray());
}

size_t TextureData::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfBitBuffer(m_textureData_);
    endBitPosition += m_TextureSectionArray_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TextureData::bitSizeOf(TextureData::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfBitBuffer(m_textureData_);
    endBitPosition += m_TextureSectionArray_.bitSizeOf(context.getTextureSectionArray(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TextureData::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfBitBuffer(m_textureData_);
    endBitPosition = m_TextureSectionArray_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t TextureData::initializeOffsets(TextureData::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfBitBuffer(m_textureData_);
    endBitPosition = m_TextureSectionArray_.initializeOffsets(context.getTextureSectionArray(), endBitPosition);

    return endBitPosition;
}

bool TextureData::operator==(const TextureData& other) const
{
    if (this != &other)
    {
        return
                (m_textureData_ == other.m_textureData_) &&
                (m_TextureSectionArray_ == other.m_TextureSectionArray_);
    }

    return true;
}

uint32_t TextureData::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_textureData_);
    result = ::zserio::calcHashCode(result, m_TextureSectionArray_);

    return result;
}

void TextureData::write(::zserio::BitStreamWriter& out) const
{
    out.writeBitBuffer(m_textureData_);
    m_TextureSectionArray_.write(out);
}

void TextureData::write(TextureData::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    out.writeBitBuffer(m_textureData_);
    m_TextureSectionArray_.write(context.getTextureSectionArray(), out);
}

::zserio::BitBuffer TextureData::readTextureData(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return static_cast<::zserio::BitBuffer>(in.readBitBuffer(allocator));
}
::nds::display::types::TextureSectionArray TextureData::readTextureSectionArray(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::display::types::TextureSectionArray(in, allocator);
}

::nds::display::types::TextureSectionArray TextureData::readTextureSectionArray(TextureData::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::display::types::TextureSectionArray(context.getTextureSectionArray(), in, allocator);
}

} // namespace types
} // namespace display
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/display/types/TextureSectionArray.h>

namespace nds
{
namespace display
{
namespace types
{

TextureSectionArray::TextureSectionArray(const allocator_type& allocator) noexcept :
        m_numSections_(::nds::display::reference::types::TextureSectionNumber()),
        m_sections_(allocator)
{
}

TextureSectionArray::TextureSectionArray(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numSections_(readNumSections(in)),
        m_sections_(readSections(in, allocator))
{
}

TextureSectionArray::TextureSectionArray(TextureSectionArray::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numSections_(readNumSections(context, in)),
        m_sections_(readSections(context, in, allocator))
{
}

TextureSectionArray::TextureSectionArray(::zserio::PropagateAllocatorT,
        const TextureSectionArray& other, const allocator_type& allocator) :
        m_numSections_(::zserio::allocatorPropagatingCopy(other.m_numSections_, allocator)),
        m_sections_(::zserio::allocatorPropagatingCopy(other.m_sections_, allocator))
{
}

::nds::display::reference::types::TextureSectionNumber TextureSectionArray::getNumSections() const
{
    return m_numSections_;
}

void TextureSectionArray::setNumSections(::nds::display::reference::types::TextureSectionNumber numSections_)
{
    m_numSections_ = numSections_;
}

::zserio::vector<::nds::display::types::TextureSection>& TextureSectionArray::getSections()
{
    return m_sections_.getRawArray();
}

const ::zserio::vector<::nds::display::types::TextureSection>& TextureSectionArray::getSections() const
{
    return m_sections_.getRawArray();
}

void TextureSectionArray::setSections(const ::zserio::vector<::nds::display::types::TextureSection>& sections_)
{
    m_sections_ = ZserioArrayType_sections(sections_);
}

void TextureSectionArray::setSections(::zserio::vector<::nds::display::types::TextureSection>&& sections_)
{
    m_sections_ = ZserioArrayType_sections(std::move(sections_));
}

void TextureSectionArray::initPackingContext(TextureSectionArray::ZserioPackingContext& context) const
{
    context.getNumSections().init<::zserio::VarIntNNArrayTraits<::nds::display::reference::types::TextureSectionNumber>>(m_numSections_);
}

size_t TextureSectionArray::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_numSections_);
    endBitPosition += m_sections_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TextureSectionArray::bitSizeOf(TextureSectionArray::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumSections().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::display::reference::types::TextureSectionNumber>>(m_numSections_);
    endBitPosition += m_sections_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TextureSectionArray::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_numSections_);
    endBitPosition = m_sections_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t TextureSectionArray::initializeOffsets(TextureSectionArray::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumSections().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::display::reference::types::TextureSectionNumber>>(m_numSections_);
    endBitPosition = m_sections_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool TextureSectionArray::operator==(const TextureSectionArray& other) const
{
    if (this != &other)
    {
        return
                (m_numSections_ == other.m_numSections_) &&
                (m_sections_ == other.m_sections_);
    }

    return true;
}

uint32_t TextureSectionArray::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_numSections_);
    result = ::zserio::calcHashCode(result, m_sections_);

    return result;
}

void TextureSectionArray::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt16(m_numSections_);

    // check array length
    if (m_sections_.getRawArray().size() != static_cast<size_t>(getNumSections()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TextureSectionArray.sections: ") <<
                m_sections_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumSections()) << "!";
    }
    m_sections_.write(*this, out);
}

void TextureSectionArray::write(TextureSectionArray::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumSections().write<::zserio::VarIntNNArrayTraits<::nds::display::reference::types::TextureSectionNumber>>(out, m_numSections_);

    // check array length
    if (m_sections_.getRawArray().size() != static_cast<size_t>(getNumSections()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field TextureSectionArray.sections: ") <<
                m_sections_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumSections()) << "!";
    }
    m_sections_.writePacked(*this, out);
}

void TextureSectionArray::ZserioElementFactory_sections::create(TextureSectionArray&        ,
        ::zserio::vector<::nds::display::types::TextureSection>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void TextureSectionArray::ZserioElementFactory_sections::create(TextureSectionArray&        ,
        ::zserio::vector<::nds::display::types::TextureSection>& array,
        ::nds::display::types::TextureSection::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::display::reference::types::TextureSectionNumber TextureSectionArray::readNumSections(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::display::reference::types::TextureSectionNumber>(in.readVarUInt16());
}

::nds::display::reference::types::TextureSectionNumber TextureSectionArray::readNumSections(TextureSectionArray::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumSections().read<::zserio::VarIntNNArrayTraits<::nds::display::reference::types::TextureSectionNumber>>(in);
}
TextureSectionArray::ZserioArrayType_sections TextureSectionArray::readSections(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_sections readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getNumSections()));

    return readField;
}

TextureSectionArray::ZserioArrayType_sections TextureSectionArray::readSections(TextureSectionArray::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_sections readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumSections()));

    return readField;
}

} // namespace types
} // namespace display
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/display/types/TextureSection.h>

namespace nds
{
namespace display
{
namespace types
{

TextureSection::TextureSection(const allocator_type&) noexcept :
        m_top_(uint16_t()),
        m_left_(uint16_t()),
        m_height_(uint16_t()),
        m_width_(uint16_t())
{
}

TextureSection::TextureSection(::zserio::BitStreamReader& in, const allocator_type&) :
        m_top_(readTop(in)),
        m_left_(readLeft(in)),
        m_height_(readHeight(in)),
        m_width_(readWidth(in))
{
}

TextureSection::TextureSection(TextureSection::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type&) :
        m_top_(readTop(context, in)),
        m_left_(readLeft(context, in)),
        m_height_(readHeight(context, in)),
        m_width_(readWidth(context, in))
{
}

TextureSection::TextureSection(::zserio::PropagateAllocatorT,
        const TextureSection& other, const allocator_type& allocator) :
        m_top_(::zserio::allocatorPropagatingCopy(other.m_top_, allocator)),
        m_left_(::zserio::allocatorPropagatingCopy(other.m_left_, allocator)),
        m_height_(::zserio::allocatorPropagatingCopy(other.m_height_, allocator)),
        m_width_(::zserio::allocatorPropagatingCopy(other.m_width_, allocator))
{
}

uint16_t TextureSection::getTop() const
{
    return m_top_;
}

void TextureSection::setTop(uint16_t top_)
{
    m_top_ = top_;
}

uint16_t TextureSection::getLeft() const
{
    return m_left_;
}

void TextureSection::setLeft(uint16_t left_)
{
    m_left_ = left_;
}

uint16_t TextureSection::getHeight() const
{
    return m_height_;
}

void TextureSection::setHeight(uint16_t height_)
{
    m_height_ = height_;
}

uint16_t TextureSection::getWidth() const
{
    return m_width_;
}

void TextureSection::setWidth(uint16_t width_)
{
    m_width_ = width_;
}

void TextureSection::initPackingContext(TextureSection::ZserioPackingContext& context) const
{
    context.getTop().init<::zserio::StdIntArrayTraits<uint16_t>>(m_top_);
    context.getLeft().init<::zserio::StdIntArrayTraits<uint16_t>>(m_left_);
    context.getHeight().init<::zserio::StdIntArrayTraits<uint16_t>>(m_height_);
    context.getWidth().init<::zserio::StdIntArrayTraits<uint16_t>>(m_width_);
}

size_t TextureSection::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(16);
    endBitPosition += UINT8_C(16);
    endBitPosition += UINT8_C(16);
    endBitPosition += UINT8_C(16);

    return endBitPosition - bitPosition;
}

size_t TextureSection::bitSizeOf(TextureSection::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getTop().bitSizeOf<::zserio::StdIntArrayTraits<uint16_t>>(m_top_);
    endBitPosition += context.getLeft().bitSizeOf<::zserio::StdIntArrayTraits<uint16_t>>(m_left_);
    endBitPosition += context.getHeight().bitSizeOf<::zserio::StdIntArrayTraits<uint16_t>>(m_height_);
    endBitPosition += context.getWidth().bitSizeOf<::zserio::StdIntArrayTraits<uint16_t>>(m_width_);

    return endBitPosition - bitPosition;
}

size_t TextureSection::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(16);
    endBitPosition += UINT8_C(16);
    endBitPosition += UINT8_C(16);
    endBitPosition += UINT8_C(16);

    return endBitPosition;
}

size_t TextureSection::initializeOffsets(TextureSection::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getTop().bitSizeOf<::zserio::StdIntArrayTraits<uint16_t>>(m_top_);
    endBitPosition += context.getLeft().bitSizeOf<::zserio::StdIntArrayTraits<uint16_t>>(m_left_);
    endBitPosition += context.getHeight().bitSizeOf<::zserio::StdIntArrayTraits<uint16_t>>(m_height_);
    endBitPosition += context.getWidth().bitSizeOf<::zserio::StdIntArrayTraits<uint16_t>>(m_width_);

    return endBitPosition;
}

bool TextureSection::operator==(const TextureSection& other) const
{
    if (this != &other)
    {
        return
                (m_top_ == other.m_top_) &&
                (m_left_ == other.m_left_) &&
                (m_height_ == other.m_height_) &&
                (m_width_ == other.m_width_);
    }

    return true;
}

uint32_t TextureSection::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_top_);
    result = ::zserio::calcHashCode(result, m_left_);
    result = ::zserio::calcHashCode(result, m_height_);
    result = ::zserio::calcHashCode(result, m_width_);

    return result;
}

void TextureSection::write(::zserio::BitStreamWriter& out) const
{
    out.writeBits(m_top_, UINT8_C(16));
    out.writeBits(m_left_, UINT8_C(16));
    out.writeBits(m_height_, UINT8_C(16));
    out.writeBits(m_width_, UINT8_C(16));
}

void TextureSection::write(TextureSection::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getTop().write<::zserio::StdIntArrayTraits<uint16_t>>(out, m_top_);
    context.getLeft().write<::zserio::StdIntArrayTraits<uint16_t>>(out, m_left_);
    context.getHeight().write<::zserio::StdIntArrayTraits<uint16_t>>(out, m_height_);
    context.getWidth().write<::zserio::StdIntArrayTraits<uint16_t>>(out, m_width_);
}

uint16_t TextureSection::readTop(::zserio::BitStreamReader& in)
{
    return static_cast<uint16_t>(in.readBits(UINT8_C(16)));
}

uint16_t TextureSection::readTop(TextureSection::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getTop().read<::zserio::StdIntArrayTraits<uint16_t>>(in);
}
uint16_t TextureSection::readLeft(::zserio::BitStreamReader& in)
{
    return static_cast<uint16_t>(in.readBits(UINT8_C(16)));
}

uint16_t TextureSection::readLeft(TextureSection::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getLeft().read<::zserio::StdIntArrayTraits<uint16_t>>(in);
}
uint16_t TextureSection::readHeight(::zserio::BitStreamReader& in)
{
    return static_cast<uint16_t>(in.readBits(UINT8_C(16)));
}

uint16_t TextureSection::readHeight(TextureSection::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getHeight().read<::zserio::StdIntArrayTraits<uint16_t>>(in);
}
uint16_t TextureSection::readWidth(::zserio::BitStreamReader& in)
{
    return static_cast<uint16_t>(in.readBits(UINT8_C(16)));
}

uint16_t TextureSection::readWidth(TextureSection::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getWidth().read<::zserio::StdIntArrayTraits<uint16_t>>(in);
}

} // namespace types
} // namespace display
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/display/types/Style3DColor.h>

namespace nds
{
namespace display
{
namespace types
{

Style3DColor::Style3DColor(const allocator_type& allocator) noexcept :
        m_colorId_(::nds::display::types::ColorId()),
        m_colorRgba_(allocator)
{
}

Style3DColor::Style3DColor(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_colorId_(readColorId(in)),
        m_colorRgba_(readColorRgba(in, allocator))
{
}

Style3DColor::Style3DColor(Style3DColor::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_colorId_(readColorId(context, in)),
        m_colorRgba_(readColorRgba(context, in, allocator))
{
}

Style3DColor::Style3DColor(::zserio::PropagateAllocatorT,
        const Style3DColor& other, const allocator_type& allocator) :
        m_colorId_(::zserio::allocatorPropagatingCopy(other.m_colorId_, allocator)),
        m_colorRgba_(::zserio::allocatorPropagatingCopy(other.m_colorRgba_, allocator))
{
}

::nds::display::types::ColorId Style3DColor::getColorId() const
{
    return m_colorId_;
}

void Style3DColor::setColorId(::nds::display::types::ColorId colorId_)
{
    m_colorId_ = colorId_;
}

::nds::core::color::ColorRgba& Style3DColor::getColorRgba()
{
    return m_colorRgba_;
}

const ::nds::core::color::ColorRgba& Style3DColor::getColorRgba() const
{
    return m_colorRgba_;
}

void Style3DColor::setColorRgba(const ::nds::core::color::ColorRgba& colorRgba_)
{
    m_colorRgba_ = colorRgba_;
}

void Style3DColor::setColorRgba(::nds::core::color::ColorRgba&& colorRgba_)
{
    m_colorRgba_ = ::std::move(colorRgba_);
}

void Style3DColor::initPackingContext(Style3DColor::ZserioPackingContext& context) const
{
    context.getColorId().init<::zserio::VarIntNNArrayTraits<::nds::display::types::ColorId>>(m_colorId_);
    m_colorRgba_.initPackingContext(context.getColorRgba());
}

size_t Style3DColor::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_colorId_);
    endBitPosition += m_colorRgba_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t Style3DColor::bitSizeOf(Style3DColor::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getColorId().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::display::types::ColorId>>(m_colorId_);
    endBitPosition += m_colorRgba_.bitSizeOf(context.getColorRgba(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t Style3DColor::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_colorId_);
    endBitPosition = m_colorRgba_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t Style3DColor::initializeOffsets(Style3DColor::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getColorId().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::display::types::ColorId>>(m_colorId_);
    endBitPosition = m_colorRgba_.initializeOffsets(context.getColorRgba(), endBitPosition);

    return endBitPosition;
}

bool Style3DColor::operator==(const Style3DColor& other) const
{
    if (this != &other)
    {
        return
                (m_colorId_ == other.m_colorId_) &&
                (m_colorRgba_ == other.m_colorRgba_);
    }

    return true;
}

uint32_t Style3DColor::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_colorId_);
    result = ::zserio::calcHashCode(result, m_colorRgba_);

    return result;
}

void Style3DColor::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt16(m_colorId_);
    m_colorRgba_.write(out);
}

void Style3DColor::write(Style3DColor::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getColorId().write<::zserio::VarIntNNArrayTraits<::nds::display::types::ColorId>>(out, m_colorId_);
    m_colorRgba_.write(context.getColorRgba(), out);
}

::nds::display::types::ColorId Style3DColor::readColorId(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::display::types::ColorId>(in.readVarUInt16());
}

::nds::display::types::ColorId Style3DColor::readColorId(Style3DColor::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getColorId().read<::zserio::VarIntNNArrayTraits<::nds::display::types::ColorId>>(in);
}
::nds::core::color::ColorRgba Style3DColor::readColorRgba(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::color::ColorRgba(in, allocator);
}

::nds::core::color::ColorRgba Style3DColor::readColorRgba(Style3DColor::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::color::ColorRgba(context.getColorRgba(), in, allocator);
}

} // namespace types
} // namespace display
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/display/types/BdamSurfaceGrid.h>

namespace nds
{
namespace display
{
namespace types
{

BdamSurfaceGrid::BdamSurfaceGrid(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_southWestCorner_(allocator),
        m_surfaceGridCellSize_(::nds::display::types::SurfaceGridCellSize()),
        m_numRows_(::nds::core::grid::NumGridCells()),
        m_numColumns_(::nds::core::grid::NumGridCells()),
        m_longSideErrorL1_(::nds::display::types::SpaceError()),
        m_shortSideErrorL1_(::nds::display::types::SpaceError()),
        m_shortSideErrorL2_(::nds::display::types::SpaceError()),
        m_vertexGridCellSize_(::nds::display::types::VertexGridCellSize()),
        m_surfaces_(allocator)
{
}

BdamSurfaceGrid::BdamSurfaceGrid(::zserio::BitStreamReader& in,
        ::nds::display::types::BdamLayerHeader& header_, const allocator_type& allocator) :
        m_header_(&header_),
        m_isInitialized(true),
        m_southWestCorner_(readSouthWestCorner(in, allocator)),
        m_surfaceGridCellSize_(readSurfaceGridCellSize(in)),
        m_numRows_(readNumRows(in)),
        m_numColumns_(readNumColumns(in)),
        m_longSideErrorL1_(readLongSideErrorL1(in)),
        m_shortSideErrorL1_(readShortSideErrorL1(in)),
        m_shortSideErrorL2_(readShortSideErrorL2(in)),
        m_vertexGridCellSize_(readVertexGridCellSize(in)),
        m_surfaces_(readSurfaces(in, allocator))
{
}

BdamSurfaceGrid::BdamSurfaceGrid(BdamSurfaceGrid::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::display::types::BdamLayerHeader& header_, const allocator_type& allocator) :
        m_header_(&header_),
        m_isInitialized(true),
        m_southWestCorner_(readSouthWestCorner(context, in, allocator)),
        m_surfaceGridCellSize_(readSurfaceGridCellSize(context, in)),
        m_numRows_(readNumRows(context, in)),
        m_numColumns_(readNumColumns(context, in)),
        m_longSideErrorL1_(readLongSideErrorL1(context, in)),
        m_shortSideErrorL1_(readShortSideErrorL1(context, in)),
        m_shortSideErrorL2_(readShortSideErrorL2(context, in)),
        m_vertexGridCellSize_(readVertexGridCellSize(context, in)),
        m_surfaces_(readSurfaces(context, in, allocator))
{
}

BdamSurfaceGrid::BdamSurfaceGrid(const BdamSurfaceGrid& other) :
        m_southWestCorner_(other.m_southWestCorner_),
        m_surfaceGridCellSize_(other.m_surfaceGridCellSize_),
        m_numRows_(other.m_numRows_),
        m_numColumns_(other.m_numColumns_),
        m_longSideErrorL1_(other.m_longSideErrorL1_),
        m_shortSideErrorL1_(other.m_shortSideErrorL1_),
        m_shortSideErrorL2_(other.m_shortSideErrorL2_),
        m_vertexGridCellSize_(other.m_vertexGridCellSize_),
        m_surfaces_(other.m_surfaces_)
{
    if (other.m_isInitialized)
        initialize(*(other.m_header_));
    else
        m_isInitialized = false;
}

BdamSurfaceGrid& BdamSurfaceGrid::operator=(const BdamSurfaceGrid& other)
{
    m_southWestCorner_ = other.m_southWestCorner_;
    m_surfaceGridCellSize_ = other.m_surfaceGridCellSize_;
    m_numRows_ = other.m_numRows_;
    m_numColumns_ = other.m_numColumns_;
    m_longSideErrorL1_ = other.m_longSideErrorL1_;
    m_shortSideErrorL1_ = other.m_shortSideErrorL1_;
    m_shortSideErrorL2_ = other.m_shortSideErrorL2_;
    m_vertexGridCellSize_ = other.m_vertexGridCellSize_;
    m_surfaces_ = other.m_surfaces_;
    if (other.m_isInitialized)
        initialize(*(other.m_header_));
    else
        m_isInitialized = false;

    return *this;
}

BdamSurfaceGrid::BdamSurfaceGrid(BdamSurfaceGrid&& other) :
        m_southWestCorner_(::std::move(other.m_southWestCorner_)),
        m_surfaceGridCellSize_(::std::move(other.m_surfaceGridCellSize_)),
        m_numRows_(::std::move(other.m_numRows_)),
        m_numColumns_(::std::move(other.m_numColumns_)),
        m_longSideErrorL1_(::std::move(other.m_longSideErrorL1_)),
        m_shortSideErrorL1_(::std::move(other.m_shortSideErrorL1_)),
        m_shortSideErrorL2_(::std::move(other.m_shortSideErrorL2_)),
        m_vertexGridCellSize_(::std::move(other.m_vertexGridCellSize_)),
        m_surfaces_(::std::move(other.m_surfaces_))
{
    if (other.m_isInitialized)
        initialize(*(other.m_header_));
    else
        m_isInitialized = false;
}

BdamSurfaceGrid& BdamSurfaceGrid::operator=(BdamSurfaceGrid&& other)
{
    m_southWestCorner_ = ::std::move(other.m_southWestCorner_);
    m_surfaceGridCellSize_ = ::std::move(other.m_surfaceGridCellSize_);
    m_numRows_ = ::std::move(other.m_numRows_);
    m_numColumns_ = ::std::move(other.m_numColumns_);
    m_longSideErrorL1_ = ::std::move(other.m_longSideErrorL1_);
    m_shortSideErrorL1_ = ::std::move(other.m_shortSideErrorL1_);
    m_shortSideErrorL2_ = ::std::move(other.m_shortSideErrorL2_);
    m_vertexGridCellSize_ = ::std::move(other.m_vertexGridCellSize_);
    m_surfaces_ = ::std::move(other.m_surfaces_);
    if (other.m_isInitialized)
        initialize(*(other.m_header_));
    else
        m_isInitialized = false;

    return *this;
}

BdamSurfaceGrid::BdamSurfaceGrid(::zserio::PropagateAllocatorT,
        const BdamSurfaceGrid& other, const allocator_type& allocator) :
        m_southWestCorner_(::zserio::allocatorPropagatingCopy(other.m_southWestCorner_, allocator)),
        m_surfaceGridCellSize_(::zserio::allocatorPropagatingCopy(other.m_surfaceGridCellSize_, allocator)),
        m_numRows_(::zserio::allocatorPropagatingCopy(other.m_numRows_, allocator)),
        m_numColumns_(::zserio::allocatorPropagatingCopy(other.m_numColumns_, allocator)),
        m_longSideErrorL1_(::zserio::allocatorPropagatingCopy(other.m_longSideErrorL1_, allocator)),
        m_shortSideErrorL1_(::zserio::allocatorPropagatingCopy(other.m_shortSideErrorL1_, allocator)),
        m_shortSideErrorL2_(::zserio::allocatorPropagatingCopy(other.m_shortSideErrorL2_, allocator)),
        m_vertexGridCellSize_(::zserio::allocatorPropagatingCopy(other.m_vertexGridCellSize_, allocator)),
        m_surfaces_(::zserio::allocatorPropagatingCopy(other.m_surfaces_, allocator))
{
    if (other.m_isInitialized)
        initialize(*(other.m_header_));
    else
        m_isInitialized = false;
}

void BdamSurfaceGrid::initialize(
        ::nds::display::types::BdamLayerHeader& header_)
{
    m_header_ = &header_;
    m_isInitialized = true;

    initializeChildren();
}

bool BdamSurfaceGrid::isInitialized() const
{
    return m_isInitialized;
}

void BdamSurfaceGrid::initializeChildren()
{
    m_southWestCorner_.initialize(static_cast<::nds::core::geometry::CoordShift>(getHeader().getShiftXY()));
    m_surfaces_.initializeElements(*this);
}

::nds::display::types::BdamLayerHeader& BdamSurfaceGrid::getHeader()
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'header' of compound 'BdamSurfaceGrid' is not initialized!");

    return *m_header_;
}

const ::nds::display::types::BdamLayerHeader& BdamSurfaceGrid::getHeader() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'header' of compound 'BdamSurfaceGrid' is not initialized!");

    return *m_header_;
}

::nds::core::geometry::Position2D& BdamSurfaceGrid::getSouthWestCorner()
{
    return m_southWestCorner_;
}

const ::nds::core::geometry::Position2D& BdamSurfaceGrid::getSouthWestCorner() const
{
    return m_southWestCorner_;
}

void BdamSurfaceGrid::setSouthWestCorner(const ::nds::core::geometry::Position2D& southWestCorner_)
{
    m_southWestCorner_ = southWestCorner_;
}

void BdamSurfaceGrid::setSouthWestCorner(::nds::core::geometry::Position2D&& southWestCorner_)
{
    m_southWestCorner_ = ::std::move(southWestCorner_);
}

::nds::display::types::SurfaceGridCellSize BdamSurfaceGrid::getSurfaceGridCellSize() const
{
    return m_surfaceGridCellSize_;
}

void BdamSurfaceGrid::setSurfaceGridCellSize(::nds::display::types::SurfaceGridCellSize surfaceGridCellSize_)
{
    m_surfaceGridCellSize_ = surfaceGridCellSize_;
}

::nds::core::grid::NumGridCells BdamSurfaceGrid::getNumRows() const
{
    return m_numRows_;
}

void BdamSurfaceGrid::setNumRows(::nds::core::grid::NumGridCells numRows_)
{
    m_numRows_ = numRows_;
}

::nds::core::grid::NumGridCells BdamSurfaceGrid::getNumColumns() const
{
    return m_numColumns_;
}

void BdamSurfaceGrid::setNumColumns(::nds::core::grid::NumGridCells numColumns_)
{
    m_numColumns_ = numColumns_;
}

::nds::display::types::SpaceError BdamSurfaceGrid::getLongSideErrorL1() const
{
    return m_longSideErrorL1_;
}

void BdamSurfaceGrid::setLongSideErrorL1(::nds::display::types::SpaceError longSideErrorL1_)
{
    m_longSideErrorL1_ = longSideErrorL1_;
}

::nds::display::types::SpaceError BdamSurfaceGrid::getShortSideErrorL1() const
{
    return m_shortSideErrorL1_;
}

void BdamSurfaceGrid::setShortSideErrorL1(::nds::display::types::SpaceError shortSideErrorL1_)
{
    m_shortSideErrorL1_ = shortSideErrorL1_;
}

::nds::display::types::SpaceError BdamSurfaceGrid::getShortSideErrorL2() const
{
    return m_shortSideErrorL2_;
}

void BdamSurfaceGrid::setShortSideErrorL2(::nds::display::types::SpaceError shortSideErrorL2_)
{
    m_shortSideErrorL2_ = shortSideErrorL2_;
}

::nds::display::types::VertexGridCellSize BdamSurfaceGrid::getVertexGridCellSize() const
{
    return m_vertexGridCellSize_;
}

void BdamSurfaceGrid::setVertexGridCellSize(::nds::display::types::VertexGridCellSize vertexGridCellSize_)
{
    m_vertexGridCellSize_ = vertexGridCellSize_;
}

::zserio::vector<::nds::display::types::BdamSurface>& BdamSurfaceGrid::getSurfaces()
{
    return m_surfaces_.getRawArray();
}

const ::zserio::vector<::nds::display::types::BdamSurface>& BdamSurfaceGrid::getSurfaces() const
{
    return m_surfaces_.getRawArray();
}

void BdamSurfaceGrid::setSurfaces(const ::zserio::vector<::nds::display::types::BdamSurface>& surfaces_)
{
    m_surfaces_ = ZserioArrayType_surfaces(surfaces_);
}

void BdamSurfaceGrid::setSurfaces(::zserio::vector<::nds::display::types::BdamSurface>&& surfaces_)
{
    m_surfaces_ = ZserioArrayType_surfaces(std::move(surfaces_));
}

void BdamSurfaceGrid::initPackingContext(BdamSurfaceGrid::ZserioPackingContext& context) const
{
    m_southWestCorner_.initPackingContext(context.getSouthWestCorner());
    context.getSurfaceGridCellSize().init<::zserio::VarSizeArrayTraits>(m_surfaceGridCellSize_);
    context.getNumRows().init<::zserio::VarSizeArrayTraits>(m_numRows_);
    context.getNumColumns().init<::zserio::VarSizeArrayTraits>(m_numColumns_);
    context.getLongSideErrorL1().init<::zserio::VarSizeArrayTraits>(m_longSideErrorL1_);
    context.getShortSideErrorL1().init<::zserio::VarSizeArrayTraits>(m_shortSideErrorL1_);
    context.getShortSideErrorL2().init<::zserio::VarSizeArrayTraits>(m_shortSideErrorL2_);
    context.getVertexGridCellSize().init<::zserio::VarSizeArrayTraits>(m_vertexGridCellSize_);
}

size_t BdamSurfaceGrid::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_southWestCorner_.bitSizeOf(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_surfaceGridCellSize_);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_numRows_);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_numColumns_);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_longSideErrorL1_);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_shortSideErrorL1_);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_shortSideErrorL2_);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_vertexGridCellSize_);
    endBitPosition += m_surfaces_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t BdamSurfaceGrid::bitSizeOf(BdamSurfaceGrid::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_southWestCorner_.bitSizeOf(context.getSouthWestCorner(), endBitPosition);
    endBitPosition += context.getSurfaceGridCellSize().bitSizeOf<::zserio::VarSizeArrayTraits>(m_surfaceGridCellSize_);
    endBitPosition += context.getNumRows().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numRows_);
    endBitPosition += context.getNumColumns().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numColumns_);
    endBitPosition += context.getLongSideErrorL1().bitSizeOf<::zserio::VarSizeArrayTraits>(m_longSideErrorL1_);
    endBitPosition += context.getShortSideErrorL1().bitSizeOf<::zserio::VarSizeArrayTraits>(m_shortSideErrorL1_);
    endBitPosition += context.getShortSideErrorL2().bitSizeOf<::zserio::VarSizeArrayTraits>(m_shortSideErrorL2_);
    endBitPosition += context.getVertexGridCellSize().bitSizeOf<::zserio::VarSizeArrayTraits>(m_vertexGridCellSize_);
    endBitPosition += m_surfaces_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t BdamSurfaceGrid::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_southWestCorner_.initializeOffsets(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_surfaceGridCellSize_);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_numRows_);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_numColumns_);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_longSideErrorL1_);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_shortSideErrorL1_);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_shortSideErrorL2_);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_vertexGridCellSize_);
    endBitPosition = m_surfaces_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t BdamSurfaceGrid::initializeOffsets(BdamSurfaceGrid::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_southWestCorner_.initializeOffsets(context.getSouthWestCorner(), endBitPosition);
    endBitPosition += context.getSurfaceGridCellSize().bitSizeOf<::zserio::VarSizeArrayTraits>(m_surfaceGridCellSize_);
    endBitPosition += context.getNumRows().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numRows_);
    endBitPosition += context.getNumColumns().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numColumns_);
    endBitPosition += context.getLongSideErrorL1().bitSizeOf<::zserio::VarSizeArrayTraits>(m_longSideErrorL1_);
    endBitPosition += context.getShortSideErrorL1().bitSizeOf<::zserio::VarSizeArrayTraits>(m_shortSideErrorL1_);
    endBitPosition += context.getShortSideErrorL2().bitSizeOf<::zserio::VarSizeArrayTraits>(m_shortSideErrorL2_);
    endBitPosition += context.getVertexGridCellSize().bitSizeOf<::zserio::VarSizeArrayTraits>(m_vertexGridCellSize_);
    endBitPosition = m_surfaces_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool BdamSurfaceGrid::operator==(const BdamSurfaceGrid& other) const
{
    if (this != &other)
    {
        return
                (getHeader() == other.getHeader()) &&
                (m_southWestCorner_ == other.m_southWestCorner_) &&
                (m_surfaceGridCellSize_ == other.m_surfaceGridCellSize_) &&
                (m_numRows_ == other.m_numRows_) &&
                (m_numColumns_ == other.m_numColumns_) &&
                (m_longSideErrorL1_ == other.m_longSideErrorL1_) &&
                (m_shortSideErrorL1_ == other.m_shortSideErrorL1_) &&
                (m_shortSideErrorL2_ == other.m_shortSideErrorL2_) &&
                (m_vertexGridCellSize_ == other.m_vertexGridCellSize_) &&
                (m_surfaces_ == other.m_surfaces_);
    }

    return true;
}

uint32_t BdamSurfaceGrid::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getHeader());
    result = ::zserio::calcHashCode(result, m_southWestCorner_);
    result = ::zserio::calcHashCode(result, m_surfaceGridCellSize_);
    result = ::zserio::calcHashCode(result, m_numRows_);
    result = ::zserio::calcHashCode(result, m_numColumns_);
    result = ::zserio::calcHashCode(result, m_longSideErrorL1_);
    result = ::zserio::calcHashCode(result, m_shortSideErrorL1_);
    result = ::zserio::calcHashCode(result, m_shortSideErrorL2_);
    result = ::zserio::calcHashCode(result, m_vertexGridCellSize_);
    result = ::zserio::calcHashCode(result, m_surfaces_);

    return result;
}

void BdamSurfaceGrid::write(::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_southWestCorner_.getShift() != static_cast<::nds::core::geometry::CoordShift>(getHeader().getShiftXY()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field BdamSurfaceGrid.southWestCorner: ") <<
                m_southWestCorner_.getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(getHeader().getShiftXY()) << "!";
    }
    m_southWestCorner_.write(out);

    out.writeVarSize(m_surfaceGridCellSize_);

    out.writeVarSize(m_numRows_);

    out.writeVarSize(m_numColumns_);

    out.writeVarSize(m_longSideErrorL1_);

    out.writeVarSize(m_shortSideErrorL1_);

    out.writeVarSize(m_shortSideErrorL2_);

    out.writeVarSize(m_vertexGridCellSize_);

    // check array length
    if (m_surfaces_.getRawArray().size() != static_cast<size_t>(getNumRows() * getNumColumns()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field BdamSurfaceGrid.surfaces: ") <<
                m_surfaces_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumRows() * getNumColumns()) << "!";
    }
    m_surfaces_.write(*this, out);
}

void BdamSurfaceGrid::write(BdamSurfaceGrid::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_southWestCorner_.getShift() != static_cast<::nds::core::geometry::CoordShift>(getHeader().getShiftXY()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field BdamSurfaceGrid.southWestCorner: ") <<
                m_southWestCorner_.getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(getHeader().getShiftXY()) << "!";
    }
    m_southWestCorner_.write(context.getSouthWestCorner(), out);

    context.getSurfaceGridCellSize().write<::zserio::VarSizeArrayTraits>(out, m_surfaceGridCellSize_);

    context.getNumRows().write<::zserio::VarSizeArrayTraits>(out, m_numRows_);

    context.getNumColumns().write<::zserio::VarSizeArrayTraits>(out, m_numColumns_);

    context.getLongSideErrorL1().write<::zserio::VarSizeArrayTraits>(out, m_longSideErrorL1_);

    context.getShortSideErrorL1().write<::zserio::VarSizeArrayTraits>(out, m_shortSideErrorL1_);

    context.getShortSideErrorL2().write<::zserio::VarSizeArrayTraits>(out, m_shortSideErrorL2_);

    context.getVertexGridCellSize().write<::zserio::VarSizeArrayTraits>(out, m_vertexGridCellSize_);

    // check array length
    if (m_surfaces_.getRawArray().size() != static_cast<size_t>(getNumRows() * getNumColumns()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field BdamSurfaceGrid.surfaces: ") <<
                m_surfaces_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumRows() * getNumColumns()) << "!";
    }
    m_surfaces_.writePacked(*this, out);
}

void BdamSurfaceGrid::ZserioArrayExpressions_surfaces::initializeElement(BdamSurfaceGrid& owner,
        ::nds::display::types::BdamSurface& element, size_t)
{
    element.initialize(owner.getHeader(), static_cast<::nds::display::types::SurfaceGridCellSize>(owner.getSurfaceGridCellSize()), static_cast<::nds::display::types::VertexGridCellSize>(owner.getVertexGridCellSize()));
}

void BdamSurfaceGrid::ZserioElementFactory_surfaces::create(BdamSurfaceGrid&         owner,
        ::zserio::vector<::nds::display::types::BdamSurface>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, owner.getHeader(), static_cast<::nds::display::types::SurfaceGridCellSize>(owner.getSurfaceGridCellSize()), static_cast<::nds::display::types::VertexGridCellSize>(owner.getVertexGridCellSize()), array.get_allocator());
}

void BdamSurfaceGrid::ZserioElementFactory_surfaces::create(BdamSurfaceGrid&         owner,
        ::zserio::vector<::nds::display::types::BdamSurface>& array,
        ::nds::display::types::BdamSurface::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, owner.getHeader(), static_cast<::nds::display::types::SurfaceGridCellSize>(owner.getSurfaceGridCellSize()), static_cast<::nds::display::types::VertexGridCellSize>(owner.getVertexGridCellSize()), array.get_allocator());
}

::nds::core::geometry::Position2D BdamSurfaceGrid::readSouthWestCorner(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::geometry::Position2D(in, static_cast<::nds::core::geometry::CoordShift>(getHeader().getShiftXY()), allocator);
}

::nds::core::geometry::Position2D BdamSurfaceGrid::readSouthWestCorner(BdamSurfaceGrid::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::geometry::Position2D(context.getSouthWestCorner(), in, static_cast<::nds::core::geometry::CoordShift>(getHeader().getShiftXY()), allocator);
}
::nds::display::types::SurfaceGridCellSize BdamSurfaceGrid::readSurfaceGridCellSize(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::display::types::SurfaceGridCellSize>(in.readVarSize());
}

::nds::display::types::SurfaceGridCellSize BdamSurfaceGrid::readSurfaceGridCellSize(BdamSurfaceGrid::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getSurfaceGridCellSize().read<::zserio::VarSizeArrayTraits>(in);
}
::nds::core::grid::NumGridCells BdamSurfaceGrid::readNumRows(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::grid::NumGridCells>(in.readVarSize());
}

::nds::core::grid::NumGridCells BdamSurfaceGrid::readNumRows(BdamSurfaceGrid::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumRows().read<::zserio::VarSizeArrayTraits>(in);
}
::nds::core::grid::NumGridCells BdamSurfaceGrid::readNumColumns(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::grid::NumGridCells>(in.readVarSize());
}

::nds::core::grid::NumGridCells BdamSurfaceGrid::readNumColumns(BdamSurfaceGrid::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumColumns().read<::zserio::VarSizeArrayTraits>(in);
}
::nds::display::types::SpaceError BdamSurfaceGrid::readLongSideErrorL1(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::display::types::SpaceError>(in.readVarSize());
}

::nds::display::types::SpaceError BdamSurfaceGrid::readLongSideErrorL1(BdamSurfaceGrid::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getLongSideErrorL1().read<::zserio::VarSizeArrayTraits>(in);
}
::nds::display::types::SpaceError BdamSurfaceGrid::readShortSideErrorL1(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::display::types::SpaceError>(in.readVarSize());
}

::nds::display::types::SpaceError BdamSurfaceGrid::readShortSideErrorL1(BdamSurfaceGrid::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getShortSideErrorL1().read<::zserio::VarSizeArrayTraits>(in);
}
::nds::display::types::SpaceError BdamSurfaceGrid::readShortSideErrorL2(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::display::types::SpaceError>(in.readVarSize());
}

::nds::display::types::SpaceError BdamSurfaceGrid::readShortSideErrorL2(BdamSurfaceGrid::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getShortSideErrorL2().read<::zserio::VarSizeArrayTraits>(in);
}
::nds::display::types::VertexGridCellSize BdamSurfaceGrid::readVertexGridCellSize(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::display::types::VertexGridCellSize>(in.readVarSize());
}

::nds::display::types::VertexGridCellSize BdamSurfaceGrid::readVertexGridCellSize(BdamSurfaceGrid::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getVertexGridCellSize().read<::zserio::VarSizeArrayTraits>(in);
}
BdamSurfaceGrid::ZserioArrayType_surfaces BdamSurfaceGrid::readSurfaces(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_surfaces readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getNumRows() * getNumColumns()));

    return readField;
}

BdamSurfaceGrid::ZserioArrayType_surfaces BdamSurfaceGrid::readSurfaces(BdamSurfaceGrid::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_surfaces readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumRows() * getNumColumns()));

    return readField;
}

} // namespace types
} // namespace display
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/display/types/BdamLayerHeader.h>

namespace nds
{
namespace display
{
namespace types
{

BdamLayerHeader::BdamLayerHeader(const allocator_type&) noexcept :
        m_shiftXY_(::nds::core::geometry::CoordShift()),
        m_shiftZ_(::nds::core::geometry::CoordShift()),
        m_hasTexture_(bool())
{
}

BdamLayerHeader::BdamLayerHeader(::zserio::BitStreamReader& in, const allocator_type&) :
        m_shiftXY_(readShiftXY(in)),
        m_shiftZ_(readShiftZ(in)),
        m_hasTexture_(readHasTexture(in))
{
}

BdamLayerHeader::BdamLayerHeader(BdamLayerHeader::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type&) :
        m_shiftXY_(readShiftXY(context, in)),
        m_shiftZ_(readShiftZ(context, in)),
        m_hasTexture_(readHasTexture(in))
{
}

BdamLayerHeader::BdamLayerHeader(::zserio::PropagateAllocatorT,
        const BdamLayerHeader& other, const allocator_type& allocator) :
        m_shiftXY_(::zserio::allocatorPropagatingCopy(other.m_shiftXY_, allocator)),
        m_shiftZ_(::zserio::allocatorPropagatingCopy(other.m_shiftZ_, allocator)),
        m_hasTexture_(::zserio::allocatorPropagatingCopy(other.m_hasTexture_, allocator))
{
}

::nds::core::geometry::CoordShift BdamLayerHeader::getShiftXY() const
{
    return m_shiftXY_;
}

void BdamLayerHeader::setShiftXY(::nds::core::geometry::CoordShift shiftXY_)
{
    m_shiftXY_ = shiftXY_;
}

::nds::core::geometry::CoordShift BdamLayerHeader::getShiftZ() const
{
    return m_shiftZ_;
}

void BdamLayerHeader::setShiftZ(::nds::core::geometry::CoordShift shiftZ_)
{
    m_shiftZ_ = shiftZ_;
}

bool BdamLayerHeader::getHasTexture() const
{
    return m_hasTexture_;
}

void BdamLayerHeader::setHasTexture(bool hasTexture_)
{
    m_hasTexture_ = hasTexture_;
}

void BdamLayerHeader::initPackingContext(BdamLayerHeader::ZserioPackingContext& context) const
{
    context.getShiftXY().init<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(m_shiftXY_);
    context.getShiftZ().init<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(m_shiftZ_);
}

size_t BdamLayerHeader::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(5);
    endBitPosition += UINT8_C(5);
    endBitPosition += UINT8_C(1);

    return endBitPosition - bitPosition;
}

size_t BdamLayerHeader::bitSizeOf(BdamLayerHeader::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getShiftXY().bitSizeOf<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(m_shiftXY_);
    endBitPosition += context.getShiftZ().bitSizeOf<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(m_shiftZ_);
    endBitPosition += UINT8_C(1);

    return endBitPosition - bitPosition;
}

size_t BdamLayerHeader::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(5);
    endBitPosition += UINT8_C(5);
    endBitPosition += UINT8_C(1);

    return endBitPosition;
}

size_t BdamLayerHeader::initializeOffsets(BdamLayerHeader::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getShiftXY().bitSizeOf<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(m_shiftXY_);
    endBitPosition += context.getShiftZ().bitSizeOf<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(m_shiftZ_);
    endBitPosition += UINT8_C(1);

    return endBitPosition;
}

bool BdamLayerHeader::operator==(const BdamLayerHeader& other) const
{
    if (this != &other)
    {
        return
                (m_shiftXY_ == other.m_shiftXY_) &&
                (m_shiftZ_ == other.m_shiftZ_) &&
                (m_hasTexture_ == other.m_hasTexture_);
    }

    return true;
}

uint32_t BdamLayerHeader::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_shiftXY_);
    result = ::zserio::calcHashCode(result, m_shiftZ_);
    result = ::zserio::calcHashCode(result, m_hasTexture_);

    return result;
}

void BdamLayerHeader::write(::zserio::BitStreamWriter& out) const
{
    out.writeBits(m_shiftXY_, UINT8_C(5));
    out.writeBits(m_shiftZ_, UINT8_C(5));
    out.writeBool(m_hasTexture_);
}

void BdamLayerHeader::write(BdamLayerHeader::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getShiftXY().write<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(out, m_shiftXY_);
    context.getShiftZ().write<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(out, m_shiftZ_);
    out.writeBool(m_hasTexture_);
}

::nds::core::geometry::CoordShift BdamLayerHeader::readShiftXY(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::geometry::CoordShift>(in.readBits(UINT8_C(5)));
}

::nds::core::geometry::CoordShift BdamLayerHeader::readShiftXY(BdamLayerHeader::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getShiftXY().read<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(in);
}
::nds::core::geometry::CoordShift BdamLayerHeader::readShiftZ(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::geometry::CoordShift>(in.readBits(UINT8_C(5)));
}

::nds::core::geometry::CoordShift BdamLayerHeader::readShiftZ(BdamLayerHeader::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getShiftZ().read<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(in);
}
bool BdamLayerHeader::readHasTexture(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}

} // namespace types
} // namespace display
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/BuiltInOperators.h>

#include <nds/display/types/BdamSurface.h>

namespace nds
{
namespace display
{
namespace types
{

BdamSurface::BdamSurface(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_hasRegularVertexGrid_(bool()),
        m_regularVertexGrid_(::zserio::NullOpt),
        m_vertices_(allocator),
        m_normals_(allocator),
        m_textureCoordinates_(::zserio::NullOpt),
        m_surfaceTins_(allocator)
{
}

BdamSurface::BdamSurface(::zserio::BitStreamReader& in,
        ::nds::display::types::BdamLayerHeader& header_,
        ::nds::display::types::SurfaceGridCellSize surfaceCellSize_,
        ::nds::display::types::VertexGridCellSize vertexCellSize_, const allocator_type& allocator) :
        m_header_(&header_),
        m_surfaceCellSize_(surfaceCellSize_),
        m_vertexCellSize_(vertexCellSize_),
        m_isInitialized(true),
        m_hasRegularVertexGrid_(readHasRegularVertexGrid(in)),
        m_regularVertexGrid_(readRegularVertexGrid(in, allocator)),
        m_vertices_(readVertices(in, allocator)),
        m_normals_(readNormals(in, allocator)),
        m_textureCoordinates_(readTextureCoordinates(in, allocator)),
        m_surfaceTins_(readSurfaceTins(in, allocator))
{
}

BdamSurface::BdamSurface(BdamSurface::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::display::types::BdamLayerHeader& header_,
        ::nds::display::types::SurfaceGridCellSize surfaceCellSize_,
        ::nds::display::types::VertexGridCellSize vertexCellSize_, const allocator_type& allocator) :
        m_header_(&header_),
        m_surfaceCellSize_(surfaceCellSize_),
        m_vertexCellSize_(vertexCellSize_),
        m_isInitialized(true),
        m_hasRegularVertexGrid_(readHasRegularVertexGrid(in)),
        m_regularVertexGrid_(readRegularVertexGrid(context, in, allocator)),
        m_vertices_(readVertices(context, in, allocator)),
        m_normals_(readNormals(context, in, allocator)),
        m_textureCoordinates_(readTextureCoordinates(in, allocator)),
        m_surfaceTins_(readSurfaceTins(context, in, allocator))
{
}

BdamSurface::BdamSurface(const BdamSurface& other) :
        m_hasRegularVertexGrid_(other.m_hasRegularVertexGrid_),
        m_regularVertexGrid_(other.m_regularVertexGrid_),
        m_vertices_(other.m_vertices_),
        m_normals_(other.m_normals_),
        m_textureCoordinates_(other.m_textureCoordinates_),
        m_surfaceTins_(other.m_surfaceTins_)
{
    if (other.m_isInitialized)
        initialize(*(other.m_header_), other.m_surfaceCellSize_, other.m_vertexCellSize_);
    else
        m_isInitialized = false;
}

BdamSurface& BdamSurface::operator=(const BdamSurface& other)
{
    m_hasRegularVertexGrid_ = other.m_hasRegularVertexGrid_;
    m_regularVertexGrid_ = other.m_regularVertexGrid_;
    m_vertices_ = other.m_vertices_;
    m_normals_ = other.m_normals_;
    m_textureCoordinates_ = other.m_textureCoordinates_;
    m_surfaceTins_ = other.m_surfaceTins_;
    if (other.m_isInitialized)
        initialize(*(other.m_header_), other.m_surfaceCellSize_, other.m_vertexCellSize_);
    else
        m_isInitialized = false;

    return *this;
}

BdamSurface::BdamSurface(BdamSurface&& other) :
        m_hasRegularVertexGrid_(::std::move(other.m_hasRegularVertexGrid_)),
        m_regularVertexGrid_(::std::move(other.m_regularVertexGrid_)),
        m_vertices_(::std::move(other.m_vertices_)),
        m_normals_(::std::move(other.m_normals_)),
        m_textureCoordinates_(::std::move(other.m_textureCoordinates_)),
        m_surfaceTins_(::std::move(other.m_surfaceTins_))
{
    if (other.m_isInitialized)
        initialize(*(other.m_header_), other.m_surfaceCellSize_, other.m_vertexCellSize_);
    else
        m_isInitialized = false;
}

BdamSurface& BdamSurface::operator=(BdamSurface&& other)
{
    m_hasRegularVertexGrid_ = ::std::move(other.m_hasRegularVertexGrid_);
    m_regularVertexGrid_ = ::std::move(other.m_regularVertexGrid_);
    m_vertices_ = ::std::move(other.m_vertices_);
    m_normals_ = ::std::move(other.m_normals_);
    m_textureCoordinates_ = ::std::move(other.m_textureCoordinates_);
    m_surfaceTins_ = ::std::move(other.m_surfaceTins_);
    if (other.m_isInitialized)
        initialize(*(other.m_header_), other.m_surfaceCellSize_, other.m_vertexCellSize_);
    else
        m_isInitialized = false;

    return *this;
}

BdamSurface::BdamSurface(::zserio::PropagateAllocatorT,
        const BdamSurface& other, const allocator_type& allocator) :
        m_hasRegularVertexGrid_(::zserio::allocatorPropagatingCopy(other.m_hasRegularVertexGrid_, allocator)),
        m_regularVertexGrid_(::zserio::allocatorPropagatingCopy(other.m_regularVertexGrid_, allocator)),
        m_vertices_(::zserio::allocatorPropagatingCopy(other.m_vertices_, allocator)),
        m_normals_(::zserio::allocatorPropagatingCopy(other.m_normals_, allocator)),
        m_textureCoordinates_(::zserio::allocatorPropagatingCopy(other.m_textureCoordinates_, allocator)),
        m_surfaceTins_(::zserio::allocatorPropagatingCopy(other.m_surfaceTins_, allocator))
{
    if (other.m_isInitialized)
        initialize(*(other.m_header_), other.m_surfaceCellSize_, other.m_vertexCellSize_);
    else
        m_isInitialized = false;
}

void BdamSurface::initialize(
        ::nds::display::types::BdamLayerHeader& header_,
        ::nds::display::types::SurfaceGridCellSize surfaceCellSize_,
        ::nds::display::types::VertexGridCellSize vertexCellSize_)
{
    m_header_ = &header_;
    m_surfaceCellSize_ = surfaceCellSize_;
    m_vertexCellSize_ = vertexCellSize_;
    m_isInitialized = true;

    initializeChildren();
}

bool BdamSurface::isInitialized() const
{
    return m_isInitialized;
}

void BdamSurface::initializeChildren()
{
    if (getHasRegularVertexGrid() == true)
        m_regularVertexGrid_.value().initializeElements(*this);
    m_vertices_.initializeElements(*this);
    m_surfaceTins_.initializeElements(*this);
}

::nds::display::types::BdamLayerHeader& BdamSurface::getHeader()
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'header' of compound 'BdamSurface' is not initialized!");

    return *m_header_;
}

const ::nds::display::types::BdamLayerHeader& BdamSurface::getHeader() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'header' of compound 'BdamSurface' is not initialized!");

    return *m_header_;
}

::nds::display::types::SurfaceGridCellSize BdamSurface::getSurfaceCellSize() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'surfaceCellSize' of compound 'BdamSurface' is not initialized!");

    return m_surfaceCellSize_;
}

::nds::display::types::VertexGridCellSize BdamSurface::getVertexCellSize() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'vertexCellSize' of compound 'BdamSurface' is not initialized!");

    return m_vertexCellSize_;
}

bool BdamSurface::getHasRegularVertexGrid() const
{
    return m_hasRegularVertexGrid_;
}

void BdamSurface::setHasRegularVertexGrid(bool hasRegularVertexGrid_)
{
    m_hasRegularVertexGrid_ = hasRegularVertexGrid_;
}

::zserio::vector<::nds::display::types::RegularGridVertex>& BdamSurface::getRegularVertexGrid()
{
    return m_regularVertexGrid_.value().getRawArray();
}

const ::zserio::vector<::nds::display::types::RegularGridVertex>& BdamSurface::getRegularVertexGrid() const
{
    return m_regularVertexGrid_.value().getRawArray();
}

void BdamSurface::setRegularVertexGrid(const ::zserio::vector<::nds::display::types::RegularGridVertex>& regularVertexGrid_)
{
    m_regularVertexGrid_ = ZserioArrayType_regularVertexGrid(regularVertexGrid_);
}

void BdamSurface::setRegularVertexGrid(::zserio::vector<::nds::display::types::RegularGridVertex>&& regularVertexGrid_)
{
    m_regularVertexGrid_ = ZserioArrayType_regularVertexGrid(std::move(regularVertexGrid_));
}

bool BdamSurface::isRegularVertexGridUsed() const
{
    return (getHasRegularVertexGrid() == true);
}

bool BdamSurface::isRegularVertexGridSet() const
{
    return m_regularVertexGrid_.hasValue();
}

void BdamSurface::resetRegularVertexGrid()
{
    m_regularVertexGrid_.reset();
}

::zserio::vector<::nds::core::geometry::Position3D>& BdamSurface::getVertices()
{
    return m_vertices_.getRawArray();
}

const ::zserio::vector<::nds::core::geometry::Position3D>& BdamSurface::getVertices() const
{
    return m_vertices_.getRawArray();
}

void BdamSurface::setVertices(const ::zserio::vector<::nds::core::geometry::Position3D>& vertices_)
{
    m_vertices_ = ZserioArrayType_vertices(vertices_);
}

void BdamSurface::setVertices(::zserio::vector<::nds::core::geometry::Position3D>&& vertices_)
{
    m_vertices_ = ZserioArrayType_vertices(std::move(vertices_));
}

::zserio::vector<::nds::display::types::NormalSphere>& BdamSurface::getNormals()
{
    return m_normals_.getRawArray();
}

const ::zserio::vector<::nds::display::types::NormalSphere>& BdamSurface::getNormals() const
{
    return m_normals_.getRawArray();
}

void BdamSurface::setNormals(const ::zserio::vector<::nds::display::types::NormalSphere>& normals_)
{
    m_normals_ = ZserioArrayType_normals(normals_);
}

void BdamSurface::setNormals(::zserio::vector<::nds::display::types::NormalSphere>&& normals_)
{
    m_normals_ = ZserioArrayType_normals(std::move(normals_));
}

::zserio::vector<::nds::display::types::TextureCoords>& BdamSurface::getTextureCoordinates()
{
    return m_textureCoordinates_.value().getRawArray();
}

const ::zserio::vector<::nds::display::types::TextureCoords>& BdamSurface::getTextureCoordinates() const
{
    return m_textureCoordinates_.value().getRawArray();
}

void BdamSurface::setTextureCoordinates(const ::zserio::vector<::nds::display::types::TextureCoords>& textureCoordinates_)
{
    m_textureCoordinates_ = ZserioArrayType_textureCoordinates(textureCoordinates_);
}

void BdamSurface::setTextureCoordinates(::zserio::vector<::nds::display::types::TextureCoords>&& textureCoordinates_)
{
    m_textureCoordinates_ = ZserioArrayType_textureCoordinates(std::move(textureCoordinates_));
}

bool BdamSurface::isTextureCoordinatesUsed() const
{
    return (getHeader().getHasTexture() == true);
}

bool BdamSurface::isTextureCoordinatesSet() const
{
    return m_textureCoordinates_.hasValue();
}

void BdamSurface::resetTextureCoordinates()
{
    m_textureCoordinates_.reset();
}

::zserio::vector<::nds::display::types::BdamSurfaceTin>& BdamSurface::getSurfaceTins()
{
    return m_surfaceTins_.getRawArray();
}

const ::zserio::vector<::nds::display::types::BdamSurfaceTin>& BdamSurface::getSurfaceTins() const
{
    return m_surfaceTins_.getRawArray();
}

void BdamSurface::setSurfaceTins(const ::zserio::vector<::nds::display::types::BdamSurfaceTin>& surfaceTins_)
{
    m_surfaceTins_ = ZserioArrayType_surfaceTins(surfaceTins_);
}

void BdamSurface::setSurfaceTins(::zserio::vector<::nds::display::types::BdamSurfaceTin>&& surfaceTins_)
{
    m_surfaceTins_ = ZserioArrayType_surfaceTins(std::move(surfaceTins_));
}

uint32_t BdamSurface::funcNumGridVertices() const
{
    return static_cast<uint32_t>((getHasRegularVertexGrid()) ? ((getSurfaceCellSize() / getVertexCellSize()) * (getSurfaceCellSize() / getVertexCellSize())) : 0);
}

uint32_t BdamSurface::funcNumVertices() const
{
    return static_cast<uint32_t>(getVertices().size() + funcNumGridVertices());
}

void BdamSurface::initPackingContext(BdamSurface::ZserioPackingContext&) const
{
}

size_t BdamSurface::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    if (getHasRegularVertexGrid() == true)
    {
        endBitPosition += m_regularVertexGrid_.value().bitSizeOfPacked(*this, endBitPosition);
    }
    endBitPosition += m_vertices_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_normals_.bitSizeOfPacked(*this, endBitPosition);
    if (getHeader().getHasTexture() == true)
    {
        endBitPosition += m_textureCoordinates_.value().bitSizeOf(*this, endBitPosition);
    }
    endBitPosition += m_surfaceTins_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t BdamSurface::bitSizeOf(BdamSurface::ZserioPackingContext&, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    if (getHasRegularVertexGrid() == true)
    {
        endBitPosition += m_regularVertexGrid_.value().bitSizeOfPacked(*this, endBitPosition);
    }
    endBitPosition += m_vertices_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_normals_.bitSizeOfPacked(*this, endBitPosition);
    if (getHeader().getHasTexture() == true)
    {
        endBitPosition += m_textureCoordinates_.value().bitSizeOf(*this, endBitPosition);
    }
    endBitPosition += m_surfaceTins_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t BdamSurface::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    if (getHasRegularVertexGrid() == true)
    {
        endBitPosition = m_regularVertexGrid_.value().initializeOffsetsPacked(*this, endBitPosition);
    }
    endBitPosition = m_vertices_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_normals_.initializeOffsetsPacked(*this, endBitPosition);
    if (getHeader().getHasTexture() == true)
    {
        endBitPosition = m_textureCoordinates_.value().initializeOffsets(*this, endBitPosition);
    }
    endBitPosition = m_surfaceTins_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t BdamSurface::initializeOffsets(BdamSurface::ZserioPackingContext&, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    if (getHasRegularVertexGrid() == true)
    {
        endBitPosition = m_regularVertexGrid_.value().initializeOffsetsPacked(*this, endBitPosition);
    }
    endBitPosition = m_vertices_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_normals_.initializeOffsetsPacked(*this, endBitPosition);
    if (getHeader().getHasTexture() == true)
    {
        endBitPosition = m_textureCoordinates_.value().initializeOffsets(*this, endBitPosition);
    }
    endBitPosition = m_surfaceTins_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool BdamSurface::operator==(const BdamSurface& other) const
{
    if (this != &other)
    {
        return
                (getHeader() == other.getHeader()) &&
                (getSurfaceCellSize() == other.getSurfaceCellSize()) &&
                (getVertexCellSize() == other.getVertexCellSize()) &&
                (m_hasRegularVertexGrid_ == other.m_hasRegularVertexGrid_) &&
                (!isRegularVertexGridUsed() ? !other.isRegularVertexGridUsed() : (m_regularVertexGrid_ == other.m_regularVertexGrid_)) &&
                (m_vertices_ == other.m_vertices_) &&
                (m_normals_ == other.m_normals_) &&
                (!isTextureCoordinatesUsed() ? !other.isTextureCoordinatesUsed() : (m_textureCoordinates_ == other.m_textureCoordinates_)) &&
                (m_surfaceTins_ == other.m_surfaceTins_);
    }

    return true;
}

uint32_t BdamSurface::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getHeader());
    result = ::zserio::calcHashCode(result, getSurfaceCellSize());
    result = ::zserio::calcHashCode(result, getVertexCellSize());
    result = ::zserio::calcHashCode(result, m_hasRegularVertexGrid_);
    if (isRegularVertexGridUsed())
        result = ::zserio::calcHashCode(result, m_regularVertexGrid_);
    result = ::zserio::calcHashCode(result, m_vertices_);
    result = ::zserio::calcHashCode(result, m_normals_);
    if (isTextureCoordinatesUsed())
        result = ::zserio::calcHashCode(result, m_textureCoordinates_);
    result = ::zserio::calcHashCode(result, m_surfaceTins_);

    return result;
}

void BdamSurface::write(::zserio::BitStreamWriter& out) const
{
    out.writeBool(m_hasRegularVertexGrid_);

    if (getHasRegularVertexGrid() == true)
    {
        // check array length
        if (m_regularVertexGrid_.value().getRawArray().size() != static_cast<size_t>(funcNumGridVertices()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field BdamSurface.regularVertexGrid: ") <<
                    m_regularVertexGrid_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(funcNumGridVertices()) << "!";
        }
        m_regularVertexGrid_.value().writePacked(*this, out);
    }

    m_vertices_.writePacked(*this, out);

    // check array length
    if (m_normals_.getRawArray().size() != static_cast<size_t>(getVertices().size()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field BdamSurface.normals: ") <<
                m_normals_.getRawArray().size() << " != " <<
                static_cast<size_t>(getVertices().size()) << "!";
    }
    m_normals_.writePacked(*this, out);

    if (getHeader().getHasTexture() == true)
    {
        // check array length
        if (m_textureCoordinates_.value().getRawArray().size() != static_cast<size_t>(getVertices().size()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field BdamSurface.textureCoordinates: ") <<
                    m_textureCoordinates_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getVertices().size()) << "!";
        }
        m_textureCoordinates_.value().write(*this, out);
    }

    // check array length
    if (m_surfaceTins_.getRawArray().size() != static_cast<size_t>(6))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field BdamSurface.surfaceTins: ") <<
                m_surfaceTins_.getRawArray().size() << " != " <<
                static_cast<size_t>(6) << "!";
    }
    m_surfaceTins_.write(*this, out);
}

void BdamSurface::write(BdamSurface::ZserioPackingContext&, ::zserio::BitStreamWriter& out) const
{
    out.writeBool(m_hasRegularVertexGrid_);

    if (getHasRegularVertexGrid() == true)
    {
        // check array length
        if (m_regularVertexGrid_.value().getRawArray().size() != static_cast<size_t>(funcNumGridVertices()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field BdamSurface.regularVertexGrid: ") <<
                    m_regularVertexGrid_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(funcNumGridVertices()) << "!";
        }
        m_regularVertexGrid_.value().writePacked(*this, out);
    }

    m_vertices_.writePacked(*this, out);

    // check array length
    if (m_normals_.getRawArray().size() != static_cast<size_t>(getVertices().size()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field BdamSurface.normals: ") <<
                m_normals_.getRawArray().size() << " != " <<
                static_cast<size_t>(getVertices().size()) << "!";
    }
    m_normals_.writePacked(*this, out);

    if (getHeader().getHasTexture() == true)
    {
        // check array length
        if (m_textureCoordinates_.value().getRawArray().size() != static_cast<size_t>(getVertices().size()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field BdamSurface.textureCoordinates: ") <<
                    m_textureCoordinates_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getVertices().size()) << "!";
        }
        m_textureCoordinates_.value().write(*this, out);
    }

    // check array length
    if (m_surfaceTins_.getRawArray().size() != static_cast<size_t>(6))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field BdamSurface.surfaceTins: ") <<
                m_surfaceTins_.getRawArray().size() << " != " <<
                static_cast<size_t>(6) << "!";
    }
    m_surfaceTins_.writePacked(*this, out);
}

void BdamSurface::ZserioArrayExpressions_regularVertexGrid::initializeElement(BdamSurface& owner,
        ::nds::display::types::RegularGridVertex& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getHeader().getShiftZ()), static_cast<bool>(owner.getHeader().getHasTexture()));
}

void BdamSurface::ZserioElementFactory_regularVertexGrid::create(BdamSurface&         owner,
        ::zserio::vector<::nds::display::types::RegularGridVertex>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getHeader().getShiftZ()), static_cast<bool>(owner.getHeader().getHasTexture()), array.get_allocator());
}

void BdamSurface::ZserioElementFactory_regularVertexGrid::create(BdamSurface&         owner,
        ::zserio::vector<::nds::display::types::RegularGridVertex>& array,
        ::nds::display::types::RegularGridVertex::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getHeader().getShiftZ()), static_cast<bool>(owner.getHeader().getHasTexture()), array.get_allocator());
}

void BdamSurface::ZserioArrayExpressions_vertices::initializeElement(BdamSurface& owner,
        ::nds::core::geometry::Position3D& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getHeader().getShiftXY()), static_cast<::nds::core::geometry::CoordShift>(owner.getHeader().getShiftZ()));
}

void BdamSurface::ZserioElementFactory_vertices::create(BdamSurface&         owner,
        ::zserio::vector<::nds::core::geometry::Position3D>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getHeader().getShiftXY()), static_cast<::nds::core::geometry::CoordShift>(owner.getHeader().getShiftZ()), array.get_allocator());
}

void BdamSurface::ZserioElementFactory_vertices::create(BdamSurface&         owner,
        ::zserio::vector<::nds::core::geometry::Position3D>& array,
        ::nds::core::geometry::Position3D::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getHeader().getShiftXY()), static_cast<::nds::core::geometry::CoordShift>(owner.getHeader().getShiftZ()), array.get_allocator());
}

void BdamSurface::ZserioElementFactory_normals::create(BdamSurface&        ,
        ::zserio::vector<::nds::display::types::NormalSphere>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void BdamSurface::ZserioElementFactory_normals::create(BdamSurface&        ,
        ::zserio::vector<::nds::display::types::NormalSphere>& array,
        ::nds::display::types::NormalSphere::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void BdamSurface::ZserioElementFactory_textureCoordinates::create(BdamSurface&        ,
        ::zserio::vector<::nds::display::types::TextureCoords>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void BdamSurface::ZserioArrayExpressions_surfaceTins::initializeElement(BdamSurface& owner,
        ::nds::display::types::BdamSurfaceTin& element, size_t)
{
    element.initialize(static_cast<uint8_t>(::zserio::builtin::numBits(owner.funcNumVertices())));
}

void BdamSurface::ZserioElementFactory_surfaceTins::create(BdamSurface&         owner,
        ::zserio::vector<::nds::display::types::BdamSurfaceTin>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<uint8_t>(::zserio::builtin::numBits(owner.funcNumVertices())), array.get_allocator());
}

void BdamSurface::ZserioElementFactory_surfaceTins::create(BdamSurface&         owner,
        ::zserio::vector<::nds::display::types::BdamSurfaceTin>& array,
        ::nds::display::types::BdamSurfaceTin::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<uint8_t>(::zserio::builtin::numBits(owner.funcNumVertices())), array.get_allocator());
}

bool BdamSurface::readHasRegularVertexGrid(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
::zserio::InplaceOptionalHolder<BdamSurface::ZserioArrayType_regularVertexGrid> BdamSurface::readRegularVertexGrid(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getHasRegularVertexGrid() == true)
    {
        ZserioArrayType_regularVertexGrid readField(allocator);
        readField.readPacked(*this, in, static_cast<size_t>(funcNumGridVertices()));

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_regularVertexGrid>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_regularVertexGrid>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<BdamSurface::ZserioArrayType_regularVertexGrid> BdamSurface::readRegularVertexGrid(BdamSurface::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getHasRegularVertexGrid() == true)
    {
        ZserioArrayType_regularVertexGrid readField(allocator);
        readField.readPacked(*this, in, static_cast<size_t>(funcNumGridVertices()));

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_regularVertexGrid>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_regularVertexGrid>(::zserio::NullOpt);
}
BdamSurface::ZserioArrayType_vertices BdamSurface::readVertices(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_vertices readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}

BdamSurface::ZserioArrayType_vertices BdamSurface::readVertices(BdamSurface::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_vertices readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}
BdamSurface::ZserioArrayType_normals BdamSurface::readNormals(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_normals readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getVertices().size()));

    return readField;
}

BdamSurface::ZserioArrayType_normals BdamSurface::readNormals(BdamSurface::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_normals readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getVertices().size()));

    return readField;
}
::zserio::InplaceOptionalHolder<BdamSurface::ZserioArrayType_textureCoordinates> BdamSurface::readTextureCoordinates(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getHeader().getHasTexture() == true)
    {
        ZserioArrayType_textureCoordinates readField(allocator);
        readField.read(*this, in, static_cast<size_t>(getVertices().size()));

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_textureCoordinates>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_textureCoordinates>(::zserio::NullOpt);
}
BdamSurface::ZserioArrayType_surfaceTins BdamSurface::readSurfaceTins(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_surfaceTins readField(allocator);
    readField.read(*this, in, static_cast<size_t>(6));

    return readField;
}

BdamSurface::ZserioArrayType_surfaceTins BdamSurface::readSurfaceTins(BdamSurface::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_surfaceTins readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(6));

    return readField;
}

} // namespace types
} // namespace display
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/display/types/BdamSurfaceTin.h>

namespace nds
{
namespace display
{
namespace types
{

BdamSurfaceTin::BdamSurfaceTin(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_renderSurfaces_(allocator),
        m_indices_(allocator)
{
}

BdamSurfaceTin::BdamSurfaceTin(::zserio::BitStreamReader& in,
        uint8_t numIndexBits_, const allocator_type& allocator) :
        m_numIndexBits_(numIndexBits_),
        m_isInitialized(true),
        m_renderSurfaces_(readRenderSurfaces(in, allocator)),
        m_indices_(readIndices(in, allocator))
{
}

BdamSurfaceTin::BdamSurfaceTin(BdamSurfaceTin::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        uint8_t numIndexBits_, const allocator_type& allocator) :
        m_numIndexBits_(numIndexBits_),
        m_isInitialized(true),
        m_renderSurfaces_(readRenderSurfaces(context, in, allocator)),
        m_indices_(readIndices(context, in, allocator))
{
}

BdamSurfaceTin::BdamSurfaceTin(const BdamSurfaceTin& other) :
        m_renderSurfaces_(other.m_renderSurfaces_),
        m_indices_(other.m_indices_)
{
    if (other.m_isInitialized)
        initialize(other.m_numIndexBits_);
    else
        m_isInitialized = false;
}

BdamSurfaceTin& BdamSurfaceTin::operator=(const BdamSurfaceTin& other)
{
    m_renderSurfaces_ = other.m_renderSurfaces_;
    m_indices_ = other.m_indices_;
    if (other.m_isInitialized)
        initialize(other.m_numIndexBits_);
    else
        m_isInitialized = false;

    return *this;
}

BdamSurfaceTin::BdamSurfaceTin(BdamSurfaceTin&& other) :
        m_renderSurfaces_(::std::move(other.m_renderSurfaces_)),
        m_indices_(::std::move(other.m_indices_))
{
    if (other.m_isInitialized)
        initialize(other.m_numIndexBits_);
    else
        m_isInitialized = false;
}

BdamSurfaceTin& BdamSurfaceTin::operator=(BdamSurfaceTin&& other)
{
    m_renderSurfaces_ = ::std::move(other.m_renderSurfaces_);
    m_indices_ = ::std::move(other.m_indices_);
    if (other.m_isInitialized)
        initialize(other.m_numIndexBits_);
    else
        m_isInitialized = false;

    return *this;
}

BdamSurfaceTin::BdamSurfaceTin(::zserio::PropagateAllocatorT,
        const BdamSurfaceTin& other, const allocator_type& allocator) :
        m_renderSurfaces_(::zserio::allocatorPropagatingCopy(other.m_renderSurfaces_, allocator)),
        m_indices_(::zserio::allocatorPropagatingCopy(other.m_indices_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_numIndexBits_);
    else
        m_isInitialized = false;
}

void BdamSurfaceTin::initialize(
        uint8_t numIndexBits_)
{
    m_numIndexBits_ = numIndexBits_;
    m_isInitialized = true;

    initializeChildren();
}

bool BdamSurfaceTin::isInitialized() const
{
    return m_isInitialized;
}

void BdamSurfaceTin::initializeChildren()
{
    m_renderSurfaces_.initializeElements(*this);
}

uint8_t BdamSurfaceTin::getNumIndexBits() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'numIndexBits' of compound 'BdamSurfaceTin' is not initialized!");

    return m_numIndexBits_;
}

::zserio::vector<::nds::display::types::RenderSurface>& BdamSurfaceTin::getRenderSurfaces()
{
    return m_renderSurfaces_.getRawArray();
}

const ::zserio::vector<::nds::display::types::RenderSurface>& BdamSurfaceTin::getRenderSurfaces() const
{
    return m_renderSurfaces_.getRawArray();
}

void BdamSurfaceTin::setRenderSurfaces(const ::zserio::vector<::nds::display::types::RenderSurface>& renderSurfaces_)
{
    m_renderSurfaces_ = ZserioArrayType_renderSurfaces(renderSurfaces_);
}

void BdamSurfaceTin::setRenderSurfaces(::zserio::vector<::nds::display::types::RenderSurface>&& renderSurfaces_)
{
    m_renderSurfaces_ = ZserioArrayType_renderSurfaces(std::move(renderSurfaces_));
}

::zserio::vector<uint32_t>& BdamSurfaceTin::getIndices()
{
    return m_indices_.getRawArray();
}

const ::zserio::vector<uint32_t>& BdamSurfaceTin::getIndices() const
{
    return m_indices_.getRawArray();
}

void BdamSurfaceTin::setIndices(const ::zserio::vector<uint32_t>& indices_)
{
    m_indices_ = ZserioArrayType_indices(indices_);
}

void BdamSurfaceTin::setIndices(::zserio::vector<uint32_t>&& indices_)
{
    m_indices_ = ZserioArrayType_indices(std::move(indices_));
}

void BdamSurfaceTin::initPackingContext(BdamSurfaceTin::ZserioPackingContext&) const
{
}

size_t BdamSurfaceTin::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_renderSurfaces_.bitSizeOf(*this, endBitPosition);
    endBitPosition += m_indices_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t BdamSurfaceTin::bitSizeOf(BdamSurfaceTin::ZserioPackingContext&, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_renderSurfaces_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_indices_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t BdamSurfaceTin::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_renderSurfaces_.initializeOffsets(*this, endBitPosition);
    endBitPosition = m_indices_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t BdamSurfaceTin::initializeOffsets(BdamSurfaceTin::ZserioPackingContext&, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_renderSurfaces_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_indices_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool BdamSurfaceTin::operator==(const BdamSurfaceTin& other) const
{
    if (this != &other)
    {
        return
                (getNumIndexBits() == other.getNumIndexBits()) &&
                (m_renderSurfaces_ == other.m_renderSurfaces_) &&
                (m_indices_ == other.m_indices_);
    }

    return true;
}

uint32_t BdamSurfaceTin::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getNumIndexBits());
    result = ::zserio::calcHashCode(result, m_renderSurfaces_);
    result = ::zserio::calcHashCode(result, m_indices_);

    return result;
}

void BdamSurfaceTin::write(::zserio::BitStreamWriter& out) const
{
    m_renderSurfaces_.write(*this, out);
    m_indices_.writePacked(*this, out);
}

void BdamSurfaceTin::write(BdamSurfaceTin::ZserioPackingContext&, ::zserio::BitStreamWriter& out) const
{
    m_renderSurfaces_.writePacked(*this, out);
    m_indices_.writePacked(*this, out);
}

void BdamSurfaceTin::ZserioArrayExpressions_renderSurfaces::initializeElement(BdamSurfaceTin& owner,
        ::nds::display::types::RenderSurface& element, size_t)
{
    element.initialize(static_cast<uint8_t>(owner.getNumIndexBits()));
}

void BdamSurfaceTin::ZserioElementFactory_renderSurfaces::create(BdamSurfaceTin&         owner,
        ::zserio::vector<::nds::display::types::RenderSurface>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<uint8_t>(owner.getNumIndexBits()), array.get_allocator());
}

void BdamSurfaceTin::ZserioElementFactory_renderSurfaces::create(BdamSurfaceTin&         owner,
        ::zserio::vector<::nds::display::types::RenderSurface>& array,
        ::nds::display::types::RenderSurface::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<uint8_t>(owner.getNumIndexBits()), array.get_allocator());
}

uint8_t BdamSurfaceTin::ZserioElementBitSize_indices::get(const BdamSurfaceTin& owner)
{
    return static_cast<uint8_t>(owner.getNumIndexBits() + 1);
}

BdamSurfaceTin::ZserioArrayType_renderSurfaces BdamSurfaceTin::readRenderSurfaces(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_renderSurfaces readField(allocator);
    readField.read(*this, in);

    return readField;
}

BdamSurfaceTin::ZserioArrayType_renderSurfaces BdamSurfaceTin::readRenderSurfaces(BdamSurfaceTin::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_renderSurfaces readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}
BdamSurfaceTin::ZserioArrayType_indices BdamSurfaceTin::readIndices(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_indices readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}

BdamSurfaceTin::ZserioArrayType_indices BdamSurfaceTin::readIndices(BdamSurfaceTin::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_indices readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}

} // namespace types
} // namespace display
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ConstraintException.h>

#include <nds/display/types/RenderSurface.h>

namespace nds
{
namespace display
{
namespace types
{

RenderSurface::RenderSurface(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_areaType_(::nds::display::types::DisplayAreaType()),
        m_renderSurfaceParts_(allocator)
{
}

RenderSurface::RenderSurface(::zserio::BitStreamReader& in,
        uint8_t numIndexBits_, const allocator_type& allocator) :
        m_numIndexBits_(numIndexBits_),
        m_isInitialized(true),
        m_areaType_(readAreaType(in)),
        m_renderSurfaceParts_(readRenderSurfaceParts(in, allocator))
{
}

RenderSurface::RenderSurface(RenderSurface::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        uint8_t numIndexBits_, const allocator_type& allocator) :
        m_numIndexBits_(numIndexBits_),
        m_isInitialized(true),
        m_areaType_(readAreaType(context, in)),
        m_renderSurfaceParts_(readRenderSurfaceParts(context, in, allocator))
{
}

RenderSurface::RenderSurface(const RenderSurface& other) :
        m_areaType_(other.m_areaType_),
        m_renderSurfaceParts_(other.m_renderSurfaceParts_)
{
    if (other.m_isInitialized)
        initialize(other.m_numIndexBits_);
    else
        m_isInitialized = false;
}

RenderSurface& RenderSurface::operator=(const RenderSurface& other)
{
    m_areaType_ = other.m_areaType_;
    m_renderSurfaceParts_ = other.m_renderSurfaceParts_;
    if (other.m_isInitialized)
        initialize(other.m_numIndexBits_);
    else
        m_isInitialized = false;

    return *this;
}

RenderSurface::RenderSurface(RenderSurface&& other) :
        m_areaType_(::std::move(other.m_areaType_)),
        m_renderSurfaceParts_(::std::move(other.m_renderSurfaceParts_))
{
    if (other.m_isInitialized)
        initialize(other.m_numIndexBits_);
    else
        m_isInitialized = false;
}

RenderSurface& RenderSurface::operator=(RenderSurface&& other)
{
    m_areaType_ = ::std::move(other.m_areaType_);
    m_renderSurfaceParts_ = ::std::move(other.m_renderSurfaceParts_);
    if (other.m_isInitialized)
        initialize(other.m_numIndexBits_);
    else
        m_isInitialized = false;

    return *this;
}

RenderSurface::RenderSurface(::zserio::PropagateAllocatorT,
        const RenderSurface& other, const allocator_type& allocator) :
        m_areaType_(::zserio::allocatorPropagatingCopy(other.m_areaType_, allocator)),
        m_renderSurfaceParts_(::zserio::allocatorPropagatingCopy(other.m_renderSurfaceParts_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_numIndexBits_);
    else
        m_isInitialized = false;
}

void RenderSurface::initialize(
        uint8_t numIndexBits_)
{
    m_numIndexBits_ = numIndexBits_;
    m_isInitialized = true;

    initializeChildren();
}

bool RenderSurface::isInitialized() const
{
    return m_isInitialized;
}

void RenderSurface::initializeChildren()
{
    m_renderSurfaceParts_.initializeElements(*this);
}

uint8_t RenderSurface::getNumIndexBits() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'numIndexBits' of compound 'RenderSurface' is not initialized!");

    return m_numIndexBits_;
}

::nds::display::types::DisplayAreaType RenderSurface::getAreaType() const
{
    return m_areaType_;
}

void RenderSurface::setAreaType(::nds::display::types::DisplayAreaType areaType_)
{
    m_areaType_ = areaType_;
}

::zserio::vector<::nds::display::types::RenderSurfacePart>& RenderSurface::getRenderSurfaceParts()
{
    return m_renderSurfaceParts_.getRawArray();
}

const ::zserio::vector<::nds::display::types::RenderSurfacePart>& RenderSurface::getRenderSurfaceParts() const
{
    return m_renderSurfaceParts_.getRawArray();
}

void RenderSurface::setRenderSurfaceParts(const ::zserio::vector<::nds::display::types::RenderSurfacePart>& renderSurfaceParts_)
{
    m_renderSurfaceParts_ = ZserioArrayType_renderSurfaceParts(renderSurfaceParts_);
}

void RenderSurface::setRenderSurfaceParts(::zserio::vector<::nds::display::types::RenderSurfacePart>&& renderSurfaceParts_)
{
    m_renderSurfaceParts_ = ZserioArrayType_renderSurfaceParts(std::move(renderSurfaceParts_));
}

void RenderSurface::initPackingContext(RenderSurface::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getAreaType(), m_areaType_);
}

size_t RenderSurface::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_areaType_);
    endBitPosition += m_renderSurfaceParts_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RenderSurface::bitSizeOf(RenderSurface::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getAreaType(), m_areaType_);
    endBitPosition += m_renderSurfaceParts_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RenderSurface::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_areaType_);
    endBitPosition = m_renderSurfaceParts_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t RenderSurface::initializeOffsets(RenderSurface::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getAreaType(), endBitPosition,
        m_areaType_);
    endBitPosition = m_renderSurfaceParts_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RenderSurface::operator==(const RenderSurface& other) const
{
    if (this != &other)
    {
        return
                (getNumIndexBits() == other.getNumIndexBits()) &&
                (m_areaType_ == other.m_areaType_) &&
                (m_renderSurfaceParts_ == other.m_renderSurfaceParts_);
    }

    return true;
}

uint32_t RenderSurface::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getNumIndexBits());
    result = ::zserio::calcHashCode(result, m_areaType_);
    result = ::zserio::calcHashCode(result, m_renderSurfaceParts_);

    return result;
}

void RenderSurface::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_areaType_);

    // check constraint
    if (!(getRenderSurfaceParts().size() > 0))
        throw ::zserio::ConstraintException("Write: Constraint violated at RenderSurface.renderSurfaceParts!");
    m_renderSurfaceParts_.write(*this, out);
}

void RenderSurface::write(RenderSurface::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getAreaType(), out, m_areaType_);

    // check constraint
    if (!(getRenderSurfaceParts().size() > 0))
        throw ::zserio::ConstraintException("Write: Constraint violated at RenderSurface.renderSurfaceParts!");
    m_renderSurfaceParts_.writePacked(*this, out);
}

void RenderSurface::ZserioArrayExpressions_renderSurfaceParts::initializeElement(RenderSurface& owner,
        ::nds::display::types::RenderSurfacePart& element, size_t)
{
    element.initialize(static_cast<uint8_t>(owner.getNumIndexBits()));
}

void RenderSurface::ZserioElementFactory_renderSurfaceParts::create(RenderSurface&         owner,
        ::zserio::vector<::nds::display::types::RenderSurfacePart>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<uint8_t>(owner.getNumIndexBits()), array.get_allocator());
}

void RenderSurface::ZserioElementFactory_renderSurfaceParts::create(RenderSurface&         owner,
        ::zserio::vector<::nds::display::types::RenderSurfacePart>& array,
        ::nds::display::types::RenderSurfacePart::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<uint8_t>(owner.getNumIndexBits()), array.get_allocator());
}

::nds::display::types::DisplayAreaType RenderSurface::readAreaType(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::display::types::DisplayAreaType>(in);
}

::nds::display::types::DisplayAreaType RenderSurface::readAreaType(RenderSurface::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::display::types::DisplayAreaType>(context.getAreaType(), in);
}
RenderSurface::ZserioArrayType_renderSurfaceParts RenderSurface::readRenderSurfaceParts(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_renderSurfaceParts readField(allocator);
    readField.read(*this, in);
    // check constraint
    if (!(readField.getRawArray().size() > 0))
        throw ::zserio::ConstraintException("Read: Constraint violated at RenderSurface.renderSurfaceParts!");

    return readField;
}

RenderSurface::ZserioArrayType_renderSurfaceParts RenderSurface::readRenderSurfaceParts(RenderSurface::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_renderSurfaceParts readField(allocator);
    readField.readPacked(*this, in);
    // check constraint
    if (!(readField.getRawArray().size() > 0))
        throw ::zserio::ConstraintException("Read: Constraint violated at RenderSurface.renderSurfaceParts!");

    return readField;
}

} // namespace types
} // namespace display
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/display/types/RenderSurfacePart.h>

namespace nds
{
namespace display
{
namespace types
{

RenderSurfacePart::RenderSurfacePart(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_material_(::zserio::NullOpt),
        m_indices_(allocator)
{
}

RenderSurfacePart::RenderSurfacePart(::zserio::BitStreamReader& in,
        uint8_t numIndexBits_, const allocator_type& allocator) :
        m_numIndexBits_(numIndexBits_),
        m_isInitialized(true),
        m_material_(readMaterial(in, allocator)),
        m_indices_(readIndices(in, allocator))
{
}

RenderSurfacePart::RenderSurfacePart(RenderSurfacePart::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        uint8_t numIndexBits_, const allocator_type& allocator) :
        m_numIndexBits_(numIndexBits_),
        m_isInitialized(true),
        m_material_(readMaterial(context, in, allocator)),
        m_indices_(readIndices(context, in, allocator))
{
}

RenderSurfacePart::RenderSurfacePart(const RenderSurfacePart& other) :
        m_material_(other.m_material_),
        m_indices_(other.m_indices_)
{
    if (other.m_isInitialized)
        initialize(other.m_numIndexBits_);
    else
        m_isInitialized = false;
}

RenderSurfacePart& RenderSurfacePart::operator=(const RenderSurfacePart& other)
{
    m_material_ = other.m_material_;
    m_indices_ = other.m_indices_;
    if (other.m_isInitialized)
        initialize(other.m_numIndexBits_);
    else
        m_isInitialized = false;

    return *this;
}

RenderSurfacePart::RenderSurfacePart(RenderSurfacePart&& other) :
        m_material_(::std::move(other.m_material_)),
        m_indices_(::std::move(other.m_indices_))
{
    if (other.m_isInitialized)
        initialize(other.m_numIndexBits_);
    else
        m_isInitialized = false;
}

RenderSurfacePart& RenderSurfacePart::operator=(RenderSurfacePart&& other)
{
    m_material_ = ::std::move(other.m_material_);
    m_indices_ = ::std::move(other.m_indices_);
    if (other.m_isInitialized)
        initialize(other.m_numIndexBits_);
    else
        m_isInitialized = false;

    return *this;
}

RenderSurfacePart::RenderSurfacePart(::zserio::PropagateAllocatorT,
        const RenderSurfacePart& other, const allocator_type& allocator) :
        m_material_(::zserio::allocatorPropagatingCopy(other.m_material_, allocator)),
        m_indices_(::zserio::allocatorPropagatingCopy(other.m_indices_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_numIndexBits_);
    else
        m_isInitialized = false;
}

void RenderSurfacePart::initialize(
        uint8_t numIndexBits_)
{
    m_numIndexBits_ = numIndexBits_;
    m_isInitialized = true;
}

bool RenderSurfacePart::isInitialized() const
{
    return m_isInitialized;
}

uint8_t RenderSurfacePart::getNumIndexBits() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'numIndexBits' of compound 'RenderSurfacePart' is not initialized!");

    return m_numIndexBits_;
}

::nds::display::types::Material& RenderSurfacePart::getMaterial()
{
    return m_material_.value();
}

const ::nds::display::types::Material& RenderSurfacePart::getMaterial() const
{
    return m_material_.value();
}

void RenderSurfacePart::setMaterial(const ::nds::display::types::Material& material_)
{
    m_material_ = material_;
}

void RenderSurfacePart::setMaterial(::nds::display::types::Material&& material_)
{
    m_material_ = ::std::move(material_);
}

bool RenderSurfacePart::isMaterialUsed() const
{
    return (isMaterialSet());
}

bool RenderSurfacePart::isMaterialSet() const
{
    return m_material_.hasValue();
}

void RenderSurfacePart::resetMaterial()
{
    m_material_.reset();
}

::zserio::vector<uint32_t>& RenderSurfacePart::getIndices()
{
    return m_indices_.getRawArray();
}

const ::zserio::vector<uint32_t>& RenderSurfacePart::getIndices() const
{
    return m_indices_.getRawArray();
}

void RenderSurfacePart::setIndices(const ::zserio::vector<uint32_t>& indices_)
{
    m_indices_ = ZserioArrayType_indices(indices_);
}

void RenderSurfacePart::setIndices(::zserio::vector<uint32_t>&& indices_)
{
    m_indices_ = ZserioArrayType_indices(std::move(indices_));
}

void RenderSurfacePart::initPackingContext(RenderSurfacePart::ZserioPackingContext& context) const
{
    if (isMaterialSet())
    {
        m_material_.value().initPackingContext(context.getMaterial());
    }
}

size_t RenderSurfacePart::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += 1;
    if (isMaterialSet())
    {
        endBitPosition += m_material_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_indices_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RenderSurfacePart::bitSizeOf(RenderSurfacePart::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += 1;
    if (isMaterialSet())
    {
        endBitPosition += m_material_.value().bitSizeOf(context.getMaterial(), endBitPosition);
    }
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_indices_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RenderSurfacePart::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += 1;
    if (isMaterialSet())
    {
        endBitPosition = m_material_.value().initializeOffsets(endBitPosition);
    }
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_indices_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RenderSurfacePart::initializeOffsets(RenderSurfacePart::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += 1;
    if (isMaterialSet())
    {
        endBitPosition = m_material_.value().initializeOffsets(context.getMaterial(), endBitPosition);
    }
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_indices_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RenderSurfacePart::operator==(const RenderSurfacePart& other) const
{
    if (this != &other)
    {
        return
                (getNumIndexBits() == other.getNumIndexBits()) &&
                (!isMaterialUsed() ? !other.isMaterialUsed() : (m_material_ == other.m_material_)) &&
                (m_indices_ == other.m_indices_);
    }

    return true;
}

uint32_t RenderSurfacePart::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getNumIndexBits());
    if (isMaterialUsed())
        result = ::zserio::calcHashCode(result, m_material_);
    result = ::zserio::calcHashCode(result, m_indices_);

    return result;
}

void RenderSurfacePart::write(::zserio::BitStreamWriter& out) const
{
    if (isMaterialSet())
    {
        out.writeBool(true);
        m_material_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
    out.alignTo(8);
    m_indices_.writePacked(*this, out);
}

void RenderSurfacePart::write(RenderSurfacePart::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    if (isMaterialSet())
    {
        out.writeBool(true);
        m_material_.value().write(context.getMaterial(), out);
    }
    else
    {
        out.writeBool(false);
    }
    out.alignTo(8);
    m_indices_.writePacked(*this, out);
}

uint8_t RenderSurfacePart::ZserioElementBitSize_indices::get(const RenderSurfacePart& owner)
{
    return static_cast<uint8_t>(owner.getNumIndexBits() + 1);
}

::zserio::InplaceOptionalHolder<::nds::display::types::Material> RenderSurfacePart::readMaterial(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::display::types::Material>(::nds::display::types::Material(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::display::types::Material>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::display::types::Material> RenderSurfacePart::readMaterial(RenderSurfacePart::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::display::types::Material>(::nds::display::types::Material(context.getMaterial(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::display::types::Material>(::zserio::NullOpt);
}
RenderSurfacePart::ZserioArrayType_indices RenderSurfacePart::readIndices(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_indices readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}

RenderSurfacePart::ZserioArrayType_indices RenderSurfacePart::readIndices(RenderSurfacePart::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_indices readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}

} // namespace types
} // namespace display
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/display/types/RegularGridVertex.h>

namespace nds
{
namespace display
{
namespace types
{

RegularGridVertex::RegularGridVertex(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_elevation_(int32_t()),
        m_normal_(allocator),
        m_textureCoord_(::zserio::NullOpt)
{
}

RegularGridVertex::RegularGridVertex(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift shiftZ_,
        bool hasTexture_, const allocator_type& allocator) :
        m_shiftZ_(shiftZ_),
        m_hasTexture_(hasTexture_),
        m_isInitialized(true),
        m_elevation_(readElevation(in)),
        m_normal_(readNormal(in, allocator)),
        m_textureCoord_(readTextureCoord(in, allocator))
{
}

RegularGridVertex::RegularGridVertex(RegularGridVertex::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift shiftZ_,
        bool hasTexture_, const allocator_type& allocator) :
        m_shiftZ_(shiftZ_),
        m_hasTexture_(hasTexture_),
        m_isInitialized(true),
        m_elevation_(readElevation(context, in)),
        m_normal_(readNormal(context, in, allocator)),
        m_textureCoord_(readTextureCoord(in, allocator))
{
}

RegularGridVertex::RegularGridVertex(const RegularGridVertex& other) :
        m_elevation_(other.m_elevation_),
        m_normal_(other.m_normal_),
        m_textureCoord_(other.m_textureCoord_)
{
    if (other.m_isInitialized)
        initialize(other.m_shiftZ_, other.m_hasTexture_);
    else
        m_isInitialized = false;
}

RegularGridVertex& RegularGridVertex::operator=(const RegularGridVertex& other)
{
    m_elevation_ = other.m_elevation_;
    m_normal_ = other.m_normal_;
    m_textureCoord_ = other.m_textureCoord_;
    if (other.m_isInitialized)
        initialize(other.m_shiftZ_, other.m_hasTexture_);
    else
        m_isInitialized = false;

    return *this;
}

RegularGridVertex::RegularGridVertex(RegularGridVertex&& other) :
        m_elevation_(::std::move(other.m_elevation_)),
        m_normal_(::std::move(other.m_normal_)),
        m_textureCoord_(::std::move(other.m_textureCoord_))
{
    if (other.m_isInitialized)
        initialize(other.m_shiftZ_, other.m_hasTexture_);
    else
        m_isInitialized = false;
}

RegularGridVertex& RegularGridVertex::operator=(RegularGridVertex&& other)
{
    m_elevation_ = ::std::move(other.m_elevation_);
    m_normal_ = ::std::move(other.m_normal_);
    m_textureCoord_ = ::std::move(other.m_textureCoord_);
    if (other.m_isInitialized)
        initialize(other.m_shiftZ_, other.m_hasTexture_);
    else
        m_isInitialized = false;

    return *this;
}

RegularGridVertex::RegularGridVertex(::zserio::PropagateAllocatorT,
        const RegularGridVertex& other, const allocator_type& allocator) :
        m_elevation_(::zserio::allocatorPropagatingCopy(other.m_elevation_, allocator)),
        m_normal_(::zserio::allocatorPropagatingCopy(other.m_normal_, allocator)),
        m_textureCoord_(::zserio::allocatorPropagatingCopy(other.m_textureCoord_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_shiftZ_, other.m_hasTexture_);
    else
        m_isInitialized = false;
}

void RegularGridVertex::initialize(
        ::nds::core::geometry::CoordShift shiftZ_,
        bool hasTexture_)
{
    m_shiftZ_ = shiftZ_;
    m_hasTexture_ = hasTexture_;
    m_isInitialized = true;
}

bool RegularGridVertex::isInitialized() const
{
    return m_isInitialized;
}

::nds::core::geometry::CoordShift RegularGridVertex::getShiftZ() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'shiftZ' of compound 'RegularGridVertex' is not initialized!");

    return m_shiftZ_;
}

bool RegularGridVertex::getHasTexture() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'hasTexture' of compound 'RegularGridVertex' is not initialized!");

    return m_hasTexture_;
}

int32_t RegularGridVertex::getElevation() const
{
    return m_elevation_;
}

void RegularGridVertex::setElevation(int32_t elevation_)
{
    m_elevation_ = elevation_;
}

::nds::display::types::NormalSphere& RegularGridVertex::getNormal()
{
    return m_normal_;
}

const ::nds::display::types::NormalSphere& RegularGridVertex::getNormal() const
{
    return m_normal_;
}

void RegularGridVertex::setNormal(const ::nds::display::types::NormalSphere& normal_)
{
    m_normal_ = normal_;
}

void RegularGridVertex::setNormal(::nds::display::types::NormalSphere&& normal_)
{
    m_normal_ = ::std::move(normal_);
}

::nds::display::types::TextureCoords& RegularGridVertex::getTextureCoord()
{
    return m_textureCoord_.value();
}

const ::nds::display::types::TextureCoords& RegularGridVertex::getTextureCoord() const
{
    return m_textureCoord_.value();
}

void RegularGridVertex::setTextureCoord(const ::nds::display::types::TextureCoords& textureCoord_)
{
    m_textureCoord_ = textureCoord_;
}

void RegularGridVertex::setTextureCoord(::nds::display::types::TextureCoords&& textureCoord_)
{
    m_textureCoord_ = ::std::move(textureCoord_);
}

bool RegularGridVertex::isTextureCoordUsed() const
{
    return (getHasTexture() == true);
}

bool RegularGridVertex::isTextureCoordSet() const
{
    return m_textureCoord_.hasValue();
}

void RegularGridVertex::resetTextureCoord()
{
    m_textureCoord_.reset();
}

void RegularGridVertex::initPackingContext(RegularGridVertex::ZserioPackingContext& context) const
{
    context.getElevation().init<::zserio::DynamicBitFieldArrayTraits<int32_t, ZserioElementBitSize_elevation>>(*this, m_elevation_);
    m_normal_.initPackingContext(context.getNormal());
}

size_t RegularGridVertex::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += static_cast<uint8_t>(31 - getShiftZ() + 1);
    endBitPosition += m_normal_.bitSizeOf(endBitPosition);
    if (getHasTexture() == true)
    {
        endBitPosition += m_textureCoord_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t RegularGridVertex::bitSizeOf(RegularGridVertex::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getElevation().bitSizeOf<::zserio::DynamicBitFieldArrayTraits<int32_t, ZserioElementBitSize_elevation>>(*this, m_elevation_);
    endBitPosition += m_normal_.bitSizeOf(context.getNormal(), endBitPosition);
    if (getHasTexture() == true)
    {
        endBitPosition += m_textureCoord_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t RegularGridVertex::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += static_cast<uint8_t>(31 - getShiftZ() + 1);
    endBitPosition = m_normal_.initializeOffsets(endBitPosition);
    if (getHasTexture() == true)
    {
        endBitPosition = m_textureCoord_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

size_t RegularGridVertex::initializeOffsets(RegularGridVertex::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getElevation().bitSizeOf<::zserio::DynamicBitFieldArrayTraits<int32_t, ZserioElementBitSize_elevation>>(*this, m_elevation_);
    endBitPosition = m_normal_.initializeOffsets(context.getNormal(), endBitPosition);
    if (getHasTexture() == true)
    {
        endBitPosition = m_textureCoord_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

bool RegularGridVertex::operator==(const RegularGridVertex& other) const
{
    if (this != &other)
    {
        return
                (getShiftZ() == other.getShiftZ()) &&
                (getHasTexture() == other.getHasTexture()) &&
                (m_elevation_ == other.m_elevation_) &&
                (m_normal_ == other.m_normal_) &&
                (!isTextureCoordUsed() ? !other.isTextureCoordUsed() : (m_textureCoord_ == other.m_textureCoord_));
    }

    return true;
}

uint32_t RegularGridVertex::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getShiftZ());
    result = ::zserio::calcHashCode(result, getHasTexture());
    result = ::zserio::calcHashCode(result, m_elevation_);
    result = ::zserio::calcHashCode(result, m_normal_);
    if (isTextureCoordUsed())
        result = ::zserio::calcHashCode(result, m_textureCoord_);

    return result;
}

void RegularGridVertex::write(::zserio::BitStreamWriter& out) const
{
    out.writeSignedBits(m_elevation_, static_cast<uint8_t>(31 - getShiftZ() + 1));
    m_normal_.write(out);
    if (getHasTexture() == true)
    {
        m_textureCoord_.value().write(out);
    }
}

void RegularGridVertex::write(RegularGridVertex::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getElevation().write<::zserio::DynamicBitFieldArrayTraits<int32_t, ZserioElementBitSize_elevation>>(*this, out, m_elevation_);
    m_normal_.write(context.getNormal(), out);
    if (getHasTexture() == true)
    {
        m_textureCoord_.value().write(out);
    }
}

uint8_t RegularGridVertex::ZserioElementBitSize_elevation::get(const RegularGridVertex& owner)
{
    return static_cast<uint8_t>(31 - owner.getShiftZ() + 1);
}

int32_t RegularGridVertex::readElevation(::zserio::BitStreamReader& in)
{
    return static_cast<int32_t>(in.readSignedBits(static_cast<uint8_t>(31 - getShiftZ() + 1)));
}

int32_t RegularGridVertex::readElevation(RegularGridVertex::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getElevation().read<::zserio::DynamicBitFieldArrayTraits<int32_t, ZserioElementBitSize_elevation>>(*this, in);
}
::nds::display::types::NormalSphere RegularGridVertex::readNormal(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::display::types::NormalSphere(in, allocator);
}

::nds::display::types::NormalSphere RegularGridVertex::readNormal(RegularGridVertex::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::display::types::NormalSphere(context.getNormal(), in, allocator);
}
::zserio::InplaceOptionalHolder<::nds::display::types::TextureCoords> RegularGridVertex::readTextureCoord(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getHasTexture() == true)
    {
        return ::zserio::InplaceOptionalHolder<::nds::display::types::TextureCoords>(::nds::display::types::TextureCoords(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::display::types::TextureCoords>(::zserio::NullOpt);
}

} // namespace types
} // namespace display
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/display/types/OrthoImageConfig.h>

namespace nds
{
namespace display
{
namespace types
{

OrthoImageConfig::OrthoImageConfig(const allocator_type&) noexcept :
        m_format_(::nds::display::types::OrthoImageFormat()),
        m_sourceType_(::nds::display::types::OrthoImageContentType()),
        m_usageType_(::nds::display::types::OrthoImageConditionUsageType())
{
}

OrthoImageConfig::OrthoImageConfig(::zserio::BitStreamReader& in, const allocator_type&) :
        m_format_(readFormat(in)),
        m_sourceType_(readSourceType(in)),
        m_usageType_(readUsageType(in))
{
}

OrthoImageConfig::OrthoImageConfig(OrthoImageConfig::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type&) :
        m_format_(readFormat(context, in)),
        m_sourceType_(readSourceType(context, in)),
        m_usageType_(readUsageType(context, in))
{
}

OrthoImageConfig::OrthoImageConfig(::zserio::PropagateAllocatorT,
        const OrthoImageConfig& other, const allocator_type& allocator) :
        m_format_(::zserio::allocatorPropagatingCopy(other.m_format_, allocator)),
        m_sourceType_(::zserio::allocatorPropagatingCopy(other.m_sourceType_, allocator)),
        m_usageType_(::zserio::allocatorPropagatingCopy(other.m_usageType_, allocator))
{
}

::nds::display::types::OrthoImageFormat OrthoImageConfig::getFormat() const
{
    return m_format_;
}

void OrthoImageConfig::setFormat(::nds::display::types::OrthoImageFormat format_)
{
    m_format_ = format_;
}

::nds::display::types::OrthoImageContentType OrthoImageConfig::getSourceType() const
{
    return m_sourceType_;
}

void OrthoImageConfig::setSourceType(::nds::display::types::OrthoImageContentType sourceType_)
{
    m_sourceType_ = sourceType_;
}

::nds::display::types::OrthoImageConditionUsageType OrthoImageConfig::getUsageType() const
{
    return m_usageType_;
}

void OrthoImageConfig::setUsageType(::nds::display::types::OrthoImageConditionUsageType usageType_)
{
    m_usageType_ = usageType_;
}

void OrthoImageConfig::initPackingContext(OrthoImageConfig::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getFormat(), m_format_);
    ::zserio::initPackingContext(context.getSourceType(), m_sourceType_);
    m_usageType_.initPackingContext(context.getUsageType());
}

size_t OrthoImageConfig::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_format_);
    endBitPosition += ::zserio::bitSizeOf(m_sourceType_);
    endBitPosition += m_usageType_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t OrthoImageConfig::bitSizeOf(OrthoImageConfig::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getFormat(), m_format_);
    endBitPosition += ::zserio::bitSizeOf(context.getSourceType(), m_sourceType_);
    endBitPosition += m_usageType_.bitSizeOf(context.getUsageType(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t OrthoImageConfig::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_format_);
    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_sourceType_);
    endBitPosition = m_usageType_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t OrthoImageConfig::initializeOffsets(OrthoImageConfig::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getFormat(), endBitPosition,
        m_format_);
    endBitPosition = ::zserio::initializeOffsets(context.getSourceType(), endBitPosition,
        m_sourceType_);
    endBitPosition = m_usageType_.initializeOffsets(context.getUsageType(), endBitPosition);

    return endBitPosition;
}

bool OrthoImageConfig::operator==(const OrthoImageConfig& other) const
{
    if (this != &other)
    {
        return
                (m_format_ == other.m_format_) &&
                (m_sourceType_ == other.m_sourceType_) &&
                (m_usageType_ == other.m_usageType_);
    }

    return true;
}

uint32_t OrthoImageConfig::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_format_);
    result = ::zserio::calcHashCode(result, m_sourceType_);
    result = ::zserio::calcHashCode(result, m_usageType_);

    return result;
}

void OrthoImageConfig::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_format_);
    ::zserio::write(out, m_sourceType_);
    m_usageType_.write(out);
}

void OrthoImageConfig::write(OrthoImageConfig::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getFormat(), out, m_format_);
    ::zserio::write(context.getSourceType(), out, m_sourceType_);
    m_usageType_.write(context.getUsageType(), out);
}

::nds::display::types::OrthoImageFormat OrthoImageConfig::readFormat(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::display::types::OrthoImageFormat>(in);
}

::nds::display::types::OrthoImageFormat OrthoImageConfig::readFormat(OrthoImageConfig::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::display::types::OrthoImageFormat>(context.getFormat(), in);
}
::nds::display::types::OrthoImageContentType OrthoImageConfig::readSourceType(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::display::types::OrthoImageContentType>(in);
}

::nds::display::types::OrthoImageContentType OrthoImageConfig::readSourceType(OrthoImageConfig::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::display::types::OrthoImageContentType>(context.getSourceType(), in);
}
::nds::display::types::OrthoImageConditionUsageType OrthoImageConfig::readUsageType(::zserio::BitStreamReader& in)
{
    return ::nds::display::types::OrthoImageConditionUsageType(in);
}

::nds::display::types::OrthoImageConditionUsageType OrthoImageConfig::readUsageType(OrthoImageConfig::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::nds::display::types::OrthoImageConditionUsageType(context.getUsageType(), in);
}

} // namespace types
} // namespace display
} // namespace nds
