/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ConstraintException.h>
#include <zserio/ArrayTraits.h>

#include <nds/localization/layer/LandmarkLayer.h>
#include <nds/core/geometry/GeometryLayerType.h>
#include <nds/system/types/LayerType.h>

namespace nds
{
namespace localization
{
namespace layer
{

LandmarkLayer::LandmarkLayer(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_header_(allocator),
        m_lineGeometryLayer_(::zserio::NullOpt),
        m_polygonGeometryLayer_(::zserio::NullOpt),
        m_meshGeometryLayer_(::zserio::NullOpt)
{
}

LandmarkLayer::LandmarkLayer(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_header_(readHeader(in, allocator)),
        m_lineGeometryLayer_(readLineGeometryLayer(in, allocator)),
        m_polygonGeometryLayer_(readPolygonGeometryLayer(in, allocator)),
        m_meshGeometryLayer_(readMeshGeometryLayer(in, allocator))
{
}

LandmarkLayer::LandmarkLayer(LandmarkLayer::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_header_(readHeader(context, in, allocator)),
        m_lineGeometryLayer_(readLineGeometryLayer(context, in, allocator)),
        m_polygonGeometryLayer_(readPolygonGeometryLayer(context, in, allocator)),
        m_meshGeometryLayer_(readMeshGeometryLayer(context, in, allocator))
{
}

LandmarkLayer::LandmarkLayer(const LandmarkLayer& other) :
        m_header_(other.m_header_),
        m_lineGeometryLayer_(other.m_lineGeometryLayer_),
        m_polygonGeometryLayer_(other.m_polygonGeometryLayer_),
        m_meshGeometryLayer_(other.m_meshGeometryLayer_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

LandmarkLayer& LandmarkLayer::operator=(const LandmarkLayer& other)
{
    m_header_ = other.m_header_;
    m_lineGeometryLayer_ = other.m_lineGeometryLayer_;
    m_polygonGeometryLayer_ = other.m_polygonGeometryLayer_;
    m_meshGeometryLayer_ = other.m_meshGeometryLayer_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

LandmarkLayer::LandmarkLayer(LandmarkLayer&& other) :
        m_header_(::std::move(other.m_header_)),
        m_lineGeometryLayer_(::std::move(other.m_lineGeometryLayer_)),
        m_polygonGeometryLayer_(::std::move(other.m_polygonGeometryLayer_)),
        m_meshGeometryLayer_(::std::move(other.m_meshGeometryLayer_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

LandmarkLayer& LandmarkLayer::operator=(LandmarkLayer&& other)
{
    m_header_ = ::std::move(other.m_header_);
    m_lineGeometryLayer_ = ::std::move(other.m_lineGeometryLayer_);
    m_polygonGeometryLayer_ = ::std::move(other.m_polygonGeometryLayer_);
    m_meshGeometryLayer_ = ::std::move(other.m_meshGeometryLayer_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

LandmarkLayer::LandmarkLayer(::zserio::PropagateAllocatorT,
        const LandmarkLayer& other, const allocator_type& allocator) :
        m_header_(::zserio::allocatorPropagatingCopy(other.m_header_, allocator)),
        m_lineGeometryLayer_(::zserio::allocatorPropagatingCopy(other.m_lineGeometryLayer_, allocator)),
        m_polygonGeometryLayer_(::zserio::allocatorPropagatingCopy(other.m_polygonGeometryLayer_, allocator)),
        m_meshGeometryLayer_(::zserio::allocatorPropagatingCopy(other.m_meshGeometryLayer_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void LandmarkLayer::initializeChildren()
{
    if (getHeader().getAvailableLineTypes().size() > 0)
        m_lineGeometryLayer_.value().initialize(static_cast<::nds::core::geometry::GeometryLayerType>(::nds::core::geometry::GeometryLayerType::LINE_3D), static_cast<bool>((getHeader().getHasRelations() || getHeader().getHasDetails())), static_cast<bool>(true));
    if (getHeader().getAvailablePolygonTypes().size() > 0)
        m_polygonGeometryLayer_.value().initialize(static_cast<::nds::core::geometry::GeometryLayerType>(::nds::core::geometry::GeometryLayerType::POLYGON_3D), static_cast<bool>((getHeader().getHasRelations() || getHeader().getHasDetails())), static_cast<bool>(true));
    if (getHeader().getAvailableMeshTypes().size() > 0)
        m_meshGeometryLayer_.value().initialize(static_cast<::nds::core::geometry::GeometryLayerType>(::nds::core::geometry::GeometryLayerType::MESH_3D), static_cast<bool>((getHeader().getHasRelations() || getHeader().getHasDetails())), static_cast<bool>(true));

    m_areChildrenInitialized = true;
}

::nds::localization::layer::LandmarkLayerHeader& LandmarkLayer::getHeader()
{
    return m_header_;
}

const ::nds::localization::layer::LandmarkLayerHeader& LandmarkLayer::getHeader() const
{
    return m_header_;
}

void LandmarkLayer::setHeader(const ::nds::localization::layer::LandmarkLayerHeader& header_)
{
    m_header_ = header_;
}

void LandmarkLayer::setHeader(::nds::localization::layer::LandmarkLayerHeader&& header_)
{
    m_header_ = ::std::move(header_);
}

::nds::localization::instantiations::LandmarkLineGeometryLayer& LandmarkLayer::getLineGeometryLayer()
{
    return m_lineGeometryLayer_.value();
}

const ::nds::localization::instantiations::LandmarkLineGeometryLayer& LandmarkLayer::getLineGeometryLayer() const
{
    return m_lineGeometryLayer_.value();
}

void LandmarkLayer::setLineGeometryLayer(const ::nds::localization::instantiations::LandmarkLineGeometryLayer& lineGeometryLayer_)
{
    m_lineGeometryLayer_ = lineGeometryLayer_;
}

void LandmarkLayer::setLineGeometryLayer(::nds::localization::instantiations::LandmarkLineGeometryLayer&& lineGeometryLayer_)
{
    m_lineGeometryLayer_ = ::std::move(lineGeometryLayer_);
}

bool LandmarkLayer::isLineGeometryLayerUsed() const
{
    return (getHeader().getAvailableLineTypes().size() > 0);
}

bool LandmarkLayer::isLineGeometryLayerSet() const
{
    return m_lineGeometryLayer_.hasValue();
}

void LandmarkLayer::resetLineGeometryLayer()
{
    m_lineGeometryLayer_.reset();
}

::nds::localization::instantiations::LandmarkPolygonGeometryLayer& LandmarkLayer::getPolygonGeometryLayer()
{
    return m_polygonGeometryLayer_.value();
}

const ::nds::localization::instantiations::LandmarkPolygonGeometryLayer& LandmarkLayer::getPolygonGeometryLayer() const
{
    return m_polygonGeometryLayer_.value();
}

void LandmarkLayer::setPolygonGeometryLayer(const ::nds::localization::instantiations::LandmarkPolygonGeometryLayer& polygonGeometryLayer_)
{
    m_polygonGeometryLayer_ = polygonGeometryLayer_;
}

void LandmarkLayer::setPolygonGeometryLayer(::nds::localization::instantiations::LandmarkPolygonGeometryLayer&& polygonGeometryLayer_)
{
    m_polygonGeometryLayer_ = ::std::move(polygonGeometryLayer_);
}

bool LandmarkLayer::isPolygonGeometryLayerUsed() const
{
    return (getHeader().getAvailablePolygonTypes().size() > 0);
}

bool LandmarkLayer::isPolygonGeometryLayerSet() const
{
    return m_polygonGeometryLayer_.hasValue();
}

void LandmarkLayer::resetPolygonGeometryLayer()
{
    m_polygonGeometryLayer_.reset();
}

::nds::localization::instantiations::LandmarkMeshGeometryLayer& LandmarkLayer::getMeshGeometryLayer()
{
    return m_meshGeometryLayer_.value();
}

const ::nds::localization::instantiations::LandmarkMeshGeometryLayer& LandmarkLayer::getMeshGeometryLayer() const
{
    return m_meshGeometryLayer_.value();
}

void LandmarkLayer::setMeshGeometryLayer(const ::nds::localization::instantiations::LandmarkMeshGeometryLayer& meshGeometryLayer_)
{
    m_meshGeometryLayer_ = meshGeometryLayer_;
}

void LandmarkLayer::setMeshGeometryLayer(::nds::localization::instantiations::LandmarkMeshGeometryLayer&& meshGeometryLayer_)
{
    m_meshGeometryLayer_ = ::std::move(meshGeometryLayer_);
}

bool LandmarkLayer::isMeshGeometryLayerUsed() const
{
    return (getHeader().getAvailableMeshTypes().size() > 0);
}

bool LandmarkLayer::isMeshGeometryLayerSet() const
{
    return m_meshGeometryLayer_.hasValue();
}

void LandmarkLayer::resetMeshGeometryLayer()
{
    m_meshGeometryLayer_.reset();
}

::nds::system::types::LayerType LandmarkLayer::funcGetLayerType() const
{
    return static_cast<::nds::system::types::LayerType>(::nds::system::types::LayerType::GEOMETRY);
}

void LandmarkLayer::initPackingContext(LandmarkLayer::ZserioPackingContext& context) const
{
    m_header_.initPackingContext(context.getHeader());
    if (getHeader().getAvailableLineTypes().size() > 0)
    {
        m_lineGeometryLayer_.value().initPackingContext(context.getLineGeometryLayer());
    }
    if (getHeader().getAvailablePolygonTypes().size() > 0)
    {
        m_polygonGeometryLayer_.value().initPackingContext(context.getPolygonGeometryLayer());
    }
    if (getHeader().getAvailableMeshTypes().size() > 0)
    {
        m_meshGeometryLayer_.value().initPackingContext(context.getMeshGeometryLayer());
    }
}

size_t LandmarkLayer::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_header_.bitSizeOf(endBitPosition);
    if (getHeader().getAvailableLineTypes().size() > 0)
    {
        endBitPosition += m_lineGeometryLayer_.value().bitSizeOf(endBitPosition);
    }
    if (getHeader().getAvailablePolygonTypes().size() > 0)
    {
        endBitPosition += m_polygonGeometryLayer_.value().bitSizeOf(endBitPosition);
    }
    if (getHeader().getAvailableMeshTypes().size() > 0)
    {
        endBitPosition += m_meshGeometryLayer_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t LandmarkLayer::bitSizeOf(LandmarkLayer::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_header_.bitSizeOf(context.getHeader(), endBitPosition);
    if (getHeader().getAvailableLineTypes().size() > 0)
    {
        endBitPosition += m_lineGeometryLayer_.value().bitSizeOf(context.getLineGeometryLayer(), endBitPosition);
    }
    if (getHeader().getAvailablePolygonTypes().size() > 0)
    {
        endBitPosition += m_polygonGeometryLayer_.value().bitSizeOf(context.getPolygonGeometryLayer(), endBitPosition);
    }
    if (getHeader().getAvailableMeshTypes().size() > 0)
    {
        endBitPosition += m_meshGeometryLayer_.value().bitSizeOf(context.getMeshGeometryLayer(), endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t LandmarkLayer::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_header_.initializeOffsets(endBitPosition);
    if (getHeader().getAvailableLineTypes().size() > 0)
    {
        endBitPosition = m_lineGeometryLayer_.value().initializeOffsets(endBitPosition);
    }
    if (getHeader().getAvailablePolygonTypes().size() > 0)
    {
        endBitPosition = m_polygonGeometryLayer_.value().initializeOffsets(endBitPosition);
    }
    if (getHeader().getAvailableMeshTypes().size() > 0)
    {
        endBitPosition = m_meshGeometryLayer_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

size_t LandmarkLayer::initializeOffsets(LandmarkLayer::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_header_.initializeOffsets(context.getHeader(), endBitPosition);
    if (getHeader().getAvailableLineTypes().size() > 0)
    {
        endBitPosition = m_lineGeometryLayer_.value().initializeOffsets(context.getLineGeometryLayer(), endBitPosition);
    }
    if (getHeader().getAvailablePolygonTypes().size() > 0)
    {
        endBitPosition = m_polygonGeometryLayer_.value().initializeOffsets(context.getPolygonGeometryLayer(), endBitPosition);
    }
    if (getHeader().getAvailableMeshTypes().size() > 0)
    {
        endBitPosition = m_meshGeometryLayer_.value().initializeOffsets(context.getMeshGeometryLayer(), endBitPosition);
    }

    return endBitPosition;
}

bool LandmarkLayer::operator==(const LandmarkLayer& other) const
{
    if (this != &other)
    {
        return
                (m_header_ == other.m_header_) &&
                (!isLineGeometryLayerUsed() ? !other.isLineGeometryLayerUsed() : (m_lineGeometryLayer_ == other.m_lineGeometryLayer_)) &&
                (!isPolygonGeometryLayerUsed() ? !other.isPolygonGeometryLayerUsed() : (m_polygonGeometryLayer_ == other.m_polygonGeometryLayer_)) &&
                (!isMeshGeometryLayerUsed() ? !other.isMeshGeometryLayerUsed() : (m_meshGeometryLayer_ == other.m_meshGeometryLayer_));
    }

    return true;
}

uint32_t LandmarkLayer::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_header_);
    if (isLineGeometryLayerUsed())
        result = ::zserio::calcHashCode(result, m_lineGeometryLayer_);
    if (isPolygonGeometryLayerUsed())
        result = ::zserio::calcHashCode(result, m_polygonGeometryLayer_);
    if (isMeshGeometryLayerUsed())
        result = ::zserio::calcHashCode(result, m_meshGeometryLayer_);

    return result;
}

void LandmarkLayer::write(::zserio::BitStreamWriter& out) const
{
    // check constraint
    if (!((getHeader().getAvailableLineTypes().size() > 0) || (getHeader().getAvailablePolygonTypes().size() > 0) || (getHeader().getAvailableMeshTypes().size() > 0)))
        throw ::zserio::ConstraintException("Write: Constraint violated at LandmarkLayer.header!");
    m_header_.write(out);

    if (getHeader().getAvailableLineTypes().size() > 0)
    {
        // check parameters
        if (m_lineGeometryLayer_.value().getType() != static_cast<::nds::core::geometry::GeometryLayerType>(::nds::core::geometry::GeometryLayerType::LINE_3D))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field LandmarkLayer.lineGeometryLayer: ") <<
                    m_lineGeometryLayer_.value().getType() << " != " << static_cast<::nds::core::geometry::GeometryLayerType>(::nds::core::geometry::GeometryLayerType::LINE_3D) << "!";
        }
        if (m_lineGeometryLayer_.value().getHasIds() != static_cast<bool>((getHeader().getHasRelations() || getHeader().getHasDetails())))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter hasIds for field LandmarkLayer.lineGeometryLayer: ") <<
                    m_lineGeometryLayer_.value().getHasIds() << " != " << static_cast<bool>((getHeader().getHasRelations() || getHeader().getHasDetails())) << "!";
        }
        if (m_lineGeometryLayer_.value().getHasTypes() != static_cast<bool>(true))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter hasTypes for field LandmarkLayer.lineGeometryLayer: ") <<
                    m_lineGeometryLayer_.value().getHasTypes() << " != " << static_cast<bool>(true) << "!";
        }
        m_lineGeometryLayer_.value().write(out);
    }

    if (getHeader().getAvailablePolygonTypes().size() > 0)
    {
        // check parameters
        if (m_polygonGeometryLayer_.value().getType() != static_cast<::nds::core::geometry::GeometryLayerType>(::nds::core::geometry::GeometryLayerType::POLYGON_3D))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field LandmarkLayer.polygonGeometryLayer: ") <<
                    m_polygonGeometryLayer_.value().getType() << " != " << static_cast<::nds::core::geometry::GeometryLayerType>(::nds::core::geometry::GeometryLayerType::POLYGON_3D) << "!";
        }
        if (m_polygonGeometryLayer_.value().getHasIds() != static_cast<bool>((getHeader().getHasRelations() || getHeader().getHasDetails())))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter hasIds for field LandmarkLayer.polygonGeometryLayer: ") <<
                    m_polygonGeometryLayer_.value().getHasIds() << " != " << static_cast<bool>((getHeader().getHasRelations() || getHeader().getHasDetails())) << "!";
        }
        if (m_polygonGeometryLayer_.value().getHasTypes() != static_cast<bool>(true))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter hasTypes for field LandmarkLayer.polygonGeometryLayer: ") <<
                    m_polygonGeometryLayer_.value().getHasTypes() << " != " << static_cast<bool>(true) << "!";
        }
        m_polygonGeometryLayer_.value().write(out);
    }

    if (getHeader().getAvailableMeshTypes().size() > 0)
    {
        // check parameters
        if (m_meshGeometryLayer_.value().getType() != static_cast<::nds::core::geometry::GeometryLayerType>(::nds::core::geometry::GeometryLayerType::MESH_3D))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field LandmarkLayer.meshGeometryLayer: ") <<
                    m_meshGeometryLayer_.value().getType() << " != " << static_cast<::nds::core::geometry::GeometryLayerType>(::nds::core::geometry::GeometryLayerType::MESH_3D) << "!";
        }
        if (m_meshGeometryLayer_.value().getHasIds() != static_cast<bool>((getHeader().getHasRelations() || getHeader().getHasDetails())))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter hasIds for field LandmarkLayer.meshGeometryLayer: ") <<
                    m_meshGeometryLayer_.value().getHasIds() << " != " << static_cast<bool>((getHeader().getHasRelations() || getHeader().getHasDetails())) << "!";
        }
        if (m_meshGeometryLayer_.value().getHasTypes() != static_cast<bool>(true))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter hasTypes for field LandmarkLayer.meshGeometryLayer: ") <<
                    m_meshGeometryLayer_.value().getHasTypes() << " != " << static_cast<bool>(true) << "!";
        }
        m_meshGeometryLayer_.value().write(out);
    }
}

void LandmarkLayer::write(LandmarkLayer::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    // check constraint
    if (!((getHeader().getAvailableLineTypes().size() > 0) || (getHeader().getAvailablePolygonTypes().size() > 0) || (getHeader().getAvailableMeshTypes().size() > 0)))
        throw ::zserio::ConstraintException("Write: Constraint violated at LandmarkLayer.header!");
    m_header_.write(context.getHeader(), out);

    if (getHeader().getAvailableLineTypes().size() > 0)
    {
        // check parameters
        if (m_lineGeometryLayer_.value().getType() != static_cast<::nds::core::geometry::GeometryLayerType>(::nds::core::geometry::GeometryLayerType::LINE_3D))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field LandmarkLayer.lineGeometryLayer: ") <<
                    m_lineGeometryLayer_.value().getType() << " != " << static_cast<::nds::core::geometry::GeometryLayerType>(::nds::core::geometry::GeometryLayerType::LINE_3D) << "!";
        }
        if (m_lineGeometryLayer_.value().getHasIds() != static_cast<bool>((getHeader().getHasRelations() || getHeader().getHasDetails())))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter hasIds for field LandmarkLayer.lineGeometryLayer: ") <<
                    m_lineGeometryLayer_.value().getHasIds() << " != " << static_cast<bool>((getHeader().getHasRelations() || getHeader().getHasDetails())) << "!";
        }
        if (m_lineGeometryLayer_.value().getHasTypes() != static_cast<bool>(true))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter hasTypes for field LandmarkLayer.lineGeometryLayer: ") <<
                    m_lineGeometryLayer_.value().getHasTypes() << " != " << static_cast<bool>(true) << "!";
        }
        m_lineGeometryLayer_.value().write(context.getLineGeometryLayer(), out);
    }

    if (getHeader().getAvailablePolygonTypes().size() > 0)
    {
        // check parameters
        if (m_polygonGeometryLayer_.value().getType() != static_cast<::nds::core::geometry::GeometryLayerType>(::nds::core::geometry::GeometryLayerType::POLYGON_3D))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field LandmarkLayer.polygonGeometryLayer: ") <<
                    m_polygonGeometryLayer_.value().getType() << " != " << static_cast<::nds::core::geometry::GeometryLayerType>(::nds::core::geometry::GeometryLayerType::POLYGON_3D) << "!";
        }
        if (m_polygonGeometryLayer_.value().getHasIds() != static_cast<bool>((getHeader().getHasRelations() || getHeader().getHasDetails())))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter hasIds for field LandmarkLayer.polygonGeometryLayer: ") <<
                    m_polygonGeometryLayer_.value().getHasIds() << " != " << static_cast<bool>((getHeader().getHasRelations() || getHeader().getHasDetails())) << "!";
        }
        if (m_polygonGeometryLayer_.value().getHasTypes() != static_cast<bool>(true))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter hasTypes for field LandmarkLayer.polygonGeometryLayer: ") <<
                    m_polygonGeometryLayer_.value().getHasTypes() << " != " << static_cast<bool>(true) << "!";
        }
        m_polygonGeometryLayer_.value().write(context.getPolygonGeometryLayer(), out);
    }

    if (getHeader().getAvailableMeshTypes().size() > 0)
    {
        // check parameters
        if (m_meshGeometryLayer_.value().getType() != static_cast<::nds::core::geometry::GeometryLayerType>(::nds::core::geometry::GeometryLayerType::MESH_3D))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field LandmarkLayer.meshGeometryLayer: ") <<
                    m_meshGeometryLayer_.value().getType() << " != " << static_cast<::nds::core::geometry::GeometryLayerType>(::nds::core::geometry::GeometryLayerType::MESH_3D) << "!";
        }
        if (m_meshGeometryLayer_.value().getHasIds() != static_cast<bool>((getHeader().getHasRelations() || getHeader().getHasDetails())))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter hasIds for field LandmarkLayer.meshGeometryLayer: ") <<
                    m_meshGeometryLayer_.value().getHasIds() << " != " << static_cast<bool>((getHeader().getHasRelations() || getHeader().getHasDetails())) << "!";
        }
        if (m_meshGeometryLayer_.value().getHasTypes() != static_cast<bool>(true))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter hasTypes for field LandmarkLayer.meshGeometryLayer: ") <<
                    m_meshGeometryLayer_.value().getHasTypes() << " != " << static_cast<bool>(true) << "!";
        }
        m_meshGeometryLayer_.value().write(context.getMeshGeometryLayer(), out);
    }
}

::nds::localization::layer::LandmarkLayerHeader LandmarkLayer::readHeader(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ::nds::localization::layer::LandmarkLayerHeader readField = ::nds::localization::layer::LandmarkLayerHeader(in, allocator);
    // check constraint
    if (!((readField.getAvailableLineTypes().size() > 0) || (readField.getAvailablePolygonTypes().size() > 0) || (readField.getAvailableMeshTypes().size() > 0)))
        throw ::zserio::ConstraintException("Read: Constraint violated at LandmarkLayer.header!");

    return readField;
}

::nds::localization::layer::LandmarkLayerHeader LandmarkLayer::readHeader(LandmarkLayer::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ::nds::localization::layer::LandmarkLayerHeader readField = ::nds::localization::layer::LandmarkLayerHeader(context.getHeader(), in, allocator);
    // check constraint
    if (!((readField.getAvailableLineTypes().size() > 0) || (readField.getAvailablePolygonTypes().size() > 0) || (readField.getAvailableMeshTypes().size() > 0)))
        throw ::zserio::ConstraintException("Read: Constraint violated at LandmarkLayer.header!");

    return readField;
}
::zserio::InplaceOptionalHolder<::nds::localization::instantiations::LandmarkLineGeometryLayer> LandmarkLayer::readLineGeometryLayer(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getHeader().getAvailableLineTypes().size() > 0)
    {
        return ::zserio::InplaceOptionalHolder<::nds::localization::instantiations::LandmarkLineGeometryLayer>(::nds::localization::instantiations::LandmarkLineGeometryLayer(in, static_cast<::nds::core::geometry::GeometryLayerType>(::nds::core::geometry::GeometryLayerType::LINE_3D), static_cast<bool>((getHeader().getHasRelations() || getHeader().getHasDetails())), static_cast<bool>(true), allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::localization::instantiations::LandmarkLineGeometryLayer>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::localization::instantiations::LandmarkLineGeometryLayer> LandmarkLayer::readLineGeometryLayer(LandmarkLayer::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getHeader().getAvailableLineTypes().size() > 0)
    {
        return ::zserio::InplaceOptionalHolder<::nds::localization::instantiations::LandmarkLineGeometryLayer>(::nds::localization::instantiations::LandmarkLineGeometryLayer(context.getLineGeometryLayer(), in, static_cast<::nds::core::geometry::GeometryLayerType>(::nds::core::geometry::GeometryLayerType::LINE_3D), static_cast<bool>((getHeader().getHasRelations() || getHeader().getHasDetails())), static_cast<bool>(true), allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::localization::instantiations::LandmarkLineGeometryLayer>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::localization::instantiations::LandmarkPolygonGeometryLayer> LandmarkLayer::readPolygonGeometryLayer(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getHeader().getAvailablePolygonTypes().size() > 0)
    {
        return ::zserio::InplaceOptionalHolder<::nds::localization::instantiations::LandmarkPolygonGeometryLayer>(::nds::localization::instantiations::LandmarkPolygonGeometryLayer(in, static_cast<::nds::core::geometry::GeometryLayerType>(::nds::core::geometry::GeometryLayerType::POLYGON_3D), static_cast<bool>((getHeader().getHasRelations() || getHeader().getHasDetails())), static_cast<bool>(true), allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::localization::instantiations::LandmarkPolygonGeometryLayer>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::localization::instantiations::LandmarkPolygonGeometryLayer> LandmarkLayer::readPolygonGeometryLayer(LandmarkLayer::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getHeader().getAvailablePolygonTypes().size() > 0)
    {
        return ::zserio::InplaceOptionalHolder<::nds::localization::instantiations::LandmarkPolygonGeometryLayer>(::nds::localization::instantiations::LandmarkPolygonGeometryLayer(context.getPolygonGeometryLayer(), in, static_cast<::nds::core::geometry::GeometryLayerType>(::nds::core::geometry::GeometryLayerType::POLYGON_3D), static_cast<bool>((getHeader().getHasRelations() || getHeader().getHasDetails())), static_cast<bool>(true), allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::localization::instantiations::LandmarkPolygonGeometryLayer>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::localization::instantiations::LandmarkMeshGeometryLayer> LandmarkLayer::readMeshGeometryLayer(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getHeader().getAvailableMeshTypes().size() > 0)
    {
        return ::zserio::InplaceOptionalHolder<::nds::localization::instantiations::LandmarkMeshGeometryLayer>(::nds::localization::instantiations::LandmarkMeshGeometryLayer(in, static_cast<::nds::core::geometry::GeometryLayerType>(::nds::core::geometry::GeometryLayerType::MESH_3D), static_cast<bool>((getHeader().getHasRelations() || getHeader().getHasDetails())), static_cast<bool>(true), allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::localization::instantiations::LandmarkMeshGeometryLayer>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::localization::instantiations::LandmarkMeshGeometryLayer> LandmarkLayer::readMeshGeometryLayer(LandmarkLayer::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getHeader().getAvailableMeshTypes().size() > 0)
    {
        return ::zserio::InplaceOptionalHolder<::nds::localization::instantiations::LandmarkMeshGeometryLayer>(::nds::localization::instantiations::LandmarkMeshGeometryLayer(context.getMeshGeometryLayer(), in, static_cast<::nds::core::geometry::GeometryLayerType>(::nds::core::geometry::GeometryLayerType::MESH_3D), static_cast<bool>((getHeader().getHasRelations() || getHeader().getHasDetails())), static_cast<bool>(true), allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::localization::instantiations::LandmarkMeshGeometryLayer>(::zserio::NullOpt);
}

} // namespace layer
} // namespace localization
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/localization/layer/LandmarkLayerHeader.h>

namespace nds
{
namespace localization
{
namespace layer
{

LandmarkLayerHeader::LandmarkLayerHeader(const allocator_type& allocator) noexcept :
        m_availableLineTypes_(allocator),
        m_availablePolygonTypes_(allocator),
        m_availableMeshTypes_(allocator),
        m_hasRelations_(bool()),
        m_hasDetails_(bool())
{
}

LandmarkLayerHeader::LandmarkLayerHeader(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_availableLineTypes_(readAvailableLineTypes(in, allocator)),
        m_availablePolygonTypes_(readAvailablePolygonTypes(in, allocator)),
        m_availableMeshTypes_(readAvailableMeshTypes(in, allocator)),
        m_hasRelations_(readHasRelations(in)),
        m_hasDetails_(readHasDetails(in))
{
}

LandmarkLayerHeader::LandmarkLayerHeader(LandmarkLayerHeader::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_availableLineTypes_(readAvailableLineTypes(context, in, allocator)),
        m_availablePolygonTypes_(readAvailablePolygonTypes(context, in, allocator)),
        m_availableMeshTypes_(readAvailableMeshTypes(context, in, allocator)),
        m_hasRelations_(readHasRelations(in)),
        m_hasDetails_(readHasDetails(in))
{
}

LandmarkLayerHeader::LandmarkLayerHeader(::zserio::PropagateAllocatorT,
        const LandmarkLayerHeader& other, const allocator_type& allocator) :
        m_availableLineTypes_(::zserio::allocatorPropagatingCopy(other.m_availableLineTypes_, allocator)),
        m_availablePolygonTypes_(::zserio::allocatorPropagatingCopy(other.m_availablePolygonTypes_, allocator)),
        m_availableMeshTypes_(::zserio::allocatorPropagatingCopy(other.m_availableMeshTypes_, allocator)),
        m_hasRelations_(::zserio::allocatorPropagatingCopy(other.m_hasRelations_, allocator)),
        m_hasDetails_(::zserio::allocatorPropagatingCopy(other.m_hasDetails_, allocator))
{
}

::zserio::vector<::nds::localization::types::LandmarkLineType>& LandmarkLayerHeader::getAvailableLineTypes()
{
    return m_availableLineTypes_.getRawArray();
}

const ::zserio::vector<::nds::localization::types::LandmarkLineType>& LandmarkLayerHeader::getAvailableLineTypes() const
{
    return m_availableLineTypes_.getRawArray();
}

void LandmarkLayerHeader::setAvailableLineTypes(const ::zserio::vector<::nds::localization::types::LandmarkLineType>& availableLineTypes_)
{
    m_availableLineTypes_ = ZserioArrayType_availableLineTypes(availableLineTypes_);
}

void LandmarkLayerHeader::setAvailableLineTypes(::zserio::vector<::nds::localization::types::LandmarkLineType>&& availableLineTypes_)
{
    m_availableLineTypes_ = ZserioArrayType_availableLineTypes(std::move(availableLineTypes_));
}

::zserio::vector<::nds::localization::types::LandmarkPolygonType>& LandmarkLayerHeader::getAvailablePolygonTypes()
{
    return m_availablePolygonTypes_.getRawArray();
}

const ::zserio::vector<::nds::localization::types::LandmarkPolygonType>& LandmarkLayerHeader::getAvailablePolygonTypes() const
{
    return m_availablePolygonTypes_.getRawArray();
}

void LandmarkLayerHeader::setAvailablePolygonTypes(const ::zserio::vector<::nds::localization::types::LandmarkPolygonType>& availablePolygonTypes_)
{
    m_availablePolygonTypes_ = ZserioArrayType_availablePolygonTypes(availablePolygonTypes_);
}

void LandmarkLayerHeader::setAvailablePolygonTypes(::zserio::vector<::nds::localization::types::LandmarkPolygonType>&& availablePolygonTypes_)
{
    m_availablePolygonTypes_ = ZserioArrayType_availablePolygonTypes(std::move(availablePolygonTypes_));
}

::zserio::vector<::nds::localization::types::LandmarkMeshType>& LandmarkLayerHeader::getAvailableMeshTypes()
{
    return m_availableMeshTypes_.getRawArray();
}

const ::zserio::vector<::nds::localization::types::LandmarkMeshType>& LandmarkLayerHeader::getAvailableMeshTypes() const
{
    return m_availableMeshTypes_.getRawArray();
}

void LandmarkLayerHeader::setAvailableMeshTypes(const ::zserio::vector<::nds::localization::types::LandmarkMeshType>& availableMeshTypes_)
{
    m_availableMeshTypes_ = ZserioArrayType_availableMeshTypes(availableMeshTypes_);
}

void LandmarkLayerHeader::setAvailableMeshTypes(::zserio::vector<::nds::localization::types::LandmarkMeshType>&& availableMeshTypes_)
{
    m_availableMeshTypes_ = ZserioArrayType_availableMeshTypes(std::move(availableMeshTypes_));
}

bool LandmarkLayerHeader::getHasRelations() const
{
    return m_hasRelations_;
}

void LandmarkLayerHeader::setHasRelations(bool hasRelations_)
{
    m_hasRelations_ = hasRelations_;
}

bool LandmarkLayerHeader::getHasDetails() const
{
    return m_hasDetails_;
}

void LandmarkLayerHeader::setHasDetails(bool hasDetails_)
{
    m_hasDetails_ = hasDetails_;
}

void LandmarkLayerHeader::initPackingContext(LandmarkLayerHeader::ZserioPackingContext&) const
{
}

size_t LandmarkLayerHeader::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_availableLineTypes_.bitSizeOf(endBitPosition);
    endBitPosition += m_availablePolygonTypes_.bitSizeOf(endBitPosition);
    endBitPosition += m_availableMeshTypes_.bitSizeOf(endBitPosition);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);

    return endBitPosition - bitPosition;
}

size_t LandmarkLayerHeader::bitSizeOf(LandmarkLayerHeader::ZserioPackingContext&, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_availableLineTypes_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_availablePolygonTypes_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_availableMeshTypes_.bitSizeOfPacked(endBitPosition);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);

    return endBitPosition - bitPosition;
}

size_t LandmarkLayerHeader::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_availableLineTypes_.initializeOffsets(endBitPosition);
    endBitPosition = m_availablePolygonTypes_.initializeOffsets(endBitPosition);
    endBitPosition = m_availableMeshTypes_.initializeOffsets(endBitPosition);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);

    return endBitPosition;
}

size_t LandmarkLayerHeader::initializeOffsets(LandmarkLayerHeader::ZserioPackingContext&, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_availableLineTypes_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_availablePolygonTypes_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_availableMeshTypes_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);

    return endBitPosition;
}

bool LandmarkLayerHeader::operator==(const LandmarkLayerHeader& other) const
{
    if (this != &other)
    {
        return
                (m_availableLineTypes_ == other.m_availableLineTypes_) &&
                (m_availablePolygonTypes_ == other.m_availablePolygonTypes_) &&
                (m_availableMeshTypes_ == other.m_availableMeshTypes_) &&
                (m_hasRelations_ == other.m_hasRelations_) &&
                (m_hasDetails_ == other.m_hasDetails_);
    }

    return true;
}

uint32_t LandmarkLayerHeader::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_availableLineTypes_);
    result = ::zserio::calcHashCode(result, m_availablePolygonTypes_);
    result = ::zserio::calcHashCode(result, m_availableMeshTypes_);
    result = ::zserio::calcHashCode(result, m_hasRelations_);
    result = ::zserio::calcHashCode(result, m_hasDetails_);

    return result;
}

void LandmarkLayerHeader::write(::zserio::BitStreamWriter& out) const
{
    m_availableLineTypes_.write(out);
    m_availablePolygonTypes_.write(out);
    m_availableMeshTypes_.write(out);
    out.writeBool(m_hasRelations_);
    out.writeBool(m_hasDetails_);
}

void LandmarkLayerHeader::write(LandmarkLayerHeader::ZserioPackingContext&, ::zserio::BitStreamWriter& out) const
{
    m_availableLineTypes_.writePacked(out);
    m_availablePolygonTypes_.writePacked(out);
    m_availableMeshTypes_.writePacked(out);
    out.writeBool(m_hasRelations_);
    out.writeBool(m_hasDetails_);
}

LandmarkLayerHeader::ZserioArrayType_availableLineTypes LandmarkLayerHeader::readAvailableLineTypes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_availableLineTypes readField(allocator);
    readField.read(in);

    return readField;
}

LandmarkLayerHeader::ZserioArrayType_availableLineTypes LandmarkLayerHeader::readAvailableLineTypes(LandmarkLayerHeader::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_availableLineTypes readField(allocator);
    readField.readPacked(in);

    return readField;
}
LandmarkLayerHeader::ZserioArrayType_availablePolygonTypes LandmarkLayerHeader::readAvailablePolygonTypes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_availablePolygonTypes readField(allocator);
    readField.read(in);

    return readField;
}

LandmarkLayerHeader::ZserioArrayType_availablePolygonTypes LandmarkLayerHeader::readAvailablePolygonTypes(LandmarkLayerHeader::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_availablePolygonTypes readField(allocator);
    readField.readPacked(in);

    return readField;
}
LandmarkLayerHeader::ZserioArrayType_availableMeshTypes LandmarkLayerHeader::readAvailableMeshTypes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_availableMeshTypes readField(allocator);
    readField.read(in);

    return readField;
}

LandmarkLayerHeader::ZserioArrayType_availableMeshTypes LandmarkLayerHeader::readAvailableMeshTypes(LandmarkLayerHeader::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_availableMeshTypes readField(allocator);
    readField.readPacked(in);

    return readField;
}
bool LandmarkLayerHeader::readHasRelations(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
bool LandmarkLayerHeader::readHasDetails(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}

} // namespace layer
} // namespace localization
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ArrayTraits.h>

#include <nds/localization/layer/RoadLandmarkLayer.h>
#include <nds/system/types/LayerType.h>

namespace nds
{
namespace localization
{
namespace layer
{

RoadLandmarkLayer::RoadLandmarkLayer(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_shift_(::nds::core::geometry::CoordShift()),
        m_roadAttributeMaps_(allocator)
{
}

RoadLandmarkLayer::RoadLandmarkLayer(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_shift_(readShift(in)),
        m_roadAttributeMaps_(readRoadAttributeMaps(in, allocator))
{
}

RoadLandmarkLayer::RoadLandmarkLayer(RoadLandmarkLayer::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_shift_(readShift(context, in)),
        m_roadAttributeMaps_(readRoadAttributeMaps(context, in, allocator))
{
}

RoadLandmarkLayer::RoadLandmarkLayer(const RoadLandmarkLayer& other) :
        m_shift_(other.m_shift_),
        m_roadAttributeMaps_(other.m_roadAttributeMaps_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

RoadLandmarkLayer& RoadLandmarkLayer::operator=(const RoadLandmarkLayer& other)
{
    m_shift_ = other.m_shift_;
    m_roadAttributeMaps_ = other.m_roadAttributeMaps_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

RoadLandmarkLayer::RoadLandmarkLayer(RoadLandmarkLayer&& other) :
        m_shift_(::std::move(other.m_shift_)),
        m_roadAttributeMaps_(::std::move(other.m_roadAttributeMaps_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

RoadLandmarkLayer& RoadLandmarkLayer::operator=(RoadLandmarkLayer&& other)
{
    m_shift_ = ::std::move(other.m_shift_);
    m_roadAttributeMaps_ = ::std::move(other.m_roadAttributeMaps_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

RoadLandmarkLayer::RoadLandmarkLayer(::zserio::PropagateAllocatorT,
        const RoadLandmarkLayer& other, const allocator_type& allocator) :
        m_shift_(::zserio::allocatorPropagatingCopy(other.m_shift_, allocator)),
        m_roadAttributeMaps_(::zserio::allocatorPropagatingCopy(other.m_roadAttributeMaps_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void RoadLandmarkLayer::initializeChildren()
{
    m_roadAttributeMaps_.initialize(static_cast<::nds::core::geometry::CoordShift>(getShift()));

    m_areChildrenInitialized = true;
}

::nds::core::geometry::CoordShift RoadLandmarkLayer::getShift() const
{
    return m_shift_;
}

void RoadLandmarkLayer::setShift(::nds::core::geometry::CoordShift shift_)
{
    m_shift_ = shift_;
}

::nds::localization::instantiations::LandmarkRoadAttributeMapList& RoadLandmarkLayer::getRoadAttributeMaps()
{
    return m_roadAttributeMaps_;
}

const ::nds::localization::instantiations::LandmarkRoadAttributeMapList& RoadLandmarkLayer::getRoadAttributeMaps() const
{
    return m_roadAttributeMaps_;
}

void RoadLandmarkLayer::setRoadAttributeMaps(const ::nds::localization::instantiations::LandmarkRoadAttributeMapList& roadAttributeMaps_)
{
    m_roadAttributeMaps_ = roadAttributeMaps_;
}

void RoadLandmarkLayer::setRoadAttributeMaps(::nds::localization::instantiations::LandmarkRoadAttributeMapList&& roadAttributeMaps_)
{
    m_roadAttributeMaps_ = ::std::move(roadAttributeMaps_);
}

::nds::system::types::LayerType RoadLandmarkLayer::funcGetLayerType() const
{
    return static_cast<::nds::system::types::LayerType>(::nds::system::types::LayerType::RELATION);
}

void RoadLandmarkLayer::initPackingContext(RoadLandmarkLayer::ZserioPackingContext& context) const
{
    context.getShift().init<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(m_shift_);
    m_roadAttributeMaps_.initPackingContext(context.getRoadAttributeMaps());
}

size_t RoadLandmarkLayer::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(5);
    endBitPosition += m_roadAttributeMaps_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoadLandmarkLayer::bitSizeOf(RoadLandmarkLayer::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getShift().bitSizeOf<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(m_shift_);
    endBitPosition += m_roadAttributeMaps_.bitSizeOf(context.getRoadAttributeMaps(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoadLandmarkLayer::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(5);
    endBitPosition = m_roadAttributeMaps_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t RoadLandmarkLayer::initializeOffsets(RoadLandmarkLayer::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getShift().bitSizeOf<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(m_shift_);
    endBitPosition = m_roadAttributeMaps_.initializeOffsets(context.getRoadAttributeMaps(), endBitPosition);

    return endBitPosition;
}

bool RoadLandmarkLayer::operator==(const RoadLandmarkLayer& other) const
{
    if (this != &other)
    {
        return
                (m_shift_ == other.m_shift_) &&
                (m_roadAttributeMaps_ == other.m_roadAttributeMaps_);
    }

    return true;
}

uint32_t RoadLandmarkLayer::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_shift_);
    result = ::zserio::calcHashCode(result, m_roadAttributeMaps_);

    return result;
}

void RoadLandmarkLayer::write(::zserio::BitStreamWriter& out) const
{
    out.writeBits(m_shift_, UINT8_C(5));

    // check parameters
    if (m_roadAttributeMaps_.getCoordShift() != static_cast<::nds::core::geometry::CoordShift>(getShift()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter coordShift for field RoadLandmarkLayer.roadAttributeMaps: ") <<
                m_roadAttributeMaps_.getCoordShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShift()) << "!";
    }
    m_roadAttributeMaps_.write(out);
}

void RoadLandmarkLayer::write(RoadLandmarkLayer::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getShift().write<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(out, m_shift_);

    // check parameters
    if (m_roadAttributeMaps_.getCoordShift() != static_cast<::nds::core::geometry::CoordShift>(getShift()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter coordShift for field RoadLandmarkLayer.roadAttributeMaps: ") <<
                m_roadAttributeMaps_.getCoordShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShift()) << "!";
    }
    m_roadAttributeMaps_.write(context.getRoadAttributeMaps(), out);
}

::nds::core::geometry::CoordShift RoadLandmarkLayer::readShift(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::geometry::CoordShift>(in.readBits(UINT8_C(5)));
}

::nds::core::geometry::CoordShift RoadLandmarkLayer::readShift(RoadLandmarkLayer::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getShift().read<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(in);
}
::nds::localization::instantiations::LandmarkRoadAttributeMapList RoadLandmarkLayer::readRoadAttributeMaps(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::localization::instantiations::LandmarkRoadAttributeMapList(in, static_cast<::nds::core::geometry::CoordShift>(getShift()), allocator);
}

::nds::localization::instantiations::LandmarkRoadAttributeMapList RoadLandmarkLayer::readRoadAttributeMaps(RoadLandmarkLayer::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::localization::instantiations::LandmarkRoadAttributeMapList(context.getRoadAttributeMaps(), in, static_cast<::nds::core::geometry::CoordShift>(getShift()), allocator);
}

} // namespace layer
} // namespace localization
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ArrayTraits.h>

#include <nds/localization/layer/LaneLandmarkLayer.h>
#include <nds/system/types/LayerType.h>

namespace nds
{
namespace localization
{
namespace layer
{

LaneLandmarkLayer::LaneLandmarkLayer(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_laneAttributeMaps_(allocator)
{
}

LaneLandmarkLayer::LaneLandmarkLayer(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_laneAttributeMaps_(readLaneAttributeMaps(in, allocator))
{
}

LaneLandmarkLayer::LaneLandmarkLayer(LaneLandmarkLayer::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_laneAttributeMaps_(readLaneAttributeMaps(context, in, allocator))
{
}

LaneLandmarkLayer::LaneLandmarkLayer(const LaneLandmarkLayer& other) :
        m_laneAttributeMaps_(other.m_laneAttributeMaps_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

LaneLandmarkLayer& LaneLandmarkLayer::operator=(const LaneLandmarkLayer& other)
{
    m_laneAttributeMaps_ = other.m_laneAttributeMaps_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

LaneLandmarkLayer::LaneLandmarkLayer(LaneLandmarkLayer&& other) :
        m_laneAttributeMaps_(::std::move(other.m_laneAttributeMaps_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

LaneLandmarkLayer& LaneLandmarkLayer::operator=(LaneLandmarkLayer&& other)
{
    m_laneAttributeMaps_ = ::std::move(other.m_laneAttributeMaps_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

LaneLandmarkLayer::LaneLandmarkLayer(::zserio::PropagateAllocatorT,
        const LaneLandmarkLayer& other, const allocator_type& allocator) :
        m_laneAttributeMaps_(::zserio::allocatorPropagatingCopy(other.m_laneAttributeMaps_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void LaneLandmarkLayer::initializeChildren()
{
    m_laneAttributeMaps_.initialize(static_cast<::nds::core::geometry::CoordShift>(0));

    m_areChildrenInitialized = true;
}

::nds::localization::instantiations::LandmarkLaneAttributeMapList& LaneLandmarkLayer::getLaneAttributeMaps()
{
    return m_laneAttributeMaps_;
}

const ::nds::localization::instantiations::LandmarkLaneAttributeMapList& LaneLandmarkLayer::getLaneAttributeMaps() const
{
    return m_laneAttributeMaps_;
}

void LaneLandmarkLayer::setLaneAttributeMaps(const ::nds::localization::instantiations::LandmarkLaneAttributeMapList& laneAttributeMaps_)
{
    m_laneAttributeMaps_ = laneAttributeMaps_;
}

void LaneLandmarkLayer::setLaneAttributeMaps(::nds::localization::instantiations::LandmarkLaneAttributeMapList&& laneAttributeMaps_)
{
    m_laneAttributeMaps_ = ::std::move(laneAttributeMaps_);
}

::nds::system::types::LayerType LaneLandmarkLayer::funcGetLayerType() const
{
    return static_cast<::nds::system::types::LayerType>(::nds::system::types::LayerType::RELATION);
}

void LaneLandmarkLayer::initPackingContext(LaneLandmarkLayer::ZserioPackingContext& context) const
{
    m_laneAttributeMaps_.initPackingContext(context.getLaneAttributeMaps());
}

size_t LaneLandmarkLayer::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_laneAttributeMaps_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LaneLandmarkLayer::bitSizeOf(LaneLandmarkLayer::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_laneAttributeMaps_.bitSizeOf(context.getLaneAttributeMaps(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LaneLandmarkLayer::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_laneAttributeMaps_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t LaneLandmarkLayer::initializeOffsets(LaneLandmarkLayer::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_laneAttributeMaps_.initializeOffsets(context.getLaneAttributeMaps(), endBitPosition);

    return endBitPosition;
}

bool LaneLandmarkLayer::operator==(const LaneLandmarkLayer& other) const
{
    if (this != &other)
    {
        return
                (m_laneAttributeMaps_ == other.m_laneAttributeMaps_);
    }

    return true;
}

uint32_t LaneLandmarkLayer::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_laneAttributeMaps_);

    return result;
}

void LaneLandmarkLayer::write(::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_laneAttributeMaps_.getCoordShift() != static_cast<::nds::core::geometry::CoordShift>(0))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter coordShift for field LaneLandmarkLayer.laneAttributeMaps: ") <<
                m_laneAttributeMaps_.getCoordShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(0) << "!";
    }
    m_laneAttributeMaps_.write(out);
}

void LaneLandmarkLayer::write(LaneLandmarkLayer::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_laneAttributeMaps_.getCoordShift() != static_cast<::nds::core::geometry::CoordShift>(0))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter coordShift for field LaneLandmarkLayer.laneAttributeMaps: ") <<
                m_laneAttributeMaps_.getCoordShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(0) << "!";
    }
    m_laneAttributeMaps_.write(context.getLaneAttributeMaps(), out);
}

::nds::localization::instantiations::LandmarkLaneAttributeMapList LaneLandmarkLayer::readLaneAttributeMaps(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::localization::instantiations::LandmarkLaneAttributeMapList(in, static_cast<::nds::core::geometry::CoordShift>(0), allocator);
}

::nds::localization::instantiations::LandmarkLaneAttributeMapList LaneLandmarkLayer::readLaneAttributeMaps(LaneLandmarkLayer::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::localization::instantiations::LandmarkLaneAttributeMapList(context.getLaneAttributeMaps(), in, static_cast<::nds::core::geometry::CoordShift>(0), allocator);
}

} // namespace layer
} // namespace localization
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ArrayTraits.h>

#include <nds/localization/layer/RoadSurfaceLandmarkLayer.h>
#include <nds/system/types/LayerType.h>

namespace nds
{
namespace localization
{
namespace layer
{

RoadSurfaceLandmarkLayer::RoadSurfaceLandmarkLayer(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_roadSurfaceAttributeMaps_(allocator)
{
}

RoadSurfaceLandmarkLayer::RoadSurfaceLandmarkLayer(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_roadSurfaceAttributeMaps_(readRoadSurfaceAttributeMaps(in, allocator))
{
}

RoadSurfaceLandmarkLayer::RoadSurfaceLandmarkLayer(RoadSurfaceLandmarkLayer::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_roadSurfaceAttributeMaps_(readRoadSurfaceAttributeMaps(context, in, allocator))
{
}

RoadSurfaceLandmarkLayer::RoadSurfaceLandmarkLayer(const RoadSurfaceLandmarkLayer& other) :
        m_roadSurfaceAttributeMaps_(other.m_roadSurfaceAttributeMaps_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

RoadSurfaceLandmarkLayer& RoadSurfaceLandmarkLayer::operator=(const RoadSurfaceLandmarkLayer& other)
{
    m_roadSurfaceAttributeMaps_ = other.m_roadSurfaceAttributeMaps_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

RoadSurfaceLandmarkLayer::RoadSurfaceLandmarkLayer(RoadSurfaceLandmarkLayer&& other) :
        m_roadSurfaceAttributeMaps_(::std::move(other.m_roadSurfaceAttributeMaps_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

RoadSurfaceLandmarkLayer& RoadSurfaceLandmarkLayer::operator=(RoadSurfaceLandmarkLayer&& other)
{
    m_roadSurfaceAttributeMaps_ = ::std::move(other.m_roadSurfaceAttributeMaps_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

RoadSurfaceLandmarkLayer::RoadSurfaceLandmarkLayer(::zserio::PropagateAllocatorT,
        const RoadSurfaceLandmarkLayer& other, const allocator_type& allocator) :
        m_roadSurfaceAttributeMaps_(::zserio::allocatorPropagatingCopy(other.m_roadSurfaceAttributeMaps_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void RoadSurfaceLandmarkLayer::initializeChildren()
{
    m_roadSurfaceAttributeMaps_.initialize(static_cast<::nds::core::geometry::CoordShift>(0));

    m_areChildrenInitialized = true;
}

::nds::localization::instantiations::LandmarkRoadSurfaceAttributeMapList& RoadSurfaceLandmarkLayer::getRoadSurfaceAttributeMaps()
{
    return m_roadSurfaceAttributeMaps_;
}

const ::nds::localization::instantiations::LandmarkRoadSurfaceAttributeMapList& RoadSurfaceLandmarkLayer::getRoadSurfaceAttributeMaps() const
{
    return m_roadSurfaceAttributeMaps_;
}

void RoadSurfaceLandmarkLayer::setRoadSurfaceAttributeMaps(const ::nds::localization::instantiations::LandmarkRoadSurfaceAttributeMapList& roadSurfaceAttributeMaps_)
{
    m_roadSurfaceAttributeMaps_ = roadSurfaceAttributeMaps_;
}

void RoadSurfaceLandmarkLayer::setRoadSurfaceAttributeMaps(::nds::localization::instantiations::LandmarkRoadSurfaceAttributeMapList&& roadSurfaceAttributeMaps_)
{
    m_roadSurfaceAttributeMaps_ = ::std::move(roadSurfaceAttributeMaps_);
}

::nds::system::types::LayerType RoadSurfaceLandmarkLayer::funcGetLayerType() const
{
    return static_cast<::nds::system::types::LayerType>(::nds::system::types::LayerType::RELATION);
}

void RoadSurfaceLandmarkLayer::initPackingContext(RoadSurfaceLandmarkLayer::ZserioPackingContext& context) const
{
    m_roadSurfaceAttributeMaps_.initPackingContext(context.getRoadSurfaceAttributeMaps());
}

size_t RoadSurfaceLandmarkLayer::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_roadSurfaceAttributeMaps_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoadSurfaceLandmarkLayer::bitSizeOf(RoadSurfaceLandmarkLayer::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_roadSurfaceAttributeMaps_.bitSizeOf(context.getRoadSurfaceAttributeMaps(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoadSurfaceLandmarkLayer::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_roadSurfaceAttributeMaps_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t RoadSurfaceLandmarkLayer::initializeOffsets(RoadSurfaceLandmarkLayer::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_roadSurfaceAttributeMaps_.initializeOffsets(context.getRoadSurfaceAttributeMaps(), endBitPosition);

    return endBitPosition;
}

bool RoadSurfaceLandmarkLayer::operator==(const RoadSurfaceLandmarkLayer& other) const
{
    if (this != &other)
    {
        return
                (m_roadSurfaceAttributeMaps_ == other.m_roadSurfaceAttributeMaps_);
    }

    return true;
}

uint32_t RoadSurfaceLandmarkLayer::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_roadSurfaceAttributeMaps_);

    return result;
}

void RoadSurfaceLandmarkLayer::write(::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_roadSurfaceAttributeMaps_.getCoordShift() != static_cast<::nds::core::geometry::CoordShift>(0))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter coordShift for field RoadSurfaceLandmarkLayer.roadSurfaceAttributeMaps: ") <<
                m_roadSurfaceAttributeMaps_.getCoordShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(0) << "!";
    }
    m_roadSurfaceAttributeMaps_.write(out);
}

void RoadSurfaceLandmarkLayer::write(RoadSurfaceLandmarkLayer::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_roadSurfaceAttributeMaps_.getCoordShift() != static_cast<::nds::core::geometry::CoordShift>(0))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter coordShift for field RoadSurfaceLandmarkLayer.roadSurfaceAttributeMaps: ") <<
                m_roadSurfaceAttributeMaps_.getCoordShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(0) << "!";
    }
    m_roadSurfaceAttributeMaps_.write(context.getRoadSurfaceAttributeMaps(), out);
}

::nds::localization::instantiations::LandmarkRoadSurfaceAttributeMapList RoadSurfaceLandmarkLayer::readRoadSurfaceAttributeMaps(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::localization::instantiations::LandmarkRoadSurfaceAttributeMapList(in, static_cast<::nds::core::geometry::CoordShift>(0), allocator);
}

::nds::localization::instantiations::LandmarkRoadSurfaceAttributeMapList RoadSurfaceLandmarkLayer::readRoadSurfaceAttributeMaps(RoadSurfaceLandmarkLayer::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::localization::instantiations::LandmarkRoadSurfaceAttributeMapList(context.getRoadSurfaceAttributeMaps(), in, static_cast<::nds::core::geometry::CoordShift>(0), allocator);
}

} // namespace layer
} // namespace localization
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ArrayTraits.h>

#include <nds/localization/layer/ObstacleLayer.h>
#include <nds/core/geometry/GeometryLayerType.h>
#include <nds/system/types/LayerType.h>

namespace nds
{
namespace localization
{
namespace layer
{

ObstacleLayer::ObstacleLayer(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_obstacleGeometryLayer_(allocator)
{
}

ObstacleLayer::ObstacleLayer(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_obstacleGeometryLayer_(readObstacleGeometryLayer(in, allocator))
{
}

ObstacleLayer::ObstacleLayer(ObstacleLayer::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_obstacleGeometryLayer_(readObstacleGeometryLayer(context, in, allocator))
{
}

ObstacleLayer::ObstacleLayer(const ObstacleLayer& other) :
        m_obstacleGeometryLayer_(other.m_obstacleGeometryLayer_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

ObstacleLayer& ObstacleLayer::operator=(const ObstacleLayer& other)
{
    m_obstacleGeometryLayer_ = other.m_obstacleGeometryLayer_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

ObstacleLayer::ObstacleLayer(ObstacleLayer&& other) :
        m_obstacleGeometryLayer_(::std::move(other.m_obstacleGeometryLayer_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

ObstacleLayer& ObstacleLayer::operator=(ObstacleLayer&& other)
{
    m_obstacleGeometryLayer_ = ::std::move(other.m_obstacleGeometryLayer_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

ObstacleLayer::ObstacleLayer(::zserio::PropagateAllocatorT,
        const ObstacleLayer& other, const allocator_type& allocator) :
        m_obstacleGeometryLayer_(::zserio::allocatorPropagatingCopy(other.m_obstacleGeometryLayer_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void ObstacleLayer::initializeChildren()
{
    m_obstacleGeometryLayer_.initialize(static_cast<::nds::core::geometry::GeometryLayerType>(::nds::core::geometry::GeometryLayerType::LINE_3D), static_cast<bool>(false), static_cast<bool>(true));

    m_areChildrenInitialized = true;
}

::nds::localization::instantiations::ObstacleGeometryLayer& ObstacleLayer::getObstacleGeometryLayer()
{
    return m_obstacleGeometryLayer_;
}

const ::nds::localization::instantiations::ObstacleGeometryLayer& ObstacleLayer::getObstacleGeometryLayer() const
{
    return m_obstacleGeometryLayer_;
}

void ObstacleLayer::setObstacleGeometryLayer(const ::nds::localization::instantiations::ObstacleGeometryLayer& obstacleGeometryLayer_)
{
    m_obstacleGeometryLayer_ = obstacleGeometryLayer_;
}

void ObstacleLayer::setObstacleGeometryLayer(::nds::localization::instantiations::ObstacleGeometryLayer&& obstacleGeometryLayer_)
{
    m_obstacleGeometryLayer_ = ::std::move(obstacleGeometryLayer_);
}

::nds::system::types::LayerType ObstacleLayer::funcGetLayerType() const
{
    return static_cast<::nds::system::types::LayerType>(::nds::system::types::LayerType::GEOMETRY);
}

void ObstacleLayer::initPackingContext(ObstacleLayer::ZserioPackingContext& context) const
{
    m_obstacleGeometryLayer_.initPackingContext(context.getObstacleGeometryLayer());
}

size_t ObstacleLayer::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_obstacleGeometryLayer_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ObstacleLayer::bitSizeOf(ObstacleLayer::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_obstacleGeometryLayer_.bitSizeOf(context.getObstacleGeometryLayer(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ObstacleLayer::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_obstacleGeometryLayer_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t ObstacleLayer::initializeOffsets(ObstacleLayer::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_obstacleGeometryLayer_.initializeOffsets(context.getObstacleGeometryLayer(), endBitPosition);

    return endBitPosition;
}

bool ObstacleLayer::operator==(const ObstacleLayer& other) const
{
    if (this != &other)
    {
        return
                (m_obstacleGeometryLayer_ == other.m_obstacleGeometryLayer_);
    }

    return true;
}

uint32_t ObstacleLayer::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_obstacleGeometryLayer_);

    return result;
}

void ObstacleLayer::write(::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_obstacleGeometryLayer_.getType() != static_cast<::nds::core::geometry::GeometryLayerType>(::nds::core::geometry::GeometryLayerType::LINE_3D))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field ObstacleLayer.obstacleGeometryLayer: ") <<
                m_obstacleGeometryLayer_.getType() << " != " << static_cast<::nds::core::geometry::GeometryLayerType>(::nds::core::geometry::GeometryLayerType::LINE_3D) << "!";
    }
    if (m_obstacleGeometryLayer_.getHasIds() != static_cast<bool>(false))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter hasIds for field ObstacleLayer.obstacleGeometryLayer: ") <<
                m_obstacleGeometryLayer_.getHasIds() << " != " << static_cast<bool>(false) << "!";
    }
    if (m_obstacleGeometryLayer_.getHasTypes() != static_cast<bool>(true))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter hasTypes for field ObstacleLayer.obstacleGeometryLayer: ") <<
                m_obstacleGeometryLayer_.getHasTypes() << " != " << static_cast<bool>(true) << "!";
    }
    m_obstacleGeometryLayer_.write(out);
}

void ObstacleLayer::write(ObstacleLayer::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_obstacleGeometryLayer_.getType() != static_cast<::nds::core::geometry::GeometryLayerType>(::nds::core::geometry::GeometryLayerType::LINE_3D))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field ObstacleLayer.obstacleGeometryLayer: ") <<
                m_obstacleGeometryLayer_.getType() << " != " << static_cast<::nds::core::geometry::GeometryLayerType>(::nds::core::geometry::GeometryLayerType::LINE_3D) << "!";
    }
    if (m_obstacleGeometryLayer_.getHasIds() != static_cast<bool>(false))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter hasIds for field ObstacleLayer.obstacleGeometryLayer: ") <<
                m_obstacleGeometryLayer_.getHasIds() << " != " << static_cast<bool>(false) << "!";
    }
    if (m_obstacleGeometryLayer_.getHasTypes() != static_cast<bool>(true))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter hasTypes for field ObstacleLayer.obstacleGeometryLayer: ") <<
                m_obstacleGeometryLayer_.getHasTypes() << " != " << static_cast<bool>(true) << "!";
    }
    m_obstacleGeometryLayer_.write(context.getObstacleGeometryLayer(), out);
}

::nds::localization::instantiations::ObstacleGeometryLayer ObstacleLayer::readObstacleGeometryLayer(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::localization::instantiations::ObstacleGeometryLayer(in, static_cast<::nds::core::geometry::GeometryLayerType>(::nds::core::geometry::GeometryLayerType::LINE_3D), static_cast<bool>(false), static_cast<bool>(true), allocator);
}

::nds::localization::instantiations::ObstacleGeometryLayer ObstacleLayer::readObstacleGeometryLayer(ObstacleLayer::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::localization::instantiations::ObstacleGeometryLayer(context.getObstacleGeometryLayer(), in, static_cast<::nds::core::geometry::GeometryLayerType>(::nds::core::geometry::GeometryLayerType::LINE_3D), static_cast<bool>(false), static_cast<bool>(true), allocator);
}

} // namespace layer
} // namespace localization
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ArrayTraits.h>

#include <nds/localization/layer/OccupancyGridLayer.h>
#include <nds/system/types/LayerType.h>

namespace nds
{
namespace localization
{
namespace layer
{

OccupancyGridLayer::OccupancyGridLayer(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_hasIds_(bool()),
        m_gridLayer_(allocator)
{
}

OccupancyGridLayer::OccupancyGridLayer(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_hasIds_(readHasIds(in)),
        m_gridLayer_(readGridLayer(in, allocator))
{
}

OccupancyGridLayer::OccupancyGridLayer(OccupancyGridLayer::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_hasIds_(readHasIds(in)),
        m_gridLayer_(readGridLayer(context, in, allocator))
{
}

OccupancyGridLayer::OccupancyGridLayer(const OccupancyGridLayer& other) :
        m_hasIds_(other.m_hasIds_),
        m_gridLayer_(other.m_gridLayer_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

OccupancyGridLayer& OccupancyGridLayer::operator=(const OccupancyGridLayer& other)
{
    m_hasIds_ = other.m_hasIds_;
    m_gridLayer_ = other.m_gridLayer_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

OccupancyGridLayer::OccupancyGridLayer(OccupancyGridLayer&& other) :
        m_hasIds_(::std::move(other.m_hasIds_)),
        m_gridLayer_(::std::move(other.m_gridLayer_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

OccupancyGridLayer& OccupancyGridLayer::operator=(OccupancyGridLayer&& other)
{
    m_hasIds_ = ::std::move(other.m_hasIds_);
    m_gridLayer_ = ::std::move(other.m_gridLayer_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

OccupancyGridLayer::OccupancyGridLayer(::zserio::PropagateAllocatorT,
        const OccupancyGridLayer& other, const allocator_type& allocator) :
        m_hasIds_(::zserio::allocatorPropagatingCopy(other.m_hasIds_, allocator)),
        m_gridLayer_(::zserio::allocatorPropagatingCopy(other.m_gridLayer_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void OccupancyGridLayer::initializeChildren()
{
    m_gridLayer_.initialize(static_cast<bool>(getHasIds()), static_cast<bool>(false));

    m_areChildrenInitialized = true;
}

bool OccupancyGridLayer::getHasIds() const
{
    return m_hasIds_;
}

void OccupancyGridLayer::setHasIds(bool hasIds_)
{
    m_hasIds_ = hasIds_;
}

::nds::localization::instantiations::OccupancyProbabilityGridLayer& OccupancyGridLayer::getGridLayer()
{
    return m_gridLayer_;
}

const ::nds::localization::instantiations::OccupancyProbabilityGridLayer& OccupancyGridLayer::getGridLayer() const
{
    return m_gridLayer_;
}

void OccupancyGridLayer::setGridLayer(const ::nds::localization::instantiations::OccupancyProbabilityGridLayer& gridLayer_)
{
    m_gridLayer_ = gridLayer_;
}

void OccupancyGridLayer::setGridLayer(::nds::localization::instantiations::OccupancyProbabilityGridLayer&& gridLayer_)
{
    m_gridLayer_ = ::std::move(gridLayer_);
}

::nds::system::types::LayerType OccupancyGridLayer::funcGetLayerType() const
{
    return static_cast<::nds::system::types::LayerType>(::nds::system::types::LayerType::GEOMETRY);
}

void OccupancyGridLayer::initPackingContext(OccupancyGridLayer::ZserioPackingContext& context) const
{
    m_gridLayer_.initPackingContext(context.getGridLayer());
}

size_t OccupancyGridLayer::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    endBitPosition += m_gridLayer_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t OccupancyGridLayer::bitSizeOf(OccupancyGridLayer::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    endBitPosition += m_gridLayer_.bitSizeOf(context.getGridLayer(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t OccupancyGridLayer::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    endBitPosition = m_gridLayer_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t OccupancyGridLayer::initializeOffsets(OccupancyGridLayer::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(1);
    endBitPosition = m_gridLayer_.initializeOffsets(context.getGridLayer(), endBitPosition);

    return endBitPosition;
}

bool OccupancyGridLayer::operator==(const OccupancyGridLayer& other) const
{
    if (this != &other)
    {
        return
                (m_hasIds_ == other.m_hasIds_) &&
                (m_gridLayer_ == other.m_gridLayer_);
    }

    return true;
}

uint32_t OccupancyGridLayer::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_hasIds_);
    result = ::zserio::calcHashCode(result, m_gridLayer_);

    return result;
}

void OccupancyGridLayer::write(::zserio::BitStreamWriter& out) const
{
    out.writeBool(m_hasIds_);

    // check parameters
    if (m_gridLayer_.getHasIds() != static_cast<bool>(getHasIds()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter hasIds for field OccupancyGridLayer.gridLayer: ") <<
                m_gridLayer_.getHasIds() << " != " << static_cast<bool>(getHasIds()) << "!";
    }
    if (m_gridLayer_.getHasTypes() != static_cast<bool>(false))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter hasTypes for field OccupancyGridLayer.gridLayer: ") <<
                m_gridLayer_.getHasTypes() << " != " << static_cast<bool>(false) << "!";
    }
    m_gridLayer_.write(out);
}

void OccupancyGridLayer::write(OccupancyGridLayer::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    out.writeBool(m_hasIds_);

    // check parameters
    if (m_gridLayer_.getHasIds() != static_cast<bool>(getHasIds()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter hasIds for field OccupancyGridLayer.gridLayer: ") <<
                m_gridLayer_.getHasIds() << " != " << static_cast<bool>(getHasIds()) << "!";
    }
    if (m_gridLayer_.getHasTypes() != static_cast<bool>(false))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter hasTypes for field OccupancyGridLayer.gridLayer: ") <<
                m_gridLayer_.getHasTypes() << " != " << static_cast<bool>(false) << "!";
    }
    m_gridLayer_.write(context.getGridLayer(), out);
}

bool OccupancyGridLayer::readHasIds(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
::nds::localization::instantiations::OccupancyProbabilityGridLayer OccupancyGridLayer::readGridLayer(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::localization::instantiations::OccupancyProbabilityGridLayer(in, static_cast<bool>(getHasIds()), static_cast<bool>(false), allocator);
}

::nds::localization::instantiations::OccupancyProbabilityGridLayer OccupancyGridLayer::readGridLayer(OccupancyGridLayer::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::localization::instantiations::OccupancyProbabilityGridLayer(context.getGridLayer(), in, static_cast<bool>(getHasIds()), static_cast<bool>(false), allocator);
}

} // namespace layer
} // namespace localization
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ArrayTraits.h>

#include <nds/localization/layer/RoadOccupancyGridLayer.h>
#include <nds/system/types/LayerType.h>

namespace nds
{
namespace localization
{
namespace layer
{

RoadOccupancyGridLayer::RoadOccupancyGridLayer(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_shift_(::nds::core::geometry::CoordShift()),
        m_roadAttributeMaps_(allocator)
{
}

RoadOccupancyGridLayer::RoadOccupancyGridLayer(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_shift_(readShift(in)),
        m_roadAttributeMaps_(readRoadAttributeMaps(in, allocator))
{
}

RoadOccupancyGridLayer::RoadOccupancyGridLayer(RoadOccupancyGridLayer::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_shift_(readShift(context, in)),
        m_roadAttributeMaps_(readRoadAttributeMaps(context, in, allocator))
{
}

RoadOccupancyGridLayer::RoadOccupancyGridLayer(const RoadOccupancyGridLayer& other) :
        m_shift_(other.m_shift_),
        m_roadAttributeMaps_(other.m_roadAttributeMaps_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

RoadOccupancyGridLayer& RoadOccupancyGridLayer::operator=(const RoadOccupancyGridLayer& other)
{
    m_shift_ = other.m_shift_;
    m_roadAttributeMaps_ = other.m_roadAttributeMaps_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

RoadOccupancyGridLayer::RoadOccupancyGridLayer(RoadOccupancyGridLayer&& other) :
        m_shift_(::std::move(other.m_shift_)),
        m_roadAttributeMaps_(::std::move(other.m_roadAttributeMaps_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

RoadOccupancyGridLayer& RoadOccupancyGridLayer::operator=(RoadOccupancyGridLayer&& other)
{
    m_shift_ = ::std::move(other.m_shift_);
    m_roadAttributeMaps_ = ::std::move(other.m_roadAttributeMaps_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

RoadOccupancyGridLayer::RoadOccupancyGridLayer(::zserio::PropagateAllocatorT,
        const RoadOccupancyGridLayer& other, const allocator_type& allocator) :
        m_shift_(::zserio::allocatorPropagatingCopy(other.m_shift_, allocator)),
        m_roadAttributeMaps_(::zserio::allocatorPropagatingCopy(other.m_roadAttributeMaps_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void RoadOccupancyGridLayer::initializeChildren()
{
    m_roadAttributeMaps_.initialize(static_cast<::nds::core::geometry::CoordShift>(getShift()));

    m_areChildrenInitialized = true;
}

::nds::core::geometry::CoordShift RoadOccupancyGridLayer::getShift() const
{
    return m_shift_;
}

void RoadOccupancyGridLayer::setShift(::nds::core::geometry::CoordShift shift_)
{
    m_shift_ = shift_;
}

::nds::localization::instantiations::OccupancyGridRoadAttributeMapList& RoadOccupancyGridLayer::getRoadAttributeMaps()
{
    return m_roadAttributeMaps_;
}

const ::nds::localization::instantiations::OccupancyGridRoadAttributeMapList& RoadOccupancyGridLayer::getRoadAttributeMaps() const
{
    return m_roadAttributeMaps_;
}

void RoadOccupancyGridLayer::setRoadAttributeMaps(const ::nds::localization::instantiations::OccupancyGridRoadAttributeMapList& roadAttributeMaps_)
{
    m_roadAttributeMaps_ = roadAttributeMaps_;
}

void RoadOccupancyGridLayer::setRoadAttributeMaps(::nds::localization::instantiations::OccupancyGridRoadAttributeMapList&& roadAttributeMaps_)
{
    m_roadAttributeMaps_ = ::std::move(roadAttributeMaps_);
}

::nds::system::types::LayerType RoadOccupancyGridLayer::funcGetLayerType() const
{
    return static_cast<::nds::system::types::LayerType>(::nds::system::types::LayerType::RELATION);
}

void RoadOccupancyGridLayer::initPackingContext(RoadOccupancyGridLayer::ZserioPackingContext& context) const
{
    context.getShift().init<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(m_shift_);
    m_roadAttributeMaps_.initPackingContext(context.getRoadAttributeMaps());
}

size_t RoadOccupancyGridLayer::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(5);
    endBitPosition += m_roadAttributeMaps_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoadOccupancyGridLayer::bitSizeOf(RoadOccupancyGridLayer::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getShift().bitSizeOf<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(m_shift_);
    endBitPosition += m_roadAttributeMaps_.bitSizeOf(context.getRoadAttributeMaps(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoadOccupancyGridLayer::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(5);
    endBitPosition = m_roadAttributeMaps_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t RoadOccupancyGridLayer::initializeOffsets(RoadOccupancyGridLayer::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getShift().bitSizeOf<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(m_shift_);
    endBitPosition = m_roadAttributeMaps_.initializeOffsets(context.getRoadAttributeMaps(), endBitPosition);

    return endBitPosition;
}

bool RoadOccupancyGridLayer::operator==(const RoadOccupancyGridLayer& other) const
{
    if (this != &other)
    {
        return
                (m_shift_ == other.m_shift_) &&
                (m_roadAttributeMaps_ == other.m_roadAttributeMaps_);
    }

    return true;
}

uint32_t RoadOccupancyGridLayer::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_shift_);
    result = ::zserio::calcHashCode(result, m_roadAttributeMaps_);

    return result;
}

void RoadOccupancyGridLayer::write(::zserio::BitStreamWriter& out) const
{
    out.writeBits(m_shift_, UINT8_C(5));

    // check parameters
    if (m_roadAttributeMaps_.getCoordShift() != static_cast<::nds::core::geometry::CoordShift>(getShift()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter coordShift for field RoadOccupancyGridLayer.roadAttributeMaps: ") <<
                m_roadAttributeMaps_.getCoordShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShift()) << "!";
    }
    m_roadAttributeMaps_.write(out);
}

void RoadOccupancyGridLayer::write(RoadOccupancyGridLayer::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getShift().write<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(out, m_shift_);

    // check parameters
    if (m_roadAttributeMaps_.getCoordShift() != static_cast<::nds::core::geometry::CoordShift>(getShift()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter coordShift for field RoadOccupancyGridLayer.roadAttributeMaps: ") <<
                m_roadAttributeMaps_.getCoordShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShift()) << "!";
    }
    m_roadAttributeMaps_.write(context.getRoadAttributeMaps(), out);
}

::nds::core::geometry::CoordShift RoadOccupancyGridLayer::readShift(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::geometry::CoordShift>(in.readBits(UINT8_C(5)));
}

::nds::core::geometry::CoordShift RoadOccupancyGridLayer::readShift(RoadOccupancyGridLayer::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getShift().read<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(in);
}
::nds::localization::instantiations::OccupancyGridRoadAttributeMapList RoadOccupancyGridLayer::readRoadAttributeMaps(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::localization::instantiations::OccupancyGridRoadAttributeMapList(in, static_cast<::nds::core::geometry::CoordShift>(getShift()), allocator);
}

::nds::localization::instantiations::OccupancyGridRoadAttributeMapList RoadOccupancyGridLayer::readRoadAttributeMaps(RoadOccupancyGridLayer::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::localization::instantiations::OccupancyGridRoadAttributeMapList(context.getRoadAttributeMaps(), in, static_cast<::nds::core::geometry::CoordShift>(getShift()), allocator);
}

} // namespace layer
} // namespace localization
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ArrayTraits.h>

#include <nds/localization/layer/LaneOccupancyGridLayer.h>
#include <nds/system/types/LayerType.h>

namespace nds
{
namespace localization
{
namespace layer
{

LaneOccupancyGridLayer::LaneOccupancyGridLayer(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_laneAttributeMaps_(allocator)
{
}

LaneOccupancyGridLayer::LaneOccupancyGridLayer(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_laneAttributeMaps_(readLaneAttributeMaps(in, allocator))
{
}

LaneOccupancyGridLayer::LaneOccupancyGridLayer(LaneOccupancyGridLayer::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_laneAttributeMaps_(readLaneAttributeMaps(context, in, allocator))
{
}

LaneOccupancyGridLayer::LaneOccupancyGridLayer(const LaneOccupancyGridLayer& other) :
        m_laneAttributeMaps_(other.m_laneAttributeMaps_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

LaneOccupancyGridLayer& LaneOccupancyGridLayer::operator=(const LaneOccupancyGridLayer& other)
{
    m_laneAttributeMaps_ = other.m_laneAttributeMaps_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

LaneOccupancyGridLayer::LaneOccupancyGridLayer(LaneOccupancyGridLayer&& other) :
        m_laneAttributeMaps_(::std::move(other.m_laneAttributeMaps_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

LaneOccupancyGridLayer& LaneOccupancyGridLayer::operator=(LaneOccupancyGridLayer&& other)
{
    m_laneAttributeMaps_ = ::std::move(other.m_laneAttributeMaps_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

LaneOccupancyGridLayer::LaneOccupancyGridLayer(::zserio::PropagateAllocatorT,
        const LaneOccupancyGridLayer& other, const allocator_type& allocator) :
        m_laneAttributeMaps_(::zserio::allocatorPropagatingCopy(other.m_laneAttributeMaps_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void LaneOccupancyGridLayer::initializeChildren()
{
    m_laneAttributeMaps_.initialize(static_cast<::nds::core::geometry::CoordShift>(0));

    m_areChildrenInitialized = true;
}

::nds::localization::instantiations::OccupancyGridLaneAttributeMapList& LaneOccupancyGridLayer::getLaneAttributeMaps()
{
    return m_laneAttributeMaps_;
}

const ::nds::localization::instantiations::OccupancyGridLaneAttributeMapList& LaneOccupancyGridLayer::getLaneAttributeMaps() const
{
    return m_laneAttributeMaps_;
}

void LaneOccupancyGridLayer::setLaneAttributeMaps(const ::nds::localization::instantiations::OccupancyGridLaneAttributeMapList& laneAttributeMaps_)
{
    m_laneAttributeMaps_ = laneAttributeMaps_;
}

void LaneOccupancyGridLayer::setLaneAttributeMaps(::nds::localization::instantiations::OccupancyGridLaneAttributeMapList&& laneAttributeMaps_)
{
    m_laneAttributeMaps_ = ::std::move(laneAttributeMaps_);
}

::nds::system::types::LayerType LaneOccupancyGridLayer::funcGetLayerType() const
{
    return static_cast<::nds::system::types::LayerType>(::nds::system::types::LayerType::RELATION);
}

void LaneOccupancyGridLayer::initPackingContext(LaneOccupancyGridLayer::ZserioPackingContext& context) const
{
    m_laneAttributeMaps_.initPackingContext(context.getLaneAttributeMaps());
}

size_t LaneOccupancyGridLayer::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_laneAttributeMaps_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LaneOccupancyGridLayer::bitSizeOf(LaneOccupancyGridLayer::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_laneAttributeMaps_.bitSizeOf(context.getLaneAttributeMaps(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LaneOccupancyGridLayer::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_laneAttributeMaps_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t LaneOccupancyGridLayer::initializeOffsets(LaneOccupancyGridLayer::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_laneAttributeMaps_.initializeOffsets(context.getLaneAttributeMaps(), endBitPosition);

    return endBitPosition;
}

bool LaneOccupancyGridLayer::operator==(const LaneOccupancyGridLayer& other) const
{
    if (this != &other)
    {
        return
                (m_laneAttributeMaps_ == other.m_laneAttributeMaps_);
    }

    return true;
}

uint32_t LaneOccupancyGridLayer::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_laneAttributeMaps_);

    return result;
}

void LaneOccupancyGridLayer::write(::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_laneAttributeMaps_.getCoordShift() != static_cast<::nds::core::geometry::CoordShift>(0))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter coordShift for field LaneOccupancyGridLayer.laneAttributeMaps: ") <<
                m_laneAttributeMaps_.getCoordShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(0) << "!";
    }
    m_laneAttributeMaps_.write(out);
}

void LaneOccupancyGridLayer::write(LaneOccupancyGridLayer::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_laneAttributeMaps_.getCoordShift() != static_cast<::nds::core::geometry::CoordShift>(0))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter coordShift for field LaneOccupancyGridLayer.laneAttributeMaps: ") <<
                m_laneAttributeMaps_.getCoordShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(0) << "!";
    }
    m_laneAttributeMaps_.write(context.getLaneAttributeMaps(), out);
}

::nds::localization::instantiations::OccupancyGridLaneAttributeMapList LaneOccupancyGridLayer::readLaneAttributeMaps(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::localization::instantiations::OccupancyGridLaneAttributeMapList(in, static_cast<::nds::core::geometry::CoordShift>(0), allocator);
}

::nds::localization::instantiations::OccupancyGridLaneAttributeMapList LaneOccupancyGridLayer::readLaneAttributeMaps(LaneOccupancyGridLayer::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::localization::instantiations::OccupancyGridLaneAttributeMapList(context.getLaneAttributeMaps(), in, static_cast<::nds::core::geometry::CoordShift>(0), allocator);
}

} // namespace layer
} // namespace localization
} // namespace nds
