/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/localization/metadata/OccupancyGridLayerMetadata.h>

namespace nds
{
namespace localization
{
namespace metadata
{

OccupancyGridLayerMetadata::OccupancyGridLayerMetadata(const allocator_type&) noexcept :
        m_cellSize_(::nds::core::grid::GridCellSize()),
        m_hasRelations_(bool())
{
}

OccupancyGridLayerMetadata::OccupancyGridLayerMetadata(::zserio::BitStreamReader& in, const allocator_type&) :
        m_cellSize_(readCellSize(in)),
        m_hasRelations_(readHasRelations(in))
{
}

OccupancyGridLayerMetadata::OccupancyGridLayerMetadata(OccupancyGridLayerMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type&) :
        m_cellSize_(readCellSize(context, in)),
        m_hasRelations_(readHasRelations(in))
{
}

OccupancyGridLayerMetadata::OccupancyGridLayerMetadata(::zserio::PropagateAllocatorT,
        const OccupancyGridLayerMetadata& other, const allocator_type& allocator) :
        m_cellSize_(::zserio::allocatorPropagatingCopy(other.m_cellSize_, allocator)),
        m_hasRelations_(::zserio::allocatorPropagatingCopy(other.m_hasRelations_, allocator))
{
}

::nds::core::grid::GridCellSize OccupancyGridLayerMetadata::getCellSize() const
{
    return m_cellSize_;
}

void OccupancyGridLayerMetadata::setCellSize(::nds::core::grid::GridCellSize cellSize_)
{
    m_cellSize_ = cellSize_;
}

bool OccupancyGridLayerMetadata::getHasRelations() const
{
    return m_hasRelations_;
}

void OccupancyGridLayerMetadata::setHasRelations(bool hasRelations_)
{
    m_hasRelations_ = hasRelations_;
}

void OccupancyGridLayerMetadata::initPackingContext(OccupancyGridLayerMetadata::ZserioPackingContext& context) const
{
    context.getCellSize().init<::zserio::VarSizeArrayTraits>(m_cellSize_);
}

size_t OccupancyGridLayerMetadata::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_cellSize_);
    endBitPosition += UINT8_C(1);

    return endBitPosition - bitPosition;
}

size_t OccupancyGridLayerMetadata::bitSizeOf(OccupancyGridLayerMetadata::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getCellSize().bitSizeOf<::zserio::VarSizeArrayTraits>(m_cellSize_);
    endBitPosition += UINT8_C(1);

    return endBitPosition - bitPosition;
}

size_t OccupancyGridLayerMetadata::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_cellSize_);
    endBitPosition += UINT8_C(1);

    return endBitPosition;
}

size_t OccupancyGridLayerMetadata::initializeOffsets(OccupancyGridLayerMetadata::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getCellSize().bitSizeOf<::zserio::VarSizeArrayTraits>(m_cellSize_);
    endBitPosition += UINT8_C(1);

    return endBitPosition;
}

bool OccupancyGridLayerMetadata::operator==(const OccupancyGridLayerMetadata& other) const
{
    if (this != &other)
    {
        return
                (m_cellSize_ == other.m_cellSize_) &&
                (m_hasRelations_ == other.m_hasRelations_);
    }

    return true;
}

uint32_t OccupancyGridLayerMetadata::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_cellSize_);
    result = ::zserio::calcHashCode(result, m_hasRelations_);

    return result;
}

void OccupancyGridLayerMetadata::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_cellSize_);
    out.writeBool(m_hasRelations_);
}

void OccupancyGridLayerMetadata::write(OccupancyGridLayerMetadata::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getCellSize().write<::zserio::VarSizeArrayTraits>(out, m_cellSize_);
    out.writeBool(m_hasRelations_);
}

::nds::core::grid::GridCellSize OccupancyGridLayerMetadata::readCellSize(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::grid::GridCellSize>(in.readVarSize());
}

::nds::core::grid::GridCellSize OccupancyGridLayerMetadata::readCellSize(OccupancyGridLayerMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getCellSize().read<::zserio::VarSizeArrayTraits>(in);
}
bool OccupancyGridLayerMetadata::readHasRelations(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}

} // namespace metadata
} // namespace localization
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/localization/metadata/ObstacleLayerMetadata.h>

namespace nds
{
namespace localization
{
namespace metadata
{

ObstacleLayerMetadata::ObstacleLayerMetadata(const allocator_type& allocator) noexcept :
        m_availableObstacleTypes_(allocator)
{
}

ObstacleLayerMetadata::ObstacleLayerMetadata(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_availableObstacleTypes_(readAvailableObstacleTypes(in, allocator))
{
}

ObstacleLayerMetadata::ObstacleLayerMetadata(ObstacleLayerMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_availableObstacleTypes_(readAvailableObstacleTypes(context, in, allocator))
{
}

ObstacleLayerMetadata::ObstacleLayerMetadata(::zserio::PropagateAllocatorT,
        const ObstacleLayerMetadata& other, const allocator_type& allocator) :
        m_availableObstacleTypes_(::zserio::allocatorPropagatingCopy(other.m_availableObstacleTypes_, allocator))
{
}

::zserio::vector<::nds::localization::types::ObstacleType>& ObstacleLayerMetadata::getAvailableObstacleTypes()
{
    return m_availableObstacleTypes_.getRawArray();
}

const ::zserio::vector<::nds::localization::types::ObstacleType>& ObstacleLayerMetadata::getAvailableObstacleTypes() const
{
    return m_availableObstacleTypes_.getRawArray();
}

void ObstacleLayerMetadata::setAvailableObstacleTypes(const ::zserio::vector<::nds::localization::types::ObstacleType>& availableObstacleTypes_)
{
    m_availableObstacleTypes_ = ZserioArrayType_availableObstacleTypes(availableObstacleTypes_);
}

void ObstacleLayerMetadata::setAvailableObstacleTypes(::zserio::vector<::nds::localization::types::ObstacleType>&& availableObstacleTypes_)
{
    m_availableObstacleTypes_ = ZserioArrayType_availableObstacleTypes(std::move(availableObstacleTypes_));
}

void ObstacleLayerMetadata::initPackingContext(ObstacleLayerMetadata::ZserioPackingContext&) const
{
}

size_t ObstacleLayerMetadata::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_availableObstacleTypes_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ObstacleLayerMetadata::bitSizeOf(ObstacleLayerMetadata::ZserioPackingContext&, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_availableObstacleTypes_.bitSizeOfPacked(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ObstacleLayerMetadata::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_availableObstacleTypes_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t ObstacleLayerMetadata::initializeOffsets(ObstacleLayerMetadata::ZserioPackingContext&, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_availableObstacleTypes_.initializeOffsetsPacked(endBitPosition);

    return endBitPosition;
}

bool ObstacleLayerMetadata::operator==(const ObstacleLayerMetadata& other) const
{
    if (this != &other)
    {
        return
                (m_availableObstacleTypes_ == other.m_availableObstacleTypes_);
    }

    return true;
}

uint32_t ObstacleLayerMetadata::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_availableObstacleTypes_);

    return result;
}

void ObstacleLayerMetadata::write(::zserio::BitStreamWriter& out) const
{
    m_availableObstacleTypes_.write(out);
}

void ObstacleLayerMetadata::write(ObstacleLayerMetadata::ZserioPackingContext&, ::zserio::BitStreamWriter& out) const
{
    m_availableObstacleTypes_.writePacked(out);
}

ObstacleLayerMetadata::ZserioArrayType_availableObstacleTypes ObstacleLayerMetadata::readAvailableObstacleTypes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_availableObstacleTypes readField(allocator);
    readField.read(in);

    return readField;
}

ObstacleLayerMetadata::ZserioArrayType_availableObstacleTypes ObstacleLayerMetadata::readAvailableObstacleTypes(ObstacleLayerMetadata::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_availableObstacleTypes readField(allocator);
    readField.readPacked(in);

    return readField;
}

} // namespace metadata
} // namespace localization
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/localization/metadata/LandmarkLayerMetadata.h>

namespace nds
{
namespace localization
{
namespace metadata
{

LandmarkLayerMetadata::LandmarkLayerMetadata(const allocator_type& allocator) noexcept :
        m_availableLineTypes_(allocator),
        m_availablePolygonTypes_(allocator),
        m_availableMeshTypes_(allocator),
        m_hasRelations_(bool()),
        m_hasDetails_(bool())
{
}

LandmarkLayerMetadata::LandmarkLayerMetadata(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_availableLineTypes_(readAvailableLineTypes(in, allocator)),
        m_availablePolygonTypes_(readAvailablePolygonTypes(in, allocator)),
        m_availableMeshTypes_(readAvailableMeshTypes(in, allocator)),
        m_hasRelations_(readHasRelations(in)),
        m_hasDetails_(readHasDetails(in))
{
}

LandmarkLayerMetadata::LandmarkLayerMetadata(LandmarkLayerMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_availableLineTypes_(readAvailableLineTypes(context, in, allocator)),
        m_availablePolygonTypes_(readAvailablePolygonTypes(context, in, allocator)),
        m_availableMeshTypes_(readAvailableMeshTypes(context, in, allocator)),
        m_hasRelations_(readHasRelations(in)),
        m_hasDetails_(readHasDetails(in))
{
}

LandmarkLayerMetadata::LandmarkLayerMetadata(::zserio::PropagateAllocatorT,
        const LandmarkLayerMetadata& other, const allocator_type& allocator) :
        m_availableLineTypes_(::zserio::allocatorPropagatingCopy(other.m_availableLineTypes_, allocator)),
        m_availablePolygonTypes_(::zserio::allocatorPropagatingCopy(other.m_availablePolygonTypes_, allocator)),
        m_availableMeshTypes_(::zserio::allocatorPropagatingCopy(other.m_availableMeshTypes_, allocator)),
        m_hasRelations_(::zserio::allocatorPropagatingCopy(other.m_hasRelations_, allocator)),
        m_hasDetails_(::zserio::allocatorPropagatingCopy(other.m_hasDetails_, allocator))
{
}

::zserio::vector<::nds::localization::types::LandmarkLineType>& LandmarkLayerMetadata::getAvailableLineTypes()
{
    return m_availableLineTypes_.getRawArray();
}

const ::zserio::vector<::nds::localization::types::LandmarkLineType>& LandmarkLayerMetadata::getAvailableLineTypes() const
{
    return m_availableLineTypes_.getRawArray();
}

void LandmarkLayerMetadata::setAvailableLineTypes(const ::zserio::vector<::nds::localization::types::LandmarkLineType>& availableLineTypes_)
{
    m_availableLineTypes_ = ZserioArrayType_availableLineTypes(availableLineTypes_);
}

void LandmarkLayerMetadata::setAvailableLineTypes(::zserio::vector<::nds::localization::types::LandmarkLineType>&& availableLineTypes_)
{
    m_availableLineTypes_ = ZserioArrayType_availableLineTypes(std::move(availableLineTypes_));
}

::zserio::vector<::nds::localization::types::LandmarkPolygonType>& LandmarkLayerMetadata::getAvailablePolygonTypes()
{
    return m_availablePolygonTypes_.getRawArray();
}

const ::zserio::vector<::nds::localization::types::LandmarkPolygonType>& LandmarkLayerMetadata::getAvailablePolygonTypes() const
{
    return m_availablePolygonTypes_.getRawArray();
}

void LandmarkLayerMetadata::setAvailablePolygonTypes(const ::zserio::vector<::nds::localization::types::LandmarkPolygonType>& availablePolygonTypes_)
{
    m_availablePolygonTypes_ = ZserioArrayType_availablePolygonTypes(availablePolygonTypes_);
}

void LandmarkLayerMetadata::setAvailablePolygonTypes(::zserio::vector<::nds::localization::types::LandmarkPolygonType>&& availablePolygonTypes_)
{
    m_availablePolygonTypes_ = ZserioArrayType_availablePolygonTypes(std::move(availablePolygonTypes_));
}

::zserio::vector<::nds::localization::types::LandmarkMeshType>& LandmarkLayerMetadata::getAvailableMeshTypes()
{
    return m_availableMeshTypes_.getRawArray();
}

const ::zserio::vector<::nds::localization::types::LandmarkMeshType>& LandmarkLayerMetadata::getAvailableMeshTypes() const
{
    return m_availableMeshTypes_.getRawArray();
}

void LandmarkLayerMetadata::setAvailableMeshTypes(const ::zserio::vector<::nds::localization::types::LandmarkMeshType>& availableMeshTypes_)
{
    m_availableMeshTypes_ = ZserioArrayType_availableMeshTypes(availableMeshTypes_);
}

void LandmarkLayerMetadata::setAvailableMeshTypes(::zserio::vector<::nds::localization::types::LandmarkMeshType>&& availableMeshTypes_)
{
    m_availableMeshTypes_ = ZserioArrayType_availableMeshTypes(std::move(availableMeshTypes_));
}

bool LandmarkLayerMetadata::getHasRelations() const
{
    return m_hasRelations_;
}

void LandmarkLayerMetadata::setHasRelations(bool hasRelations_)
{
    m_hasRelations_ = hasRelations_;
}

bool LandmarkLayerMetadata::getHasDetails() const
{
    return m_hasDetails_;
}

void LandmarkLayerMetadata::setHasDetails(bool hasDetails_)
{
    m_hasDetails_ = hasDetails_;
}

void LandmarkLayerMetadata::initPackingContext(LandmarkLayerMetadata::ZserioPackingContext&) const
{
}

size_t LandmarkLayerMetadata::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_availableLineTypes_.bitSizeOf(endBitPosition);
    endBitPosition += m_availablePolygonTypes_.bitSizeOf(endBitPosition);
    endBitPosition += m_availableMeshTypes_.bitSizeOf(endBitPosition);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);

    return endBitPosition - bitPosition;
}

size_t LandmarkLayerMetadata::bitSizeOf(LandmarkLayerMetadata::ZserioPackingContext&, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_availableLineTypes_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_availablePolygonTypes_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_availableMeshTypes_.bitSizeOfPacked(endBitPosition);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);

    return endBitPosition - bitPosition;
}

size_t LandmarkLayerMetadata::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_availableLineTypes_.initializeOffsets(endBitPosition);
    endBitPosition = m_availablePolygonTypes_.initializeOffsets(endBitPosition);
    endBitPosition = m_availableMeshTypes_.initializeOffsets(endBitPosition);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);

    return endBitPosition;
}

size_t LandmarkLayerMetadata::initializeOffsets(LandmarkLayerMetadata::ZserioPackingContext&, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_availableLineTypes_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_availablePolygonTypes_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_availableMeshTypes_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += UINT8_C(1);
    endBitPosition += UINT8_C(1);

    return endBitPosition;
}

bool LandmarkLayerMetadata::operator==(const LandmarkLayerMetadata& other) const
{
    if (this != &other)
    {
        return
                (m_availableLineTypes_ == other.m_availableLineTypes_) &&
                (m_availablePolygonTypes_ == other.m_availablePolygonTypes_) &&
                (m_availableMeshTypes_ == other.m_availableMeshTypes_) &&
                (m_hasRelations_ == other.m_hasRelations_) &&
                (m_hasDetails_ == other.m_hasDetails_);
    }

    return true;
}

uint32_t LandmarkLayerMetadata::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_availableLineTypes_);
    result = ::zserio::calcHashCode(result, m_availablePolygonTypes_);
    result = ::zserio::calcHashCode(result, m_availableMeshTypes_);
    result = ::zserio::calcHashCode(result, m_hasRelations_);
    result = ::zserio::calcHashCode(result, m_hasDetails_);

    return result;
}

void LandmarkLayerMetadata::write(::zserio::BitStreamWriter& out) const
{
    m_availableLineTypes_.write(out);
    m_availablePolygonTypes_.write(out);
    m_availableMeshTypes_.write(out);
    out.writeBool(m_hasRelations_);
    out.writeBool(m_hasDetails_);
}

void LandmarkLayerMetadata::write(LandmarkLayerMetadata::ZserioPackingContext&, ::zserio::BitStreamWriter& out) const
{
    m_availableLineTypes_.writePacked(out);
    m_availablePolygonTypes_.writePacked(out);
    m_availableMeshTypes_.writePacked(out);
    out.writeBool(m_hasRelations_);
    out.writeBool(m_hasDetails_);
}

LandmarkLayerMetadata::ZserioArrayType_availableLineTypes LandmarkLayerMetadata::readAvailableLineTypes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_availableLineTypes readField(allocator);
    readField.read(in);

    return readField;
}

LandmarkLayerMetadata::ZserioArrayType_availableLineTypes LandmarkLayerMetadata::readAvailableLineTypes(LandmarkLayerMetadata::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_availableLineTypes readField(allocator);
    readField.readPacked(in);

    return readField;
}
LandmarkLayerMetadata::ZserioArrayType_availablePolygonTypes LandmarkLayerMetadata::readAvailablePolygonTypes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_availablePolygonTypes readField(allocator);
    readField.read(in);

    return readField;
}

LandmarkLayerMetadata::ZserioArrayType_availablePolygonTypes LandmarkLayerMetadata::readAvailablePolygonTypes(LandmarkLayerMetadata::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_availablePolygonTypes readField(allocator);
    readField.readPacked(in);

    return readField;
}
LandmarkLayerMetadata::ZserioArrayType_availableMeshTypes LandmarkLayerMetadata::readAvailableMeshTypes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_availableMeshTypes readField(allocator);
    readField.read(in);

    return readField;
}

LandmarkLayerMetadata::ZserioArrayType_availableMeshTypes LandmarkLayerMetadata::readAvailableMeshTypes(LandmarkLayerMetadata::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_availableMeshTypes readField(allocator);
    readField.readPacked(in);

    return readField;
}
bool LandmarkLayerMetadata::readHasRelations(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
bool LandmarkLayerMetadata::readHasDetails(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}

} // namespace metadata
} // namespace localization
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/localization/metadata/LandmarkRelationLayerMetadata.h>

namespace nds
{
namespace localization
{
namespace metadata
{

LandmarkRelationLayerMetadata::LandmarkRelationLayerMetadata(const allocator_type&) noexcept
{
}

LandmarkRelationLayerMetadata::LandmarkRelationLayerMetadata(::zserio::BitStreamReader&, const allocator_type&)
{
}

LandmarkRelationLayerMetadata::LandmarkRelationLayerMetadata(::zserio::PropagateAllocatorT,
        const LandmarkRelationLayerMetadata&, const allocator_type&)
{
}

size_t LandmarkRelationLayerMetadata::bitSizeOf(size_t) const
{
    return 0;
}

size_t LandmarkRelationLayerMetadata::initializeOffsets(size_t bitPosition)
{
    return bitPosition;
}

bool LandmarkRelationLayerMetadata::operator==(const LandmarkRelationLayerMetadata&) const
{
    return true;
}

uint32_t LandmarkRelationLayerMetadata::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    return result;
}

void LandmarkRelationLayerMetadata::write(::zserio::BitStreamWriter&) const
{
}

} // namespace metadata
} // namespace localization
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/localization/metadata/OccupancyGridRelationLayerMetadata.h>

namespace nds
{
namespace localization
{
namespace metadata
{

OccupancyGridRelationLayerMetadata::OccupancyGridRelationLayerMetadata(const allocator_type&) noexcept
{
}

OccupancyGridRelationLayerMetadata::OccupancyGridRelationLayerMetadata(::zserio::BitStreamReader&, const allocator_type&)
{
}

OccupancyGridRelationLayerMetadata::OccupancyGridRelationLayerMetadata(::zserio::PropagateAllocatorT,
        const OccupancyGridRelationLayerMetadata&, const allocator_type&)
{
}

size_t OccupancyGridRelationLayerMetadata::bitSizeOf(size_t) const
{
    return 0;
}

size_t OccupancyGridRelationLayerMetadata::initializeOffsets(size_t bitPosition)
{
    return bitPosition;
}

bool OccupancyGridRelationLayerMetadata::operator==(const OccupancyGridRelationLayerMetadata&) const
{
    return true;
}

uint32_t OccupancyGridRelationLayerMetadata::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    return result;
}

void OccupancyGridRelationLayerMetadata::write(::zserio::BitStreamWriter&) const
{
}

} // namespace metadata
} // namespace localization
} // namespace nds
