/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/localization/types/LandmarkLineType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for LandmarkLineType enumeration.
constexpr ::std::array<const char*, 17> EnumTraits<::nds::localization::types::LandmarkLineType>::names;
constexpr ::std::array<::nds::localization::types::LandmarkLineType, 17> EnumTraits<::nds::localization::types::LandmarkLineType>::values;
constexpr const char* EnumTraits<::nds::localization::types::LandmarkLineType>::enumName;

template <>
size_t enumToOrdinal(::nds::localization::types::LandmarkLineType value)
{
    switch (value)
    {
    case ::nds::localization::types::LandmarkLineType::GUARDRAIL_POST:
        return 0;
    case ::nds::localization::types::LandmarkLineType::LIGHT_POLE:
        return 1;
    case ::nds::localization::types::LandmarkLineType::DELINEATOR_POST:
        return 2;
    case ::nds::localization::types::LandmarkLineType::REFLECTOR_POST:
        return 3;
    case ::nds::localization::types::LandmarkLineType::GANTRY_POLE:
        return 4;
    case ::nds::localization::types::LandmarkLineType::SIGNPOST_POLE:
        return 5;
    case ::nds::localization::types::LandmarkLineType::POLE_UNKNOWN:
        return 6;
    case ::nds::localization::types::LandmarkLineType::CURB:
        return 7;
    case ::nds::localization::types::LandmarkLineType::WALL_FLAT:
        return 8;
    case ::nds::localization::types::LandmarkLineType::WALL_TUNNEL:
        return 9;
    case ::nds::localization::types::LandmarkLineType::BARRIER_JERSEY:
        return 10;
    case ::nds::localization::types::LandmarkLineType::BARRIER_SOUND:
        return 11;
    case ::nds::localization::types::LandmarkLineType::BARRIER_CABLE:
        return 12;
    case ::nds::localization::types::LandmarkLineType::GUARDRAIL:
        return 13;
    case ::nds::localization::types::LandmarkLineType::FENCE:
        return 14;
    case ::nds::localization::types::LandmarkLineType::CLIFF:
        return 15;
    case ::nds::localization::types::LandmarkLineType::DITCH:
        return 16;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration LandmarkLineType: ") <<
                static_cast<typename ::std::underlying_type<::nds::localization::types::LandmarkLineType>::type>(value) << "!";
    }
}

template <>
::nds::localization::types::LandmarkLineType valueToEnum(
        typename ::std::underlying_type<::nds::localization::types::LandmarkLineType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
    case UINT8_C(3):
    case UINT8_C(4):
    case UINT8_C(5):
    case UINT8_C(6):
    case UINT8_C(7):
    case UINT8_C(8):
    case UINT8_C(9):
    case UINT8_C(10):
    case UINT8_C(11):
    case UINT8_C(12):
    case UINT8_C(13):
    case UINT8_C(14):
    case UINT8_C(15):
    case UINT8_C(16):
        return static_cast<::nds::localization::types::LandmarkLineType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration LandmarkLineType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::localization::types::LandmarkLineType>(::nds::localization::types::LandmarkLineType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::localization::types::LandmarkLineType value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::localization::types::LandmarkLineType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::localization::types::LandmarkLineType)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::localization::types::LandmarkLineType value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::localization::types::LandmarkLineType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::localization::types::LandmarkLineType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::localization::types::LandmarkLineType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::localization::types::LandmarkLineType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::localization::types::LandmarkLineType>(
            static_cast<typename ::std::underlying_type<::nds::localization::types::LandmarkLineType>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::localization::types::LandmarkLineType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::localization::types::LandmarkLineType>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::localization::types::LandmarkLineType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::localization::types::LandmarkLineType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::localization::types::LandmarkLineType value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::localization::types::LandmarkLineType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/localization/types/LandmarkPolygonType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for LandmarkPolygonType enumeration.
constexpr ::std::array<const char*, 10> EnumTraits<::nds::localization::types::LandmarkPolygonType>::names;
constexpr ::std::array<::nds::localization::types::LandmarkPolygonType, 10> EnumTraits<::nds::localization::types::LandmarkPolygonType>::values;
constexpr const char* EnumTraits<::nds::localization::types::LandmarkPolygonType>::enumName;

template <>
size_t enumToOrdinal(::nds::localization::types::LandmarkPolygonType value)
{
    switch (value)
    {
    case ::nds::localization::types::LandmarkPolygonType::SIGN_BOUNDING_BOX:
        return 0;
    case ::nds::localization::types::LandmarkPolygonType::SIGN:
        return 1;
    case ::nds::localization::types::LandmarkPolygonType::PERPENDICULAR_WALL:
        return 2;
    case ::nds::localization::types::LandmarkPolygonType::OVERHEAD_STRUCTURE:
        return 3;
    case ::nds::localization::types::LandmarkPolygonType::SPEED_BUMP:
        return 4;
    case ::nds::localization::types::LandmarkPolygonType::BUILDING_DOOR:
        return 5;
    case ::nds::localization::types::LandmarkPolygonType::BUILDING_WINDOW:
        return 6;
    case ::nds::localization::types::LandmarkPolygonType::BUILDING_ROOF:
        return 7;
    case ::nds::localization::types::LandmarkPolygonType::BUILDING_BRACE:
        return 8;
    case ::nds::localization::types::LandmarkPolygonType::FIDUCIAL_MARKER:
        return 9;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration LandmarkPolygonType: ") <<
                static_cast<typename ::std::underlying_type<::nds::localization::types::LandmarkPolygonType>::type>(value) << "!";
    }
}

template <>
::nds::localization::types::LandmarkPolygonType valueToEnum(
        typename ::std::underlying_type<::nds::localization::types::LandmarkPolygonType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
    case UINT8_C(3):
    case UINT8_C(4):
    case UINT8_C(5):
    case UINT8_C(6):
    case UINT8_C(7):
    case UINT8_C(8):
    case UINT8_C(9):
        return static_cast<::nds::localization::types::LandmarkPolygonType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration LandmarkPolygonType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::localization::types::LandmarkPolygonType>(::nds::localization::types::LandmarkPolygonType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::localization::types::LandmarkPolygonType value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::localization::types::LandmarkPolygonType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::localization::types::LandmarkPolygonType)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::localization::types::LandmarkPolygonType value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::localization::types::LandmarkPolygonType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::localization::types::LandmarkPolygonType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::localization::types::LandmarkPolygonType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::localization::types::LandmarkPolygonType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::localization::types::LandmarkPolygonType>(
            static_cast<typename ::std::underlying_type<::nds::localization::types::LandmarkPolygonType>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::localization::types::LandmarkPolygonType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::localization::types::LandmarkPolygonType>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::localization::types::LandmarkPolygonType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::localization::types::LandmarkPolygonType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::localization::types::LandmarkPolygonType value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::localization::types::LandmarkPolygonType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/localization/types/LandmarkSignType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for LandmarkSignType enumeration.
constexpr ::std::array<const char*, 10> EnumTraits<::nds::localization::types::LandmarkSignType>::names;
constexpr ::std::array<::nds::localization::types::LandmarkSignType, 10> EnumTraits<::nds::localization::types::LandmarkSignType>::values;
constexpr const char* EnumTraits<::nds::localization::types::LandmarkSignType>::enumName;

template <>
size_t enumToOrdinal(::nds::localization::types::LandmarkSignType value)
{
    switch (value)
    {
    case ::nds::localization::types::LandmarkSignType::DETAILED_SHAPE:
        return 0;
    case ::nds::localization::types::LandmarkSignType::TRIANGLE_TIP_UP:
        return 1;
    case ::nds::localization::types::LandmarkSignType::TRIANGLE_TIP_DOWN:
        return 2;
    case ::nds::localization::types::LandmarkSignType::RECTANGLE:
        return 3;
    case ::nds::localization::types::LandmarkSignType::ROUND:
        return 4;
    case ::nds::localization::types::LandmarkSignType::OCTAGON:
        return 5;
    case ::nds::localization::types::LandmarkSignType::DIAMOND:
        return 6;
    case ::nds::localization::types::LandmarkSignType::CROSSBUCK:
        return 7;
    case ::nds::localization::types::LandmarkSignType::ELLIPSE:
        return 8;
    case ::nds::localization::types::LandmarkSignType::UNKNOWN:
        return 9;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration LandmarkSignType: ") <<
                static_cast<typename ::std::underlying_type<::nds::localization::types::LandmarkSignType>::type>(value) << "!";
    }
}

template <>
::nds::localization::types::LandmarkSignType valueToEnum(
        typename ::std::underlying_type<::nds::localization::types::LandmarkSignType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
    case UINT8_C(3):
    case UINT8_C(4):
    case UINT8_C(5):
    case UINT8_C(6):
    case UINT8_C(7):
    case UINT8_C(8):
    case UINT8_C(9):
        return static_cast<::nds::localization::types::LandmarkSignType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration LandmarkSignType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::localization::types::LandmarkSignType>(::nds::localization::types::LandmarkSignType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::localization::types::LandmarkSignType value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::localization::types::LandmarkSignType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::localization::types::LandmarkSignType)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::localization::types::LandmarkSignType value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::localization::types::LandmarkSignType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::localization::types::LandmarkSignType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::localization::types::LandmarkSignType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::localization::types::LandmarkSignType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::localization::types::LandmarkSignType>(
            static_cast<typename ::std::underlying_type<::nds::localization::types::LandmarkSignType>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::localization::types::LandmarkSignType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::localization::types::LandmarkSignType>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::localization::types::LandmarkSignType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::localization::types::LandmarkSignType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::localization::types::LandmarkSignType value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::localization::types::LandmarkSignType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/localization/types/FiducialMarkerSystemType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for FiducialMarkerSystemType enumeration.
constexpr ::std::array<const char*, 4> EnumTraits<::nds::localization::types::FiducialMarkerSystemType>::names;
constexpr ::std::array<::nds::localization::types::FiducialMarkerSystemType, 4> EnumTraits<::nds::localization::types::FiducialMarkerSystemType>::values;
constexpr const char* EnumTraits<::nds::localization::types::FiducialMarkerSystemType>::enumName;

template <>
size_t enumToOrdinal(::nds::localization::types::FiducialMarkerSystemType value)
{
    switch (value)
    {
    case ::nds::localization::types::FiducialMarkerSystemType::AR_TOOLKIT:
        return 0;
    case ::nds::localization::types::FiducialMarkerSystemType::AR_TAG:
        return 1;
    case ::nds::localization::types::FiducialMarkerSystemType::AR_UCO:
        return 2;
    case ::nds::localization::types::FiducialMarkerSystemType::APRIL_TAG:
        return 3;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration FiducialMarkerSystemType: ") <<
                static_cast<typename ::std::underlying_type<::nds::localization::types::FiducialMarkerSystemType>::type>(value) << "!";
    }
}

template <>
::nds::localization::types::FiducialMarkerSystemType valueToEnum(
        typename ::std::underlying_type<::nds::localization::types::FiducialMarkerSystemType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
    case UINT8_C(3):
        return static_cast<::nds::localization::types::FiducialMarkerSystemType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration FiducialMarkerSystemType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::localization::types::FiducialMarkerSystemType>(::nds::localization::types::FiducialMarkerSystemType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::localization::types::FiducialMarkerSystemType value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::localization::types::FiducialMarkerSystemType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::localization::types::FiducialMarkerSystemType)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::localization::types::FiducialMarkerSystemType value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::localization::types::FiducialMarkerSystemType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::localization::types::FiducialMarkerSystemType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::localization::types::FiducialMarkerSystemType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::localization::types::FiducialMarkerSystemType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::localization::types::FiducialMarkerSystemType>(
            static_cast<typename ::std::underlying_type<::nds::localization::types::FiducialMarkerSystemType>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::localization::types::FiducialMarkerSystemType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::localization::types::FiducialMarkerSystemType>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::localization::types::FiducialMarkerSystemType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::localization::types::FiducialMarkerSystemType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::localization::types::FiducialMarkerSystemType value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::localization::types::FiducialMarkerSystemType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/localization/types/LandmarkMeshType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for LandmarkMeshType enumeration.
constexpr ::std::array<const char*, 11> EnumTraits<::nds::localization::types::LandmarkMeshType>::names;
constexpr ::std::array<::nds::localization::types::LandmarkMeshType, 11> EnumTraits<::nds::localization::types::LandmarkMeshType>::values;
constexpr const char* EnumTraits<::nds::localization::types::LandmarkMeshType>::enumName;

template <>
size_t enumToOrdinal(::nds::localization::types::LandmarkMeshType value)
{
    switch (value)
    {
    case ::nds::localization::types::LandmarkMeshType::TRAFFIC_LIGHT_BOX:
        return 0;
    case ::nds::localization::types::LandmarkMeshType::BOX:
        return 1;
    case ::nds::localization::types::LandmarkMeshType::PILLAR:
        return 2;
    case ::nds::localization::types::LandmarkMeshType::STREET_LIGHTS:
        return 3;
    case ::nds::localization::types::LandmarkMeshType::WALL:
        return 4;
    case ::nds::localization::types::LandmarkMeshType::ACCESS_BOOTH:
        return 5;
    case ::nds::localization::types::LandmarkMeshType::TICKET_MACHINE:
        return 6;
    case ::nds::localization::types::LandmarkMeshType::BUILDING_CEILING_BEAM:
        return 7;
    case ::nds::localization::types::LandmarkMeshType::BUILDING_COLUMN:
        return 8;
    case ::nds::localization::types::LandmarkMeshType::BUILDING_CONNECTING_RAMP:
        return 9;
    case ::nds::localization::types::LandmarkMeshType::BUILDING_STAIRS:
        return 10;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration LandmarkMeshType: ") <<
                static_cast<typename ::std::underlying_type<::nds::localization::types::LandmarkMeshType>::type>(value) << "!";
    }
}

template <>
::nds::localization::types::LandmarkMeshType valueToEnum(
        typename ::std::underlying_type<::nds::localization::types::LandmarkMeshType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
    case UINT8_C(3):
    case UINT8_C(4):
    case UINT8_C(5):
    case UINT8_C(6):
    case UINT8_C(7):
    case UINT8_C(8):
    case UINT8_C(9):
    case UINT8_C(10):
        return static_cast<::nds::localization::types::LandmarkMeshType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration LandmarkMeshType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::localization::types::LandmarkMeshType>(::nds::localization::types::LandmarkMeshType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::localization::types::LandmarkMeshType value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::localization::types::LandmarkMeshType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::localization::types::LandmarkMeshType)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::localization::types::LandmarkMeshType value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::localization::types::LandmarkMeshType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::localization::types::LandmarkMeshType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::localization::types::LandmarkMeshType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::localization::types::LandmarkMeshType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::localization::types::LandmarkMeshType>(
            static_cast<typename ::std::underlying_type<::nds::localization::types::LandmarkMeshType>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::localization::types::LandmarkMeshType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::localization::types::LandmarkMeshType>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::localization::types::LandmarkMeshType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::localization::types::LandmarkMeshType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::localization::types::LandmarkMeshType value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::localization::types::LandmarkMeshType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/localization/types/ObstacleType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for ObstacleType enumeration.
constexpr ::std::array<const char*, 2> EnumTraits<::nds::localization::types::ObstacleType>::names;
constexpr ::std::array<::nds::localization::types::ObstacleType, 2> EnumTraits<::nds::localization::types::ObstacleType>::values;
constexpr const char* EnumTraits<::nds::localization::types::ObstacleType>::enumName;

template <>
size_t enumToOrdinal(::nds::localization::types::ObstacleType value)
{
    switch (value)
    {
    case ::nds::localization::types::ObstacleType::HORIZONTAL:
        return 0;
    case ::nds::localization::types::ObstacleType::VERTICAL:
        return 1;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration ObstacleType: ") <<
                static_cast<typename ::std::underlying_type<::nds::localization::types::ObstacleType>::type>(value) << "!";
    }
}

template <>
::nds::localization::types::ObstacleType valueToEnum(
        typename ::std::underlying_type<::nds::localization::types::ObstacleType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
        return static_cast<::nds::localization::types::ObstacleType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration ObstacleType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::localization::types::ObstacleType>(::nds::localization::types::ObstacleType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::localization::types::ObstacleType value)
{
    context.init<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::localization::types::ObstacleType>::type, UINT8_C(1)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::localization::types::ObstacleType)
{
    return UINT8_C(1);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::localization::types::ObstacleType value)
{
    return context.bitSizeOf<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::localization::types::ObstacleType>::type, UINT8_C(1)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::localization::types::ObstacleType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::localization::types::ObstacleType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::localization::types::ObstacleType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::localization::types::ObstacleType>(
            static_cast<typename ::std::underlying_type<::nds::localization::types::ObstacleType>::type>(
                    in.readBits(UINT8_C(1))));
}

template <>
::nds::localization::types::ObstacleType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::localization::types::ObstacleType>(context.read<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::localization::types::ObstacleType>::type, UINT8_C(1)>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::localization::types::ObstacleType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(1));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::localization::types::ObstacleType value)
{
    context.write<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::localization::types::ObstacleType>::type, UINT8_C(1)>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/HashCodeUtil.h>
#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/localization/types/LandmarkSignDetailsType.h>

namespace nds
{
namespace localization
{
namespace types
{

LandmarkSignDetailsType::LandmarkSignDetailsType(::zserio::BitStreamReader& in) :
        m_value(readValue(in))
{}

LandmarkSignDetailsType::LandmarkSignDetailsType(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in) :
        m_value(readValue(context, in))
{}

LandmarkSignDetailsType::LandmarkSignDetailsType(underlying_type value) :
        m_value(value)
{
    if (m_value > UINT16_C(32767))
        throw ::zserio::CppRuntimeException("Value for bitmask 'LandmarkSignDetailsType' out of bounds: ") << value << "!";
}

void LandmarkSignDetailsType::initPackingContext(::zserio::DeltaContext& context) const
{
    context.init<::zserio::VarIntNNArrayTraits<::nds::localization::types::LandmarkSignDetailsType::underlying_type>>(m_value);
}

size_t LandmarkSignDetailsType::bitSizeOf(size_t) const
{
    return ::zserio::bitSizeOfVarUInt16(m_value);
}

size_t LandmarkSignDetailsType::bitSizeOf(::zserio::DeltaContext& context, size_t) const
{
    return context.bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::localization::types::LandmarkSignDetailsType::underlying_type>>(m_value);
}

size_t LandmarkSignDetailsType::initializeOffsets(size_t bitPosition) const
{
    return bitPosition + bitSizeOf(bitPosition);
}

size_t LandmarkSignDetailsType::initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition) const
{
    return bitPosition + bitSizeOf(context, bitPosition);
}

uint32_t LandmarkSignDetailsType::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, m_value);
    return result;
}

void LandmarkSignDetailsType::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt16(m_value);
}

void LandmarkSignDetailsType::write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out) const
{
    context.write<::zserio::VarIntNNArrayTraits<::nds::localization::types::LandmarkSignDetailsType::underlying_type>>(out, m_value);
}

::zserio::string<> LandmarkSignDetailsType::toString(const ::zserio::string<>::allocator_type& allocator) const
{
    ::zserio::string<> result(allocator);
    if ((*this & LandmarkSignDetailsType::Values::MEANING) == LandmarkSignDetailsType::Values::MEANING)
        result += result.empty() ? "MEANING" : " | MEANING";
    if ((*this & LandmarkSignDetailsType::Values::DIAMETER) == LandmarkSignDetailsType::Values::DIAMETER)
        result += result.empty() ? "DIAMETER" : " | DIAMETER";
    if ((*this & LandmarkSignDetailsType::Values::TEXT) == LandmarkSignDetailsType::Values::TEXT)
        result += result.empty() ? "TEXT" : " | TEXT";
    if ((*this & LandmarkSignDetailsType::Values::NUMBER) == LandmarkSignDetailsType::Values::NUMBER)
        result += result.empty() ? "NUMBER" : " | NUMBER";

    return ::zserio::toString<::zserio::string<>::allocator_type>(m_value, allocator) + "[" + result + "]";
}

LandmarkSignDetailsType::underlying_type LandmarkSignDetailsType::readValue(::zserio::BitStreamReader& in)
{
    return static_cast<underlying_type>(in.readVarUInt16());
}

LandmarkSignDetailsType::underlying_type LandmarkSignDetailsType::readValue(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return context.read<::zserio::VarIntNNArrayTraits<::nds::localization::types::LandmarkSignDetailsType::underlying_type>>(
            in);
}

} // namespace types
} // namespace localization
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ConstraintException.h>

#include <nds/localization/types/LandmarkLine.h>

namespace nds
{
namespace localization
{
namespace types
{

LandmarkLine::LandmarkLine(const allocator_type&) noexcept :
        m_type_(::nds::localization::types::LandmarkLineType()),
        m_diameter_(::zserio::NullOpt),
        m_confidence_(::zserio::NullOpt)
{
}

LandmarkLine::LandmarkLine(::zserio::BitStreamReader& in, const allocator_type&) :
        m_type_(readType(in)),
        m_diameter_(readDiameter(in)),
        m_confidence_(readConfidence(in))
{
}

LandmarkLine::LandmarkLine(LandmarkLine::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type&) :
        m_type_(readType(context, in)),
        m_diameter_(readDiameter(context, in)),
        m_confidence_(readConfidence(context, in))
{
}

LandmarkLine::LandmarkLine(::zserio::PropagateAllocatorT,
        const LandmarkLine& other, const allocator_type& allocator) :
        m_type_(::zserio::allocatorPropagatingCopy(other.m_type_, allocator)),
        m_diameter_(::zserio::allocatorPropagatingCopy(other.m_diameter_, allocator)),
        m_confidence_(::zserio::allocatorPropagatingCopy(other.m_confidence_, allocator))
{
}

::nds::localization::types::LandmarkLineType LandmarkLine::getType() const
{
    return m_type_;
}

void LandmarkLine::setType(::nds::localization::types::LandmarkLineType type_)
{
    m_type_ = type_;
}

::nds::core::types::WidthCentimeters LandmarkLine::getDiameter() const
{
    return m_diameter_.value();
}

void LandmarkLine::setDiameter(::nds::core::types::WidthCentimeters diameter_)
{
    m_diameter_ = diameter_;
}

bool LandmarkLine::isDiameterUsed() const
{
    return (isDiameterSet());
}

bool LandmarkLine::isDiameterSet() const
{
    return m_diameter_.hasValue();
}

void LandmarkLine::resetDiameter()
{
    m_diameter_.reset();
}

::nds::localization::types::LandmarkConfidence LandmarkLine::getConfidence() const
{
    return m_confidence_.value();
}

void LandmarkLine::setConfidence(::nds::localization::types::LandmarkConfidence confidence_)
{
    m_confidence_ = confidence_;
}

bool LandmarkLine::isConfidenceUsed() const
{
    return (isConfidenceSet());
}

bool LandmarkLine::isConfidenceSet() const
{
    return m_confidence_.hasValue();
}

void LandmarkLine::resetConfidence()
{
    m_confidence_.reset();
}

void LandmarkLine::initPackingContext(LandmarkLine::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getType(), m_type_);
    if (isDiameterSet())
    {
        context.getDiameter().init<::zserio::VarIntNNArrayTraits<::nds::core::types::WidthCentimeters>>(m_diameter_.value());
    }
    if (isConfidenceSet())
    {
        context.getConfidence().init<::zserio::StdIntArrayTraits<::nds::localization::types::LandmarkConfidence>>(m_confidence_.value());
    }
}

size_t LandmarkLine::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_type_);
    endBitPosition += 1;
    if (isDiameterSet())
    {
        endBitPosition += ::zserio::bitSizeOfVarUInt32(m_diameter_.value());
    }
    endBitPosition += 1;
    if (isConfidenceSet())
    {
        endBitPosition += UINT8_C(8);
    }

    return endBitPosition - bitPosition;
}

size_t LandmarkLine::bitSizeOf(LandmarkLine::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getType(), m_type_);
    endBitPosition += 1;
    if (isDiameterSet())
    {
        endBitPosition += context.getDiameter().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::types::WidthCentimeters>>(m_diameter_.value());
    }
    endBitPosition += 1;
    if (isConfidenceSet())
    {
        endBitPosition += context.getConfidence().bitSizeOf<::zserio::StdIntArrayTraits<::nds::localization::types::LandmarkConfidence>>(m_confidence_.value());
    }

    return endBitPosition - bitPosition;
}

size_t LandmarkLine::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_type_);
    endBitPosition += 1;
    if (isDiameterSet())
    {
        endBitPosition += ::zserio::bitSizeOfVarUInt32(m_diameter_.value());
    }
    endBitPosition += 1;
    if (isConfidenceSet())
    {
        endBitPosition += UINT8_C(8);
    }

    return endBitPosition;
}

size_t LandmarkLine::initializeOffsets(LandmarkLine::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getType(), endBitPosition,
        m_type_);
    endBitPosition += 1;
    if (isDiameterSet())
    {
        endBitPosition += context.getDiameter().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::types::WidthCentimeters>>(m_diameter_.value());
    }
    endBitPosition += 1;
    if (isConfidenceSet())
    {
        endBitPosition += context.getConfidence().bitSizeOf<::zserio::StdIntArrayTraits<::nds::localization::types::LandmarkConfidence>>(m_confidence_.value());
    }

    return endBitPosition;
}

bool LandmarkLine::operator==(const LandmarkLine& other) const
{
    if (this != &other)
    {
        return
                (m_type_ == other.m_type_) &&
                (!isDiameterUsed() ? !other.isDiameterUsed() : (m_diameter_ == other.m_diameter_)) &&
                (!isConfidenceUsed() ? !other.isConfidenceUsed() : (m_confidence_ == other.m_confidence_));
    }

    return true;
}

uint32_t LandmarkLine::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_type_);
    if (isDiameterUsed())
        result = ::zserio::calcHashCode(result, m_diameter_);
    if (isConfidenceUsed())
        result = ::zserio::calcHashCode(result, m_confidence_);

    return result;
}

void LandmarkLine::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_type_);

    if (isDiameterSet())
    {
        out.writeBool(true);
        out.writeVarUInt32(m_diameter_.value());
    }
    else
    {
        out.writeBool(false);
    }

    if (isConfidenceSet())
    {
        out.writeBool(true);
        // check constraint
        if (!(getConfidence() <= 100))
            throw ::zserio::ConstraintException("Write: Constraint violated at LandmarkLine.confidence!");
        out.writeBits(m_confidence_.value(), UINT8_C(8));
    }
    else
    {
        out.writeBool(false);
    }
}

void LandmarkLine::write(LandmarkLine::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getType(), out, m_type_);

    if (isDiameterSet())
    {
        out.writeBool(true);
        context.getDiameter().write<::zserio::VarIntNNArrayTraits<::nds::core::types::WidthCentimeters>>(out, m_diameter_.value());
    }
    else
    {
        out.writeBool(false);
    }

    if (isConfidenceSet())
    {
        out.writeBool(true);
        // check constraint
        if (!(getConfidence() <= 100))
            throw ::zserio::ConstraintException("Write: Constraint violated at LandmarkLine.confidence!");
        context.getConfidence().write<::zserio::StdIntArrayTraits<::nds::localization::types::LandmarkConfidence>>(out, m_confidence_.value());
    }
    else
    {
        out.writeBool(false);
    }
}

::nds::localization::types::LandmarkLineType LandmarkLine::readType(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::localization::types::LandmarkLineType>(in);
}

::nds::localization::types::LandmarkLineType LandmarkLine::readType(LandmarkLine::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::localization::types::LandmarkLineType>(context.getType(), in);
}
::zserio::InplaceOptionalHolder<::nds::core::types::WidthCentimeters> LandmarkLine::readDiameter(::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::types::WidthCentimeters>(static_cast<::nds::core::types::WidthCentimeters>(in.readVarUInt32()));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::types::WidthCentimeters>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::types::WidthCentimeters> LandmarkLine::readDiameter(LandmarkLine::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::types::WidthCentimeters>(context.getDiameter().read<::zserio::VarIntNNArrayTraits<::nds::core::types::WidthCentimeters>>(in));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::types::WidthCentimeters>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::localization::types::LandmarkConfidence> LandmarkLine::readConfidence(::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        ::nds::localization::types::LandmarkConfidence readField = static_cast<::nds::localization::types::LandmarkConfidence>(in.readBits(UINT8_C(8)));
        // check constraint
        if (!(readField <= 100))
            throw ::zserio::ConstraintException("Read: Constraint violated at LandmarkLine.confidence!");

        return ::zserio::InplaceOptionalHolder<::nds::localization::types::LandmarkConfidence>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<::nds::localization::types::LandmarkConfidence>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::localization::types::LandmarkConfidence> LandmarkLine::readConfidence(LandmarkLine::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        ::nds::localization::types::LandmarkConfidence readField = context.getConfidence().read<::zserio::StdIntArrayTraits<::nds::localization::types::LandmarkConfidence>>(in);
        // check constraint
        if (!(readField <= 100))
            throw ::zserio::ConstraintException("Read: Constraint violated at LandmarkLine.confidence!");

        return ::zserio::InplaceOptionalHolder<::nds::localization::types::LandmarkConfidence>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<::nds::localization::types::LandmarkConfidence>(::zserio::NullOpt);
}

} // namespace types
} // namespace localization
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ConstraintException.h>
#include <zserio/ArrayTraits.h>

#include <nds/localization/types/LandmarkPolygon.h>
#include <nds/localization/types/LandmarkPolygonType.h>

namespace nds
{
namespace localization
{
namespace types
{

LandmarkPolygon::LandmarkPolygon(const allocator_type&) noexcept :
        m_type_(::nds::localization::types::LandmarkPolygonType()),
        m_signType_(::zserio::NullOpt),
        m_hasSignDetails_(::zserio::NullOpt),
        m_signDetails_(::zserio::NullOpt),
        m_markerDetails_(::zserio::NullOpt),
        m_color_(::zserio::NullOpt),
        m_confidence_(::zserio::NullOpt)
{
}

LandmarkPolygon::LandmarkPolygon(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_type_(readType(in)),
        m_signType_(readSignType(in)),
        m_hasSignDetails_(readHasSignDetails(in)),
        m_signDetails_(readSignDetails(in, allocator)),
        m_markerDetails_(readMarkerDetails(in, allocator)),
        m_color_(readColor(in, allocator)),
        m_confidence_(readConfidence(in))
{
}

LandmarkPolygon::LandmarkPolygon(LandmarkPolygon::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_type_(readType(context, in)),
        m_signType_(readSignType(context, in)),
        m_hasSignDetails_(readHasSignDetails(in)),
        m_signDetails_(readSignDetails(context, in, allocator)),
        m_markerDetails_(readMarkerDetails(context, in, allocator)),
        m_color_(readColor(context, in, allocator)),
        m_confidence_(readConfidence(context, in))
{
}

LandmarkPolygon::LandmarkPolygon(::zserio::PropagateAllocatorT,
        const LandmarkPolygon& other, const allocator_type& allocator) :
        m_type_(::zserio::allocatorPropagatingCopy(other.m_type_, allocator)),
        m_signType_(::zserio::allocatorPropagatingCopy(other.m_signType_, allocator)),
        m_hasSignDetails_(::zserio::allocatorPropagatingCopy(other.m_hasSignDetails_, allocator)),
        m_signDetails_(::zserio::allocatorPropagatingCopy(other.m_signDetails_, allocator)),
        m_markerDetails_(::zserio::allocatorPropagatingCopy(other.m_markerDetails_, allocator)),
        m_color_(::zserio::allocatorPropagatingCopy(other.m_color_, allocator)),
        m_confidence_(::zserio::allocatorPropagatingCopy(other.m_confidence_, allocator))
{
}

::nds::localization::types::LandmarkPolygonType LandmarkPolygon::getType() const
{
    return m_type_;
}

void LandmarkPolygon::setType(::nds::localization::types::LandmarkPolygonType type_)
{
    m_type_ = type_;
}

::nds::localization::types::LandmarkSignType LandmarkPolygon::getSignType() const
{
    return m_signType_.value();
}

void LandmarkPolygon::setSignType(::nds::localization::types::LandmarkSignType signType_)
{
    m_signType_ = signType_;
}

bool LandmarkPolygon::isSignTypeUsed() const
{
    return (getType() == ::nds::localization::types::LandmarkPolygonType::SIGN || getType() == ::nds::localization::types::LandmarkPolygonType::SIGN_BOUNDING_BOX);
}

bool LandmarkPolygon::isSignTypeSet() const
{
    return m_signType_.hasValue();
}

void LandmarkPolygon::resetSignType()
{
    m_signType_.reset();
}

bool LandmarkPolygon::getHasSignDetails() const
{
    return m_hasSignDetails_.value();
}

void LandmarkPolygon::setHasSignDetails(bool hasSignDetails_)
{
    m_hasSignDetails_ = hasSignDetails_;
}

bool LandmarkPolygon::isHasSignDetailsUsed() const
{
    return (getType() == ::nds::localization::types::LandmarkPolygonType::SIGN || getType() == ::nds::localization::types::LandmarkPolygonType::SIGN_BOUNDING_BOX);
}

bool LandmarkPolygon::isHasSignDetailsSet() const
{
    return m_hasSignDetails_.hasValue();
}

void LandmarkPolygon::resetHasSignDetails()
{
    m_hasSignDetails_.reset();
}

::nds::localization::types::LandmarkSignDetails& LandmarkPolygon::getSignDetails()
{
    return m_signDetails_.value();
}

const ::nds::localization::types::LandmarkSignDetails& LandmarkPolygon::getSignDetails() const
{
    return m_signDetails_.value();
}

void LandmarkPolygon::setSignDetails(const ::nds::localization::types::LandmarkSignDetails& signDetails_)
{
    m_signDetails_ = signDetails_;
}

void LandmarkPolygon::setSignDetails(::nds::localization::types::LandmarkSignDetails&& signDetails_)
{
    m_signDetails_ = ::std::move(signDetails_);
}

bool LandmarkPolygon::isSignDetailsUsed() const
{
    return ((getType() == ::nds::localization::types::LandmarkPolygonType::SIGN || getType() == ::nds::localization::types::LandmarkPolygonType::SIGN_BOUNDING_BOX) && getHasSignDetails());
}

bool LandmarkPolygon::isSignDetailsSet() const
{
    return m_signDetails_.hasValue();
}

void LandmarkPolygon::resetSignDetails()
{
    m_signDetails_.reset();
}

::nds::localization::types::FiducialMarkerDetails& LandmarkPolygon::getMarkerDetails()
{
    return m_markerDetails_.value();
}

const ::nds::localization::types::FiducialMarkerDetails& LandmarkPolygon::getMarkerDetails() const
{
    return m_markerDetails_.value();
}

void LandmarkPolygon::setMarkerDetails(const ::nds::localization::types::FiducialMarkerDetails& markerDetails_)
{
    m_markerDetails_ = markerDetails_;
}

void LandmarkPolygon::setMarkerDetails(::nds::localization::types::FiducialMarkerDetails&& markerDetails_)
{
    m_markerDetails_ = ::std::move(markerDetails_);
}

bool LandmarkPolygon::isMarkerDetailsUsed() const
{
    return (getType() == ::nds::localization::types::LandmarkPolygonType::FIDUCIAL_MARKER);
}

bool LandmarkPolygon::isMarkerDetailsSet() const
{
    return m_markerDetails_.hasValue();
}

void LandmarkPolygon::resetMarkerDetails()
{
    m_markerDetails_.reset();
}

::nds::localization::types::LandmarkColor& LandmarkPolygon::getColor()
{
    return m_color_.value();
}

const ::nds::localization::types::LandmarkColor& LandmarkPolygon::getColor() const
{
    return m_color_.value();
}

void LandmarkPolygon::setColor(const ::nds::localization::types::LandmarkColor& color_)
{
    m_color_ = color_;
}

void LandmarkPolygon::setColor(::nds::localization::types::LandmarkColor&& color_)
{
    m_color_ = ::std::move(color_);
}

bool LandmarkPolygon::isColorUsed() const
{
    return (isColorSet());
}

bool LandmarkPolygon::isColorSet() const
{
    return m_color_.hasValue();
}

void LandmarkPolygon::resetColor()
{
    m_color_.reset();
}

::nds::localization::types::LandmarkConfidence LandmarkPolygon::getConfidence() const
{
    return m_confidence_.value();
}

void LandmarkPolygon::setConfidence(::nds::localization::types::LandmarkConfidence confidence_)
{
    m_confidence_ = confidence_;
}

bool LandmarkPolygon::isConfidenceUsed() const
{
    return (isConfidenceSet());
}

bool LandmarkPolygon::isConfidenceSet() const
{
    return m_confidence_.hasValue();
}

void LandmarkPolygon::resetConfidence()
{
    m_confidence_.reset();
}

void LandmarkPolygon::initPackingContext(LandmarkPolygon::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getType(), m_type_);
    if (getType() == ::nds::localization::types::LandmarkPolygonType::SIGN || getType() == ::nds::localization::types::LandmarkPolygonType::SIGN_BOUNDING_BOX)
    {
        ::zserio::initPackingContext(context.getSignType(), m_signType_.value());
    }
    if ((getType() == ::nds::localization::types::LandmarkPolygonType::SIGN || getType() == ::nds::localization::types::LandmarkPolygonType::SIGN_BOUNDING_BOX) && getHasSignDetails())
    {
        m_signDetails_.value().initPackingContext(context.getSignDetails());
    }
    if (getType() == ::nds::localization::types::LandmarkPolygonType::FIDUCIAL_MARKER)
    {
        m_markerDetails_.value().initPackingContext(context.getMarkerDetails());
    }
    if (isColorSet())
    {
        m_color_.value().initPackingContext(context.getColor());
    }
    if (isConfidenceSet())
    {
        context.getConfidence().init<::zserio::StdIntArrayTraits<::nds::localization::types::LandmarkConfidence>>(m_confidence_.value());
    }
}

size_t LandmarkPolygon::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_type_);
    if (getType() == ::nds::localization::types::LandmarkPolygonType::SIGN || getType() == ::nds::localization::types::LandmarkPolygonType::SIGN_BOUNDING_BOX)
    {
        endBitPosition += ::zserio::bitSizeOf(m_signType_.value());
    }
    if (getType() == ::nds::localization::types::LandmarkPolygonType::SIGN || getType() == ::nds::localization::types::LandmarkPolygonType::SIGN_BOUNDING_BOX)
    {
        endBitPosition += UINT8_C(1);
    }
    if ((getType() == ::nds::localization::types::LandmarkPolygonType::SIGN || getType() == ::nds::localization::types::LandmarkPolygonType::SIGN_BOUNDING_BOX) && getHasSignDetails())
    {
        endBitPosition += m_signDetails_.value().bitSizeOf(endBitPosition);
    }
    if (getType() == ::nds::localization::types::LandmarkPolygonType::FIDUCIAL_MARKER)
    {
        endBitPosition += m_markerDetails_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition += 1;
    if (isColorSet())
    {
        endBitPosition += m_color_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition += 1;
    if (isConfidenceSet())
    {
        endBitPosition += UINT8_C(8);
    }

    return endBitPosition - bitPosition;
}

size_t LandmarkPolygon::bitSizeOf(LandmarkPolygon::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getType(), m_type_);
    if (getType() == ::nds::localization::types::LandmarkPolygonType::SIGN || getType() == ::nds::localization::types::LandmarkPolygonType::SIGN_BOUNDING_BOX)
    {
        endBitPosition += ::zserio::bitSizeOf(context.getSignType(), m_signType_.value());
    }
    if (getType() == ::nds::localization::types::LandmarkPolygonType::SIGN || getType() == ::nds::localization::types::LandmarkPolygonType::SIGN_BOUNDING_BOX)
    {
        endBitPosition += UINT8_C(1);
    }
    if ((getType() == ::nds::localization::types::LandmarkPolygonType::SIGN || getType() == ::nds::localization::types::LandmarkPolygonType::SIGN_BOUNDING_BOX) && getHasSignDetails())
    {
        endBitPosition += m_signDetails_.value().bitSizeOf(context.getSignDetails(), endBitPosition);
    }
    if (getType() == ::nds::localization::types::LandmarkPolygonType::FIDUCIAL_MARKER)
    {
        endBitPosition += m_markerDetails_.value().bitSizeOf(context.getMarkerDetails(), endBitPosition);
    }
    endBitPosition += 1;
    if (isColorSet())
    {
        endBitPosition += m_color_.value().bitSizeOf(context.getColor(), endBitPosition);
    }
    endBitPosition += 1;
    if (isConfidenceSet())
    {
        endBitPosition += context.getConfidence().bitSizeOf<::zserio::StdIntArrayTraits<::nds::localization::types::LandmarkConfidence>>(m_confidence_.value());
    }

    return endBitPosition - bitPosition;
}

size_t LandmarkPolygon::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_type_);
    if (getType() == ::nds::localization::types::LandmarkPolygonType::SIGN || getType() == ::nds::localization::types::LandmarkPolygonType::SIGN_BOUNDING_BOX)
    {
        endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_signType_.value());
    }
    if (getType() == ::nds::localization::types::LandmarkPolygonType::SIGN || getType() == ::nds::localization::types::LandmarkPolygonType::SIGN_BOUNDING_BOX)
    {
        endBitPosition += UINT8_C(1);
    }
    if ((getType() == ::nds::localization::types::LandmarkPolygonType::SIGN || getType() == ::nds::localization::types::LandmarkPolygonType::SIGN_BOUNDING_BOX) && getHasSignDetails())
    {
        endBitPosition = m_signDetails_.value().initializeOffsets(endBitPosition);
    }
    if (getType() == ::nds::localization::types::LandmarkPolygonType::FIDUCIAL_MARKER)
    {
        endBitPosition = m_markerDetails_.value().initializeOffsets(endBitPosition);
    }
    endBitPosition += 1;
    if (isColorSet())
    {
        endBitPosition = m_color_.value().initializeOffsets(endBitPosition);
    }
    endBitPosition += 1;
    if (isConfidenceSet())
    {
        endBitPosition += UINT8_C(8);
    }

    return endBitPosition;
}

size_t LandmarkPolygon::initializeOffsets(LandmarkPolygon::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getType(), endBitPosition,
        m_type_);
    if (getType() == ::nds::localization::types::LandmarkPolygonType::SIGN || getType() == ::nds::localization::types::LandmarkPolygonType::SIGN_BOUNDING_BOX)
    {
        endBitPosition = ::zserio::initializeOffsets(context.getSignType(), endBitPosition,
        m_signType_.value());
    }
    if (getType() == ::nds::localization::types::LandmarkPolygonType::SIGN || getType() == ::nds::localization::types::LandmarkPolygonType::SIGN_BOUNDING_BOX)
    {
        endBitPosition += UINT8_C(1);
    }
    if ((getType() == ::nds::localization::types::LandmarkPolygonType::SIGN || getType() == ::nds::localization::types::LandmarkPolygonType::SIGN_BOUNDING_BOX) && getHasSignDetails())
    {
        endBitPosition = m_signDetails_.value().initializeOffsets(context.getSignDetails(), endBitPosition);
    }
    if (getType() == ::nds::localization::types::LandmarkPolygonType::FIDUCIAL_MARKER)
    {
        endBitPosition = m_markerDetails_.value().initializeOffsets(context.getMarkerDetails(), endBitPosition);
    }
    endBitPosition += 1;
    if (isColorSet())
    {
        endBitPosition = m_color_.value().initializeOffsets(context.getColor(), endBitPosition);
    }
    endBitPosition += 1;
    if (isConfidenceSet())
    {
        endBitPosition += context.getConfidence().bitSizeOf<::zserio::StdIntArrayTraits<::nds::localization::types::LandmarkConfidence>>(m_confidence_.value());
    }

    return endBitPosition;
}

bool LandmarkPolygon::operator==(const LandmarkPolygon& other) const
{
    if (this != &other)
    {
        return
                (m_type_ == other.m_type_) &&
                (!isSignTypeUsed() ? !other.isSignTypeUsed() : (m_signType_ == other.m_signType_)) &&
                (!isHasSignDetailsUsed() ? !other.isHasSignDetailsUsed() : (m_hasSignDetails_ == other.m_hasSignDetails_)) &&
                (!isSignDetailsUsed() ? !other.isSignDetailsUsed() : (m_signDetails_ == other.m_signDetails_)) &&
                (!isMarkerDetailsUsed() ? !other.isMarkerDetailsUsed() : (m_markerDetails_ == other.m_markerDetails_)) &&
                (!isColorUsed() ? !other.isColorUsed() : (m_color_ == other.m_color_)) &&
                (!isConfidenceUsed() ? !other.isConfidenceUsed() : (m_confidence_ == other.m_confidence_));
    }

    return true;
}

uint32_t LandmarkPolygon::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_type_);
    if (isSignTypeUsed())
        result = ::zserio::calcHashCode(result, m_signType_);
    if (isHasSignDetailsUsed())
        result = ::zserio::calcHashCode(result, m_hasSignDetails_);
    if (isSignDetailsUsed())
        result = ::zserio::calcHashCode(result, m_signDetails_);
    if (isMarkerDetailsUsed())
        result = ::zserio::calcHashCode(result, m_markerDetails_);
    if (isColorUsed())
        result = ::zserio::calcHashCode(result, m_color_);
    if (isConfidenceUsed())
        result = ::zserio::calcHashCode(result, m_confidence_);

    return result;
}

void LandmarkPolygon::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_type_);

    if (getType() == ::nds::localization::types::LandmarkPolygonType::SIGN || getType() == ::nds::localization::types::LandmarkPolygonType::SIGN_BOUNDING_BOX)
    {
        ::zserio::write(out, m_signType_.value());
    }

    if (getType() == ::nds::localization::types::LandmarkPolygonType::SIGN || getType() == ::nds::localization::types::LandmarkPolygonType::SIGN_BOUNDING_BOX)
    {
        out.writeBool(m_hasSignDetails_.value());
    }

    if ((getType() == ::nds::localization::types::LandmarkPolygonType::SIGN || getType() == ::nds::localization::types::LandmarkPolygonType::SIGN_BOUNDING_BOX) && getHasSignDetails())
    {
        m_signDetails_.value().write(out);
    }

    if (getType() == ::nds::localization::types::LandmarkPolygonType::FIDUCIAL_MARKER)
    {
        m_markerDetails_.value().write(out);
    }

    if (isColorSet())
    {
        out.writeBool(true);
        m_color_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isConfidenceSet())
    {
        out.writeBool(true);
        // check constraint
        if (!(getConfidence() <= 100))
            throw ::zserio::ConstraintException("Write: Constraint violated at LandmarkPolygon.confidence!");
        out.writeBits(m_confidence_.value(), UINT8_C(8));
    }
    else
    {
        out.writeBool(false);
    }
}

void LandmarkPolygon::write(LandmarkPolygon::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getType(), out, m_type_);

    if (getType() == ::nds::localization::types::LandmarkPolygonType::SIGN || getType() == ::nds::localization::types::LandmarkPolygonType::SIGN_BOUNDING_BOX)
    {
        ::zserio::write(context.getSignType(), out, m_signType_.value());
    }

    if (getType() == ::nds::localization::types::LandmarkPolygonType::SIGN || getType() == ::nds::localization::types::LandmarkPolygonType::SIGN_BOUNDING_BOX)
    {
        out.writeBool(m_hasSignDetails_.value());
    }

    if ((getType() == ::nds::localization::types::LandmarkPolygonType::SIGN || getType() == ::nds::localization::types::LandmarkPolygonType::SIGN_BOUNDING_BOX) && getHasSignDetails())
    {
        m_signDetails_.value().write(context.getSignDetails(), out);
    }

    if (getType() == ::nds::localization::types::LandmarkPolygonType::FIDUCIAL_MARKER)
    {
        m_markerDetails_.value().write(context.getMarkerDetails(), out);
    }

    if (isColorSet())
    {
        out.writeBool(true);
        m_color_.value().write(context.getColor(), out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isConfidenceSet())
    {
        out.writeBool(true);
        // check constraint
        if (!(getConfidence() <= 100))
            throw ::zserio::ConstraintException("Write: Constraint violated at LandmarkPolygon.confidence!");
        context.getConfidence().write<::zserio::StdIntArrayTraits<::nds::localization::types::LandmarkConfidence>>(out, m_confidence_.value());
    }
    else
    {
        out.writeBool(false);
    }
}

::nds::localization::types::LandmarkPolygonType LandmarkPolygon::readType(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::localization::types::LandmarkPolygonType>(in);
}

::nds::localization::types::LandmarkPolygonType LandmarkPolygon::readType(LandmarkPolygon::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::localization::types::LandmarkPolygonType>(context.getType(), in);
}
::zserio::InplaceOptionalHolder<::nds::localization::types::LandmarkSignType> LandmarkPolygon::readSignType(::zserio::BitStreamReader& in)
{
    if (getType() == ::nds::localization::types::LandmarkPolygonType::SIGN || getType() == ::nds::localization::types::LandmarkPolygonType::SIGN_BOUNDING_BOX)
    {
        return ::zserio::InplaceOptionalHolder<::nds::localization::types::LandmarkSignType>(::zserio::read<::nds::localization::types::LandmarkSignType>(in));
    }

    return ::zserio::InplaceOptionalHolder<::nds::localization::types::LandmarkSignType>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::localization::types::LandmarkSignType> LandmarkPolygon::readSignType(LandmarkPolygon::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (getType() == ::nds::localization::types::LandmarkPolygonType::SIGN || getType() == ::nds::localization::types::LandmarkPolygonType::SIGN_BOUNDING_BOX)
    {
        return ::zserio::InplaceOptionalHolder<::nds::localization::types::LandmarkSignType>(::zserio::read<::nds::localization::types::LandmarkSignType>(context.getSignType(), in));
    }

    return ::zserio::InplaceOptionalHolder<::nds::localization::types::LandmarkSignType>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<bool> LandmarkPolygon::readHasSignDetails(::zserio::BitStreamReader& in)
{
    if (getType() == ::nds::localization::types::LandmarkPolygonType::SIGN || getType() == ::nds::localization::types::LandmarkPolygonType::SIGN_BOUNDING_BOX)
    {
        return ::zserio::InplaceOptionalHolder<bool>(static_cast<bool>(in.readBool()));
    }

    return ::zserio::InplaceOptionalHolder<bool>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::localization::types::LandmarkSignDetails> LandmarkPolygon::readSignDetails(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if ((getType() == ::nds::localization::types::LandmarkPolygonType::SIGN || getType() == ::nds::localization::types::LandmarkPolygonType::SIGN_BOUNDING_BOX) && getHasSignDetails())
    {
        return ::zserio::InplaceOptionalHolder<::nds::localization::types::LandmarkSignDetails>(::nds::localization::types::LandmarkSignDetails(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::localization::types::LandmarkSignDetails>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::localization::types::LandmarkSignDetails> LandmarkPolygon::readSignDetails(LandmarkPolygon::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if ((getType() == ::nds::localization::types::LandmarkPolygonType::SIGN || getType() == ::nds::localization::types::LandmarkPolygonType::SIGN_BOUNDING_BOX) && getHasSignDetails())
    {
        return ::zserio::InplaceOptionalHolder<::nds::localization::types::LandmarkSignDetails>(::nds::localization::types::LandmarkSignDetails(context.getSignDetails(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::localization::types::LandmarkSignDetails>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::localization::types::FiducialMarkerDetails> LandmarkPolygon::readMarkerDetails(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getType() == ::nds::localization::types::LandmarkPolygonType::FIDUCIAL_MARKER)
    {
        return ::zserio::InplaceOptionalHolder<::nds::localization::types::FiducialMarkerDetails>(::nds::localization::types::FiducialMarkerDetails(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::localization::types::FiducialMarkerDetails>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::localization::types::FiducialMarkerDetails> LandmarkPolygon::readMarkerDetails(LandmarkPolygon::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getType() == ::nds::localization::types::LandmarkPolygonType::FIDUCIAL_MARKER)
    {
        return ::zserio::InplaceOptionalHolder<::nds::localization::types::FiducialMarkerDetails>(::nds::localization::types::FiducialMarkerDetails(context.getMarkerDetails(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::localization::types::FiducialMarkerDetails>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::localization::types::LandmarkColor> LandmarkPolygon::readColor(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::localization::types::LandmarkColor>(::nds::localization::types::LandmarkColor(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::localization::types::LandmarkColor>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::localization::types::LandmarkColor> LandmarkPolygon::readColor(LandmarkPolygon::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::localization::types::LandmarkColor>(::nds::localization::types::LandmarkColor(context.getColor(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::localization::types::LandmarkColor>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::localization::types::LandmarkConfidence> LandmarkPolygon::readConfidence(::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        ::nds::localization::types::LandmarkConfidence readField = static_cast<::nds::localization::types::LandmarkConfidence>(in.readBits(UINT8_C(8)));
        // check constraint
        if (!(readField <= 100))
            throw ::zserio::ConstraintException("Read: Constraint violated at LandmarkPolygon.confidence!");

        return ::zserio::InplaceOptionalHolder<::nds::localization::types::LandmarkConfidence>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<::nds::localization::types::LandmarkConfidence>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::localization::types::LandmarkConfidence> LandmarkPolygon::readConfidence(LandmarkPolygon::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        ::nds::localization::types::LandmarkConfidence readField = context.getConfidence().read<::zserio::StdIntArrayTraits<::nds::localization::types::LandmarkConfidence>>(in);
        // check constraint
        if (!(readField <= 100))
            throw ::zserio::ConstraintException("Read: Constraint violated at LandmarkPolygon.confidence!");

        return ::zserio::InplaceOptionalHolder<::nds::localization::types::LandmarkConfidence>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<::nds::localization::types::LandmarkConfidence>(::zserio::NullOpt);
}

} // namespace types
} // namespace localization
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ArrayTraits.h>

#include <nds/localization/types/LandmarkSignDetails.h>
#include <nds/localization/types/LandmarkSignDetailsType.h>

namespace nds
{
namespace localization
{
namespace types
{

LandmarkSignDetails::LandmarkSignDetails(const allocator_type&) noexcept :
        m_detailType_(::nds::localization::types::LandmarkSignDetailsType()),
        m_meaning_(::zserio::NullOpt),
        m_diameter_(::zserio::NullOpt),
        m_number_(::zserio::NullOpt),
        m_text_(::zserio::NullOpt)
{
}

LandmarkSignDetails::LandmarkSignDetails(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_detailType_(readDetailType(in)),
        m_meaning_(readMeaning(in)),
        m_diameter_(readDiameter(in)),
        m_number_(readNumber(in)),
        m_text_(readText(in, allocator))
{
}

LandmarkSignDetails::LandmarkSignDetails(LandmarkSignDetails::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_detailType_(readDetailType(context, in)),
        m_meaning_(readMeaning(context, in)),
        m_diameter_(readDiameter(context, in)),
        m_number_(readNumber(context, in)),
        m_text_(readText(in, allocator))
{
}

LandmarkSignDetails::LandmarkSignDetails(::zserio::PropagateAllocatorT,
        const LandmarkSignDetails& other, const allocator_type& allocator) :
        m_detailType_(::zserio::allocatorPropagatingCopy(other.m_detailType_, allocator)),
        m_meaning_(::zserio::allocatorPropagatingCopy(other.m_meaning_, allocator)),
        m_diameter_(::zserio::allocatorPropagatingCopy(other.m_diameter_, allocator)),
        m_number_(::zserio::allocatorPropagatingCopy(other.m_number_, allocator)),
        m_text_(::zserio::allocatorPropagatingCopy(other.m_text_, allocator))
{
}

::nds::localization::types::LandmarkSignDetailsType LandmarkSignDetails::getDetailType() const
{
    return m_detailType_;
}

void LandmarkSignDetails::setDetailType(::nds::localization::types::LandmarkSignDetailsType detailType_)
{
    m_detailType_ = detailType_;
}

::nds::signs::warning::WarningSign LandmarkSignDetails::getMeaning() const
{
    return m_meaning_.value();
}

void LandmarkSignDetails::setMeaning(::nds::signs::warning::WarningSign meaning_)
{
    m_meaning_ = meaning_;
}

bool LandmarkSignDetails::isMeaningUsed() const
{
    return ((getDetailType() & ::nds::localization::types::LandmarkSignDetailsType::Values::MEANING) == ::nds::localization::types::LandmarkSignDetailsType::Values::MEANING);
}

bool LandmarkSignDetails::isMeaningSet() const
{
    return m_meaning_.hasValue();
}

void LandmarkSignDetails::resetMeaning()
{
    m_meaning_.reset();
}

::nds::core::types::WidthCentimeters LandmarkSignDetails::getDiameter() const
{
    return m_diameter_.value();
}

void LandmarkSignDetails::setDiameter(::nds::core::types::WidthCentimeters diameter_)
{
    m_diameter_ = diameter_;
}

bool LandmarkSignDetails::isDiameterUsed() const
{
    return ((getDetailType() & ::nds::localization::types::LandmarkSignDetailsType::Values::DIAMETER) == ::nds::localization::types::LandmarkSignDetailsType::Values::DIAMETER);
}

bool LandmarkSignDetails::isDiameterSet() const
{
    return m_diameter_.hasValue();
}

void LandmarkSignDetails::resetDiameter()
{
    m_diameter_.reset();
}

uint64_t LandmarkSignDetails::getNumber() const
{
    return m_number_.value();
}

void LandmarkSignDetails::setNumber(uint64_t number_)
{
    m_number_ = number_;
}

bool LandmarkSignDetails::isNumberUsed() const
{
    return ((getDetailType() & ::nds::localization::types::LandmarkSignDetailsType::Values::NUMBER) == ::nds::localization::types::LandmarkSignDetailsType::Values::NUMBER);
}

bool LandmarkSignDetails::isNumberSet() const
{
    return m_number_.hasValue();
}

void LandmarkSignDetails::resetNumber()
{
    m_number_.reset();
}

::zserio::string<>& LandmarkSignDetails::getText()
{
    return m_text_.value();
}

const ::zserio::string<>& LandmarkSignDetails::getText() const
{
    return m_text_.value();
}

void LandmarkSignDetails::setText(const ::zserio::string<>& text_)
{
    m_text_ = text_;
}

void LandmarkSignDetails::setText(::zserio::string<>&& text_)
{
    m_text_ = ::std::move(text_);
}

bool LandmarkSignDetails::isTextUsed() const
{
    return ((getDetailType() & ::nds::localization::types::LandmarkSignDetailsType::Values::TEXT) == ::nds::localization::types::LandmarkSignDetailsType::Values::TEXT);
}

bool LandmarkSignDetails::isTextSet() const
{
    return m_text_.hasValue();
}

void LandmarkSignDetails::resetText()
{
    m_text_.reset();
}

void LandmarkSignDetails::initPackingContext(LandmarkSignDetails::ZserioPackingContext& context) const
{
    m_detailType_.initPackingContext(context.getDetailType());
    if ((getDetailType() & ::nds::localization::types::LandmarkSignDetailsType::Values::MEANING) == ::nds::localization::types::LandmarkSignDetailsType::Values::MEANING)
    {
        ::zserio::initPackingContext(context.getMeaning(), m_meaning_.value());
    }
    if ((getDetailType() & ::nds::localization::types::LandmarkSignDetailsType::Values::DIAMETER) == ::nds::localization::types::LandmarkSignDetailsType::Values::DIAMETER)
    {
        context.getDiameter().init<::zserio::VarIntNNArrayTraits<::nds::core::types::WidthCentimeters>>(m_diameter_.value());
    }
    if ((getDetailType() & ::nds::localization::types::LandmarkSignDetailsType::Values::NUMBER) == ::nds::localization::types::LandmarkSignDetailsType::Values::NUMBER)
    {
        context.getNumber().init<::zserio::VarIntNNArrayTraits<uint64_t>>(m_number_.value());
    }
}

size_t LandmarkSignDetails::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_detailType_.bitSizeOf(endBitPosition);
    if ((getDetailType() & ::nds::localization::types::LandmarkSignDetailsType::Values::MEANING) == ::nds::localization::types::LandmarkSignDetailsType::Values::MEANING)
    {
        endBitPosition += ::zserio::bitSizeOf(m_meaning_.value());
    }
    if ((getDetailType() & ::nds::localization::types::LandmarkSignDetailsType::Values::DIAMETER) == ::nds::localization::types::LandmarkSignDetailsType::Values::DIAMETER)
    {
        endBitPosition += ::zserio::bitSizeOfVarUInt32(m_diameter_.value());
    }
    if ((getDetailType() & ::nds::localization::types::LandmarkSignDetailsType::Values::NUMBER) == ::nds::localization::types::LandmarkSignDetailsType::Values::NUMBER)
    {
        endBitPosition += ::zserio::bitSizeOfVarUInt64(m_number_.value());
    }
    if ((getDetailType() & ::nds::localization::types::LandmarkSignDetailsType::Values::TEXT) == ::nds::localization::types::LandmarkSignDetailsType::Values::TEXT)
    {
        endBitPosition += ::zserio::bitSizeOfString(m_text_.value());
    }

    return endBitPosition - bitPosition;
}

size_t LandmarkSignDetails::bitSizeOf(LandmarkSignDetails::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_detailType_.bitSizeOf(context.getDetailType(), endBitPosition);
    if ((getDetailType() & ::nds::localization::types::LandmarkSignDetailsType::Values::MEANING) == ::nds::localization::types::LandmarkSignDetailsType::Values::MEANING)
    {
        endBitPosition += ::zserio::bitSizeOf(context.getMeaning(), m_meaning_.value());
    }
    if ((getDetailType() & ::nds::localization::types::LandmarkSignDetailsType::Values::DIAMETER) == ::nds::localization::types::LandmarkSignDetailsType::Values::DIAMETER)
    {
        endBitPosition += context.getDiameter().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::types::WidthCentimeters>>(m_diameter_.value());
    }
    if ((getDetailType() & ::nds::localization::types::LandmarkSignDetailsType::Values::NUMBER) == ::nds::localization::types::LandmarkSignDetailsType::Values::NUMBER)
    {
        endBitPosition += context.getNumber().bitSizeOf<::zserio::VarIntNNArrayTraits<uint64_t>>(m_number_.value());
    }
    if ((getDetailType() & ::nds::localization::types::LandmarkSignDetailsType::Values::TEXT) == ::nds::localization::types::LandmarkSignDetailsType::Values::TEXT)
    {
        endBitPosition += ::zserio::bitSizeOfString(m_text_.value());
    }

    return endBitPosition - bitPosition;
}

size_t LandmarkSignDetails::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_detailType_.initializeOffsets(endBitPosition);
    if ((getDetailType() & ::nds::localization::types::LandmarkSignDetailsType::Values::MEANING) == ::nds::localization::types::LandmarkSignDetailsType::Values::MEANING)
    {
        endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_meaning_.value());
    }
    if ((getDetailType() & ::nds::localization::types::LandmarkSignDetailsType::Values::DIAMETER) == ::nds::localization::types::LandmarkSignDetailsType::Values::DIAMETER)
    {
        endBitPosition += ::zserio::bitSizeOfVarUInt32(m_diameter_.value());
    }
    if ((getDetailType() & ::nds::localization::types::LandmarkSignDetailsType::Values::NUMBER) == ::nds::localization::types::LandmarkSignDetailsType::Values::NUMBER)
    {
        endBitPosition += ::zserio::bitSizeOfVarUInt64(m_number_.value());
    }
    if ((getDetailType() & ::nds::localization::types::LandmarkSignDetailsType::Values::TEXT) == ::nds::localization::types::LandmarkSignDetailsType::Values::TEXT)
    {
        endBitPosition += ::zserio::bitSizeOfString(m_text_.value());
    }

    return endBitPosition;
}

size_t LandmarkSignDetails::initializeOffsets(LandmarkSignDetails::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_detailType_.initializeOffsets(context.getDetailType(), endBitPosition);
    if ((getDetailType() & ::nds::localization::types::LandmarkSignDetailsType::Values::MEANING) == ::nds::localization::types::LandmarkSignDetailsType::Values::MEANING)
    {
        endBitPosition = ::zserio::initializeOffsets(context.getMeaning(), endBitPosition,
        m_meaning_.value());
    }
    if ((getDetailType() & ::nds::localization::types::LandmarkSignDetailsType::Values::DIAMETER) == ::nds::localization::types::LandmarkSignDetailsType::Values::DIAMETER)
    {
        endBitPosition += context.getDiameter().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::types::WidthCentimeters>>(m_diameter_.value());
    }
    if ((getDetailType() & ::nds::localization::types::LandmarkSignDetailsType::Values::NUMBER) == ::nds::localization::types::LandmarkSignDetailsType::Values::NUMBER)
    {
        endBitPosition += context.getNumber().bitSizeOf<::zserio::VarIntNNArrayTraits<uint64_t>>(m_number_.value());
    }
    if ((getDetailType() & ::nds::localization::types::LandmarkSignDetailsType::Values::TEXT) == ::nds::localization::types::LandmarkSignDetailsType::Values::TEXT)
    {
        endBitPosition += ::zserio::bitSizeOfString(m_text_.value());
    }

    return endBitPosition;
}

bool LandmarkSignDetails::operator==(const LandmarkSignDetails& other) const
{
    if (this != &other)
    {
        return
                (m_detailType_ == other.m_detailType_) &&
                (!isMeaningUsed() ? !other.isMeaningUsed() : (m_meaning_ == other.m_meaning_)) &&
                (!isDiameterUsed() ? !other.isDiameterUsed() : (m_diameter_ == other.m_diameter_)) &&
                (!isNumberUsed() ? !other.isNumberUsed() : (m_number_ == other.m_number_)) &&
                (!isTextUsed() ? !other.isTextUsed() : (m_text_ == other.m_text_));
    }

    return true;
}

uint32_t LandmarkSignDetails::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_detailType_);
    if (isMeaningUsed())
        result = ::zserio::calcHashCode(result, m_meaning_);
    if (isDiameterUsed())
        result = ::zserio::calcHashCode(result, m_diameter_);
    if (isNumberUsed())
        result = ::zserio::calcHashCode(result, m_number_);
    if (isTextUsed())
        result = ::zserio::calcHashCode(result, m_text_);

    return result;
}

void LandmarkSignDetails::write(::zserio::BitStreamWriter& out) const
{
    m_detailType_.write(out);
    if ((getDetailType() & ::nds::localization::types::LandmarkSignDetailsType::Values::MEANING) == ::nds::localization::types::LandmarkSignDetailsType::Values::MEANING)
    {
        ::zserio::write(out, m_meaning_.value());
    }
    if ((getDetailType() & ::nds::localization::types::LandmarkSignDetailsType::Values::DIAMETER) == ::nds::localization::types::LandmarkSignDetailsType::Values::DIAMETER)
    {
        out.writeVarUInt32(m_diameter_.value());
    }
    if ((getDetailType() & ::nds::localization::types::LandmarkSignDetailsType::Values::NUMBER) == ::nds::localization::types::LandmarkSignDetailsType::Values::NUMBER)
    {
        out.writeVarUInt64(m_number_.value());
    }
    if ((getDetailType() & ::nds::localization::types::LandmarkSignDetailsType::Values::TEXT) == ::nds::localization::types::LandmarkSignDetailsType::Values::TEXT)
    {
        out.writeString(m_text_.value());
    }
}

void LandmarkSignDetails::write(LandmarkSignDetails::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_detailType_.write(context.getDetailType(), out);
    if ((getDetailType() & ::nds::localization::types::LandmarkSignDetailsType::Values::MEANING) == ::nds::localization::types::LandmarkSignDetailsType::Values::MEANING)
    {
        ::zserio::write(context.getMeaning(), out, m_meaning_.value());
    }
    if ((getDetailType() & ::nds::localization::types::LandmarkSignDetailsType::Values::DIAMETER) == ::nds::localization::types::LandmarkSignDetailsType::Values::DIAMETER)
    {
        context.getDiameter().write<::zserio::VarIntNNArrayTraits<::nds::core::types::WidthCentimeters>>(out, m_diameter_.value());
    }
    if ((getDetailType() & ::nds::localization::types::LandmarkSignDetailsType::Values::NUMBER) == ::nds::localization::types::LandmarkSignDetailsType::Values::NUMBER)
    {
        context.getNumber().write<::zserio::VarIntNNArrayTraits<uint64_t>>(out, m_number_.value());
    }
    if ((getDetailType() & ::nds::localization::types::LandmarkSignDetailsType::Values::TEXT) == ::nds::localization::types::LandmarkSignDetailsType::Values::TEXT)
    {
        out.writeString(m_text_.value());
    }
}

::nds::localization::types::LandmarkSignDetailsType LandmarkSignDetails::readDetailType(::zserio::BitStreamReader& in)
{
    return ::nds::localization::types::LandmarkSignDetailsType(in);
}

::nds::localization::types::LandmarkSignDetailsType LandmarkSignDetails::readDetailType(LandmarkSignDetails::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::nds::localization::types::LandmarkSignDetailsType(context.getDetailType(), in);
}
::zserio::InplaceOptionalHolder<::nds::signs::warning::WarningSign> LandmarkSignDetails::readMeaning(::zserio::BitStreamReader& in)
{
    if ((getDetailType() & ::nds::localization::types::LandmarkSignDetailsType::Values::MEANING) == ::nds::localization::types::LandmarkSignDetailsType::Values::MEANING)
    {
        return ::zserio::InplaceOptionalHolder<::nds::signs::warning::WarningSign>(::zserio::read<::nds::signs::warning::WarningSign>(in));
    }

    return ::zserio::InplaceOptionalHolder<::nds::signs::warning::WarningSign>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::signs::warning::WarningSign> LandmarkSignDetails::readMeaning(LandmarkSignDetails::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if ((getDetailType() & ::nds::localization::types::LandmarkSignDetailsType::Values::MEANING) == ::nds::localization::types::LandmarkSignDetailsType::Values::MEANING)
    {
        return ::zserio::InplaceOptionalHolder<::nds::signs::warning::WarningSign>(::zserio::read<::nds::signs::warning::WarningSign>(context.getMeaning(), in));
    }

    return ::zserio::InplaceOptionalHolder<::nds::signs::warning::WarningSign>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::core::types::WidthCentimeters> LandmarkSignDetails::readDiameter(::zserio::BitStreamReader& in)
{
    if ((getDetailType() & ::nds::localization::types::LandmarkSignDetailsType::Values::DIAMETER) == ::nds::localization::types::LandmarkSignDetailsType::Values::DIAMETER)
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::types::WidthCentimeters>(static_cast<::nds::core::types::WidthCentimeters>(in.readVarUInt32()));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::types::WidthCentimeters>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::types::WidthCentimeters> LandmarkSignDetails::readDiameter(LandmarkSignDetails::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if ((getDetailType() & ::nds::localization::types::LandmarkSignDetailsType::Values::DIAMETER) == ::nds::localization::types::LandmarkSignDetailsType::Values::DIAMETER)
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::types::WidthCentimeters>(context.getDiameter().read<::zserio::VarIntNNArrayTraits<::nds::core::types::WidthCentimeters>>(in));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::types::WidthCentimeters>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<uint64_t> LandmarkSignDetails::readNumber(::zserio::BitStreamReader& in)
{
    if ((getDetailType() & ::nds::localization::types::LandmarkSignDetailsType::Values::NUMBER) == ::nds::localization::types::LandmarkSignDetailsType::Values::NUMBER)
    {
        return ::zserio::InplaceOptionalHolder<uint64_t>(static_cast<uint64_t>(in.readVarUInt64()));
    }

    return ::zserio::InplaceOptionalHolder<uint64_t>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<uint64_t> LandmarkSignDetails::readNumber(LandmarkSignDetails::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if ((getDetailType() & ::nds::localization::types::LandmarkSignDetailsType::Values::NUMBER) == ::nds::localization::types::LandmarkSignDetailsType::Values::NUMBER)
    {
        return ::zserio::InplaceOptionalHolder<uint64_t>(context.getNumber().read<::zserio::VarIntNNArrayTraits<uint64_t>>(in));
    }

    return ::zserio::InplaceOptionalHolder<uint64_t>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::zserio::string<>> LandmarkSignDetails::readText(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if ((getDetailType() & ::nds::localization::types::LandmarkSignDetailsType::Values::TEXT) == ::nds::localization::types::LandmarkSignDetailsType::Values::TEXT)
    {
        return ::zserio::InplaceOptionalHolder<::zserio::string<>>(static_cast<::zserio::string<>>(in.readString(allocator)));
    }

    return ::zserio::InplaceOptionalHolder<::zserio::string<>>(::zserio::NullOpt);
}

} // namespace types
} // namespace localization
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/localization/types/LandmarkColor.h>

namespace nds
{
namespace localization
{
namespace types
{

LandmarkColor::LandmarkColor(const allocator_type&) noexcept :
        m_red_(uint8_t()),
        m_green_(uint8_t()),
        m_blue_(uint8_t())
{
}

LandmarkColor::LandmarkColor(::zserio::BitStreamReader& in, const allocator_type&) :
        m_red_(readRed(in)),
        m_green_(readGreen(in)),
        m_blue_(readBlue(in))
{
}

LandmarkColor::LandmarkColor(LandmarkColor::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type&) :
        m_red_(readRed(context, in)),
        m_green_(readGreen(context, in)),
        m_blue_(readBlue(context, in))
{
}

LandmarkColor::LandmarkColor(::zserio::PropagateAllocatorT,
        const LandmarkColor& other, const allocator_type& allocator) :
        m_red_(::zserio::allocatorPropagatingCopy(other.m_red_, allocator)),
        m_green_(::zserio::allocatorPropagatingCopy(other.m_green_, allocator)),
        m_blue_(::zserio::allocatorPropagatingCopy(other.m_blue_, allocator))
{
}

uint8_t LandmarkColor::getRed() const
{
    return m_red_;
}

void LandmarkColor::setRed(uint8_t red_)
{
    m_red_ = red_;
}

uint8_t LandmarkColor::getGreen() const
{
    return m_green_;
}

void LandmarkColor::setGreen(uint8_t green_)
{
    m_green_ = green_;
}

uint8_t LandmarkColor::getBlue() const
{
    return m_blue_;
}

void LandmarkColor::setBlue(uint8_t blue_)
{
    m_blue_ = blue_;
}

void LandmarkColor::initPackingContext(LandmarkColor::ZserioPackingContext& context) const
{
    context.getRed().init<::zserio::StdIntArrayTraits<uint8_t>>(m_red_);
    context.getGreen().init<::zserio::StdIntArrayTraits<uint8_t>>(m_green_);
    context.getBlue().init<::zserio::StdIntArrayTraits<uint8_t>>(m_blue_);
}

size_t LandmarkColor::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(8);
    endBitPosition += UINT8_C(8);
    endBitPosition += UINT8_C(8);

    return endBitPosition - bitPosition;
}

size_t LandmarkColor::bitSizeOf(LandmarkColor::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getRed().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_red_);
    endBitPosition += context.getGreen().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_green_);
    endBitPosition += context.getBlue().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_blue_);

    return endBitPosition - bitPosition;
}

size_t LandmarkColor::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(8);
    endBitPosition += UINT8_C(8);
    endBitPosition += UINT8_C(8);

    return endBitPosition;
}

size_t LandmarkColor::initializeOffsets(LandmarkColor::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getRed().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_red_);
    endBitPosition += context.getGreen().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_green_);
    endBitPosition += context.getBlue().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_blue_);

    return endBitPosition;
}

bool LandmarkColor::operator==(const LandmarkColor& other) const
{
    if (this != &other)
    {
        return
                (m_red_ == other.m_red_) &&
                (m_green_ == other.m_green_) &&
                (m_blue_ == other.m_blue_);
    }

    return true;
}

uint32_t LandmarkColor::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_red_);
    result = ::zserio::calcHashCode(result, m_green_);
    result = ::zserio::calcHashCode(result, m_blue_);

    return result;
}

void LandmarkColor::write(::zserio::BitStreamWriter& out) const
{
    out.writeBits(m_red_, UINT8_C(8));
    out.writeBits(m_green_, UINT8_C(8));
    out.writeBits(m_blue_, UINT8_C(8));
}

void LandmarkColor::write(LandmarkColor::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getRed().write<::zserio::StdIntArrayTraits<uint8_t>>(out, m_red_);
    context.getGreen().write<::zserio::StdIntArrayTraits<uint8_t>>(out, m_green_);
    context.getBlue().write<::zserio::StdIntArrayTraits<uint8_t>>(out, m_blue_);
}

uint8_t LandmarkColor::readRed(::zserio::BitStreamReader& in)
{
    return static_cast<uint8_t>(in.readBits(UINT8_C(8)));
}

uint8_t LandmarkColor::readRed(LandmarkColor::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getRed().read<::zserio::StdIntArrayTraits<uint8_t>>(in);
}
uint8_t LandmarkColor::readGreen(::zserio::BitStreamReader& in)
{
    return static_cast<uint8_t>(in.readBits(UINT8_C(8)));
}

uint8_t LandmarkColor::readGreen(LandmarkColor::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getGreen().read<::zserio::StdIntArrayTraits<uint8_t>>(in);
}
uint8_t LandmarkColor::readBlue(::zserio::BitStreamReader& in)
{
    return static_cast<uint8_t>(in.readBits(UINT8_C(8)));
}

uint8_t LandmarkColor::readBlue(LandmarkColor::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getBlue().read<::zserio::StdIntArrayTraits<uint8_t>>(in);
}

} // namespace types
} // namespace localization
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/localization/types/FiducialMarkerDetails.h>

namespace nds
{
namespace localization
{
namespace types
{

FiducialMarkerDetails::FiducialMarkerDetails(const allocator_type&) noexcept :
        m_type_(::nds::localization::types::FiducialMarkerSystemType()),
        m_dictionaryIndex_(uint16_t())
{
}

FiducialMarkerDetails::FiducialMarkerDetails(::zserio::BitStreamReader& in, const allocator_type&) :
        m_type_(readType(in)),
        m_dictionaryIndex_(readDictionaryIndex(in))
{
}

FiducialMarkerDetails::FiducialMarkerDetails(FiducialMarkerDetails::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type&) :
        m_type_(readType(context, in)),
        m_dictionaryIndex_(readDictionaryIndex(context, in))
{
}

FiducialMarkerDetails::FiducialMarkerDetails(::zserio::PropagateAllocatorT,
        const FiducialMarkerDetails& other, const allocator_type& allocator) :
        m_type_(::zserio::allocatorPropagatingCopy(other.m_type_, allocator)),
        m_dictionaryIndex_(::zserio::allocatorPropagatingCopy(other.m_dictionaryIndex_, allocator))
{
}

::nds::localization::types::FiducialMarkerSystemType FiducialMarkerDetails::getType() const
{
    return m_type_;
}

void FiducialMarkerDetails::setType(::nds::localization::types::FiducialMarkerSystemType type_)
{
    m_type_ = type_;
}

uint16_t FiducialMarkerDetails::getDictionaryIndex() const
{
    return m_dictionaryIndex_;
}

void FiducialMarkerDetails::setDictionaryIndex(uint16_t dictionaryIndex_)
{
    m_dictionaryIndex_ = dictionaryIndex_;
}

void FiducialMarkerDetails::initPackingContext(FiducialMarkerDetails::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getType(), m_type_);
    context.getDictionaryIndex().init<::zserio::VarIntNNArrayTraits<uint16_t>>(m_dictionaryIndex_);
}

size_t FiducialMarkerDetails::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_type_);
    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_dictionaryIndex_);

    return endBitPosition - bitPosition;
}

size_t FiducialMarkerDetails::bitSizeOf(FiducialMarkerDetails::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getType(), m_type_);
    endBitPosition += context.getDictionaryIndex().bitSizeOf<::zserio::VarIntNNArrayTraits<uint16_t>>(m_dictionaryIndex_);

    return endBitPosition - bitPosition;
}

size_t FiducialMarkerDetails::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_type_);
    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_dictionaryIndex_);

    return endBitPosition;
}

size_t FiducialMarkerDetails::initializeOffsets(FiducialMarkerDetails::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getType(), endBitPosition,
        m_type_);
    endBitPosition += context.getDictionaryIndex().bitSizeOf<::zserio::VarIntNNArrayTraits<uint16_t>>(m_dictionaryIndex_);

    return endBitPosition;
}

bool FiducialMarkerDetails::operator==(const FiducialMarkerDetails& other) const
{
    if (this != &other)
    {
        return
                (m_type_ == other.m_type_) &&
                (m_dictionaryIndex_ == other.m_dictionaryIndex_);
    }

    return true;
}

uint32_t FiducialMarkerDetails::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_type_);
    result = ::zserio::calcHashCode(result, m_dictionaryIndex_);

    return result;
}

void FiducialMarkerDetails::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_type_);
    out.writeVarUInt16(m_dictionaryIndex_);
}

void FiducialMarkerDetails::write(FiducialMarkerDetails::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getType(), out, m_type_);
    context.getDictionaryIndex().write<::zserio::VarIntNNArrayTraits<uint16_t>>(out, m_dictionaryIndex_);
}

::nds::localization::types::FiducialMarkerSystemType FiducialMarkerDetails::readType(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::localization::types::FiducialMarkerSystemType>(in);
}

::nds::localization::types::FiducialMarkerSystemType FiducialMarkerDetails::readType(FiducialMarkerDetails::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::localization::types::FiducialMarkerSystemType>(context.getType(), in);
}
uint16_t FiducialMarkerDetails::readDictionaryIndex(::zserio::BitStreamReader& in)
{
    return static_cast<uint16_t>(in.readVarUInt16());
}

uint16_t FiducialMarkerDetails::readDictionaryIndex(FiducialMarkerDetails::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getDictionaryIndex().read<::zserio::VarIntNNArrayTraits<uint16_t>>(in);
}

} // namespace types
} // namespace localization
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ConstraintException.h>

#include <nds/localization/types/LandmarkMesh.h>

namespace nds
{
namespace localization
{
namespace types
{

LandmarkMesh::LandmarkMesh(const allocator_type&) noexcept :
        m_type_(::nds::localization::types::LandmarkMeshType()),
        m_color_(::zserio::NullOpt),
        m_confidence_(::zserio::NullOpt)
{
}

LandmarkMesh::LandmarkMesh(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_type_(readType(in)),
        m_color_(readColor(in, allocator)),
        m_confidence_(readConfidence(in))
{
}

LandmarkMesh::LandmarkMesh(LandmarkMesh::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_type_(readType(context, in)),
        m_color_(readColor(context, in, allocator)),
        m_confidence_(readConfidence(context, in))
{
}

LandmarkMesh::LandmarkMesh(::zserio::PropagateAllocatorT,
        const LandmarkMesh& other, const allocator_type& allocator) :
        m_type_(::zserio::allocatorPropagatingCopy(other.m_type_, allocator)),
        m_color_(::zserio::allocatorPropagatingCopy(other.m_color_, allocator)),
        m_confidence_(::zserio::allocatorPropagatingCopy(other.m_confidence_, allocator))
{
}

::nds::localization::types::LandmarkMeshType LandmarkMesh::getType() const
{
    return m_type_;
}

void LandmarkMesh::setType(::nds::localization::types::LandmarkMeshType type_)
{
    m_type_ = type_;
}

::nds::localization::types::LandmarkColor& LandmarkMesh::getColor()
{
    return m_color_.value();
}

const ::nds::localization::types::LandmarkColor& LandmarkMesh::getColor() const
{
    return m_color_.value();
}

void LandmarkMesh::setColor(const ::nds::localization::types::LandmarkColor& color_)
{
    m_color_ = color_;
}

void LandmarkMesh::setColor(::nds::localization::types::LandmarkColor&& color_)
{
    m_color_ = ::std::move(color_);
}

bool LandmarkMesh::isColorUsed() const
{
    return (isColorSet());
}

bool LandmarkMesh::isColorSet() const
{
    return m_color_.hasValue();
}

void LandmarkMesh::resetColor()
{
    m_color_.reset();
}

::nds::localization::types::LandmarkConfidence LandmarkMesh::getConfidence() const
{
    return m_confidence_.value();
}

void LandmarkMesh::setConfidence(::nds::localization::types::LandmarkConfidence confidence_)
{
    m_confidence_ = confidence_;
}

bool LandmarkMesh::isConfidenceUsed() const
{
    return (isConfidenceSet());
}

bool LandmarkMesh::isConfidenceSet() const
{
    return m_confidence_.hasValue();
}

void LandmarkMesh::resetConfidence()
{
    m_confidence_.reset();
}

void LandmarkMesh::initPackingContext(LandmarkMesh::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getType(), m_type_);
    if (isColorSet())
    {
        m_color_.value().initPackingContext(context.getColor());
    }
    if (isConfidenceSet())
    {
        context.getConfidence().init<::zserio::StdIntArrayTraits<::nds::localization::types::LandmarkConfidence>>(m_confidence_.value());
    }
}

size_t LandmarkMesh::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_type_);
    endBitPosition += 1;
    if (isColorSet())
    {
        endBitPosition += m_color_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition += 1;
    if (isConfidenceSet())
    {
        endBitPosition += UINT8_C(8);
    }

    return endBitPosition - bitPosition;
}

size_t LandmarkMesh::bitSizeOf(LandmarkMesh::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getType(), m_type_);
    endBitPosition += 1;
    if (isColorSet())
    {
        endBitPosition += m_color_.value().bitSizeOf(context.getColor(), endBitPosition);
    }
    endBitPosition += 1;
    if (isConfidenceSet())
    {
        endBitPosition += context.getConfidence().bitSizeOf<::zserio::StdIntArrayTraits<::nds::localization::types::LandmarkConfidence>>(m_confidence_.value());
    }

    return endBitPosition - bitPosition;
}

size_t LandmarkMesh::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_type_);
    endBitPosition += 1;
    if (isColorSet())
    {
        endBitPosition = m_color_.value().initializeOffsets(endBitPosition);
    }
    endBitPosition += 1;
    if (isConfidenceSet())
    {
        endBitPosition += UINT8_C(8);
    }

    return endBitPosition;
}

size_t LandmarkMesh::initializeOffsets(LandmarkMesh::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getType(), endBitPosition,
        m_type_);
    endBitPosition += 1;
    if (isColorSet())
    {
        endBitPosition = m_color_.value().initializeOffsets(context.getColor(), endBitPosition);
    }
    endBitPosition += 1;
    if (isConfidenceSet())
    {
        endBitPosition += context.getConfidence().bitSizeOf<::zserio::StdIntArrayTraits<::nds::localization::types::LandmarkConfidence>>(m_confidence_.value());
    }

    return endBitPosition;
}

bool LandmarkMesh::operator==(const LandmarkMesh& other) const
{
    if (this != &other)
    {
        return
                (m_type_ == other.m_type_) &&
                (!isColorUsed() ? !other.isColorUsed() : (m_color_ == other.m_color_)) &&
                (!isConfidenceUsed() ? !other.isConfidenceUsed() : (m_confidence_ == other.m_confidence_));
    }

    return true;
}

uint32_t LandmarkMesh::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_type_);
    if (isColorUsed())
        result = ::zserio::calcHashCode(result, m_color_);
    if (isConfidenceUsed())
        result = ::zserio::calcHashCode(result, m_confidence_);

    return result;
}

void LandmarkMesh::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_type_);

    if (isColorSet())
    {
        out.writeBool(true);
        m_color_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isConfidenceSet())
    {
        out.writeBool(true);
        // check constraint
        if (!(getConfidence() <= 100))
            throw ::zserio::ConstraintException("Write: Constraint violated at LandmarkMesh.confidence!");
        out.writeBits(m_confidence_.value(), UINT8_C(8));
    }
    else
    {
        out.writeBool(false);
    }
}

void LandmarkMesh::write(LandmarkMesh::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getType(), out, m_type_);

    if (isColorSet())
    {
        out.writeBool(true);
        m_color_.value().write(context.getColor(), out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isConfidenceSet())
    {
        out.writeBool(true);
        // check constraint
        if (!(getConfidence() <= 100))
            throw ::zserio::ConstraintException("Write: Constraint violated at LandmarkMesh.confidence!");
        context.getConfidence().write<::zserio::StdIntArrayTraits<::nds::localization::types::LandmarkConfidence>>(out, m_confidence_.value());
    }
    else
    {
        out.writeBool(false);
    }
}

::nds::localization::types::LandmarkMeshType LandmarkMesh::readType(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::localization::types::LandmarkMeshType>(in);
}

::nds::localization::types::LandmarkMeshType LandmarkMesh::readType(LandmarkMesh::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::localization::types::LandmarkMeshType>(context.getType(), in);
}
::zserio::InplaceOptionalHolder<::nds::localization::types::LandmarkColor> LandmarkMesh::readColor(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::localization::types::LandmarkColor>(::nds::localization::types::LandmarkColor(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::localization::types::LandmarkColor>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::localization::types::LandmarkColor> LandmarkMesh::readColor(LandmarkMesh::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::localization::types::LandmarkColor>(::nds::localization::types::LandmarkColor(context.getColor(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::localization::types::LandmarkColor>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::localization::types::LandmarkConfidence> LandmarkMesh::readConfidence(::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        ::nds::localization::types::LandmarkConfidence readField = static_cast<::nds::localization::types::LandmarkConfidence>(in.readBits(UINT8_C(8)));
        // check constraint
        if (!(readField <= 100))
            throw ::zserio::ConstraintException("Read: Constraint violated at LandmarkMesh.confidence!");

        return ::zserio::InplaceOptionalHolder<::nds::localization::types::LandmarkConfidence>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<::nds::localization::types::LandmarkConfidence>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::localization::types::LandmarkConfidence> LandmarkMesh::readConfidence(LandmarkMesh::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        ::nds::localization::types::LandmarkConfidence readField = context.getConfidence().read<::zserio::StdIntArrayTraits<::nds::localization::types::LandmarkConfidence>>(in);
        // check constraint
        if (!(readField <= 100))
            throw ::zserio::ConstraintException("Read: Constraint violated at LandmarkMesh.confidence!");

        return ::zserio::InplaceOptionalHolder<::nds::localization::types::LandmarkConfidence>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<::nds::localization::types::LandmarkConfidence>(::zserio::NullOpt);
}

} // namespace types
} // namespace localization
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ConstraintException.h>

#include <nds/localization/types/OccupancyProbability.h>

namespace nds
{
namespace localization
{
namespace types
{

OccupancyProbability::OccupancyProbability(const allocator_type&) noexcept :
        m_value_(uint8_t())
{
}

OccupancyProbability::OccupancyProbability(::zserio::BitStreamReader& in, const allocator_type&) :
        m_value_(readValue(in))
{
}

OccupancyProbability::OccupancyProbability(OccupancyProbability::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type&) :
        m_value_(readValue(context, in))
{
}

OccupancyProbability::OccupancyProbability(::zserio::PropagateAllocatorT,
        const OccupancyProbability& other, const allocator_type& allocator) :
        m_value_(::zserio::allocatorPropagatingCopy(other.m_value_, allocator))
{
}

uint8_t OccupancyProbability::getValue() const
{
    return m_value_;
}

void OccupancyProbability::setValue(uint8_t value_)
{
    m_value_ = value_;
}

void OccupancyProbability::initPackingContext(OccupancyProbability::ZserioPackingContext& context) const
{
    context.getValue().init<::zserio::StdIntArrayTraits<uint8_t>>(m_value_);
}

size_t OccupancyProbability::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(8);

    return endBitPosition - bitPosition;
}

size_t OccupancyProbability::bitSizeOf(OccupancyProbability::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getValue().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_value_);

    return endBitPosition - bitPosition;
}

size_t OccupancyProbability::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(8);

    return endBitPosition;
}

size_t OccupancyProbability::initializeOffsets(OccupancyProbability::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getValue().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_value_);

    return endBitPosition;
}

bool OccupancyProbability::operator==(const OccupancyProbability& other) const
{
    if (this != &other)
    {
        return
                (m_value_ == other.m_value_);
    }

    return true;
}

uint32_t OccupancyProbability::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_value_);

    return result;
}

void OccupancyProbability::write(::zserio::BitStreamWriter& out) const
{
    // check constraint
    if (!(getValue() <= 200))
        throw ::zserio::ConstraintException("Write: Constraint violated at OccupancyProbability.value!");
    out.writeBits(m_value_, UINT8_C(8));
}

void OccupancyProbability::write(OccupancyProbability::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    // check constraint
    if (!(getValue() <= 200))
        throw ::zserio::ConstraintException("Write: Constraint violated at OccupancyProbability.value!");
    context.getValue().write<::zserio::StdIntArrayTraits<uint8_t>>(out, m_value_);
}

uint8_t OccupancyProbability::readValue(::zserio::BitStreamReader& in)
{
    uint8_t readField = static_cast<uint8_t>(in.readBits(UINT8_C(8)));
    // check constraint
    if (!(readField <= 200))
        throw ::zserio::ConstraintException("Read: Constraint violated at OccupancyProbability.value!");

    return readField;
}

uint8_t OccupancyProbability::readValue(OccupancyProbability::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    uint8_t readField = context.getValue().read<::zserio::StdIntArrayTraits<uint8_t>>(in);
    // check constraint
    if (!(readField <= 200))
        throw ::zserio::ConstraintException("Read: Constraint violated at OccupancyProbability.value!");

    return readField;
}

} // namespace types
} // namespace localization
} // namespace nds
