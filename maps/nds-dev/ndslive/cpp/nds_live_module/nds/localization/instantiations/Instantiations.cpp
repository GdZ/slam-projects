/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/localization/instantiations/ObstacleGeometryLayer.h>

namespace nds
{
namespace localization
{
namespace instantiations
{

ObstacleGeometryLayer::ObstacleGeometryLayer(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_coordShiftXY_(::nds::core::geometry::CoordShift()),
        m_coordShiftZ_(::nds::core::geometry::CoordShift()),
        m_numElements_(uint32_t()),
        m_identifier_(::zserio::NullOpt),
        m_types_(::zserio::NullOpt),
        m_buffers_(allocator)
{
}

ObstacleGeometryLayer::ObstacleGeometryLayer(::zserio::BitStreamReader& in,
        ::nds::core::geometry::GeometryLayerType type_,
        bool hasIds_,
        bool hasTypes_, const allocator_type& allocator) :
        m_type_(type_),
        m_hasIds_(hasIds_),
        m_hasTypes_(hasTypes_),
        m_isInitialized(true),
        m_coordShiftXY_(readCoordShiftXY(in)),
        m_coordShiftZ_(readCoordShiftZ(in)),
        m_numElements_(readNumElements(in)),
        m_identifier_(readIdentifier(in, allocator)),
        m_types_(readTypes(in, allocator)),
        m_buffers_(readBuffers(in, allocator))
{
}

ObstacleGeometryLayer::ObstacleGeometryLayer(ObstacleGeometryLayer::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::GeometryLayerType type_,
        bool hasIds_,
        bool hasTypes_, const allocator_type& allocator) :
        m_type_(type_),
        m_hasIds_(hasIds_),
        m_hasTypes_(hasTypes_),
        m_isInitialized(true),
        m_coordShiftXY_(readCoordShiftXY(context, in)),
        m_coordShiftZ_(readCoordShiftZ(context, in)),
        m_numElements_(readNumElements(context, in)),
        m_identifier_(readIdentifier(in, allocator)),
        m_types_(readTypes(context, in, allocator)),
        m_buffers_(readBuffers(context, in, allocator))
{
}

ObstacleGeometryLayer::ObstacleGeometryLayer(const ObstacleGeometryLayer& other) :
        m_coordShiftXY_(other.m_coordShiftXY_),
        m_coordShiftZ_(other.m_coordShiftZ_),
        m_numElements_(other.m_numElements_),
        m_identifier_(other.m_identifier_),
        m_types_(other.m_types_),
        m_buffers_(other.m_buffers_)
{
    if (other.m_isInitialized)
        initialize(other.m_type_, other.m_hasIds_, other.m_hasTypes_);
    else
        m_isInitialized = false;
}

ObstacleGeometryLayer& ObstacleGeometryLayer::operator=(const ObstacleGeometryLayer& other)
{
    m_coordShiftXY_ = other.m_coordShiftXY_;
    m_coordShiftZ_ = other.m_coordShiftZ_;
    m_numElements_ = other.m_numElements_;
    m_identifier_ = other.m_identifier_;
    m_types_ = other.m_types_;
    m_buffers_ = other.m_buffers_;
    if (other.m_isInitialized)
        initialize(other.m_type_, other.m_hasIds_, other.m_hasTypes_);
    else
        m_isInitialized = false;

    return *this;
}

ObstacleGeometryLayer::ObstacleGeometryLayer(ObstacleGeometryLayer&& other) :
        m_coordShiftXY_(::std::move(other.m_coordShiftXY_)),
        m_coordShiftZ_(::std::move(other.m_coordShiftZ_)),
        m_numElements_(::std::move(other.m_numElements_)),
        m_identifier_(::std::move(other.m_identifier_)),
        m_types_(::std::move(other.m_types_)),
        m_buffers_(::std::move(other.m_buffers_))
{
    if (other.m_isInitialized)
        initialize(other.m_type_, other.m_hasIds_, other.m_hasTypes_);
    else
        m_isInitialized = false;
}

ObstacleGeometryLayer& ObstacleGeometryLayer::operator=(ObstacleGeometryLayer&& other)
{
    m_coordShiftXY_ = ::std::move(other.m_coordShiftXY_);
    m_coordShiftZ_ = ::std::move(other.m_coordShiftZ_);
    m_numElements_ = ::std::move(other.m_numElements_);
    m_identifier_ = ::std::move(other.m_identifier_);
    m_types_ = ::std::move(other.m_types_);
    m_buffers_ = ::std::move(other.m_buffers_);
    if (other.m_isInitialized)
        initialize(other.m_type_, other.m_hasIds_, other.m_hasTypes_);
    else
        m_isInitialized = false;

    return *this;
}

ObstacleGeometryLayer::ObstacleGeometryLayer(::zserio::PropagateAllocatorT,
        const ObstacleGeometryLayer& other, const allocator_type& allocator) :
        m_coordShiftXY_(::zserio::allocatorPropagatingCopy(other.m_coordShiftXY_, allocator)),
        m_coordShiftZ_(::zserio::allocatorPropagatingCopy(other.m_coordShiftZ_, allocator)),
        m_numElements_(::zserio::allocatorPropagatingCopy(other.m_numElements_, allocator)),
        m_identifier_(::zserio::allocatorPropagatingCopy(other.m_identifier_, allocator)),
        m_types_(::zserio::allocatorPropagatingCopy(other.m_types_, allocator)),
        m_buffers_(::zserio::allocatorPropagatingCopy(other.m_buffers_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_type_, other.m_hasIds_, other.m_hasTypes_);
    else
        m_isInitialized = false;
}

void ObstacleGeometryLayer::initialize(
        ::nds::core::geometry::GeometryLayerType type_,
        bool hasIds_,
        bool hasTypes_)
{
    m_type_ = type_;
    m_hasIds_ = hasIds_;
    m_hasTypes_ = hasTypes_;
    m_isInitialized = true;

    initializeChildren();
}

bool ObstacleGeometryLayer::isInitialized() const
{
    return m_isInitialized;
}

void ObstacleGeometryLayer::initializeChildren()
{
    m_buffers_.initialize(static_cast<::nds::core::geometry::GeometryLayerType>(getType()), static_cast<::nds::core::geometry::CoordShift>(getCoordShiftXY()), static_cast<::nds::core::geometry::CoordShift>(getCoordShiftZ()), static_cast<uint32_t>(getNumElements()));
}

::nds::core::geometry::GeometryLayerType ObstacleGeometryLayer::getType() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'type' of compound 'ObstacleGeometryLayer' is not initialized!");

    return m_type_;
}

bool ObstacleGeometryLayer::getHasIds() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'hasIds' of compound 'ObstacleGeometryLayer' is not initialized!");

    return m_hasIds_;
}

bool ObstacleGeometryLayer::getHasTypes() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'hasTypes' of compound 'ObstacleGeometryLayer' is not initialized!");

    return m_hasTypes_;
}

::nds::core::geometry::CoordShift ObstacleGeometryLayer::getCoordShiftXY() const
{
    return m_coordShiftXY_;
}

void ObstacleGeometryLayer::setCoordShiftXY(::nds::core::geometry::CoordShift coordShiftXY_)
{
    m_coordShiftXY_ = coordShiftXY_;
}

::nds::core::geometry::CoordShift ObstacleGeometryLayer::getCoordShiftZ() const
{
    return m_coordShiftZ_;
}

void ObstacleGeometryLayer::setCoordShiftZ(::nds::core::geometry::CoordShift coordShiftZ_)
{
    m_coordShiftZ_ = coordShiftZ_;
}

uint32_t ObstacleGeometryLayer::getNumElements() const
{
    return m_numElements_;
}

void ObstacleGeometryLayer::setNumElements(uint32_t numElements_)
{
    m_numElements_ = numElements_;
}

::zserio::vector<::nds::core::geometry::GeometryId>& ObstacleGeometryLayer::getIdentifier()
{
    return m_identifier_.value().getRawArray();
}

const ::zserio::vector<::nds::core::geometry::GeometryId>& ObstacleGeometryLayer::getIdentifier() const
{
    return m_identifier_.value().getRawArray();
}

void ObstacleGeometryLayer::setIdentifier(const ::zserio::vector<::nds::core::geometry::GeometryId>& identifier_)
{
    m_identifier_ = ZserioArrayType_identifier(identifier_);
}

void ObstacleGeometryLayer::setIdentifier(::zserio::vector<::nds::core::geometry::GeometryId>&& identifier_)
{
    m_identifier_ = ZserioArrayType_identifier(std::move(identifier_));
}

bool ObstacleGeometryLayer::isIdentifierUsed() const
{
    return (getHasIds());
}

bool ObstacleGeometryLayer::isIdentifierSet() const
{
    return m_identifier_.hasValue();
}

void ObstacleGeometryLayer::resetIdentifier()
{
    m_identifier_.reset();
}

::zserio::vector<::nds::localization::types::ObstacleType>& ObstacleGeometryLayer::getTypes()
{
    return m_types_.value().getRawArray();
}

const ::zserio::vector<::nds::localization::types::ObstacleType>& ObstacleGeometryLayer::getTypes() const
{
    return m_types_.value().getRawArray();
}

void ObstacleGeometryLayer::setTypes(const ::zserio::vector<::nds::localization::types::ObstacleType>& types_)
{
    m_types_ = ZserioArrayType_types(types_);
}

void ObstacleGeometryLayer::setTypes(::zserio::vector<::nds::localization::types::ObstacleType>&& types_)
{
    m_types_ = ZserioArrayType_types(std::move(types_));
}

bool ObstacleGeometryLayer::isTypesUsed() const
{
    return (getHasTypes());
}

bool ObstacleGeometryLayer::isTypesSet() const
{
    return m_types_.hasValue();
}

void ObstacleGeometryLayer::resetTypes()
{
    m_types_.reset();
}

::nds::core::geometry::Buffers& ObstacleGeometryLayer::getBuffers()
{
    return m_buffers_;
}

const ::nds::core::geometry::Buffers& ObstacleGeometryLayer::getBuffers() const
{
    return m_buffers_;
}

void ObstacleGeometryLayer::setBuffers(const ::nds::core::geometry::Buffers& buffers_)
{
    m_buffers_ = buffers_;
}

void ObstacleGeometryLayer::setBuffers(::nds::core::geometry::Buffers&& buffers_)
{
    m_buffers_ = ::std::move(buffers_);
}

void ObstacleGeometryLayer::initPackingContext(ObstacleGeometryLayer::ZserioPackingContext& context) const
{
    context.getCoordShiftXY().init<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(m_coordShiftXY_);
    context.getCoordShiftZ().init<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(m_coordShiftZ_);
    context.getNumElements().init<::zserio::VarSizeArrayTraits>(m_numElements_);
    m_buffers_.initPackingContext(context.getBuffers());
}

size_t ObstacleGeometryLayer::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(5);
    endBitPosition += UINT8_C(5);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_numElements_);
    if (getHasIds())
    {
        endBitPosition += m_identifier_.value().bitSizeOf(*this, endBitPosition);
    }
    if (getHasTypes())
    {
        endBitPosition = ::zserio::alignTo(8, endBitPosition);
        endBitPosition += m_types_.value().bitSizeOfPacked(endBitPosition);
    }
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_buffers_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ObstacleGeometryLayer::bitSizeOf(ObstacleGeometryLayer::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getCoordShiftXY().bitSizeOf<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(m_coordShiftXY_);
    endBitPosition += context.getCoordShiftZ().bitSizeOf<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(m_coordShiftZ_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getNumElements().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numElements_);
    if (getHasIds())
    {
        endBitPosition += m_identifier_.value().bitSizeOf(*this, endBitPosition);
    }
    if (getHasTypes())
    {
        endBitPosition = ::zserio::alignTo(8, endBitPosition);
        endBitPosition += m_types_.value().bitSizeOfPacked(endBitPosition);
    }
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_buffers_.bitSizeOf(context.getBuffers(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ObstacleGeometryLayer::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(5);
    endBitPosition += UINT8_C(5);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_numElements_);
    if (getHasIds())
    {
        endBitPosition = m_identifier_.value().initializeOffsets(*this, endBitPosition);
    }
    if (getHasTypes())
    {
        endBitPosition = ::zserio::alignTo(8, endBitPosition);
        endBitPosition = m_types_.value().initializeOffsetsPacked(endBitPosition);
    }
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_buffers_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t ObstacleGeometryLayer::initializeOffsets(ObstacleGeometryLayer::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getCoordShiftXY().bitSizeOf<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(m_coordShiftXY_);
    endBitPosition += context.getCoordShiftZ().bitSizeOf<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(m_coordShiftZ_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getNumElements().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numElements_);
    if (getHasIds())
    {
        endBitPosition = m_identifier_.value().initializeOffsets(*this, endBitPosition);
    }
    if (getHasTypes())
    {
        endBitPosition = ::zserio::alignTo(8, endBitPosition);
        endBitPosition = m_types_.value().initializeOffsetsPacked(endBitPosition);
    }
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_buffers_.initializeOffsets(context.getBuffers(), endBitPosition);

    return endBitPosition;
}

bool ObstacleGeometryLayer::operator==(const ObstacleGeometryLayer& other) const
{
    if (this != &other)
    {
        return
                (getType() == other.getType()) &&
                (getHasIds() == other.getHasIds()) &&
                (getHasTypes() == other.getHasTypes()) &&
                (m_coordShiftXY_ == other.m_coordShiftXY_) &&
                (m_coordShiftZ_ == other.m_coordShiftZ_) &&
                (m_numElements_ == other.m_numElements_) &&
                (!isIdentifierUsed() ? !other.isIdentifierUsed() : (m_identifier_ == other.m_identifier_)) &&
                (!isTypesUsed() ? !other.isTypesUsed() : (m_types_ == other.m_types_)) &&
                (m_buffers_ == other.m_buffers_);
    }

    return true;
}

uint32_t ObstacleGeometryLayer::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getType());
    result = ::zserio::calcHashCode(result, getHasIds());
    result = ::zserio::calcHashCode(result, getHasTypes());
    result = ::zserio::calcHashCode(result, m_coordShiftXY_);
    result = ::zserio::calcHashCode(result, m_coordShiftZ_);
    result = ::zserio::calcHashCode(result, m_numElements_);
    if (isIdentifierUsed())
        result = ::zserio::calcHashCode(result, m_identifier_);
    if (isTypesUsed())
        result = ::zserio::calcHashCode(result, m_types_);
    result = ::zserio::calcHashCode(result, m_buffers_);

    return result;
}

void ObstacleGeometryLayer::write(::zserio::BitStreamWriter& out) const
{
    out.writeBits(m_coordShiftXY_, UINT8_C(5));

    out.writeBits(m_coordShiftZ_, UINT8_C(5));

    out.alignTo(8);
    out.writeVarSize(m_numElements_);

    if (getHasIds())
    {
        // check array length
        if (m_identifier_.value().getRawArray().size() != static_cast<size_t>(getNumElements()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field ObstacleGeometryLayer.identifier: ") <<
                    m_identifier_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumElements()) << "!";
        }
        m_identifier_.value().write(*this, out);
    }

    if (getHasTypes())
    {
        out.alignTo(8);
        // check array length
        if (m_types_.value().getRawArray().size() != static_cast<size_t>(getNumElements()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field ObstacleGeometryLayer.types: ") <<
                    m_types_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumElements()) << "!";
        }
        m_types_.value().writePacked(out);
    }

    out.alignTo(8);
    // check parameters
    if (m_buffers_.getType() != static_cast<::nds::core::geometry::GeometryLayerType>(getType()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field ObstacleGeometryLayer.buffers: ") <<
                m_buffers_.getType() << " != " << static_cast<::nds::core::geometry::GeometryLayerType>(getType()) << "!";
    }
    if (m_buffers_.getShiftXY() != static_cast<::nds::core::geometry::CoordShift>(getCoordShiftXY()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shiftXY for field ObstacleGeometryLayer.buffers: ") <<
                m_buffers_.getShiftXY() << " != " << static_cast<::nds::core::geometry::CoordShift>(getCoordShiftXY()) << "!";
    }
    if (m_buffers_.getShiftZ() != static_cast<::nds::core::geometry::CoordShift>(getCoordShiftZ()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shiftZ for field ObstacleGeometryLayer.buffers: ") <<
                m_buffers_.getShiftZ() << " != " << static_cast<::nds::core::geometry::CoordShift>(getCoordShiftZ()) << "!";
    }
    if (m_buffers_.getNumElements() != static_cast<uint32_t>(getNumElements()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numElements for field ObstacleGeometryLayer.buffers: ") <<
                m_buffers_.getNumElements() << " != " << static_cast<uint32_t>(getNumElements()) << "!";
    }
    m_buffers_.write(out);
}

void ObstacleGeometryLayer::write(ObstacleGeometryLayer::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getCoordShiftXY().write<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(out, m_coordShiftXY_);

    context.getCoordShiftZ().write<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(out, m_coordShiftZ_);

    out.alignTo(8);
    context.getNumElements().write<::zserio::VarSizeArrayTraits>(out, m_numElements_);

    if (getHasIds())
    {
        // check array length
        if (m_identifier_.value().getRawArray().size() != static_cast<size_t>(getNumElements()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field ObstacleGeometryLayer.identifier: ") <<
                    m_identifier_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumElements()) << "!";
        }
        m_identifier_.value().write(*this, out);
    }

    if (getHasTypes())
    {
        out.alignTo(8);
        // check array length
        if (m_types_.value().getRawArray().size() != static_cast<size_t>(getNumElements()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field ObstacleGeometryLayer.types: ") <<
                    m_types_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumElements()) << "!";
        }
        m_types_.value().writePacked(out);
    }

    out.alignTo(8);
    // check parameters
    if (m_buffers_.getType() != static_cast<::nds::core::geometry::GeometryLayerType>(getType()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field ObstacleGeometryLayer.buffers: ") <<
                m_buffers_.getType() << " != " << static_cast<::nds::core::geometry::GeometryLayerType>(getType()) << "!";
    }
    if (m_buffers_.getShiftXY() != static_cast<::nds::core::geometry::CoordShift>(getCoordShiftXY()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shiftXY for field ObstacleGeometryLayer.buffers: ") <<
                m_buffers_.getShiftXY() << " != " << static_cast<::nds::core::geometry::CoordShift>(getCoordShiftXY()) << "!";
    }
    if (m_buffers_.getShiftZ() != static_cast<::nds::core::geometry::CoordShift>(getCoordShiftZ()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shiftZ for field ObstacleGeometryLayer.buffers: ") <<
                m_buffers_.getShiftZ() << " != " << static_cast<::nds::core::geometry::CoordShift>(getCoordShiftZ()) << "!";
    }
    if (m_buffers_.getNumElements() != static_cast<uint32_t>(getNumElements()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numElements for field ObstacleGeometryLayer.buffers: ") <<
                m_buffers_.getNumElements() << " != " << static_cast<uint32_t>(getNumElements()) << "!";
    }
    m_buffers_.write(context.getBuffers(), out);
}

void ObstacleGeometryLayer::ZserioElementFactory_identifier::create(ObstacleGeometryLayer&        ,
        ::zserio::vector<::nds::core::geometry::GeometryId>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

::nds::core::geometry::CoordShift ObstacleGeometryLayer::readCoordShiftXY(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::geometry::CoordShift>(in.readBits(UINT8_C(5)));
}

::nds::core::geometry::CoordShift ObstacleGeometryLayer::readCoordShiftXY(ObstacleGeometryLayer::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getCoordShiftXY().read<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(in);
}
::nds::core::geometry::CoordShift ObstacleGeometryLayer::readCoordShiftZ(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::geometry::CoordShift>(in.readBits(UINT8_C(5)));
}

::nds::core::geometry::CoordShift ObstacleGeometryLayer::readCoordShiftZ(ObstacleGeometryLayer::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getCoordShiftZ().read<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(in);
}
uint32_t ObstacleGeometryLayer::readNumElements(::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t ObstacleGeometryLayer::readNumElements(ObstacleGeometryLayer::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return context.getNumElements().read<::zserio::VarSizeArrayTraits>(in);
}
::zserio::InplaceOptionalHolder<ObstacleGeometryLayer::ZserioArrayType_identifier> ObstacleGeometryLayer::readIdentifier(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getHasIds())
    {
        ZserioArrayType_identifier readField(allocator);
        readField.read(*this, in, static_cast<size_t>(getNumElements()));

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_identifier>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_identifier>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<ObstacleGeometryLayer::ZserioArrayType_types> ObstacleGeometryLayer::readTypes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getHasTypes())
    {
        in.alignTo(8);
        ZserioArrayType_types readField(allocator);
        readField.readPacked(in, static_cast<size_t>(getNumElements()));

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_types>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_types>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<ObstacleGeometryLayer::ZserioArrayType_types> ObstacleGeometryLayer::readTypes(ObstacleGeometryLayer::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getHasTypes())
    {
        in.alignTo(8);
        ZserioArrayType_types readField(allocator);
        readField.readPacked(in, static_cast<size_t>(getNumElements()));

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_types>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_types>(::zserio::NullOpt);
}
::nds::core::geometry::Buffers ObstacleGeometryLayer::readBuffers(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    return ::nds::core::geometry::Buffers(in, static_cast<::nds::core::geometry::GeometryLayerType>(getType()), static_cast<::nds::core::geometry::CoordShift>(getCoordShiftXY()), static_cast<::nds::core::geometry::CoordShift>(getCoordShiftZ()), static_cast<uint32_t>(getNumElements()), allocator);
}

::nds::core::geometry::Buffers ObstacleGeometryLayer::readBuffers(ObstacleGeometryLayer::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    return ::nds::core::geometry::Buffers(context.getBuffers(), in, static_cast<::nds::core::geometry::GeometryLayerType>(getType()), static_cast<::nds::core::geometry::CoordShift>(getCoordShiftXY()), static_cast<::nds::core::geometry::CoordShift>(getCoordShiftZ()), static_cast<uint32_t>(getNumElements()), allocator);
}

} // namespace instantiations
} // namespace localization
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/localization/instantiations/LandmarkLineGeometryLayer.h>

namespace nds
{
namespace localization
{
namespace instantiations
{

LandmarkLineGeometryLayer::LandmarkLineGeometryLayer(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_coordShiftXY_(::nds::core::geometry::CoordShift()),
        m_coordShiftZ_(::nds::core::geometry::CoordShift()),
        m_numElements_(uint32_t()),
        m_identifier_(::zserio::NullOpt),
        m_types_(::zserio::NullOpt),
        m_buffers_(allocator)
{
}

LandmarkLineGeometryLayer::LandmarkLineGeometryLayer(::zserio::BitStreamReader& in,
        ::nds::core::geometry::GeometryLayerType type_,
        bool hasIds_,
        bool hasTypes_, const allocator_type& allocator) :
        m_type_(type_),
        m_hasIds_(hasIds_),
        m_hasTypes_(hasTypes_),
        m_isInitialized(true),
        m_coordShiftXY_(readCoordShiftXY(in)),
        m_coordShiftZ_(readCoordShiftZ(in)),
        m_numElements_(readNumElements(in)),
        m_identifier_(readIdentifier(in, allocator)),
        m_types_(readTypes(in, allocator)),
        m_buffers_(readBuffers(in, allocator))
{
}

LandmarkLineGeometryLayer::LandmarkLineGeometryLayer(LandmarkLineGeometryLayer::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::GeometryLayerType type_,
        bool hasIds_,
        bool hasTypes_, const allocator_type& allocator) :
        m_type_(type_),
        m_hasIds_(hasIds_),
        m_hasTypes_(hasTypes_),
        m_isInitialized(true),
        m_coordShiftXY_(readCoordShiftXY(context, in)),
        m_coordShiftZ_(readCoordShiftZ(context, in)),
        m_numElements_(readNumElements(context, in)),
        m_identifier_(readIdentifier(context, in, allocator)),
        m_types_(readTypes(context, in, allocator)),
        m_buffers_(readBuffers(context, in, allocator))
{
}

LandmarkLineGeometryLayer::LandmarkLineGeometryLayer(const LandmarkLineGeometryLayer& other) :
        m_coordShiftXY_(other.m_coordShiftXY_),
        m_coordShiftZ_(other.m_coordShiftZ_),
        m_numElements_(other.m_numElements_),
        m_identifier_(other.m_identifier_),
        m_types_(other.m_types_),
        m_buffers_(other.m_buffers_)
{
    if (other.m_isInitialized)
        initialize(other.m_type_, other.m_hasIds_, other.m_hasTypes_);
    else
        m_isInitialized = false;
}

LandmarkLineGeometryLayer& LandmarkLineGeometryLayer::operator=(const LandmarkLineGeometryLayer& other)
{
    m_coordShiftXY_ = other.m_coordShiftXY_;
    m_coordShiftZ_ = other.m_coordShiftZ_;
    m_numElements_ = other.m_numElements_;
    m_identifier_ = other.m_identifier_;
    m_types_ = other.m_types_;
    m_buffers_ = other.m_buffers_;
    if (other.m_isInitialized)
        initialize(other.m_type_, other.m_hasIds_, other.m_hasTypes_);
    else
        m_isInitialized = false;

    return *this;
}

LandmarkLineGeometryLayer::LandmarkLineGeometryLayer(LandmarkLineGeometryLayer&& other) :
        m_coordShiftXY_(::std::move(other.m_coordShiftXY_)),
        m_coordShiftZ_(::std::move(other.m_coordShiftZ_)),
        m_numElements_(::std::move(other.m_numElements_)),
        m_identifier_(::std::move(other.m_identifier_)),
        m_types_(::std::move(other.m_types_)),
        m_buffers_(::std::move(other.m_buffers_))
{
    if (other.m_isInitialized)
        initialize(other.m_type_, other.m_hasIds_, other.m_hasTypes_);
    else
        m_isInitialized = false;
}

LandmarkLineGeometryLayer& LandmarkLineGeometryLayer::operator=(LandmarkLineGeometryLayer&& other)
{
    m_coordShiftXY_ = ::std::move(other.m_coordShiftXY_);
    m_coordShiftZ_ = ::std::move(other.m_coordShiftZ_);
    m_numElements_ = ::std::move(other.m_numElements_);
    m_identifier_ = ::std::move(other.m_identifier_);
    m_types_ = ::std::move(other.m_types_);
    m_buffers_ = ::std::move(other.m_buffers_);
    if (other.m_isInitialized)
        initialize(other.m_type_, other.m_hasIds_, other.m_hasTypes_);
    else
        m_isInitialized = false;

    return *this;
}

LandmarkLineGeometryLayer::LandmarkLineGeometryLayer(::zserio::PropagateAllocatorT,
        const LandmarkLineGeometryLayer& other, const allocator_type& allocator) :
        m_coordShiftXY_(::zserio::allocatorPropagatingCopy(other.m_coordShiftXY_, allocator)),
        m_coordShiftZ_(::zserio::allocatorPropagatingCopy(other.m_coordShiftZ_, allocator)),
        m_numElements_(::zserio::allocatorPropagatingCopy(other.m_numElements_, allocator)),
        m_identifier_(::zserio::allocatorPropagatingCopy(other.m_identifier_, allocator)),
        m_types_(::zserio::allocatorPropagatingCopy(other.m_types_, allocator)),
        m_buffers_(::zserio::allocatorPropagatingCopy(other.m_buffers_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_type_, other.m_hasIds_, other.m_hasTypes_);
    else
        m_isInitialized = false;
}

void LandmarkLineGeometryLayer::initialize(
        ::nds::core::geometry::GeometryLayerType type_,
        bool hasIds_,
        bool hasTypes_)
{
    m_type_ = type_;
    m_hasIds_ = hasIds_;
    m_hasTypes_ = hasTypes_;
    m_isInitialized = true;

    initializeChildren();
}

bool LandmarkLineGeometryLayer::isInitialized() const
{
    return m_isInitialized;
}

void LandmarkLineGeometryLayer::initializeChildren()
{
    m_buffers_.initialize(static_cast<::nds::core::geometry::GeometryLayerType>(getType()), static_cast<::nds::core::geometry::CoordShift>(getCoordShiftXY()), static_cast<::nds::core::geometry::CoordShift>(getCoordShiftZ()), static_cast<uint32_t>(getNumElements()));
}

::nds::core::geometry::GeometryLayerType LandmarkLineGeometryLayer::getType() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'type' of compound 'LandmarkLineGeometryLayer' is not initialized!");

    return m_type_;
}

bool LandmarkLineGeometryLayer::getHasIds() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'hasIds' of compound 'LandmarkLineGeometryLayer' is not initialized!");

    return m_hasIds_;
}

bool LandmarkLineGeometryLayer::getHasTypes() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'hasTypes' of compound 'LandmarkLineGeometryLayer' is not initialized!");

    return m_hasTypes_;
}

::nds::core::geometry::CoordShift LandmarkLineGeometryLayer::getCoordShiftXY() const
{
    return m_coordShiftXY_;
}

void LandmarkLineGeometryLayer::setCoordShiftXY(::nds::core::geometry::CoordShift coordShiftXY_)
{
    m_coordShiftXY_ = coordShiftXY_;
}

::nds::core::geometry::CoordShift LandmarkLineGeometryLayer::getCoordShiftZ() const
{
    return m_coordShiftZ_;
}

void LandmarkLineGeometryLayer::setCoordShiftZ(::nds::core::geometry::CoordShift coordShiftZ_)
{
    m_coordShiftZ_ = coordShiftZ_;
}

uint32_t LandmarkLineGeometryLayer::getNumElements() const
{
    return m_numElements_;
}

void LandmarkLineGeometryLayer::setNumElements(uint32_t numElements_)
{
    m_numElements_ = numElements_;
}

::zserio::vector<::nds::localization::types::LandmarkId>& LandmarkLineGeometryLayer::getIdentifier()
{
    return m_identifier_.value().getRawArray();
}

const ::zserio::vector<::nds::localization::types::LandmarkId>& LandmarkLineGeometryLayer::getIdentifier() const
{
    return m_identifier_.value().getRawArray();
}

void LandmarkLineGeometryLayer::setIdentifier(const ::zserio::vector<::nds::localization::types::LandmarkId>& identifier_)
{
    m_identifier_ = ZserioArrayType_identifier(identifier_);
}

void LandmarkLineGeometryLayer::setIdentifier(::zserio::vector<::nds::localization::types::LandmarkId>&& identifier_)
{
    m_identifier_ = ZserioArrayType_identifier(std::move(identifier_));
}

bool LandmarkLineGeometryLayer::isIdentifierUsed() const
{
    return (getHasIds());
}

bool LandmarkLineGeometryLayer::isIdentifierSet() const
{
    return m_identifier_.hasValue();
}

void LandmarkLineGeometryLayer::resetIdentifier()
{
    m_identifier_.reset();
}

::zserio::vector<::nds::localization::types::LandmarkLine>& LandmarkLineGeometryLayer::getTypes()
{
    return m_types_.value().getRawArray();
}

const ::zserio::vector<::nds::localization::types::LandmarkLine>& LandmarkLineGeometryLayer::getTypes() const
{
    return m_types_.value().getRawArray();
}

void LandmarkLineGeometryLayer::setTypes(const ::zserio::vector<::nds::localization::types::LandmarkLine>& types_)
{
    m_types_ = ZserioArrayType_types(types_);
}

void LandmarkLineGeometryLayer::setTypes(::zserio::vector<::nds::localization::types::LandmarkLine>&& types_)
{
    m_types_ = ZserioArrayType_types(std::move(types_));
}

bool LandmarkLineGeometryLayer::isTypesUsed() const
{
    return (getHasTypes());
}

bool LandmarkLineGeometryLayer::isTypesSet() const
{
    return m_types_.hasValue();
}

void LandmarkLineGeometryLayer::resetTypes()
{
    m_types_.reset();
}

::nds::core::geometry::Buffers& LandmarkLineGeometryLayer::getBuffers()
{
    return m_buffers_;
}

const ::nds::core::geometry::Buffers& LandmarkLineGeometryLayer::getBuffers() const
{
    return m_buffers_;
}

void LandmarkLineGeometryLayer::setBuffers(const ::nds::core::geometry::Buffers& buffers_)
{
    m_buffers_ = buffers_;
}

void LandmarkLineGeometryLayer::setBuffers(::nds::core::geometry::Buffers&& buffers_)
{
    m_buffers_ = ::std::move(buffers_);
}

void LandmarkLineGeometryLayer::initPackingContext(LandmarkLineGeometryLayer::ZserioPackingContext& context) const
{
    context.getCoordShiftXY().init<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(m_coordShiftXY_);
    context.getCoordShiftZ().init<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(m_coordShiftZ_);
    context.getNumElements().init<::zserio::VarSizeArrayTraits>(m_numElements_);
    m_buffers_.initPackingContext(context.getBuffers());
}

size_t LandmarkLineGeometryLayer::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(5);
    endBitPosition += UINT8_C(5);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_numElements_);
    if (getHasIds())
    {
        endBitPosition += m_identifier_.value().bitSizeOfPacked(endBitPosition);
    }
    if (getHasTypes())
    {
        endBitPosition = ::zserio::alignTo(8, endBitPosition);
        endBitPosition += m_types_.value().bitSizeOfPacked(*this, endBitPosition);
    }
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_buffers_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LandmarkLineGeometryLayer::bitSizeOf(LandmarkLineGeometryLayer::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getCoordShiftXY().bitSizeOf<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(m_coordShiftXY_);
    endBitPosition += context.getCoordShiftZ().bitSizeOf<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(m_coordShiftZ_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getNumElements().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numElements_);
    if (getHasIds())
    {
        endBitPosition += m_identifier_.value().bitSizeOfPacked(endBitPosition);
    }
    if (getHasTypes())
    {
        endBitPosition = ::zserio::alignTo(8, endBitPosition);
        endBitPosition += m_types_.value().bitSizeOfPacked(*this, endBitPosition);
    }
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_buffers_.bitSizeOf(context.getBuffers(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LandmarkLineGeometryLayer::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(5);
    endBitPosition += UINT8_C(5);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_numElements_);
    if (getHasIds())
    {
        endBitPosition = m_identifier_.value().initializeOffsetsPacked(endBitPosition);
    }
    if (getHasTypes())
    {
        endBitPosition = ::zserio::alignTo(8, endBitPosition);
        endBitPosition = m_types_.value().initializeOffsetsPacked(*this, endBitPosition);
    }
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_buffers_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t LandmarkLineGeometryLayer::initializeOffsets(LandmarkLineGeometryLayer::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getCoordShiftXY().bitSizeOf<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(m_coordShiftXY_);
    endBitPosition += context.getCoordShiftZ().bitSizeOf<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(m_coordShiftZ_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getNumElements().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numElements_);
    if (getHasIds())
    {
        endBitPosition = m_identifier_.value().initializeOffsetsPacked(endBitPosition);
    }
    if (getHasTypes())
    {
        endBitPosition = ::zserio::alignTo(8, endBitPosition);
        endBitPosition = m_types_.value().initializeOffsetsPacked(*this, endBitPosition);
    }
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_buffers_.initializeOffsets(context.getBuffers(), endBitPosition);

    return endBitPosition;
}

bool LandmarkLineGeometryLayer::operator==(const LandmarkLineGeometryLayer& other) const
{
    if (this != &other)
    {
        return
                (getType() == other.getType()) &&
                (getHasIds() == other.getHasIds()) &&
                (getHasTypes() == other.getHasTypes()) &&
                (m_coordShiftXY_ == other.m_coordShiftXY_) &&
                (m_coordShiftZ_ == other.m_coordShiftZ_) &&
                (m_numElements_ == other.m_numElements_) &&
                (!isIdentifierUsed() ? !other.isIdentifierUsed() : (m_identifier_ == other.m_identifier_)) &&
                (!isTypesUsed() ? !other.isTypesUsed() : (m_types_ == other.m_types_)) &&
                (m_buffers_ == other.m_buffers_);
    }

    return true;
}

uint32_t LandmarkLineGeometryLayer::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getType());
    result = ::zserio::calcHashCode(result, getHasIds());
    result = ::zserio::calcHashCode(result, getHasTypes());
    result = ::zserio::calcHashCode(result, m_coordShiftXY_);
    result = ::zserio::calcHashCode(result, m_coordShiftZ_);
    result = ::zserio::calcHashCode(result, m_numElements_);
    if (isIdentifierUsed())
        result = ::zserio::calcHashCode(result, m_identifier_);
    if (isTypesUsed())
        result = ::zserio::calcHashCode(result, m_types_);
    result = ::zserio::calcHashCode(result, m_buffers_);

    return result;
}

void LandmarkLineGeometryLayer::write(::zserio::BitStreamWriter& out) const
{
    out.writeBits(m_coordShiftXY_, UINT8_C(5));

    out.writeBits(m_coordShiftZ_, UINT8_C(5));

    out.alignTo(8);
    out.writeVarSize(m_numElements_);

    if (getHasIds())
    {
        // check array length
        if (m_identifier_.value().getRawArray().size() != static_cast<size_t>(getNumElements()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field LandmarkLineGeometryLayer.identifier: ") <<
                    m_identifier_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumElements()) << "!";
        }
        m_identifier_.value().writePacked(out);
    }

    if (getHasTypes())
    {
        out.alignTo(8);
        // check array length
        if (m_types_.value().getRawArray().size() != static_cast<size_t>(getNumElements()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field LandmarkLineGeometryLayer.types: ") <<
                    m_types_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumElements()) << "!";
        }
        m_types_.value().writePacked(*this, out);
    }

    out.alignTo(8);
    // check parameters
    if (m_buffers_.getType() != static_cast<::nds::core::geometry::GeometryLayerType>(getType()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field LandmarkLineGeometryLayer.buffers: ") <<
                m_buffers_.getType() << " != " << static_cast<::nds::core::geometry::GeometryLayerType>(getType()) << "!";
    }
    if (m_buffers_.getShiftXY() != static_cast<::nds::core::geometry::CoordShift>(getCoordShiftXY()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shiftXY for field LandmarkLineGeometryLayer.buffers: ") <<
                m_buffers_.getShiftXY() << " != " << static_cast<::nds::core::geometry::CoordShift>(getCoordShiftXY()) << "!";
    }
    if (m_buffers_.getShiftZ() != static_cast<::nds::core::geometry::CoordShift>(getCoordShiftZ()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shiftZ for field LandmarkLineGeometryLayer.buffers: ") <<
                m_buffers_.getShiftZ() << " != " << static_cast<::nds::core::geometry::CoordShift>(getCoordShiftZ()) << "!";
    }
    if (m_buffers_.getNumElements() != static_cast<uint32_t>(getNumElements()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numElements for field LandmarkLineGeometryLayer.buffers: ") <<
                m_buffers_.getNumElements() << " != " << static_cast<uint32_t>(getNumElements()) << "!";
    }
    m_buffers_.write(out);
}

void LandmarkLineGeometryLayer::write(LandmarkLineGeometryLayer::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getCoordShiftXY().write<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(out, m_coordShiftXY_);

    context.getCoordShiftZ().write<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(out, m_coordShiftZ_);

    out.alignTo(8);
    context.getNumElements().write<::zserio::VarSizeArrayTraits>(out, m_numElements_);

    if (getHasIds())
    {
        // check array length
        if (m_identifier_.value().getRawArray().size() != static_cast<size_t>(getNumElements()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field LandmarkLineGeometryLayer.identifier: ") <<
                    m_identifier_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumElements()) << "!";
        }
        m_identifier_.value().writePacked(out);
    }

    if (getHasTypes())
    {
        out.alignTo(8);
        // check array length
        if (m_types_.value().getRawArray().size() != static_cast<size_t>(getNumElements()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field LandmarkLineGeometryLayer.types: ") <<
                    m_types_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumElements()) << "!";
        }
        m_types_.value().writePacked(*this, out);
    }

    out.alignTo(8);
    // check parameters
    if (m_buffers_.getType() != static_cast<::nds::core::geometry::GeometryLayerType>(getType()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field LandmarkLineGeometryLayer.buffers: ") <<
                m_buffers_.getType() << " != " << static_cast<::nds::core::geometry::GeometryLayerType>(getType()) << "!";
    }
    if (m_buffers_.getShiftXY() != static_cast<::nds::core::geometry::CoordShift>(getCoordShiftXY()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shiftXY for field LandmarkLineGeometryLayer.buffers: ") <<
                m_buffers_.getShiftXY() << " != " << static_cast<::nds::core::geometry::CoordShift>(getCoordShiftXY()) << "!";
    }
    if (m_buffers_.getShiftZ() != static_cast<::nds::core::geometry::CoordShift>(getCoordShiftZ()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shiftZ for field LandmarkLineGeometryLayer.buffers: ") <<
                m_buffers_.getShiftZ() << " != " << static_cast<::nds::core::geometry::CoordShift>(getCoordShiftZ()) << "!";
    }
    if (m_buffers_.getNumElements() != static_cast<uint32_t>(getNumElements()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numElements for field LandmarkLineGeometryLayer.buffers: ") <<
                m_buffers_.getNumElements() << " != " << static_cast<uint32_t>(getNumElements()) << "!";
    }
    m_buffers_.write(context.getBuffers(), out);
}

void LandmarkLineGeometryLayer::ZserioElementFactory_types::create(LandmarkLineGeometryLayer&        ,
        ::zserio::vector<::nds::localization::types::LandmarkLine>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void LandmarkLineGeometryLayer::ZserioElementFactory_types::create(LandmarkLineGeometryLayer&        ,
        ::zserio::vector<::nds::localization::types::LandmarkLine>& array,
        ::nds::localization::types::LandmarkLine::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::core::geometry::CoordShift LandmarkLineGeometryLayer::readCoordShiftXY(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::geometry::CoordShift>(in.readBits(UINT8_C(5)));
}

::nds::core::geometry::CoordShift LandmarkLineGeometryLayer::readCoordShiftXY(LandmarkLineGeometryLayer::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getCoordShiftXY().read<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(in);
}
::nds::core::geometry::CoordShift LandmarkLineGeometryLayer::readCoordShiftZ(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::geometry::CoordShift>(in.readBits(UINT8_C(5)));
}

::nds::core::geometry::CoordShift LandmarkLineGeometryLayer::readCoordShiftZ(LandmarkLineGeometryLayer::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getCoordShiftZ().read<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(in);
}
uint32_t LandmarkLineGeometryLayer::readNumElements(::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t LandmarkLineGeometryLayer::readNumElements(LandmarkLineGeometryLayer::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return context.getNumElements().read<::zserio::VarSizeArrayTraits>(in);
}
::zserio::InplaceOptionalHolder<LandmarkLineGeometryLayer::ZserioArrayType_identifier> LandmarkLineGeometryLayer::readIdentifier(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getHasIds())
    {
        ZserioArrayType_identifier readField(allocator);
        readField.readPacked(in, static_cast<size_t>(getNumElements()));

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_identifier>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_identifier>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<LandmarkLineGeometryLayer::ZserioArrayType_identifier> LandmarkLineGeometryLayer::readIdentifier(LandmarkLineGeometryLayer::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getHasIds())
    {
        ZserioArrayType_identifier readField(allocator);
        readField.readPacked(in, static_cast<size_t>(getNumElements()));

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_identifier>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_identifier>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<LandmarkLineGeometryLayer::ZserioArrayType_types> LandmarkLineGeometryLayer::readTypes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getHasTypes())
    {
        in.alignTo(8);
        ZserioArrayType_types readField(allocator);
        readField.readPacked(*this, in, static_cast<size_t>(getNumElements()));

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_types>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_types>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<LandmarkLineGeometryLayer::ZserioArrayType_types> LandmarkLineGeometryLayer::readTypes(LandmarkLineGeometryLayer::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getHasTypes())
    {
        in.alignTo(8);
        ZserioArrayType_types readField(allocator);
        readField.readPacked(*this, in, static_cast<size_t>(getNumElements()));

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_types>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_types>(::zserio::NullOpt);
}
::nds::core::geometry::Buffers LandmarkLineGeometryLayer::readBuffers(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    return ::nds::core::geometry::Buffers(in, static_cast<::nds::core::geometry::GeometryLayerType>(getType()), static_cast<::nds::core::geometry::CoordShift>(getCoordShiftXY()), static_cast<::nds::core::geometry::CoordShift>(getCoordShiftZ()), static_cast<uint32_t>(getNumElements()), allocator);
}

::nds::core::geometry::Buffers LandmarkLineGeometryLayer::readBuffers(LandmarkLineGeometryLayer::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    return ::nds::core::geometry::Buffers(context.getBuffers(), in, static_cast<::nds::core::geometry::GeometryLayerType>(getType()), static_cast<::nds::core::geometry::CoordShift>(getCoordShiftXY()), static_cast<::nds::core::geometry::CoordShift>(getCoordShiftZ()), static_cast<uint32_t>(getNumElements()), allocator);
}

} // namespace instantiations
} // namespace localization
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/localization/instantiations/LandmarkPolygonGeometryLayer.h>

namespace nds
{
namespace localization
{
namespace instantiations
{

LandmarkPolygonGeometryLayer::LandmarkPolygonGeometryLayer(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_coordShiftXY_(::nds::core::geometry::CoordShift()),
        m_coordShiftZ_(::nds::core::geometry::CoordShift()),
        m_numElements_(uint32_t()),
        m_identifier_(::zserio::NullOpt),
        m_types_(::zserio::NullOpt),
        m_buffers_(allocator)
{
}

LandmarkPolygonGeometryLayer::LandmarkPolygonGeometryLayer(::zserio::BitStreamReader& in,
        ::nds::core::geometry::GeometryLayerType type_,
        bool hasIds_,
        bool hasTypes_, const allocator_type& allocator) :
        m_type_(type_),
        m_hasIds_(hasIds_),
        m_hasTypes_(hasTypes_),
        m_isInitialized(true),
        m_coordShiftXY_(readCoordShiftXY(in)),
        m_coordShiftZ_(readCoordShiftZ(in)),
        m_numElements_(readNumElements(in)),
        m_identifier_(readIdentifier(in, allocator)),
        m_types_(readTypes(in, allocator)),
        m_buffers_(readBuffers(in, allocator))
{
}

LandmarkPolygonGeometryLayer::LandmarkPolygonGeometryLayer(LandmarkPolygonGeometryLayer::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::GeometryLayerType type_,
        bool hasIds_,
        bool hasTypes_, const allocator_type& allocator) :
        m_type_(type_),
        m_hasIds_(hasIds_),
        m_hasTypes_(hasTypes_),
        m_isInitialized(true),
        m_coordShiftXY_(readCoordShiftXY(context, in)),
        m_coordShiftZ_(readCoordShiftZ(context, in)),
        m_numElements_(readNumElements(context, in)),
        m_identifier_(readIdentifier(context, in, allocator)),
        m_types_(readTypes(context, in, allocator)),
        m_buffers_(readBuffers(context, in, allocator))
{
}

LandmarkPolygonGeometryLayer::LandmarkPolygonGeometryLayer(const LandmarkPolygonGeometryLayer& other) :
        m_coordShiftXY_(other.m_coordShiftXY_),
        m_coordShiftZ_(other.m_coordShiftZ_),
        m_numElements_(other.m_numElements_),
        m_identifier_(other.m_identifier_),
        m_types_(other.m_types_),
        m_buffers_(other.m_buffers_)
{
    if (other.m_isInitialized)
        initialize(other.m_type_, other.m_hasIds_, other.m_hasTypes_);
    else
        m_isInitialized = false;
}

LandmarkPolygonGeometryLayer& LandmarkPolygonGeometryLayer::operator=(const LandmarkPolygonGeometryLayer& other)
{
    m_coordShiftXY_ = other.m_coordShiftXY_;
    m_coordShiftZ_ = other.m_coordShiftZ_;
    m_numElements_ = other.m_numElements_;
    m_identifier_ = other.m_identifier_;
    m_types_ = other.m_types_;
    m_buffers_ = other.m_buffers_;
    if (other.m_isInitialized)
        initialize(other.m_type_, other.m_hasIds_, other.m_hasTypes_);
    else
        m_isInitialized = false;

    return *this;
}

LandmarkPolygonGeometryLayer::LandmarkPolygonGeometryLayer(LandmarkPolygonGeometryLayer&& other) :
        m_coordShiftXY_(::std::move(other.m_coordShiftXY_)),
        m_coordShiftZ_(::std::move(other.m_coordShiftZ_)),
        m_numElements_(::std::move(other.m_numElements_)),
        m_identifier_(::std::move(other.m_identifier_)),
        m_types_(::std::move(other.m_types_)),
        m_buffers_(::std::move(other.m_buffers_))
{
    if (other.m_isInitialized)
        initialize(other.m_type_, other.m_hasIds_, other.m_hasTypes_);
    else
        m_isInitialized = false;
}

LandmarkPolygonGeometryLayer& LandmarkPolygonGeometryLayer::operator=(LandmarkPolygonGeometryLayer&& other)
{
    m_coordShiftXY_ = ::std::move(other.m_coordShiftXY_);
    m_coordShiftZ_ = ::std::move(other.m_coordShiftZ_);
    m_numElements_ = ::std::move(other.m_numElements_);
    m_identifier_ = ::std::move(other.m_identifier_);
    m_types_ = ::std::move(other.m_types_);
    m_buffers_ = ::std::move(other.m_buffers_);
    if (other.m_isInitialized)
        initialize(other.m_type_, other.m_hasIds_, other.m_hasTypes_);
    else
        m_isInitialized = false;

    return *this;
}

LandmarkPolygonGeometryLayer::LandmarkPolygonGeometryLayer(::zserio::PropagateAllocatorT,
        const LandmarkPolygonGeometryLayer& other, const allocator_type& allocator) :
        m_coordShiftXY_(::zserio::allocatorPropagatingCopy(other.m_coordShiftXY_, allocator)),
        m_coordShiftZ_(::zserio::allocatorPropagatingCopy(other.m_coordShiftZ_, allocator)),
        m_numElements_(::zserio::allocatorPropagatingCopy(other.m_numElements_, allocator)),
        m_identifier_(::zserio::allocatorPropagatingCopy(other.m_identifier_, allocator)),
        m_types_(::zserio::allocatorPropagatingCopy(other.m_types_, allocator)),
        m_buffers_(::zserio::allocatorPropagatingCopy(other.m_buffers_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_type_, other.m_hasIds_, other.m_hasTypes_);
    else
        m_isInitialized = false;
}

void LandmarkPolygonGeometryLayer::initialize(
        ::nds::core::geometry::GeometryLayerType type_,
        bool hasIds_,
        bool hasTypes_)
{
    m_type_ = type_;
    m_hasIds_ = hasIds_;
    m_hasTypes_ = hasTypes_;
    m_isInitialized = true;

    initializeChildren();
}

bool LandmarkPolygonGeometryLayer::isInitialized() const
{
    return m_isInitialized;
}

void LandmarkPolygonGeometryLayer::initializeChildren()
{
    m_buffers_.initialize(static_cast<::nds::core::geometry::GeometryLayerType>(getType()), static_cast<::nds::core::geometry::CoordShift>(getCoordShiftXY()), static_cast<::nds::core::geometry::CoordShift>(getCoordShiftZ()), static_cast<uint32_t>(getNumElements()));
}

::nds::core::geometry::GeometryLayerType LandmarkPolygonGeometryLayer::getType() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'type' of compound 'LandmarkPolygonGeometryLayer' is not initialized!");

    return m_type_;
}

bool LandmarkPolygonGeometryLayer::getHasIds() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'hasIds' of compound 'LandmarkPolygonGeometryLayer' is not initialized!");

    return m_hasIds_;
}

bool LandmarkPolygonGeometryLayer::getHasTypes() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'hasTypes' of compound 'LandmarkPolygonGeometryLayer' is not initialized!");

    return m_hasTypes_;
}

::nds::core::geometry::CoordShift LandmarkPolygonGeometryLayer::getCoordShiftXY() const
{
    return m_coordShiftXY_;
}

void LandmarkPolygonGeometryLayer::setCoordShiftXY(::nds::core::geometry::CoordShift coordShiftXY_)
{
    m_coordShiftXY_ = coordShiftXY_;
}

::nds::core::geometry::CoordShift LandmarkPolygonGeometryLayer::getCoordShiftZ() const
{
    return m_coordShiftZ_;
}

void LandmarkPolygonGeometryLayer::setCoordShiftZ(::nds::core::geometry::CoordShift coordShiftZ_)
{
    m_coordShiftZ_ = coordShiftZ_;
}

uint32_t LandmarkPolygonGeometryLayer::getNumElements() const
{
    return m_numElements_;
}

void LandmarkPolygonGeometryLayer::setNumElements(uint32_t numElements_)
{
    m_numElements_ = numElements_;
}

::zserio::vector<::nds::localization::types::LandmarkId>& LandmarkPolygonGeometryLayer::getIdentifier()
{
    return m_identifier_.value().getRawArray();
}

const ::zserio::vector<::nds::localization::types::LandmarkId>& LandmarkPolygonGeometryLayer::getIdentifier() const
{
    return m_identifier_.value().getRawArray();
}

void LandmarkPolygonGeometryLayer::setIdentifier(const ::zserio::vector<::nds::localization::types::LandmarkId>& identifier_)
{
    m_identifier_ = ZserioArrayType_identifier(identifier_);
}

void LandmarkPolygonGeometryLayer::setIdentifier(::zserio::vector<::nds::localization::types::LandmarkId>&& identifier_)
{
    m_identifier_ = ZserioArrayType_identifier(std::move(identifier_));
}

bool LandmarkPolygonGeometryLayer::isIdentifierUsed() const
{
    return (getHasIds());
}

bool LandmarkPolygonGeometryLayer::isIdentifierSet() const
{
    return m_identifier_.hasValue();
}

void LandmarkPolygonGeometryLayer::resetIdentifier()
{
    m_identifier_.reset();
}

::zserio::vector<::nds::localization::types::LandmarkPolygon>& LandmarkPolygonGeometryLayer::getTypes()
{
    return m_types_.value().getRawArray();
}

const ::zserio::vector<::nds::localization::types::LandmarkPolygon>& LandmarkPolygonGeometryLayer::getTypes() const
{
    return m_types_.value().getRawArray();
}

void LandmarkPolygonGeometryLayer::setTypes(const ::zserio::vector<::nds::localization::types::LandmarkPolygon>& types_)
{
    m_types_ = ZserioArrayType_types(types_);
}

void LandmarkPolygonGeometryLayer::setTypes(::zserio::vector<::nds::localization::types::LandmarkPolygon>&& types_)
{
    m_types_ = ZserioArrayType_types(std::move(types_));
}

bool LandmarkPolygonGeometryLayer::isTypesUsed() const
{
    return (getHasTypes());
}

bool LandmarkPolygonGeometryLayer::isTypesSet() const
{
    return m_types_.hasValue();
}

void LandmarkPolygonGeometryLayer::resetTypes()
{
    m_types_.reset();
}

::nds::core::geometry::Buffers& LandmarkPolygonGeometryLayer::getBuffers()
{
    return m_buffers_;
}

const ::nds::core::geometry::Buffers& LandmarkPolygonGeometryLayer::getBuffers() const
{
    return m_buffers_;
}

void LandmarkPolygonGeometryLayer::setBuffers(const ::nds::core::geometry::Buffers& buffers_)
{
    m_buffers_ = buffers_;
}

void LandmarkPolygonGeometryLayer::setBuffers(::nds::core::geometry::Buffers&& buffers_)
{
    m_buffers_ = ::std::move(buffers_);
}

void LandmarkPolygonGeometryLayer::initPackingContext(LandmarkPolygonGeometryLayer::ZserioPackingContext& context) const
{
    context.getCoordShiftXY().init<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(m_coordShiftXY_);
    context.getCoordShiftZ().init<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(m_coordShiftZ_);
    context.getNumElements().init<::zserio::VarSizeArrayTraits>(m_numElements_);
    m_buffers_.initPackingContext(context.getBuffers());
}

size_t LandmarkPolygonGeometryLayer::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(5);
    endBitPosition += UINT8_C(5);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_numElements_);
    if (getHasIds())
    {
        endBitPosition += m_identifier_.value().bitSizeOfPacked(endBitPosition);
    }
    if (getHasTypes())
    {
        endBitPosition = ::zserio::alignTo(8, endBitPosition);
        endBitPosition += m_types_.value().bitSizeOfPacked(*this, endBitPosition);
    }
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_buffers_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LandmarkPolygonGeometryLayer::bitSizeOf(LandmarkPolygonGeometryLayer::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getCoordShiftXY().bitSizeOf<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(m_coordShiftXY_);
    endBitPosition += context.getCoordShiftZ().bitSizeOf<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(m_coordShiftZ_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getNumElements().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numElements_);
    if (getHasIds())
    {
        endBitPosition += m_identifier_.value().bitSizeOfPacked(endBitPosition);
    }
    if (getHasTypes())
    {
        endBitPosition = ::zserio::alignTo(8, endBitPosition);
        endBitPosition += m_types_.value().bitSizeOfPacked(*this, endBitPosition);
    }
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_buffers_.bitSizeOf(context.getBuffers(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LandmarkPolygonGeometryLayer::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(5);
    endBitPosition += UINT8_C(5);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_numElements_);
    if (getHasIds())
    {
        endBitPosition = m_identifier_.value().initializeOffsetsPacked(endBitPosition);
    }
    if (getHasTypes())
    {
        endBitPosition = ::zserio::alignTo(8, endBitPosition);
        endBitPosition = m_types_.value().initializeOffsetsPacked(*this, endBitPosition);
    }
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_buffers_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t LandmarkPolygonGeometryLayer::initializeOffsets(LandmarkPolygonGeometryLayer::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getCoordShiftXY().bitSizeOf<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(m_coordShiftXY_);
    endBitPosition += context.getCoordShiftZ().bitSizeOf<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(m_coordShiftZ_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getNumElements().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numElements_);
    if (getHasIds())
    {
        endBitPosition = m_identifier_.value().initializeOffsetsPacked(endBitPosition);
    }
    if (getHasTypes())
    {
        endBitPosition = ::zserio::alignTo(8, endBitPosition);
        endBitPosition = m_types_.value().initializeOffsetsPacked(*this, endBitPosition);
    }
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_buffers_.initializeOffsets(context.getBuffers(), endBitPosition);

    return endBitPosition;
}

bool LandmarkPolygonGeometryLayer::operator==(const LandmarkPolygonGeometryLayer& other) const
{
    if (this != &other)
    {
        return
                (getType() == other.getType()) &&
                (getHasIds() == other.getHasIds()) &&
                (getHasTypes() == other.getHasTypes()) &&
                (m_coordShiftXY_ == other.m_coordShiftXY_) &&
                (m_coordShiftZ_ == other.m_coordShiftZ_) &&
                (m_numElements_ == other.m_numElements_) &&
                (!isIdentifierUsed() ? !other.isIdentifierUsed() : (m_identifier_ == other.m_identifier_)) &&
                (!isTypesUsed() ? !other.isTypesUsed() : (m_types_ == other.m_types_)) &&
                (m_buffers_ == other.m_buffers_);
    }

    return true;
}

uint32_t LandmarkPolygonGeometryLayer::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getType());
    result = ::zserio::calcHashCode(result, getHasIds());
    result = ::zserio::calcHashCode(result, getHasTypes());
    result = ::zserio::calcHashCode(result, m_coordShiftXY_);
    result = ::zserio::calcHashCode(result, m_coordShiftZ_);
    result = ::zserio::calcHashCode(result, m_numElements_);
    if (isIdentifierUsed())
        result = ::zserio::calcHashCode(result, m_identifier_);
    if (isTypesUsed())
        result = ::zserio::calcHashCode(result, m_types_);
    result = ::zserio::calcHashCode(result, m_buffers_);

    return result;
}

void LandmarkPolygonGeometryLayer::write(::zserio::BitStreamWriter& out) const
{
    out.writeBits(m_coordShiftXY_, UINT8_C(5));

    out.writeBits(m_coordShiftZ_, UINT8_C(5));

    out.alignTo(8);
    out.writeVarSize(m_numElements_);

    if (getHasIds())
    {
        // check array length
        if (m_identifier_.value().getRawArray().size() != static_cast<size_t>(getNumElements()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field LandmarkPolygonGeometryLayer.identifier: ") <<
                    m_identifier_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumElements()) << "!";
        }
        m_identifier_.value().writePacked(out);
    }

    if (getHasTypes())
    {
        out.alignTo(8);
        // check array length
        if (m_types_.value().getRawArray().size() != static_cast<size_t>(getNumElements()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field LandmarkPolygonGeometryLayer.types: ") <<
                    m_types_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumElements()) << "!";
        }
        m_types_.value().writePacked(*this, out);
    }

    out.alignTo(8);
    // check parameters
    if (m_buffers_.getType() != static_cast<::nds::core::geometry::GeometryLayerType>(getType()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field LandmarkPolygonGeometryLayer.buffers: ") <<
                m_buffers_.getType() << " != " << static_cast<::nds::core::geometry::GeometryLayerType>(getType()) << "!";
    }
    if (m_buffers_.getShiftXY() != static_cast<::nds::core::geometry::CoordShift>(getCoordShiftXY()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shiftXY for field LandmarkPolygonGeometryLayer.buffers: ") <<
                m_buffers_.getShiftXY() << " != " << static_cast<::nds::core::geometry::CoordShift>(getCoordShiftXY()) << "!";
    }
    if (m_buffers_.getShiftZ() != static_cast<::nds::core::geometry::CoordShift>(getCoordShiftZ()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shiftZ for field LandmarkPolygonGeometryLayer.buffers: ") <<
                m_buffers_.getShiftZ() << " != " << static_cast<::nds::core::geometry::CoordShift>(getCoordShiftZ()) << "!";
    }
    if (m_buffers_.getNumElements() != static_cast<uint32_t>(getNumElements()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numElements for field LandmarkPolygonGeometryLayer.buffers: ") <<
                m_buffers_.getNumElements() << " != " << static_cast<uint32_t>(getNumElements()) << "!";
    }
    m_buffers_.write(out);
}

void LandmarkPolygonGeometryLayer::write(LandmarkPolygonGeometryLayer::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getCoordShiftXY().write<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(out, m_coordShiftXY_);

    context.getCoordShiftZ().write<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(out, m_coordShiftZ_);

    out.alignTo(8);
    context.getNumElements().write<::zserio::VarSizeArrayTraits>(out, m_numElements_);

    if (getHasIds())
    {
        // check array length
        if (m_identifier_.value().getRawArray().size() != static_cast<size_t>(getNumElements()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field LandmarkPolygonGeometryLayer.identifier: ") <<
                    m_identifier_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumElements()) << "!";
        }
        m_identifier_.value().writePacked(out);
    }

    if (getHasTypes())
    {
        out.alignTo(8);
        // check array length
        if (m_types_.value().getRawArray().size() != static_cast<size_t>(getNumElements()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field LandmarkPolygonGeometryLayer.types: ") <<
                    m_types_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumElements()) << "!";
        }
        m_types_.value().writePacked(*this, out);
    }

    out.alignTo(8);
    // check parameters
    if (m_buffers_.getType() != static_cast<::nds::core::geometry::GeometryLayerType>(getType()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field LandmarkPolygonGeometryLayer.buffers: ") <<
                m_buffers_.getType() << " != " << static_cast<::nds::core::geometry::GeometryLayerType>(getType()) << "!";
    }
    if (m_buffers_.getShiftXY() != static_cast<::nds::core::geometry::CoordShift>(getCoordShiftXY()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shiftXY for field LandmarkPolygonGeometryLayer.buffers: ") <<
                m_buffers_.getShiftXY() << " != " << static_cast<::nds::core::geometry::CoordShift>(getCoordShiftXY()) << "!";
    }
    if (m_buffers_.getShiftZ() != static_cast<::nds::core::geometry::CoordShift>(getCoordShiftZ()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shiftZ for field LandmarkPolygonGeometryLayer.buffers: ") <<
                m_buffers_.getShiftZ() << " != " << static_cast<::nds::core::geometry::CoordShift>(getCoordShiftZ()) << "!";
    }
    if (m_buffers_.getNumElements() != static_cast<uint32_t>(getNumElements()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numElements for field LandmarkPolygonGeometryLayer.buffers: ") <<
                m_buffers_.getNumElements() << " != " << static_cast<uint32_t>(getNumElements()) << "!";
    }
    m_buffers_.write(context.getBuffers(), out);
}

void LandmarkPolygonGeometryLayer::ZserioElementFactory_types::create(LandmarkPolygonGeometryLayer&        ,
        ::zserio::vector<::nds::localization::types::LandmarkPolygon>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void LandmarkPolygonGeometryLayer::ZserioElementFactory_types::create(LandmarkPolygonGeometryLayer&        ,
        ::zserio::vector<::nds::localization::types::LandmarkPolygon>& array,
        ::nds::localization::types::LandmarkPolygon::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::core::geometry::CoordShift LandmarkPolygonGeometryLayer::readCoordShiftXY(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::geometry::CoordShift>(in.readBits(UINT8_C(5)));
}

::nds::core::geometry::CoordShift LandmarkPolygonGeometryLayer::readCoordShiftXY(LandmarkPolygonGeometryLayer::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getCoordShiftXY().read<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(in);
}
::nds::core::geometry::CoordShift LandmarkPolygonGeometryLayer::readCoordShiftZ(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::geometry::CoordShift>(in.readBits(UINT8_C(5)));
}

::nds::core::geometry::CoordShift LandmarkPolygonGeometryLayer::readCoordShiftZ(LandmarkPolygonGeometryLayer::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getCoordShiftZ().read<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(in);
}
uint32_t LandmarkPolygonGeometryLayer::readNumElements(::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t LandmarkPolygonGeometryLayer::readNumElements(LandmarkPolygonGeometryLayer::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return context.getNumElements().read<::zserio::VarSizeArrayTraits>(in);
}
::zserio::InplaceOptionalHolder<LandmarkPolygonGeometryLayer::ZserioArrayType_identifier> LandmarkPolygonGeometryLayer::readIdentifier(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getHasIds())
    {
        ZserioArrayType_identifier readField(allocator);
        readField.readPacked(in, static_cast<size_t>(getNumElements()));

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_identifier>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_identifier>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<LandmarkPolygonGeometryLayer::ZserioArrayType_identifier> LandmarkPolygonGeometryLayer::readIdentifier(LandmarkPolygonGeometryLayer::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getHasIds())
    {
        ZserioArrayType_identifier readField(allocator);
        readField.readPacked(in, static_cast<size_t>(getNumElements()));

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_identifier>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_identifier>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<LandmarkPolygonGeometryLayer::ZserioArrayType_types> LandmarkPolygonGeometryLayer::readTypes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getHasTypes())
    {
        in.alignTo(8);
        ZserioArrayType_types readField(allocator);
        readField.readPacked(*this, in, static_cast<size_t>(getNumElements()));

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_types>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_types>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<LandmarkPolygonGeometryLayer::ZserioArrayType_types> LandmarkPolygonGeometryLayer::readTypes(LandmarkPolygonGeometryLayer::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getHasTypes())
    {
        in.alignTo(8);
        ZserioArrayType_types readField(allocator);
        readField.readPacked(*this, in, static_cast<size_t>(getNumElements()));

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_types>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_types>(::zserio::NullOpt);
}
::nds::core::geometry::Buffers LandmarkPolygonGeometryLayer::readBuffers(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    return ::nds::core::geometry::Buffers(in, static_cast<::nds::core::geometry::GeometryLayerType>(getType()), static_cast<::nds::core::geometry::CoordShift>(getCoordShiftXY()), static_cast<::nds::core::geometry::CoordShift>(getCoordShiftZ()), static_cast<uint32_t>(getNumElements()), allocator);
}

::nds::core::geometry::Buffers LandmarkPolygonGeometryLayer::readBuffers(LandmarkPolygonGeometryLayer::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    return ::nds::core::geometry::Buffers(context.getBuffers(), in, static_cast<::nds::core::geometry::GeometryLayerType>(getType()), static_cast<::nds::core::geometry::CoordShift>(getCoordShiftXY()), static_cast<::nds::core::geometry::CoordShift>(getCoordShiftZ()), static_cast<uint32_t>(getNumElements()), allocator);
}

} // namespace instantiations
} // namespace localization
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/localization/instantiations/LandmarkMeshGeometryLayer.h>

namespace nds
{
namespace localization
{
namespace instantiations
{

LandmarkMeshGeometryLayer::LandmarkMeshGeometryLayer(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_coordShiftXY_(::nds::core::geometry::CoordShift()),
        m_coordShiftZ_(::nds::core::geometry::CoordShift()),
        m_numElements_(uint32_t()),
        m_identifier_(::zserio::NullOpt),
        m_types_(::zserio::NullOpt),
        m_buffers_(allocator)
{
}

LandmarkMeshGeometryLayer::LandmarkMeshGeometryLayer(::zserio::BitStreamReader& in,
        ::nds::core::geometry::GeometryLayerType type_,
        bool hasIds_,
        bool hasTypes_, const allocator_type& allocator) :
        m_type_(type_),
        m_hasIds_(hasIds_),
        m_hasTypes_(hasTypes_),
        m_isInitialized(true),
        m_coordShiftXY_(readCoordShiftXY(in)),
        m_coordShiftZ_(readCoordShiftZ(in)),
        m_numElements_(readNumElements(in)),
        m_identifier_(readIdentifier(in, allocator)),
        m_types_(readTypes(in, allocator)),
        m_buffers_(readBuffers(in, allocator))
{
}

LandmarkMeshGeometryLayer::LandmarkMeshGeometryLayer(LandmarkMeshGeometryLayer::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::GeometryLayerType type_,
        bool hasIds_,
        bool hasTypes_, const allocator_type& allocator) :
        m_type_(type_),
        m_hasIds_(hasIds_),
        m_hasTypes_(hasTypes_),
        m_isInitialized(true),
        m_coordShiftXY_(readCoordShiftXY(context, in)),
        m_coordShiftZ_(readCoordShiftZ(context, in)),
        m_numElements_(readNumElements(context, in)),
        m_identifier_(readIdentifier(context, in, allocator)),
        m_types_(readTypes(context, in, allocator)),
        m_buffers_(readBuffers(context, in, allocator))
{
}

LandmarkMeshGeometryLayer::LandmarkMeshGeometryLayer(const LandmarkMeshGeometryLayer& other) :
        m_coordShiftXY_(other.m_coordShiftXY_),
        m_coordShiftZ_(other.m_coordShiftZ_),
        m_numElements_(other.m_numElements_),
        m_identifier_(other.m_identifier_),
        m_types_(other.m_types_),
        m_buffers_(other.m_buffers_)
{
    if (other.m_isInitialized)
        initialize(other.m_type_, other.m_hasIds_, other.m_hasTypes_);
    else
        m_isInitialized = false;
}

LandmarkMeshGeometryLayer& LandmarkMeshGeometryLayer::operator=(const LandmarkMeshGeometryLayer& other)
{
    m_coordShiftXY_ = other.m_coordShiftXY_;
    m_coordShiftZ_ = other.m_coordShiftZ_;
    m_numElements_ = other.m_numElements_;
    m_identifier_ = other.m_identifier_;
    m_types_ = other.m_types_;
    m_buffers_ = other.m_buffers_;
    if (other.m_isInitialized)
        initialize(other.m_type_, other.m_hasIds_, other.m_hasTypes_);
    else
        m_isInitialized = false;

    return *this;
}

LandmarkMeshGeometryLayer::LandmarkMeshGeometryLayer(LandmarkMeshGeometryLayer&& other) :
        m_coordShiftXY_(::std::move(other.m_coordShiftXY_)),
        m_coordShiftZ_(::std::move(other.m_coordShiftZ_)),
        m_numElements_(::std::move(other.m_numElements_)),
        m_identifier_(::std::move(other.m_identifier_)),
        m_types_(::std::move(other.m_types_)),
        m_buffers_(::std::move(other.m_buffers_))
{
    if (other.m_isInitialized)
        initialize(other.m_type_, other.m_hasIds_, other.m_hasTypes_);
    else
        m_isInitialized = false;
}

LandmarkMeshGeometryLayer& LandmarkMeshGeometryLayer::operator=(LandmarkMeshGeometryLayer&& other)
{
    m_coordShiftXY_ = ::std::move(other.m_coordShiftXY_);
    m_coordShiftZ_ = ::std::move(other.m_coordShiftZ_);
    m_numElements_ = ::std::move(other.m_numElements_);
    m_identifier_ = ::std::move(other.m_identifier_);
    m_types_ = ::std::move(other.m_types_);
    m_buffers_ = ::std::move(other.m_buffers_);
    if (other.m_isInitialized)
        initialize(other.m_type_, other.m_hasIds_, other.m_hasTypes_);
    else
        m_isInitialized = false;

    return *this;
}

LandmarkMeshGeometryLayer::LandmarkMeshGeometryLayer(::zserio::PropagateAllocatorT,
        const LandmarkMeshGeometryLayer& other, const allocator_type& allocator) :
        m_coordShiftXY_(::zserio::allocatorPropagatingCopy(other.m_coordShiftXY_, allocator)),
        m_coordShiftZ_(::zserio::allocatorPropagatingCopy(other.m_coordShiftZ_, allocator)),
        m_numElements_(::zserio::allocatorPropagatingCopy(other.m_numElements_, allocator)),
        m_identifier_(::zserio::allocatorPropagatingCopy(other.m_identifier_, allocator)),
        m_types_(::zserio::allocatorPropagatingCopy(other.m_types_, allocator)),
        m_buffers_(::zserio::allocatorPropagatingCopy(other.m_buffers_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_type_, other.m_hasIds_, other.m_hasTypes_);
    else
        m_isInitialized = false;
}

void LandmarkMeshGeometryLayer::initialize(
        ::nds::core::geometry::GeometryLayerType type_,
        bool hasIds_,
        bool hasTypes_)
{
    m_type_ = type_;
    m_hasIds_ = hasIds_;
    m_hasTypes_ = hasTypes_;
    m_isInitialized = true;

    initializeChildren();
}

bool LandmarkMeshGeometryLayer::isInitialized() const
{
    return m_isInitialized;
}

void LandmarkMeshGeometryLayer::initializeChildren()
{
    m_buffers_.initialize(static_cast<::nds::core::geometry::GeometryLayerType>(getType()), static_cast<::nds::core::geometry::CoordShift>(getCoordShiftXY()), static_cast<::nds::core::geometry::CoordShift>(getCoordShiftZ()), static_cast<uint32_t>(getNumElements()));
}

::nds::core::geometry::GeometryLayerType LandmarkMeshGeometryLayer::getType() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'type' of compound 'LandmarkMeshGeometryLayer' is not initialized!");

    return m_type_;
}

bool LandmarkMeshGeometryLayer::getHasIds() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'hasIds' of compound 'LandmarkMeshGeometryLayer' is not initialized!");

    return m_hasIds_;
}

bool LandmarkMeshGeometryLayer::getHasTypes() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'hasTypes' of compound 'LandmarkMeshGeometryLayer' is not initialized!");

    return m_hasTypes_;
}

::nds::core::geometry::CoordShift LandmarkMeshGeometryLayer::getCoordShiftXY() const
{
    return m_coordShiftXY_;
}

void LandmarkMeshGeometryLayer::setCoordShiftXY(::nds::core::geometry::CoordShift coordShiftXY_)
{
    m_coordShiftXY_ = coordShiftXY_;
}

::nds::core::geometry::CoordShift LandmarkMeshGeometryLayer::getCoordShiftZ() const
{
    return m_coordShiftZ_;
}

void LandmarkMeshGeometryLayer::setCoordShiftZ(::nds::core::geometry::CoordShift coordShiftZ_)
{
    m_coordShiftZ_ = coordShiftZ_;
}

uint32_t LandmarkMeshGeometryLayer::getNumElements() const
{
    return m_numElements_;
}

void LandmarkMeshGeometryLayer::setNumElements(uint32_t numElements_)
{
    m_numElements_ = numElements_;
}

::zserio::vector<::nds::localization::types::LandmarkId>& LandmarkMeshGeometryLayer::getIdentifier()
{
    return m_identifier_.value().getRawArray();
}

const ::zserio::vector<::nds::localization::types::LandmarkId>& LandmarkMeshGeometryLayer::getIdentifier() const
{
    return m_identifier_.value().getRawArray();
}

void LandmarkMeshGeometryLayer::setIdentifier(const ::zserio::vector<::nds::localization::types::LandmarkId>& identifier_)
{
    m_identifier_ = ZserioArrayType_identifier(identifier_);
}

void LandmarkMeshGeometryLayer::setIdentifier(::zserio::vector<::nds::localization::types::LandmarkId>&& identifier_)
{
    m_identifier_ = ZserioArrayType_identifier(std::move(identifier_));
}

bool LandmarkMeshGeometryLayer::isIdentifierUsed() const
{
    return (getHasIds());
}

bool LandmarkMeshGeometryLayer::isIdentifierSet() const
{
    return m_identifier_.hasValue();
}

void LandmarkMeshGeometryLayer::resetIdentifier()
{
    m_identifier_.reset();
}

::zserio::vector<::nds::localization::types::LandmarkMesh>& LandmarkMeshGeometryLayer::getTypes()
{
    return m_types_.value().getRawArray();
}

const ::zserio::vector<::nds::localization::types::LandmarkMesh>& LandmarkMeshGeometryLayer::getTypes() const
{
    return m_types_.value().getRawArray();
}

void LandmarkMeshGeometryLayer::setTypes(const ::zserio::vector<::nds::localization::types::LandmarkMesh>& types_)
{
    m_types_ = ZserioArrayType_types(types_);
}

void LandmarkMeshGeometryLayer::setTypes(::zserio::vector<::nds::localization::types::LandmarkMesh>&& types_)
{
    m_types_ = ZserioArrayType_types(std::move(types_));
}

bool LandmarkMeshGeometryLayer::isTypesUsed() const
{
    return (getHasTypes());
}

bool LandmarkMeshGeometryLayer::isTypesSet() const
{
    return m_types_.hasValue();
}

void LandmarkMeshGeometryLayer::resetTypes()
{
    m_types_.reset();
}

::nds::core::geometry::Buffers& LandmarkMeshGeometryLayer::getBuffers()
{
    return m_buffers_;
}

const ::nds::core::geometry::Buffers& LandmarkMeshGeometryLayer::getBuffers() const
{
    return m_buffers_;
}

void LandmarkMeshGeometryLayer::setBuffers(const ::nds::core::geometry::Buffers& buffers_)
{
    m_buffers_ = buffers_;
}

void LandmarkMeshGeometryLayer::setBuffers(::nds::core::geometry::Buffers&& buffers_)
{
    m_buffers_ = ::std::move(buffers_);
}

void LandmarkMeshGeometryLayer::initPackingContext(LandmarkMeshGeometryLayer::ZserioPackingContext& context) const
{
    context.getCoordShiftXY().init<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(m_coordShiftXY_);
    context.getCoordShiftZ().init<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(m_coordShiftZ_);
    context.getNumElements().init<::zserio::VarSizeArrayTraits>(m_numElements_);
    m_buffers_.initPackingContext(context.getBuffers());
}

size_t LandmarkMeshGeometryLayer::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(5);
    endBitPosition += UINT8_C(5);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_numElements_);
    if (getHasIds())
    {
        endBitPosition += m_identifier_.value().bitSizeOfPacked(endBitPosition);
    }
    if (getHasTypes())
    {
        endBitPosition = ::zserio::alignTo(8, endBitPosition);
        endBitPosition += m_types_.value().bitSizeOfPacked(*this, endBitPosition);
    }
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_buffers_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LandmarkMeshGeometryLayer::bitSizeOf(LandmarkMeshGeometryLayer::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getCoordShiftXY().bitSizeOf<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(m_coordShiftXY_);
    endBitPosition += context.getCoordShiftZ().bitSizeOf<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(m_coordShiftZ_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getNumElements().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numElements_);
    if (getHasIds())
    {
        endBitPosition += m_identifier_.value().bitSizeOfPacked(endBitPosition);
    }
    if (getHasTypes())
    {
        endBitPosition = ::zserio::alignTo(8, endBitPosition);
        endBitPosition += m_types_.value().bitSizeOfPacked(*this, endBitPosition);
    }
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_buffers_.bitSizeOf(context.getBuffers(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LandmarkMeshGeometryLayer::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(5);
    endBitPosition += UINT8_C(5);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_numElements_);
    if (getHasIds())
    {
        endBitPosition = m_identifier_.value().initializeOffsetsPacked(endBitPosition);
    }
    if (getHasTypes())
    {
        endBitPosition = ::zserio::alignTo(8, endBitPosition);
        endBitPosition = m_types_.value().initializeOffsetsPacked(*this, endBitPosition);
    }
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_buffers_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t LandmarkMeshGeometryLayer::initializeOffsets(LandmarkMeshGeometryLayer::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getCoordShiftXY().bitSizeOf<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(m_coordShiftXY_);
    endBitPosition += context.getCoordShiftZ().bitSizeOf<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(m_coordShiftZ_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getNumElements().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numElements_);
    if (getHasIds())
    {
        endBitPosition = m_identifier_.value().initializeOffsetsPacked(endBitPosition);
    }
    if (getHasTypes())
    {
        endBitPosition = ::zserio::alignTo(8, endBitPosition);
        endBitPosition = m_types_.value().initializeOffsetsPacked(*this, endBitPosition);
    }
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_buffers_.initializeOffsets(context.getBuffers(), endBitPosition);

    return endBitPosition;
}

bool LandmarkMeshGeometryLayer::operator==(const LandmarkMeshGeometryLayer& other) const
{
    if (this != &other)
    {
        return
                (getType() == other.getType()) &&
                (getHasIds() == other.getHasIds()) &&
                (getHasTypes() == other.getHasTypes()) &&
                (m_coordShiftXY_ == other.m_coordShiftXY_) &&
                (m_coordShiftZ_ == other.m_coordShiftZ_) &&
                (m_numElements_ == other.m_numElements_) &&
                (!isIdentifierUsed() ? !other.isIdentifierUsed() : (m_identifier_ == other.m_identifier_)) &&
                (!isTypesUsed() ? !other.isTypesUsed() : (m_types_ == other.m_types_)) &&
                (m_buffers_ == other.m_buffers_);
    }

    return true;
}

uint32_t LandmarkMeshGeometryLayer::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getType());
    result = ::zserio::calcHashCode(result, getHasIds());
    result = ::zserio::calcHashCode(result, getHasTypes());
    result = ::zserio::calcHashCode(result, m_coordShiftXY_);
    result = ::zserio::calcHashCode(result, m_coordShiftZ_);
    result = ::zserio::calcHashCode(result, m_numElements_);
    if (isIdentifierUsed())
        result = ::zserio::calcHashCode(result, m_identifier_);
    if (isTypesUsed())
        result = ::zserio::calcHashCode(result, m_types_);
    result = ::zserio::calcHashCode(result, m_buffers_);

    return result;
}

void LandmarkMeshGeometryLayer::write(::zserio::BitStreamWriter& out) const
{
    out.writeBits(m_coordShiftXY_, UINT8_C(5));

    out.writeBits(m_coordShiftZ_, UINT8_C(5));

    out.alignTo(8);
    out.writeVarSize(m_numElements_);

    if (getHasIds())
    {
        // check array length
        if (m_identifier_.value().getRawArray().size() != static_cast<size_t>(getNumElements()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field LandmarkMeshGeometryLayer.identifier: ") <<
                    m_identifier_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumElements()) << "!";
        }
        m_identifier_.value().writePacked(out);
    }

    if (getHasTypes())
    {
        out.alignTo(8);
        // check array length
        if (m_types_.value().getRawArray().size() != static_cast<size_t>(getNumElements()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field LandmarkMeshGeometryLayer.types: ") <<
                    m_types_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumElements()) << "!";
        }
        m_types_.value().writePacked(*this, out);
    }

    out.alignTo(8);
    // check parameters
    if (m_buffers_.getType() != static_cast<::nds::core::geometry::GeometryLayerType>(getType()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field LandmarkMeshGeometryLayer.buffers: ") <<
                m_buffers_.getType() << " != " << static_cast<::nds::core::geometry::GeometryLayerType>(getType()) << "!";
    }
    if (m_buffers_.getShiftXY() != static_cast<::nds::core::geometry::CoordShift>(getCoordShiftXY()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shiftXY for field LandmarkMeshGeometryLayer.buffers: ") <<
                m_buffers_.getShiftXY() << " != " << static_cast<::nds::core::geometry::CoordShift>(getCoordShiftXY()) << "!";
    }
    if (m_buffers_.getShiftZ() != static_cast<::nds::core::geometry::CoordShift>(getCoordShiftZ()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shiftZ for field LandmarkMeshGeometryLayer.buffers: ") <<
                m_buffers_.getShiftZ() << " != " << static_cast<::nds::core::geometry::CoordShift>(getCoordShiftZ()) << "!";
    }
    if (m_buffers_.getNumElements() != static_cast<uint32_t>(getNumElements()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numElements for field LandmarkMeshGeometryLayer.buffers: ") <<
                m_buffers_.getNumElements() << " != " << static_cast<uint32_t>(getNumElements()) << "!";
    }
    m_buffers_.write(out);
}

void LandmarkMeshGeometryLayer::write(LandmarkMeshGeometryLayer::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getCoordShiftXY().write<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(out, m_coordShiftXY_);

    context.getCoordShiftZ().write<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(out, m_coordShiftZ_);

    out.alignTo(8);
    context.getNumElements().write<::zserio::VarSizeArrayTraits>(out, m_numElements_);

    if (getHasIds())
    {
        // check array length
        if (m_identifier_.value().getRawArray().size() != static_cast<size_t>(getNumElements()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field LandmarkMeshGeometryLayer.identifier: ") <<
                    m_identifier_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumElements()) << "!";
        }
        m_identifier_.value().writePacked(out);
    }

    if (getHasTypes())
    {
        out.alignTo(8);
        // check array length
        if (m_types_.value().getRawArray().size() != static_cast<size_t>(getNumElements()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field LandmarkMeshGeometryLayer.types: ") <<
                    m_types_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumElements()) << "!";
        }
        m_types_.value().writePacked(*this, out);
    }

    out.alignTo(8);
    // check parameters
    if (m_buffers_.getType() != static_cast<::nds::core::geometry::GeometryLayerType>(getType()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field LandmarkMeshGeometryLayer.buffers: ") <<
                m_buffers_.getType() << " != " << static_cast<::nds::core::geometry::GeometryLayerType>(getType()) << "!";
    }
    if (m_buffers_.getShiftXY() != static_cast<::nds::core::geometry::CoordShift>(getCoordShiftXY()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shiftXY for field LandmarkMeshGeometryLayer.buffers: ") <<
                m_buffers_.getShiftXY() << " != " << static_cast<::nds::core::geometry::CoordShift>(getCoordShiftXY()) << "!";
    }
    if (m_buffers_.getShiftZ() != static_cast<::nds::core::geometry::CoordShift>(getCoordShiftZ()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shiftZ for field LandmarkMeshGeometryLayer.buffers: ") <<
                m_buffers_.getShiftZ() << " != " << static_cast<::nds::core::geometry::CoordShift>(getCoordShiftZ()) << "!";
    }
    if (m_buffers_.getNumElements() != static_cast<uint32_t>(getNumElements()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numElements for field LandmarkMeshGeometryLayer.buffers: ") <<
                m_buffers_.getNumElements() << " != " << static_cast<uint32_t>(getNumElements()) << "!";
    }
    m_buffers_.write(context.getBuffers(), out);
}

void LandmarkMeshGeometryLayer::ZserioElementFactory_types::create(LandmarkMeshGeometryLayer&        ,
        ::zserio::vector<::nds::localization::types::LandmarkMesh>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void LandmarkMeshGeometryLayer::ZserioElementFactory_types::create(LandmarkMeshGeometryLayer&        ,
        ::zserio::vector<::nds::localization::types::LandmarkMesh>& array,
        ::nds::localization::types::LandmarkMesh::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::core::geometry::CoordShift LandmarkMeshGeometryLayer::readCoordShiftXY(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::geometry::CoordShift>(in.readBits(UINT8_C(5)));
}

::nds::core::geometry::CoordShift LandmarkMeshGeometryLayer::readCoordShiftXY(LandmarkMeshGeometryLayer::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getCoordShiftXY().read<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(in);
}
::nds::core::geometry::CoordShift LandmarkMeshGeometryLayer::readCoordShiftZ(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::geometry::CoordShift>(in.readBits(UINT8_C(5)));
}

::nds::core::geometry::CoordShift LandmarkMeshGeometryLayer::readCoordShiftZ(LandmarkMeshGeometryLayer::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getCoordShiftZ().read<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(in);
}
uint32_t LandmarkMeshGeometryLayer::readNumElements(::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t LandmarkMeshGeometryLayer::readNumElements(LandmarkMeshGeometryLayer::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return context.getNumElements().read<::zserio::VarSizeArrayTraits>(in);
}
::zserio::InplaceOptionalHolder<LandmarkMeshGeometryLayer::ZserioArrayType_identifier> LandmarkMeshGeometryLayer::readIdentifier(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getHasIds())
    {
        ZserioArrayType_identifier readField(allocator);
        readField.readPacked(in, static_cast<size_t>(getNumElements()));

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_identifier>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_identifier>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<LandmarkMeshGeometryLayer::ZserioArrayType_identifier> LandmarkMeshGeometryLayer::readIdentifier(LandmarkMeshGeometryLayer::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getHasIds())
    {
        ZserioArrayType_identifier readField(allocator);
        readField.readPacked(in, static_cast<size_t>(getNumElements()));

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_identifier>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_identifier>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<LandmarkMeshGeometryLayer::ZserioArrayType_types> LandmarkMeshGeometryLayer::readTypes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getHasTypes())
    {
        in.alignTo(8);
        ZserioArrayType_types readField(allocator);
        readField.readPacked(*this, in, static_cast<size_t>(getNumElements()));

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_types>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_types>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<LandmarkMeshGeometryLayer::ZserioArrayType_types> LandmarkMeshGeometryLayer::readTypes(LandmarkMeshGeometryLayer::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getHasTypes())
    {
        in.alignTo(8);
        ZserioArrayType_types readField(allocator);
        readField.readPacked(*this, in, static_cast<size_t>(getNumElements()));

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_types>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_types>(::zserio::NullOpt);
}
::nds::core::geometry::Buffers LandmarkMeshGeometryLayer::readBuffers(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    return ::nds::core::geometry::Buffers(in, static_cast<::nds::core::geometry::GeometryLayerType>(getType()), static_cast<::nds::core::geometry::CoordShift>(getCoordShiftXY()), static_cast<::nds::core::geometry::CoordShift>(getCoordShiftZ()), static_cast<uint32_t>(getNumElements()), allocator);
}

::nds::core::geometry::Buffers LandmarkMeshGeometryLayer::readBuffers(LandmarkMeshGeometryLayer::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    return ::nds::core::geometry::Buffers(context.getBuffers(), in, static_cast<::nds::core::geometry::GeometryLayerType>(getType()), static_cast<::nds::core::geometry::CoordShift>(getCoordShiftXY()), static_cast<::nds::core::geometry::CoordShift>(getCoordShiftZ()), static_cast<uint32_t>(getNumElements()), allocator);
}

} // namespace instantiations
} // namespace localization
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/localization/instantiations/OccupancyProbabilityGridLayer.h>

namespace nds
{
namespace localization
{
namespace instantiations
{

OccupancyProbabilityGridLayer::OccupancyProbabilityGridLayer(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_coordShiftXY_(::nds::core::geometry::CoordShift()),
        m_cellSize_(::nds::core::grid::GridCellSize()),
        m_numElements_(uint32_t()),
        m_identifier_(::zserio::NullOpt),
        m_types_(::zserio::NullOpt),
        m_grids_(allocator)
{
}

OccupancyProbabilityGridLayer::OccupancyProbabilityGridLayer(::zserio::BitStreamReader& in,
        bool hasIds_,
        bool hasTypes_, const allocator_type& allocator) :
        m_hasIds_(hasIds_),
        m_hasTypes_(hasTypes_),
        m_isInitialized(true),
        m_coordShiftXY_(readCoordShiftXY(in)),
        m_cellSize_(readCellSize(in)),
        m_numElements_(readNumElements(in)),
        m_identifier_(readIdentifier(in, allocator)),
        m_types_(readTypes(in, allocator)),
        m_grids_(readGrids(in, allocator))
{
}

OccupancyProbabilityGridLayer::OccupancyProbabilityGridLayer(OccupancyProbabilityGridLayer::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        bool hasIds_,
        bool hasTypes_, const allocator_type& allocator) :
        m_hasIds_(hasIds_),
        m_hasTypes_(hasTypes_),
        m_isInitialized(true),
        m_coordShiftXY_(readCoordShiftXY(context, in)),
        m_cellSize_(readCellSize(context, in)),
        m_numElements_(readNumElements(context, in)),
        m_identifier_(readIdentifier(context, in, allocator)),
        m_types_(readTypes(in, allocator)),
        m_grids_(readGrids(context, in, allocator))
{
}

OccupancyProbabilityGridLayer::OccupancyProbabilityGridLayer(const OccupancyProbabilityGridLayer& other) :
        m_coordShiftXY_(other.m_coordShiftXY_),
        m_cellSize_(other.m_cellSize_),
        m_numElements_(other.m_numElements_),
        m_identifier_(other.m_identifier_),
        m_types_(other.m_types_),
        m_grids_(other.m_grids_)
{
    if (other.m_isInitialized)
        initialize(other.m_hasIds_, other.m_hasTypes_);
    else
        m_isInitialized = false;
}

OccupancyProbabilityGridLayer& OccupancyProbabilityGridLayer::operator=(const OccupancyProbabilityGridLayer& other)
{
    m_coordShiftXY_ = other.m_coordShiftXY_;
    m_cellSize_ = other.m_cellSize_;
    m_numElements_ = other.m_numElements_;
    m_identifier_ = other.m_identifier_;
    m_types_ = other.m_types_;
    m_grids_ = other.m_grids_;
    if (other.m_isInitialized)
        initialize(other.m_hasIds_, other.m_hasTypes_);
    else
        m_isInitialized = false;

    return *this;
}

OccupancyProbabilityGridLayer::OccupancyProbabilityGridLayer(OccupancyProbabilityGridLayer&& other) :
        m_coordShiftXY_(::std::move(other.m_coordShiftXY_)),
        m_cellSize_(::std::move(other.m_cellSize_)),
        m_numElements_(::std::move(other.m_numElements_)),
        m_identifier_(::std::move(other.m_identifier_)),
        m_types_(::std::move(other.m_types_)),
        m_grids_(::std::move(other.m_grids_))
{
    if (other.m_isInitialized)
        initialize(other.m_hasIds_, other.m_hasTypes_);
    else
        m_isInitialized = false;
}

OccupancyProbabilityGridLayer& OccupancyProbabilityGridLayer::operator=(OccupancyProbabilityGridLayer&& other)
{
    m_coordShiftXY_ = ::std::move(other.m_coordShiftXY_);
    m_cellSize_ = ::std::move(other.m_cellSize_);
    m_numElements_ = ::std::move(other.m_numElements_);
    m_identifier_ = ::std::move(other.m_identifier_);
    m_types_ = ::std::move(other.m_types_);
    m_grids_ = ::std::move(other.m_grids_);
    if (other.m_isInitialized)
        initialize(other.m_hasIds_, other.m_hasTypes_);
    else
        m_isInitialized = false;

    return *this;
}

OccupancyProbabilityGridLayer::OccupancyProbabilityGridLayer(::zserio::PropagateAllocatorT,
        const OccupancyProbabilityGridLayer& other, const allocator_type& allocator) :
        m_coordShiftXY_(::zserio::allocatorPropagatingCopy(other.m_coordShiftXY_, allocator)),
        m_cellSize_(::zserio::allocatorPropagatingCopy(other.m_cellSize_, allocator)),
        m_numElements_(::zserio::allocatorPropagatingCopy(other.m_numElements_, allocator)),
        m_identifier_(::zserio::allocatorPropagatingCopy(other.m_identifier_, allocator)),
        m_types_(::zserio::allocatorPropagatingCopy(other.m_types_, allocator)),
        m_grids_(::zserio::allocatorPropagatingCopy(other.m_grids_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_hasIds_, other.m_hasTypes_);
    else
        m_isInitialized = false;
}

void OccupancyProbabilityGridLayer::initialize(
        bool hasIds_,
        bool hasTypes_)
{
    m_hasIds_ = hasIds_;
    m_hasTypes_ = hasTypes_;
    m_isInitialized = true;

    initializeChildren();
}

bool OccupancyProbabilityGridLayer::isInitialized() const
{
    return m_isInitialized;
}

void OccupancyProbabilityGridLayer::initializeChildren()
{
    m_grids_.initializeElements(*this);
}

bool OccupancyProbabilityGridLayer::getHasIds() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'hasIds' of compound 'OccupancyProbabilityGridLayer' is not initialized!");

    return m_hasIds_;
}

bool OccupancyProbabilityGridLayer::getHasTypes() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'hasTypes' of compound 'OccupancyProbabilityGridLayer' is not initialized!");

    return m_hasTypes_;
}

::nds::core::geometry::CoordShift OccupancyProbabilityGridLayer::getCoordShiftXY() const
{
    return m_coordShiftXY_;
}

void OccupancyProbabilityGridLayer::setCoordShiftXY(::nds::core::geometry::CoordShift coordShiftXY_)
{
    m_coordShiftXY_ = coordShiftXY_;
}

::nds::core::grid::GridCellSize OccupancyProbabilityGridLayer::getCellSize() const
{
    return m_cellSize_;
}

void OccupancyProbabilityGridLayer::setCellSize(::nds::core::grid::GridCellSize cellSize_)
{
    m_cellSize_ = cellSize_;
}

uint32_t OccupancyProbabilityGridLayer::getNumElements() const
{
    return m_numElements_;
}

void OccupancyProbabilityGridLayer::setNumElements(uint32_t numElements_)
{
    m_numElements_ = numElements_;
}

::zserio::vector<::nds::localization::types::OccupancyGridId>& OccupancyProbabilityGridLayer::getIdentifier()
{
    return m_identifier_.value().getRawArray();
}

const ::zserio::vector<::nds::localization::types::OccupancyGridId>& OccupancyProbabilityGridLayer::getIdentifier() const
{
    return m_identifier_.value().getRawArray();
}

void OccupancyProbabilityGridLayer::setIdentifier(const ::zserio::vector<::nds::localization::types::OccupancyGridId>& identifier_)
{
    m_identifier_ = ZserioArrayType_identifier(identifier_);
}

void OccupancyProbabilityGridLayer::setIdentifier(::zserio::vector<::nds::localization::types::OccupancyGridId>&& identifier_)
{
    m_identifier_ = ZserioArrayType_identifier(std::move(identifier_));
}

bool OccupancyProbabilityGridLayer::isIdentifierUsed() const
{
    return (getHasIds());
}

bool OccupancyProbabilityGridLayer::isIdentifierSet() const
{
    return m_identifier_.hasValue();
}

void OccupancyProbabilityGridLayer::resetIdentifier()
{
    m_identifier_.reset();
}

::zserio::vector<::nds::core::grid::GridType>& OccupancyProbabilityGridLayer::getTypes()
{
    return m_types_.value().getRawArray();
}

const ::zserio::vector<::nds::core::grid::GridType>& OccupancyProbabilityGridLayer::getTypes() const
{
    return m_types_.value().getRawArray();
}

void OccupancyProbabilityGridLayer::setTypes(const ::zserio::vector<::nds::core::grid::GridType>& types_)
{
    m_types_ = ZserioArrayType_types(types_);
}

void OccupancyProbabilityGridLayer::setTypes(::zserio::vector<::nds::core::grid::GridType>&& types_)
{
    m_types_ = ZserioArrayType_types(std::move(types_));
}

bool OccupancyProbabilityGridLayer::isTypesUsed() const
{
    return (getHasTypes());
}

bool OccupancyProbabilityGridLayer::isTypesSet() const
{
    return m_types_.hasValue();
}

void OccupancyProbabilityGridLayer::resetTypes()
{
    m_types_.reset();
}

::zserio::vector<::nds::core::grid::Grid_OccupancyProbability>& OccupancyProbabilityGridLayer::getGrids()
{
    return m_grids_.getRawArray();
}

const ::zserio::vector<::nds::core::grid::Grid_OccupancyProbability>& OccupancyProbabilityGridLayer::getGrids() const
{
    return m_grids_.getRawArray();
}

void OccupancyProbabilityGridLayer::setGrids(const ::zserio::vector<::nds::core::grid::Grid_OccupancyProbability>& grids_)
{
    m_grids_ = ZserioArrayType_grids(grids_);
}

void OccupancyProbabilityGridLayer::setGrids(::zserio::vector<::nds::core::grid::Grid_OccupancyProbability>&& grids_)
{
    m_grids_ = ZserioArrayType_grids(std::move(grids_));
}

void OccupancyProbabilityGridLayer::initPackingContext(OccupancyProbabilityGridLayer::ZserioPackingContext& context) const
{
    context.getCoordShiftXY().init<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(m_coordShiftXY_);
    context.getCellSize().init<::zserio::VarSizeArrayTraits>(m_cellSize_);
    context.getNumElements().init<::zserio::VarSizeArrayTraits>(m_numElements_);
}

size_t OccupancyProbabilityGridLayer::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(5);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_cellSize_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_numElements_);
    if (getHasIds())
    {
        endBitPosition += m_identifier_.value().bitSizeOfPacked(endBitPosition);
    }
    if (getHasTypes())
    {
        endBitPosition = ::zserio::alignTo(8, endBitPosition);
        endBitPosition += m_types_.value().bitSizeOf(*this, endBitPosition);
    }
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_grids_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t OccupancyProbabilityGridLayer::bitSizeOf(OccupancyProbabilityGridLayer::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getCoordShiftXY().bitSizeOf<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(m_coordShiftXY_);
    endBitPosition += context.getCellSize().bitSizeOf<::zserio::VarSizeArrayTraits>(m_cellSize_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getNumElements().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numElements_);
    if (getHasIds())
    {
        endBitPosition += m_identifier_.value().bitSizeOfPacked(endBitPosition);
    }
    if (getHasTypes())
    {
        endBitPosition = ::zserio::alignTo(8, endBitPosition);
        endBitPosition += m_types_.value().bitSizeOf(*this, endBitPosition);
    }
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_grids_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t OccupancyProbabilityGridLayer::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(5);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_cellSize_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_numElements_);
    if (getHasIds())
    {
        endBitPosition = m_identifier_.value().initializeOffsetsPacked(endBitPosition);
    }
    if (getHasTypes())
    {
        endBitPosition = ::zserio::alignTo(8, endBitPosition);
        endBitPosition = m_types_.value().initializeOffsets(*this, endBitPosition);
    }
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_grids_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t OccupancyProbabilityGridLayer::initializeOffsets(OccupancyProbabilityGridLayer::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getCoordShiftXY().bitSizeOf<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(m_coordShiftXY_);
    endBitPosition += context.getCellSize().bitSizeOf<::zserio::VarSizeArrayTraits>(m_cellSize_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getNumElements().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numElements_);
    if (getHasIds())
    {
        endBitPosition = m_identifier_.value().initializeOffsetsPacked(endBitPosition);
    }
    if (getHasTypes())
    {
        endBitPosition = ::zserio::alignTo(8, endBitPosition);
        endBitPosition = m_types_.value().initializeOffsets(*this, endBitPosition);
    }
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_grids_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool OccupancyProbabilityGridLayer::operator==(const OccupancyProbabilityGridLayer& other) const
{
    if (this != &other)
    {
        return
                (getHasIds() == other.getHasIds()) &&
                (getHasTypes() == other.getHasTypes()) &&
                (m_coordShiftXY_ == other.m_coordShiftXY_) &&
                (m_cellSize_ == other.m_cellSize_) &&
                (m_numElements_ == other.m_numElements_) &&
                (!isIdentifierUsed() ? !other.isIdentifierUsed() : (m_identifier_ == other.m_identifier_)) &&
                (!isTypesUsed() ? !other.isTypesUsed() : (m_types_ == other.m_types_)) &&
                (m_grids_ == other.m_grids_);
    }

    return true;
}

uint32_t OccupancyProbabilityGridLayer::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getHasIds());
    result = ::zserio::calcHashCode(result, getHasTypes());
    result = ::zserio::calcHashCode(result, m_coordShiftXY_);
    result = ::zserio::calcHashCode(result, m_cellSize_);
    result = ::zserio::calcHashCode(result, m_numElements_);
    if (isIdentifierUsed())
        result = ::zserio::calcHashCode(result, m_identifier_);
    if (isTypesUsed())
        result = ::zserio::calcHashCode(result, m_types_);
    result = ::zserio::calcHashCode(result, m_grids_);

    return result;
}

void OccupancyProbabilityGridLayer::write(::zserio::BitStreamWriter& out) const
{
    out.writeBits(m_coordShiftXY_, UINT8_C(5));

    out.writeVarSize(m_cellSize_);

    out.alignTo(8);
    out.writeVarSize(m_numElements_);

    if (getHasIds())
    {
        // check array length
        if (m_identifier_.value().getRawArray().size() != static_cast<size_t>(getNumElements()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field OccupancyProbabilityGridLayer.identifier: ") <<
                    m_identifier_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumElements()) << "!";
        }
        m_identifier_.value().writePacked(out);
    }

    if (getHasTypes())
    {
        out.alignTo(8);
        // check array length
        if (m_types_.value().getRawArray().size() != static_cast<size_t>(getNumElements()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field OccupancyProbabilityGridLayer.types: ") <<
                    m_types_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumElements()) << "!";
        }
        m_types_.value().write(*this, out);
    }

    out.alignTo(8);
    // check array length
    if (m_grids_.getRawArray().size() != static_cast<size_t>(getNumElements()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field OccupancyProbabilityGridLayer.grids: ") <<
                m_grids_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumElements()) << "!";
    }
    m_grids_.writePacked(*this, out);
}

void OccupancyProbabilityGridLayer::write(OccupancyProbabilityGridLayer::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getCoordShiftXY().write<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(out, m_coordShiftXY_);

    context.getCellSize().write<::zserio::VarSizeArrayTraits>(out, m_cellSize_);

    out.alignTo(8);
    context.getNumElements().write<::zserio::VarSizeArrayTraits>(out, m_numElements_);

    if (getHasIds())
    {
        // check array length
        if (m_identifier_.value().getRawArray().size() != static_cast<size_t>(getNumElements()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field OccupancyProbabilityGridLayer.identifier: ") <<
                    m_identifier_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumElements()) << "!";
        }
        m_identifier_.value().writePacked(out);
    }

    if (getHasTypes())
    {
        out.alignTo(8);
        // check array length
        if (m_types_.value().getRawArray().size() != static_cast<size_t>(getNumElements()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field OccupancyProbabilityGridLayer.types: ") <<
                    m_types_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumElements()) << "!";
        }
        m_types_.value().write(*this, out);
    }

    out.alignTo(8);
    // check array length
    if (m_grids_.getRawArray().size() != static_cast<size_t>(getNumElements()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field OccupancyProbabilityGridLayer.grids: ") <<
                m_grids_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumElements()) << "!";
    }
    m_grids_.writePacked(*this, out);
}

void OccupancyProbabilityGridLayer::ZserioElementFactory_types::create(OccupancyProbabilityGridLayer&        ,
        ::zserio::vector<::nds::core::grid::GridType>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void OccupancyProbabilityGridLayer::ZserioArrayExpressions_grids::initializeElement(OccupancyProbabilityGridLayer& owner,
        ::nds::core::grid::Grid_OccupancyProbability& element, size_t)
{
    element.initialize(static_cast<::nds::core::grid::GridCellSize>(owner.getCellSize()), static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShiftXY()));
}

void OccupancyProbabilityGridLayer::ZserioElementFactory_grids::create(OccupancyProbabilityGridLayer&         owner,
        ::zserio::vector<::nds::core::grid::Grid_OccupancyProbability>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::grid::GridCellSize>(owner.getCellSize()), static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShiftXY()), array.get_allocator());
}

void OccupancyProbabilityGridLayer::ZserioElementFactory_grids::create(OccupancyProbabilityGridLayer&         owner,
        ::zserio::vector<::nds::core::grid::Grid_OccupancyProbability>& array,
        ::nds::core::grid::Grid_OccupancyProbability::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::grid::GridCellSize>(owner.getCellSize()), static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShiftXY()), array.get_allocator());
}

::nds::core::geometry::CoordShift OccupancyProbabilityGridLayer::readCoordShiftXY(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::geometry::CoordShift>(in.readBits(UINT8_C(5)));
}

::nds::core::geometry::CoordShift OccupancyProbabilityGridLayer::readCoordShiftXY(OccupancyProbabilityGridLayer::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getCoordShiftXY().read<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordShift, UINT8_C(5)>>(in);
}
::nds::core::grid::GridCellSize OccupancyProbabilityGridLayer::readCellSize(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::grid::GridCellSize>(in.readVarSize());
}

::nds::core::grid::GridCellSize OccupancyProbabilityGridLayer::readCellSize(OccupancyProbabilityGridLayer::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getCellSize().read<::zserio::VarSizeArrayTraits>(in);
}
uint32_t OccupancyProbabilityGridLayer::readNumElements(::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t OccupancyProbabilityGridLayer::readNumElements(OccupancyProbabilityGridLayer::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return context.getNumElements().read<::zserio::VarSizeArrayTraits>(in);
}
::zserio::InplaceOptionalHolder<OccupancyProbabilityGridLayer::ZserioArrayType_identifier> OccupancyProbabilityGridLayer::readIdentifier(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getHasIds())
    {
        ZserioArrayType_identifier readField(allocator);
        readField.readPacked(in, static_cast<size_t>(getNumElements()));

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_identifier>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_identifier>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<OccupancyProbabilityGridLayer::ZserioArrayType_identifier> OccupancyProbabilityGridLayer::readIdentifier(OccupancyProbabilityGridLayer::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getHasIds())
    {
        ZserioArrayType_identifier readField(allocator);
        readField.readPacked(in, static_cast<size_t>(getNumElements()));

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_identifier>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_identifier>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<OccupancyProbabilityGridLayer::ZserioArrayType_types> OccupancyProbabilityGridLayer::readTypes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getHasTypes())
    {
        in.alignTo(8);
        ZserioArrayType_types readField(allocator);
        readField.read(*this, in, static_cast<size_t>(getNumElements()));

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_types>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_types>(::zserio::NullOpt);
}
OccupancyProbabilityGridLayer::ZserioArrayType_grids OccupancyProbabilityGridLayer::readGrids(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_grids readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumElements()));

    return readField;
}

OccupancyProbabilityGridLayer::ZserioArrayType_grids OccupancyProbabilityGridLayer::readGrids(OccupancyProbabilityGridLayer::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_grids readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumElements()));

    return readField;
}

} // namespace instantiations
} // namespace localization
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/localization/instantiations/LandmarkAttributeMetadata.h>

namespace nds
{
namespace localization
{
namespace instantiations
{

LandmarkAttributeMetadata::LandmarkAttributeMetadata(const allocator_type& allocator) noexcept :
        m_availableAttributes_(allocator),
        m_availableProperties_(allocator),
        m_availableConditions_(allocator)
{
}

LandmarkAttributeMetadata::LandmarkAttributeMetadata(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_availableAttributes_(readAvailableAttributes(in, allocator)),
        m_availableProperties_(readAvailableProperties(in, allocator)),
        m_availableConditions_(readAvailableConditions(in, allocator))
{
}

LandmarkAttributeMetadata::LandmarkAttributeMetadata(LandmarkAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_availableAttributes_(readAvailableAttributes(context, in, allocator)),
        m_availableProperties_(readAvailableProperties(context, in, allocator)),
        m_availableConditions_(readAvailableConditions(context, in, allocator))
{
}

LandmarkAttributeMetadata::LandmarkAttributeMetadata(::zserio::PropagateAllocatorT,
        const LandmarkAttributeMetadata& other, const allocator_type& allocator) :
        m_availableAttributes_(::zserio::allocatorPropagatingCopy(other.m_availableAttributes_, allocator)),
        m_availableProperties_(::zserio::allocatorPropagatingCopy(other.m_availableProperties_, allocator)),
        m_availableConditions_(::zserio::allocatorPropagatingCopy(other.m_availableConditions_, allocator))
{
}

::zserio::vector<::nds::localization::attributes::LandmarkRelationAttributeType>& LandmarkAttributeMetadata::getAvailableAttributes()
{
    return m_availableAttributes_.getRawArray();
}

const ::zserio::vector<::nds::localization::attributes::LandmarkRelationAttributeType>& LandmarkAttributeMetadata::getAvailableAttributes() const
{
    return m_availableAttributes_.getRawArray();
}

void LandmarkAttributeMetadata::setAvailableAttributes(const ::zserio::vector<::nds::localization::attributes::LandmarkRelationAttributeType>& availableAttributes_)
{
    m_availableAttributes_ = ZserioArrayType_availableAttributes(availableAttributes_);
}

void LandmarkAttributeMetadata::setAvailableAttributes(::zserio::vector<::nds::localization::attributes::LandmarkRelationAttributeType>&& availableAttributes_)
{
    m_availableAttributes_ = ZserioArrayType_availableAttributes(std::move(availableAttributes_));
}

::zserio::vector<::nds::localization::properties::LocalizationPropertyType>& LandmarkAttributeMetadata::getAvailableProperties()
{
    return m_availableProperties_.getRawArray();
}

const ::zserio::vector<::nds::localization::properties::LocalizationPropertyType>& LandmarkAttributeMetadata::getAvailableProperties() const
{
    return m_availableProperties_.getRawArray();
}

void LandmarkAttributeMetadata::setAvailableProperties(const ::zserio::vector<::nds::localization::properties::LocalizationPropertyType>& availableProperties_)
{
    m_availableProperties_ = ZserioArrayType_availableProperties(availableProperties_);
}

void LandmarkAttributeMetadata::setAvailableProperties(::zserio::vector<::nds::localization::properties::LocalizationPropertyType>&& availableProperties_)
{
    m_availableProperties_ = ZserioArrayType_availableProperties(std::move(availableProperties_));
}

::nds::core::attributemap::ConditionTypeCodeCollection& LandmarkAttributeMetadata::getAvailableConditions()
{
    return m_availableConditions_;
}

const ::nds::core::attributemap::ConditionTypeCodeCollection& LandmarkAttributeMetadata::getAvailableConditions() const
{
    return m_availableConditions_;
}

void LandmarkAttributeMetadata::setAvailableConditions(const ::nds::core::attributemap::ConditionTypeCodeCollection& availableConditions_)
{
    m_availableConditions_ = availableConditions_;
}

void LandmarkAttributeMetadata::setAvailableConditions(::nds::core::attributemap::ConditionTypeCodeCollection&& availableConditions_)
{
    m_availableConditions_ = ::std::move(availableConditions_);
}

void LandmarkAttributeMetadata::initPackingContext(LandmarkAttributeMetadata::ZserioPackingContext& context) const
{
    m_availableConditions_.initPackingContext(context.getAvailableConditions());
}

size_t LandmarkAttributeMetadata::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_availableAttributes_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_availableProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_availableConditions_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LandmarkAttributeMetadata::bitSizeOf(LandmarkAttributeMetadata::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_availableAttributes_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_availableProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_availableConditions_.bitSizeOf(context.getAvailableConditions(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LandmarkAttributeMetadata::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_availableAttributes_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_availableProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_availableConditions_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t LandmarkAttributeMetadata::initializeOffsets(LandmarkAttributeMetadata::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_availableAttributes_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_availableProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_availableConditions_.initializeOffsets(context.getAvailableConditions(), endBitPosition);

    return endBitPosition;
}

bool LandmarkAttributeMetadata::operator==(const LandmarkAttributeMetadata& other) const
{
    if (this != &other)
    {
        return
                (m_availableAttributes_ == other.m_availableAttributes_) &&
                (m_availableProperties_ == other.m_availableProperties_) &&
                (m_availableConditions_ == other.m_availableConditions_);
    }

    return true;
}

uint32_t LandmarkAttributeMetadata::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_availableAttributes_);
    result = ::zserio::calcHashCode(result, m_availableProperties_);
    result = ::zserio::calcHashCode(result, m_availableConditions_);

    return result;
}

void LandmarkAttributeMetadata::write(::zserio::BitStreamWriter& out) const
{
    m_availableAttributes_.writePacked(out);
    m_availableProperties_.writePacked(*this, out);
    m_availableConditions_.write(out);
}

void LandmarkAttributeMetadata::write(LandmarkAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_availableAttributes_.writePacked(out);
    m_availableProperties_.writePacked(*this, out);
    m_availableConditions_.write(context.getAvailableConditions(), out);
}

void LandmarkAttributeMetadata::ZserioElementFactory_availableProperties::create(LandmarkAttributeMetadata&        ,
        ::zserio::vector<::nds::localization::properties::LocalizationPropertyType>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void LandmarkAttributeMetadata::ZserioElementFactory_availableProperties::create(LandmarkAttributeMetadata&        ,
        ::zserio::vector<::nds::localization::properties::LocalizationPropertyType>& array,
        ::nds::localization::properties::LocalizationPropertyType::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

LandmarkAttributeMetadata::ZserioArrayType_availableAttributes LandmarkAttributeMetadata::readAvailableAttributes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_availableAttributes readField(allocator);
    readField.readPacked(in);

    return readField;
}

LandmarkAttributeMetadata::ZserioArrayType_availableAttributes LandmarkAttributeMetadata::readAvailableAttributes(LandmarkAttributeMetadata::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_availableAttributes readField(allocator);
    readField.readPacked(in);

    return readField;
}
LandmarkAttributeMetadata::ZserioArrayType_availableProperties LandmarkAttributeMetadata::readAvailableProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_availableProperties readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}

LandmarkAttributeMetadata::ZserioArrayType_availableProperties LandmarkAttributeMetadata::readAvailableProperties(LandmarkAttributeMetadata::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_availableProperties readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}
::nds::core::attributemap::ConditionTypeCodeCollection LandmarkAttributeMetadata::readAvailableConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::attributemap::ConditionTypeCodeCollection(in, allocator);
}

::nds::core::attributemap::ConditionTypeCodeCollection LandmarkAttributeMetadata::readAvailableConditions(LandmarkAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::attributemap::ConditionTypeCodeCollection(context.getAvailableConditions(), in, allocator);
}

} // namespace instantiations
} // namespace localization
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/localization/instantiations/LandmarkLaneAttributeMapList.h>

namespace nds
{
namespace localization
{
namespace instantiations
{

LandmarkLaneAttributeMapList::LandmarkLaneAttributeMapList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numMaps_(uint32_t()),
        m_header_(allocator),
        m_maps_(allocator)
{
}

LandmarkLaneAttributeMapList::LandmarkLaneAttributeMapList(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(in)),
        m_header_(readHeader(in, allocator)),
        m_maps_(readMaps(in, allocator))
{
}

LandmarkLaneAttributeMapList::LandmarkLaneAttributeMapList(LandmarkLaneAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(context, in)),
        m_header_(readHeader(context, in, allocator)),
        m_maps_(readMaps(context, in, allocator))
{
}

LandmarkLaneAttributeMapList::LandmarkLaneAttributeMapList(const LandmarkLaneAttributeMapList& other) :
        m_numMaps_(other.m_numMaps_),
        m_header_(other.m_header_),
        m_maps_(other.m_maps_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

LandmarkLaneAttributeMapList& LandmarkLaneAttributeMapList::operator=(const LandmarkLaneAttributeMapList& other)
{
    m_numMaps_ = other.m_numMaps_;
    m_header_ = other.m_header_;
    m_maps_ = other.m_maps_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

LandmarkLaneAttributeMapList::LandmarkLaneAttributeMapList(LandmarkLaneAttributeMapList&& other) :
        m_numMaps_(::std::move(other.m_numMaps_)),
        m_header_(::std::move(other.m_header_)),
        m_maps_(::std::move(other.m_maps_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

LandmarkLaneAttributeMapList& LandmarkLaneAttributeMapList::operator=(LandmarkLaneAttributeMapList&& other)
{
    m_numMaps_ = ::std::move(other.m_numMaps_);
    m_header_ = ::std::move(other.m_header_);
    m_maps_ = ::std::move(other.m_maps_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

LandmarkLaneAttributeMapList::LandmarkLaneAttributeMapList(::zserio::PropagateAllocatorT,
        const LandmarkLaneAttributeMapList& other, const allocator_type& allocator) :
        m_numMaps_(::zserio::allocatorPropagatingCopy(other.m_numMaps_, allocator)),
        m_header_(::zserio::allocatorPropagatingCopy(other.m_header_, allocator)),
        m_maps_(::zserio::allocatorPropagatingCopy(other.m_maps_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void LandmarkLaneAttributeMapList::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool LandmarkLaneAttributeMapList::isInitialized() const
{
    return m_isInitialized;
}

void LandmarkLaneAttributeMapList::initializeChildren()
{
    m_header_.initialize(static_cast<uint16_t>(getNumMaps()));
    m_maps_.initializeElements(*this);
}

::nds::core::geometry::CoordShift LandmarkLaneAttributeMapList::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'LandmarkLaneAttributeMapList' is not initialized!");

    return m_coordShift_;
}

uint32_t LandmarkLaneAttributeMapList::getNumMaps() const
{
    return m_numMaps_;
}

void LandmarkLaneAttributeMapList::setNumMaps(uint32_t numMaps_)
{
    m_numMaps_ = numMaps_;
}

::nds::localization::instantiations::LandmarkAttributeMapListHeader& LandmarkLaneAttributeMapList::getHeader()
{
    return m_header_;
}

const ::nds::localization::instantiations::LandmarkAttributeMapListHeader& LandmarkLaneAttributeMapList::getHeader() const
{
    return m_header_;
}

void LandmarkLaneAttributeMapList::setHeader(const ::nds::localization::instantiations::LandmarkAttributeMapListHeader& header_)
{
    m_header_ = header_;
}

void LandmarkLaneAttributeMapList::setHeader(::nds::localization::instantiations::LandmarkAttributeMapListHeader&& header_)
{
    m_header_ = ::std::move(header_);
}

::zserio::vector<::nds::localization::instantiations::LandmarkLaneAttributeMap>& LandmarkLaneAttributeMapList::getMaps()
{
    return m_maps_.getRawArray();
}

const ::zserio::vector<::nds::localization::instantiations::LandmarkLaneAttributeMap>& LandmarkLaneAttributeMapList::getMaps() const
{
    return m_maps_.getRawArray();
}

void LandmarkLaneAttributeMapList::setMaps(const ::zserio::vector<::nds::localization::instantiations::LandmarkLaneAttributeMap>& maps_)
{
    m_maps_ = ZserioArrayType_maps(maps_);
}

void LandmarkLaneAttributeMapList::setMaps(::zserio::vector<::nds::localization::instantiations::LandmarkLaneAttributeMap>&& maps_)
{
    m_maps_ = ZserioArrayType_maps(std::move(maps_));
}

void LandmarkLaneAttributeMapList::initPackingContext(LandmarkLaneAttributeMapList::ZserioPackingContext& context) const
{
    context.getNumMaps().init<::zserio::VarSizeArrayTraits>(m_numMaps_);
    m_header_.initPackingContext(context.getHeader());
}

size_t LandmarkLaneAttributeMapList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LandmarkLaneAttributeMapList::bitSizeOf(LandmarkLaneAttributeMapList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(context.getHeader(), endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LandmarkLaneAttributeMapList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t LandmarkLaneAttributeMapList::initializeOffsets(LandmarkLaneAttributeMapList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(context.getHeader(), endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool LandmarkLaneAttributeMapList::operator==(const LandmarkLaneAttributeMapList& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_numMaps_ == other.m_numMaps_) &&
                (m_header_ == other.m_header_) &&
                (m_maps_ == other.m_maps_);
    }

    return true;
}

uint32_t LandmarkLaneAttributeMapList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_numMaps_);
    result = ::zserio::calcHashCode(result, m_header_);
    result = ::zserio::calcHashCode(result, m_maps_);

    return result;
}

void LandmarkLaneAttributeMapList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field LandmarkLaneAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field LandmarkLaneAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void LandmarkLaneAttributeMapList::write(LandmarkLaneAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumMaps().write<::zserio::VarSizeArrayTraits>(out, m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field LandmarkLaneAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(context.getHeader(), out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field LandmarkLaneAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void LandmarkLaneAttributeMapList::ZserioArrayExpressions_maps::initializeElement(LandmarkLaneAttributeMapList& owner,
        ::nds::localization::instantiations::LandmarkLaneAttributeMap& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void LandmarkLaneAttributeMapList::ZserioElementFactory_maps::create(LandmarkLaneAttributeMapList&         owner,
        ::zserio::vector<::nds::localization::instantiations::LandmarkLaneAttributeMap>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void LandmarkLaneAttributeMapList::ZserioElementFactory_maps::create(LandmarkLaneAttributeMapList&         owner,
        ::zserio::vector<::nds::localization::instantiations::LandmarkLaneAttributeMap>& array,
        ::nds::localization::instantiations::LandmarkLaneAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

uint32_t LandmarkLaneAttributeMapList::readNumMaps(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t LandmarkLaneAttributeMapList::readNumMaps(LandmarkLaneAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumMaps().read<::zserio::VarSizeArrayTraits>(in);
}
::nds::localization::instantiations::LandmarkAttributeMapListHeader LandmarkLaneAttributeMapList::readHeader(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::localization::instantiations::LandmarkAttributeMapListHeader(in, static_cast<uint16_t>(getNumMaps()), allocator);
}

::nds::localization::instantiations::LandmarkAttributeMapListHeader LandmarkLaneAttributeMapList::readHeader(LandmarkLaneAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::localization::instantiations::LandmarkAttributeMapListHeader(context.getHeader(), in, static_cast<uint16_t>(getNumMaps()), allocator);
}
LandmarkLaneAttributeMapList::ZserioArrayType_maps LandmarkLaneAttributeMapList::readMaps(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

LandmarkLaneAttributeMapList::ZserioArrayType_maps LandmarkLaneAttributeMapList::readMaps(LandmarkLaneAttributeMapList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

} // namespace instantiations
} // namespace localization
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/localization/instantiations/LandmarkRoadAttributeMapList.h>

namespace nds
{
namespace localization
{
namespace instantiations
{

LandmarkRoadAttributeMapList::LandmarkRoadAttributeMapList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numMaps_(uint32_t()),
        m_header_(allocator),
        m_maps_(allocator)
{
}

LandmarkRoadAttributeMapList::LandmarkRoadAttributeMapList(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(in)),
        m_header_(readHeader(in, allocator)),
        m_maps_(readMaps(in, allocator))
{
}

LandmarkRoadAttributeMapList::LandmarkRoadAttributeMapList(LandmarkRoadAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(context, in)),
        m_header_(readHeader(context, in, allocator)),
        m_maps_(readMaps(context, in, allocator))
{
}

LandmarkRoadAttributeMapList::LandmarkRoadAttributeMapList(const LandmarkRoadAttributeMapList& other) :
        m_numMaps_(other.m_numMaps_),
        m_header_(other.m_header_),
        m_maps_(other.m_maps_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

LandmarkRoadAttributeMapList& LandmarkRoadAttributeMapList::operator=(const LandmarkRoadAttributeMapList& other)
{
    m_numMaps_ = other.m_numMaps_;
    m_header_ = other.m_header_;
    m_maps_ = other.m_maps_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

LandmarkRoadAttributeMapList::LandmarkRoadAttributeMapList(LandmarkRoadAttributeMapList&& other) :
        m_numMaps_(::std::move(other.m_numMaps_)),
        m_header_(::std::move(other.m_header_)),
        m_maps_(::std::move(other.m_maps_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

LandmarkRoadAttributeMapList& LandmarkRoadAttributeMapList::operator=(LandmarkRoadAttributeMapList&& other)
{
    m_numMaps_ = ::std::move(other.m_numMaps_);
    m_header_ = ::std::move(other.m_header_);
    m_maps_ = ::std::move(other.m_maps_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

LandmarkRoadAttributeMapList::LandmarkRoadAttributeMapList(::zserio::PropagateAllocatorT,
        const LandmarkRoadAttributeMapList& other, const allocator_type& allocator) :
        m_numMaps_(::zserio::allocatorPropagatingCopy(other.m_numMaps_, allocator)),
        m_header_(::zserio::allocatorPropagatingCopy(other.m_header_, allocator)),
        m_maps_(::zserio::allocatorPropagatingCopy(other.m_maps_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void LandmarkRoadAttributeMapList::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool LandmarkRoadAttributeMapList::isInitialized() const
{
    return m_isInitialized;
}

void LandmarkRoadAttributeMapList::initializeChildren()
{
    m_header_.initialize(static_cast<uint16_t>(getNumMaps()));
    m_maps_.initializeElements(*this);
}

::nds::core::geometry::CoordShift LandmarkRoadAttributeMapList::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'LandmarkRoadAttributeMapList' is not initialized!");

    return m_coordShift_;
}

uint32_t LandmarkRoadAttributeMapList::getNumMaps() const
{
    return m_numMaps_;
}

void LandmarkRoadAttributeMapList::setNumMaps(uint32_t numMaps_)
{
    m_numMaps_ = numMaps_;
}

::nds::localization::instantiations::LandmarkAttributeMapListHeader& LandmarkRoadAttributeMapList::getHeader()
{
    return m_header_;
}

const ::nds::localization::instantiations::LandmarkAttributeMapListHeader& LandmarkRoadAttributeMapList::getHeader() const
{
    return m_header_;
}

void LandmarkRoadAttributeMapList::setHeader(const ::nds::localization::instantiations::LandmarkAttributeMapListHeader& header_)
{
    m_header_ = header_;
}

void LandmarkRoadAttributeMapList::setHeader(::nds::localization::instantiations::LandmarkAttributeMapListHeader&& header_)
{
    m_header_ = ::std::move(header_);
}

::zserio::vector<::nds::localization::instantiations::LandmarkRoadAttributeMap>& LandmarkRoadAttributeMapList::getMaps()
{
    return m_maps_.getRawArray();
}

const ::zserio::vector<::nds::localization::instantiations::LandmarkRoadAttributeMap>& LandmarkRoadAttributeMapList::getMaps() const
{
    return m_maps_.getRawArray();
}

void LandmarkRoadAttributeMapList::setMaps(const ::zserio::vector<::nds::localization::instantiations::LandmarkRoadAttributeMap>& maps_)
{
    m_maps_ = ZserioArrayType_maps(maps_);
}

void LandmarkRoadAttributeMapList::setMaps(::zserio::vector<::nds::localization::instantiations::LandmarkRoadAttributeMap>&& maps_)
{
    m_maps_ = ZserioArrayType_maps(std::move(maps_));
}

void LandmarkRoadAttributeMapList::initPackingContext(LandmarkRoadAttributeMapList::ZserioPackingContext& context) const
{
    context.getNumMaps().init<::zserio::VarSizeArrayTraits>(m_numMaps_);
    m_header_.initPackingContext(context.getHeader());
}

size_t LandmarkRoadAttributeMapList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LandmarkRoadAttributeMapList::bitSizeOf(LandmarkRoadAttributeMapList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(context.getHeader(), endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LandmarkRoadAttributeMapList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t LandmarkRoadAttributeMapList::initializeOffsets(LandmarkRoadAttributeMapList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(context.getHeader(), endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool LandmarkRoadAttributeMapList::operator==(const LandmarkRoadAttributeMapList& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_numMaps_ == other.m_numMaps_) &&
                (m_header_ == other.m_header_) &&
                (m_maps_ == other.m_maps_);
    }

    return true;
}

uint32_t LandmarkRoadAttributeMapList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_numMaps_);
    result = ::zserio::calcHashCode(result, m_header_);
    result = ::zserio::calcHashCode(result, m_maps_);

    return result;
}

void LandmarkRoadAttributeMapList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field LandmarkRoadAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field LandmarkRoadAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void LandmarkRoadAttributeMapList::write(LandmarkRoadAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumMaps().write<::zserio::VarSizeArrayTraits>(out, m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field LandmarkRoadAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(context.getHeader(), out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field LandmarkRoadAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void LandmarkRoadAttributeMapList::ZserioArrayExpressions_maps::initializeElement(LandmarkRoadAttributeMapList& owner,
        ::nds::localization::instantiations::LandmarkRoadAttributeMap& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void LandmarkRoadAttributeMapList::ZserioElementFactory_maps::create(LandmarkRoadAttributeMapList&         owner,
        ::zserio::vector<::nds::localization::instantiations::LandmarkRoadAttributeMap>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void LandmarkRoadAttributeMapList::ZserioElementFactory_maps::create(LandmarkRoadAttributeMapList&         owner,
        ::zserio::vector<::nds::localization::instantiations::LandmarkRoadAttributeMap>& array,
        ::nds::localization::instantiations::LandmarkRoadAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

uint32_t LandmarkRoadAttributeMapList::readNumMaps(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t LandmarkRoadAttributeMapList::readNumMaps(LandmarkRoadAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumMaps().read<::zserio::VarSizeArrayTraits>(in);
}
::nds::localization::instantiations::LandmarkAttributeMapListHeader LandmarkRoadAttributeMapList::readHeader(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::localization::instantiations::LandmarkAttributeMapListHeader(in, static_cast<uint16_t>(getNumMaps()), allocator);
}

::nds::localization::instantiations::LandmarkAttributeMapListHeader LandmarkRoadAttributeMapList::readHeader(LandmarkRoadAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::localization::instantiations::LandmarkAttributeMapListHeader(context.getHeader(), in, static_cast<uint16_t>(getNumMaps()), allocator);
}
LandmarkRoadAttributeMapList::ZserioArrayType_maps LandmarkRoadAttributeMapList::readMaps(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

LandmarkRoadAttributeMapList::ZserioArrayType_maps LandmarkRoadAttributeMapList::readMaps(LandmarkRoadAttributeMapList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

} // namespace instantiations
} // namespace localization
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/localization/instantiations/LandmarkRoadSurfaceAttributeMapList.h>

namespace nds
{
namespace localization
{
namespace instantiations
{

LandmarkRoadSurfaceAttributeMapList::LandmarkRoadSurfaceAttributeMapList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numMaps_(uint32_t()),
        m_header_(allocator),
        m_maps_(allocator)
{
}

LandmarkRoadSurfaceAttributeMapList::LandmarkRoadSurfaceAttributeMapList(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(in)),
        m_header_(readHeader(in, allocator)),
        m_maps_(readMaps(in, allocator))
{
}

LandmarkRoadSurfaceAttributeMapList::LandmarkRoadSurfaceAttributeMapList(LandmarkRoadSurfaceAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(context, in)),
        m_header_(readHeader(context, in, allocator)),
        m_maps_(readMaps(context, in, allocator))
{
}

LandmarkRoadSurfaceAttributeMapList::LandmarkRoadSurfaceAttributeMapList(const LandmarkRoadSurfaceAttributeMapList& other) :
        m_numMaps_(other.m_numMaps_),
        m_header_(other.m_header_),
        m_maps_(other.m_maps_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

LandmarkRoadSurfaceAttributeMapList& LandmarkRoadSurfaceAttributeMapList::operator=(const LandmarkRoadSurfaceAttributeMapList& other)
{
    m_numMaps_ = other.m_numMaps_;
    m_header_ = other.m_header_;
    m_maps_ = other.m_maps_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

LandmarkRoadSurfaceAttributeMapList::LandmarkRoadSurfaceAttributeMapList(LandmarkRoadSurfaceAttributeMapList&& other) :
        m_numMaps_(::std::move(other.m_numMaps_)),
        m_header_(::std::move(other.m_header_)),
        m_maps_(::std::move(other.m_maps_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

LandmarkRoadSurfaceAttributeMapList& LandmarkRoadSurfaceAttributeMapList::operator=(LandmarkRoadSurfaceAttributeMapList&& other)
{
    m_numMaps_ = ::std::move(other.m_numMaps_);
    m_header_ = ::std::move(other.m_header_);
    m_maps_ = ::std::move(other.m_maps_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

LandmarkRoadSurfaceAttributeMapList::LandmarkRoadSurfaceAttributeMapList(::zserio::PropagateAllocatorT,
        const LandmarkRoadSurfaceAttributeMapList& other, const allocator_type& allocator) :
        m_numMaps_(::zserio::allocatorPropagatingCopy(other.m_numMaps_, allocator)),
        m_header_(::zserio::allocatorPropagatingCopy(other.m_header_, allocator)),
        m_maps_(::zserio::allocatorPropagatingCopy(other.m_maps_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void LandmarkRoadSurfaceAttributeMapList::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool LandmarkRoadSurfaceAttributeMapList::isInitialized() const
{
    return m_isInitialized;
}

void LandmarkRoadSurfaceAttributeMapList::initializeChildren()
{
    m_header_.initialize(static_cast<uint16_t>(getNumMaps()));
    m_maps_.initializeElements(*this);
}

::nds::core::geometry::CoordShift LandmarkRoadSurfaceAttributeMapList::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'LandmarkRoadSurfaceAttributeMapList' is not initialized!");

    return m_coordShift_;
}

uint32_t LandmarkRoadSurfaceAttributeMapList::getNumMaps() const
{
    return m_numMaps_;
}

void LandmarkRoadSurfaceAttributeMapList::setNumMaps(uint32_t numMaps_)
{
    m_numMaps_ = numMaps_;
}

::nds::localization::instantiations::LandmarkAttributeMapListHeader& LandmarkRoadSurfaceAttributeMapList::getHeader()
{
    return m_header_;
}

const ::nds::localization::instantiations::LandmarkAttributeMapListHeader& LandmarkRoadSurfaceAttributeMapList::getHeader() const
{
    return m_header_;
}

void LandmarkRoadSurfaceAttributeMapList::setHeader(const ::nds::localization::instantiations::LandmarkAttributeMapListHeader& header_)
{
    m_header_ = header_;
}

void LandmarkRoadSurfaceAttributeMapList::setHeader(::nds::localization::instantiations::LandmarkAttributeMapListHeader&& header_)
{
    m_header_ = ::std::move(header_);
}

::zserio::vector<::nds::localization::instantiations::LandmarkRoadSurfaceAttributeMap>& LandmarkRoadSurfaceAttributeMapList::getMaps()
{
    return m_maps_.getRawArray();
}

const ::zserio::vector<::nds::localization::instantiations::LandmarkRoadSurfaceAttributeMap>& LandmarkRoadSurfaceAttributeMapList::getMaps() const
{
    return m_maps_.getRawArray();
}

void LandmarkRoadSurfaceAttributeMapList::setMaps(const ::zserio::vector<::nds::localization::instantiations::LandmarkRoadSurfaceAttributeMap>& maps_)
{
    m_maps_ = ZserioArrayType_maps(maps_);
}

void LandmarkRoadSurfaceAttributeMapList::setMaps(::zserio::vector<::nds::localization::instantiations::LandmarkRoadSurfaceAttributeMap>&& maps_)
{
    m_maps_ = ZserioArrayType_maps(std::move(maps_));
}

void LandmarkRoadSurfaceAttributeMapList::initPackingContext(LandmarkRoadSurfaceAttributeMapList::ZserioPackingContext& context) const
{
    context.getNumMaps().init<::zserio::VarSizeArrayTraits>(m_numMaps_);
    m_header_.initPackingContext(context.getHeader());
}

size_t LandmarkRoadSurfaceAttributeMapList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LandmarkRoadSurfaceAttributeMapList::bitSizeOf(LandmarkRoadSurfaceAttributeMapList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(context.getHeader(), endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LandmarkRoadSurfaceAttributeMapList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t LandmarkRoadSurfaceAttributeMapList::initializeOffsets(LandmarkRoadSurfaceAttributeMapList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(context.getHeader(), endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool LandmarkRoadSurfaceAttributeMapList::operator==(const LandmarkRoadSurfaceAttributeMapList& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_numMaps_ == other.m_numMaps_) &&
                (m_header_ == other.m_header_) &&
                (m_maps_ == other.m_maps_);
    }

    return true;
}

uint32_t LandmarkRoadSurfaceAttributeMapList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_numMaps_);
    result = ::zserio::calcHashCode(result, m_header_);
    result = ::zserio::calcHashCode(result, m_maps_);

    return result;
}

void LandmarkRoadSurfaceAttributeMapList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field LandmarkRoadSurfaceAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field LandmarkRoadSurfaceAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void LandmarkRoadSurfaceAttributeMapList::write(LandmarkRoadSurfaceAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumMaps().write<::zserio::VarSizeArrayTraits>(out, m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field LandmarkRoadSurfaceAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(context.getHeader(), out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field LandmarkRoadSurfaceAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void LandmarkRoadSurfaceAttributeMapList::ZserioArrayExpressions_maps::initializeElement(LandmarkRoadSurfaceAttributeMapList& owner,
        ::nds::localization::instantiations::LandmarkRoadSurfaceAttributeMap& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void LandmarkRoadSurfaceAttributeMapList::ZserioElementFactory_maps::create(LandmarkRoadSurfaceAttributeMapList&         owner,
        ::zserio::vector<::nds::localization::instantiations::LandmarkRoadSurfaceAttributeMap>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void LandmarkRoadSurfaceAttributeMapList::ZserioElementFactory_maps::create(LandmarkRoadSurfaceAttributeMapList&         owner,
        ::zserio::vector<::nds::localization::instantiations::LandmarkRoadSurfaceAttributeMap>& array,
        ::nds::localization::instantiations::LandmarkRoadSurfaceAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

uint32_t LandmarkRoadSurfaceAttributeMapList::readNumMaps(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t LandmarkRoadSurfaceAttributeMapList::readNumMaps(LandmarkRoadSurfaceAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumMaps().read<::zserio::VarSizeArrayTraits>(in);
}
::nds::localization::instantiations::LandmarkAttributeMapListHeader LandmarkRoadSurfaceAttributeMapList::readHeader(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::localization::instantiations::LandmarkAttributeMapListHeader(in, static_cast<uint16_t>(getNumMaps()), allocator);
}

::nds::localization::instantiations::LandmarkAttributeMapListHeader LandmarkRoadSurfaceAttributeMapList::readHeader(LandmarkRoadSurfaceAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::localization::instantiations::LandmarkAttributeMapListHeader(context.getHeader(), in, static_cast<uint16_t>(getNumMaps()), allocator);
}
LandmarkRoadSurfaceAttributeMapList::ZserioArrayType_maps LandmarkRoadSurfaceAttributeMapList::readMaps(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

LandmarkRoadSurfaceAttributeMapList::ZserioArrayType_maps LandmarkRoadSurfaceAttributeMapList::readMaps(LandmarkRoadSurfaceAttributeMapList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

} // namespace instantiations
} // namespace localization
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/localization/instantiations/LandmarkAttributeMapListHeader.h>

namespace nds
{
namespace localization
{
namespace instantiations
{

LandmarkAttributeMapListHeader::LandmarkAttributeMapListHeader(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeTypeCode_(allocator),
        m_conditionType_(allocator)
{
}

LandmarkAttributeMapListHeader::LandmarkAttributeMapListHeader(::zserio::BitStreamReader& in,
        uint16_t numMaps_, const allocator_type& allocator) :
        m_numMaps_(numMaps_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in, allocator)),
        m_conditionType_(readConditionType(in, allocator))
{
}

LandmarkAttributeMapListHeader::LandmarkAttributeMapListHeader(LandmarkAttributeMapListHeader::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        uint16_t numMaps_, const allocator_type& allocator) :
        m_numMaps_(numMaps_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in, allocator)),
        m_conditionType_(readConditionType(context, in, allocator))
{
}

LandmarkAttributeMapListHeader::LandmarkAttributeMapListHeader(const LandmarkAttributeMapListHeader& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_conditionType_(other.m_conditionType_)
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

LandmarkAttributeMapListHeader& LandmarkAttributeMapListHeader::operator=(const LandmarkAttributeMapListHeader& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_conditionType_ = other.m_conditionType_;
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;

    return *this;
}

LandmarkAttributeMapListHeader::LandmarkAttributeMapListHeader(LandmarkAttributeMapListHeader&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_conditionType_(::std::move(other.m_conditionType_))
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

LandmarkAttributeMapListHeader& LandmarkAttributeMapListHeader::operator=(LandmarkAttributeMapListHeader&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_conditionType_ = ::std::move(other.m_conditionType_);
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;

    return *this;
}

LandmarkAttributeMapListHeader::LandmarkAttributeMapListHeader(::zserio::PropagateAllocatorT,
        const LandmarkAttributeMapListHeader& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_conditionType_(::zserio::allocatorPropagatingCopy(other.m_conditionType_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

void LandmarkAttributeMapListHeader::initialize(
        uint16_t numMaps_)
{
    m_numMaps_ = numMaps_;
    m_isInitialized = true;
}

bool LandmarkAttributeMapListHeader::isInitialized() const
{
    return m_isInitialized;
}

uint16_t LandmarkAttributeMapListHeader::getNumMaps() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'numMaps' of compound 'LandmarkAttributeMapListHeader' is not initialized!");

    return m_numMaps_;
}

::zserio::vector<::nds::localization::attributes::LandmarkRelationAttributeType>& LandmarkAttributeMapListHeader::getAttributeTypeCode()
{
    return m_attributeTypeCode_.getRawArray();
}

const ::zserio::vector<::nds::localization::attributes::LandmarkRelationAttributeType>& LandmarkAttributeMapListHeader::getAttributeTypeCode() const
{
    return m_attributeTypeCode_.getRawArray();
}

void LandmarkAttributeMapListHeader::setAttributeTypeCode(const ::zserio::vector<::nds::localization::attributes::LandmarkRelationAttributeType>& attributeTypeCode_)
{
    m_attributeTypeCode_ = ZserioArrayType_attributeTypeCode(attributeTypeCode_);
}

void LandmarkAttributeMapListHeader::setAttributeTypeCode(::zserio::vector<::nds::localization::attributes::LandmarkRelationAttributeType>&& attributeTypeCode_)
{
    m_attributeTypeCode_ = ZserioArrayType_attributeTypeCode(std::move(attributeTypeCode_));
}

::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& LandmarkAttributeMapListHeader::getConditionType()
{
    return m_conditionType_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& LandmarkAttributeMapListHeader::getConditionType() const
{
    return m_conditionType_.getRawArray();
}

void LandmarkAttributeMapListHeader::setConditionType(const ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& conditionType_)
{
    m_conditionType_ = ZserioArrayType_conditionType(conditionType_);
}

void LandmarkAttributeMapListHeader::setConditionType(::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>&& conditionType_)
{
    m_conditionType_ = ZserioArrayType_conditionType(std::move(conditionType_));
}

void LandmarkAttributeMapListHeader::initPackingContext(LandmarkAttributeMapListHeader::ZserioPackingContext&) const
{
}

size_t LandmarkAttributeMapListHeader::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeTypeCode_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_conditionType_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LandmarkAttributeMapListHeader::bitSizeOf(LandmarkAttributeMapListHeader::ZserioPackingContext&, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeTypeCode_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_conditionType_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LandmarkAttributeMapListHeader::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeTypeCode_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_conditionType_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t LandmarkAttributeMapListHeader::initializeOffsets(LandmarkAttributeMapListHeader::ZserioPackingContext&, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeTypeCode_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_conditionType_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool LandmarkAttributeMapListHeader::operator==(const LandmarkAttributeMapListHeader& other) const
{
    if (this != &other)
    {
        return
                (getNumMaps() == other.getNumMaps()) &&
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_conditionType_ == other.m_conditionType_);
    }

    return true;
}

uint32_t LandmarkAttributeMapListHeader::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getNumMaps());
    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_conditionType_);

    return result;
}

void LandmarkAttributeMapListHeader::write(::zserio::BitStreamWriter& out) const
{
    // check array length
    if (m_attributeTypeCode_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field LandmarkAttributeMapListHeader.attributeTypeCode: ") <<
                m_attributeTypeCode_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_attributeTypeCode_.writePacked(out);

    // check array length
    if (m_conditionType_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field LandmarkAttributeMapListHeader.conditionType: ") <<
                m_conditionType_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_conditionType_.writePacked(*this, out);
}

void LandmarkAttributeMapListHeader::write(LandmarkAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamWriter& out) const
{
    // check array length
    if (m_attributeTypeCode_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field LandmarkAttributeMapListHeader.attributeTypeCode: ") <<
                m_attributeTypeCode_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_attributeTypeCode_.writePacked(out);

    // check array length
    if (m_conditionType_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field LandmarkAttributeMapListHeader.conditionType: ") <<
                m_conditionType_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_conditionType_.writePacked(*this, out);
}

void LandmarkAttributeMapListHeader::ZserioElementFactory_conditionType::create(LandmarkAttributeMapListHeader&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void LandmarkAttributeMapListHeader::ZserioElementFactory_conditionType::create(LandmarkAttributeMapListHeader&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& array,
        ::nds::core::attributemap::ConditionTypeCodeCollection::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

LandmarkAttributeMapListHeader::ZserioArrayType_attributeTypeCode LandmarkAttributeMapListHeader::readAttributeTypeCode(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributeTypeCode readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumMaps()));

    return readField;
}

LandmarkAttributeMapListHeader::ZserioArrayType_attributeTypeCode LandmarkAttributeMapListHeader::readAttributeTypeCode(LandmarkAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributeTypeCode readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumMaps()));

    return readField;
}
LandmarkAttributeMapListHeader::ZserioArrayType_conditionType LandmarkAttributeMapListHeader::readConditionType(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_conditionType readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

LandmarkAttributeMapListHeader::ZserioArrayType_conditionType LandmarkAttributeMapListHeader::readConditionType(LandmarkAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_conditionType readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

} // namespace instantiations
} // namespace localization
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/localization/instantiations/LandmarkLaneAttributeMap.h>

namespace nds
{
namespace localization
{
namespace instantiations
{

LandmarkLaneAttributeMap::LandmarkLaneAttributeMap(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeTypeCode_(::nds::localization::attributes::LandmarkRelationAttributeType()),
        m_feature_(::nds::core::attributemap::FeatureIterator()),
        m_featureReferences_(allocator),
        m_featureValidities_(allocator),
        m_featureValuePtr_(allocator),
        m_attribute_(::nds::core::attributemap::AttributeIterator()),
        m_attributeValues_(allocator),
        m_attributeProperties_(allocator),
        m_attributeConditions_(allocator)
{
}

LandmarkLaneAttributeMap::LandmarkLaneAttributeMap(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in)),
        m_feature_(readFeature(in)),
        m_featureReferences_(readFeatureReferences(in, allocator)),
        m_featureValidities_(readFeatureValidities(in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(in, allocator)),
        m_attribute_(readAttribute(in)),
        m_attributeValues_(readAttributeValues(in, allocator)),
        m_attributeProperties_(readAttributeProperties(in, allocator)),
        m_attributeConditions_(readAttributeConditions(in, allocator))
{
}

LandmarkLaneAttributeMap::LandmarkLaneAttributeMap(LandmarkLaneAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in)),
        m_feature_(readFeature(context, in)),
        m_featureReferences_(readFeatureReferences(context, in, allocator)),
        m_featureValidities_(readFeatureValidities(context, in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(context, in, allocator)),
        m_attribute_(readAttribute(context, in)),
        m_attributeValues_(readAttributeValues(context, in, allocator)),
        m_attributeProperties_(readAttributeProperties(context, in, allocator)),
        m_attributeConditions_(readAttributeConditions(context, in, allocator))
{
}

LandmarkLaneAttributeMap::LandmarkLaneAttributeMap(const LandmarkLaneAttributeMap& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_feature_(other.m_feature_),
        m_featureReferences_(other.m_featureReferences_),
        m_featureValidities_(other.m_featureValidities_),
        m_featureValuePtr_(other.m_featureValuePtr_),
        m_attribute_(other.m_attribute_),
        m_attributeValues_(other.m_attributeValues_),
        m_attributeProperties_(other.m_attributeProperties_),
        m_attributeConditions_(other.m_attributeConditions_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

LandmarkLaneAttributeMap& LandmarkLaneAttributeMap::operator=(const LandmarkLaneAttributeMap& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_feature_ = other.m_feature_;
    m_featureReferences_ = other.m_featureReferences_;
    m_featureValidities_ = other.m_featureValidities_;
    m_featureValuePtr_ = other.m_featureValuePtr_;
    m_attribute_ = other.m_attribute_;
    m_attributeValues_ = other.m_attributeValues_;
    m_attributeProperties_ = other.m_attributeProperties_;
    m_attributeConditions_ = other.m_attributeConditions_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

LandmarkLaneAttributeMap::LandmarkLaneAttributeMap(LandmarkLaneAttributeMap&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_feature_(::std::move(other.m_feature_)),
        m_featureReferences_(::std::move(other.m_featureReferences_)),
        m_featureValidities_(::std::move(other.m_featureValidities_)),
        m_featureValuePtr_(::std::move(other.m_featureValuePtr_)),
        m_attribute_(::std::move(other.m_attribute_)),
        m_attributeValues_(::std::move(other.m_attributeValues_)),
        m_attributeProperties_(::std::move(other.m_attributeProperties_)),
        m_attributeConditions_(::std::move(other.m_attributeConditions_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

LandmarkLaneAttributeMap& LandmarkLaneAttributeMap::operator=(LandmarkLaneAttributeMap&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_feature_ = ::std::move(other.m_feature_);
    m_featureReferences_ = ::std::move(other.m_featureReferences_);
    m_featureValidities_ = ::std::move(other.m_featureValidities_);
    m_featureValuePtr_ = ::std::move(other.m_featureValuePtr_);
    m_attribute_ = ::std::move(other.m_attribute_);
    m_attributeValues_ = ::std::move(other.m_attributeValues_);
    m_attributeProperties_ = ::std::move(other.m_attributeProperties_);
    m_attributeConditions_ = ::std::move(other.m_attributeConditions_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

LandmarkLaneAttributeMap::LandmarkLaneAttributeMap(::zserio::PropagateAllocatorT,
        const LandmarkLaneAttributeMap& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_feature_(::zserio::allocatorPropagatingCopy(other.m_feature_, allocator)),
        m_featureReferences_(::zserio::allocatorPropagatingCopy(other.m_featureReferences_, allocator)),
        m_featureValidities_(::zserio::allocatorPropagatingCopy(other.m_featureValidities_, allocator)),
        m_featureValuePtr_(::zserio::allocatorPropagatingCopy(other.m_featureValuePtr_, allocator)),
        m_attribute_(::zserio::allocatorPropagatingCopy(other.m_attribute_, allocator)),
        m_attributeValues_(::zserio::allocatorPropagatingCopy(other.m_attributeValues_, allocator)),
        m_attributeProperties_(::zserio::allocatorPropagatingCopy(other.m_attributeProperties_, allocator)),
        m_attributeConditions_(::zserio::allocatorPropagatingCopy(other.m_attributeConditions_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void LandmarkLaneAttributeMap::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool LandmarkLaneAttributeMap::isInitialized() const
{
    return m_isInitialized;
}

void LandmarkLaneAttributeMap::initializeChildren()
{
    m_featureValidities_.initializeElements(*this);
    m_attributeValues_.initializeElements(*this);
    m_attributeProperties_.initializeElements(*this);
    m_attributeConditions_.initializeElements(*this);
}

::nds::core::geometry::CoordShift LandmarkLaneAttributeMap::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'LandmarkLaneAttributeMap' is not initialized!");

    return m_coordShift_;
}

::nds::localization::attributes::LandmarkRelationAttributeType LandmarkLaneAttributeMap::getAttributeTypeCode() const
{
    return m_attributeTypeCode_;
}

void LandmarkLaneAttributeMap::setAttributeTypeCode(::nds::localization::attributes::LandmarkRelationAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
}

::nds::core::attributemap::FeatureIterator LandmarkLaneAttributeMap::getFeature() const
{
    return m_feature_;
}

void LandmarkLaneAttributeMap::setFeature(::nds::core::attributemap::FeatureIterator feature_)
{
    m_feature_ = feature_;
}

::zserio::vector<::nds::lane::reference::types::LaneGroupId>& LandmarkLaneAttributeMap::getFeatureReferences()
{
    return m_featureReferences_.getRawArray();
}

const ::zserio::vector<::nds::lane::reference::types::LaneGroupId>& LandmarkLaneAttributeMap::getFeatureReferences() const
{
    return m_featureReferences_.getRawArray();
}

void LandmarkLaneAttributeMap::setFeatureReferences(const ::zserio::vector<::nds::lane::reference::types::LaneGroupId>& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(featureReferences_);
}

void LandmarkLaneAttributeMap::setFeatureReferences(::zserio::vector<::nds::lane::reference::types::LaneGroupId>&& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(std::move(featureReferences_));
}

::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>& LandmarkLaneAttributeMap::getFeatureValidities()
{
    return m_featureValidities_.getRawArray();
}

const ::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>& LandmarkLaneAttributeMap::getFeatureValidities() const
{
    return m_featureValidities_.getRawArray();
}

void LandmarkLaneAttributeMap::setFeatureValidities(const ::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(featureValidities_);
}

void LandmarkLaneAttributeMap::setFeatureValidities(::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>&& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(std::move(featureValidities_));
}

::zserio::vector<::nds::core::attributemap::AttributeIterator>& LandmarkLaneAttributeMap::getFeatureValuePtr()
{
    return m_featureValuePtr_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& LandmarkLaneAttributeMap::getFeatureValuePtr() const
{
    return m_featureValuePtr_.getRawArray();
}

void LandmarkLaneAttributeMap::setFeatureValuePtr(const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(featureValuePtr_);
}

void LandmarkLaneAttributeMap::setFeatureValuePtr(::zserio::vector<::nds::core::attributemap::AttributeIterator>&& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(std::move(featureValuePtr_));
}

::nds::core::attributemap::AttributeIterator LandmarkLaneAttributeMap::getAttribute() const
{
    return m_attribute_;
}

void LandmarkLaneAttributeMap::setAttribute(::nds::core::attributemap::AttributeIterator attribute_)
{
    m_attribute_ = attribute_;
}

::zserio::vector<::nds::localization::instantiations::LandmarkAttribute>& LandmarkLaneAttributeMap::getAttributeValues()
{
    return m_attributeValues_.getRawArray();
}

const ::zserio::vector<::nds::localization::instantiations::LandmarkAttribute>& LandmarkLaneAttributeMap::getAttributeValues() const
{
    return m_attributeValues_.getRawArray();
}

void LandmarkLaneAttributeMap::setAttributeValues(const ::zserio::vector<::nds::localization::instantiations::LandmarkAttribute>& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(attributeValues_);
}

void LandmarkLaneAttributeMap::setAttributeValues(::zserio::vector<::nds::localization::instantiations::LandmarkAttribute>&& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(std::move(attributeValues_));
}

::zserio::vector<::nds::localization::instantiations::LandmarkPropertyList>& LandmarkLaneAttributeMap::getAttributeProperties()
{
    return m_attributeProperties_.getRawArray();
}

const ::zserio::vector<::nds::localization::instantiations::LandmarkPropertyList>& LandmarkLaneAttributeMap::getAttributeProperties() const
{
    return m_attributeProperties_.getRawArray();
}

void LandmarkLaneAttributeMap::setAttributeProperties(const ::zserio::vector<::nds::localization::instantiations::LandmarkPropertyList>& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(attributeProperties_);
}

void LandmarkLaneAttributeMap::setAttributeProperties(::zserio::vector<::nds::localization::instantiations::LandmarkPropertyList>&& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(std::move(attributeProperties_));
}

::zserio::vector<::nds::core::attributemap::ConditionList>& LandmarkLaneAttributeMap::getAttributeConditions()
{
    return m_attributeConditions_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::ConditionList>& LandmarkLaneAttributeMap::getAttributeConditions() const
{
    return m_attributeConditions_.getRawArray();
}

void LandmarkLaneAttributeMap::setAttributeConditions(const ::zserio::vector<::nds::core::attributemap::ConditionList>& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(attributeConditions_);
}

void LandmarkLaneAttributeMap::setAttributeConditions(::zserio::vector<::nds::core::attributemap::ConditionList>&& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(std::move(attributeConditions_));
}

void LandmarkLaneAttributeMap::initPackingContext(LandmarkLaneAttributeMap::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getAttributeTypeCode(), m_attributeTypeCode_);
    context.getFeature().init<::zserio::VarSizeArrayTraits>(m_feature_);
    context.getAttribute().init<::zserio::VarSizeArrayTraits>(m_attribute_);
}

size_t LandmarkLaneAttributeMap::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LandmarkLaneAttributeMap::bitSizeOf(LandmarkLaneAttributeMap::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getAttributeTypeCode(), m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LandmarkLaneAttributeMap::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t LandmarkLaneAttributeMap::initializeOffsets(LandmarkLaneAttributeMap::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getAttributeTypeCode(), endBitPosition,
        m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool LandmarkLaneAttributeMap::operator==(const LandmarkLaneAttributeMap& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_feature_ == other.m_feature_) &&
                (m_featureReferences_ == other.m_featureReferences_) &&
                (m_featureValidities_ == other.m_featureValidities_) &&
                (m_featureValuePtr_ == other.m_featureValuePtr_) &&
                (m_attribute_ == other.m_attribute_) &&
                (m_attributeValues_ == other.m_attributeValues_) &&
                (m_attributeProperties_ == other.m_attributeProperties_) &&
                (m_attributeConditions_ == other.m_attributeConditions_);
    }

    return true;
}

uint32_t LandmarkLaneAttributeMap::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_feature_);
    result = ::zserio::calcHashCode(result, m_featureReferences_);
    result = ::zserio::calcHashCode(result, m_featureValidities_);
    result = ::zserio::calcHashCode(result, m_featureValuePtr_);
    result = ::zserio::calcHashCode(result, m_attribute_);
    result = ::zserio::calcHashCode(result, m_attributeValues_);
    result = ::zserio::calcHashCode(result, m_attributeProperties_);
    result = ::zserio::calcHashCode(result, m_attributeConditions_);

    return result;
}

void LandmarkLaneAttributeMap::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_attributeTypeCode_);

    out.alignTo(8);
    out.writeVarSize(m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field LandmarkLaneAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field LandmarkLaneAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field LandmarkLaneAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    out.writeVarSize(m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field LandmarkLaneAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field LandmarkLaneAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field LandmarkLaneAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void LandmarkLaneAttributeMap::write(LandmarkLaneAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getAttributeTypeCode(), out, m_attributeTypeCode_);

    out.alignTo(8);
    context.getFeature().write<::zserio::VarSizeArrayTraits>(out, m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field LandmarkLaneAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field LandmarkLaneAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field LandmarkLaneAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    context.getAttribute().write<::zserio::VarSizeArrayTraits>(out, m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field LandmarkLaneAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field LandmarkLaneAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field LandmarkLaneAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void LandmarkLaneAttributeMap::ZserioElementFactory_featureReferences::create(LandmarkLaneAttributeMap&        ,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupId>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void LandmarkLaneAttributeMap::ZserioElementFactory_featureReferences::create(LandmarkLaneAttributeMap&        ,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupId>& array,
        ::nds::lane::reference::types::LaneGroupId::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void LandmarkLaneAttributeMap::ZserioArrayExpressions_featureValidities::initializeElement(LandmarkLaneAttributeMap& owner,
        ::nds::lane::reference::types::LaneGroupRangeValidity& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void LandmarkLaneAttributeMap::ZserioElementFactory_featureValidities::create(LandmarkLaneAttributeMap&         owner,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void LandmarkLaneAttributeMap::ZserioElementFactory_featureValidities::create(LandmarkLaneAttributeMap&         owner,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>& array,
        ::nds::lane::reference::types::LaneGroupRangeValidity::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void LandmarkLaneAttributeMap::ZserioArrayExpressions_attributeValues::initializeElement(LandmarkLaneAttributeMap& owner,
        ::nds::localization::instantiations::LandmarkAttribute& element, size_t)
{
    element.initialize(static_cast<::nds::localization::attributes::LandmarkRelationAttributeType>(owner.getAttributeTypeCode()));
}

void LandmarkLaneAttributeMap::ZserioElementFactory_attributeValues::create(LandmarkLaneAttributeMap&         owner,
        ::zserio::vector<::nds::localization::instantiations::LandmarkAttribute>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::localization::attributes::LandmarkRelationAttributeType>(owner.getAttributeTypeCode()), array.get_allocator());
}

void LandmarkLaneAttributeMap::ZserioElementFactory_attributeValues::create(LandmarkLaneAttributeMap&         owner,
        ::zserio::vector<::nds::localization::instantiations::LandmarkAttribute>& array,
        ::nds::localization::instantiations::LandmarkAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::localization::attributes::LandmarkRelationAttributeType>(owner.getAttributeTypeCode()), array.get_allocator());
}

void LandmarkLaneAttributeMap::ZserioArrayExpressions_attributeProperties::initializeElement(LandmarkLaneAttributeMap&,
        ::nds::localization::instantiations::LandmarkPropertyList& element, size_t)
{
    element.initializeChildren();
}

void LandmarkLaneAttributeMap::ZserioElementFactory_attributeProperties::create(LandmarkLaneAttributeMap&        ,
        ::zserio::vector<::nds::localization::instantiations::LandmarkPropertyList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void LandmarkLaneAttributeMap::ZserioElementFactory_attributeProperties::create(LandmarkLaneAttributeMap&        ,
        ::zserio::vector<::nds::localization::instantiations::LandmarkPropertyList>& array,
        ::nds::localization::instantiations::LandmarkPropertyList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void LandmarkLaneAttributeMap::ZserioArrayExpressions_attributeConditions::initializeElement(LandmarkLaneAttributeMap&,
        ::nds::core::attributemap::ConditionList& element, size_t)
{
    element.initializeChildren();
}

void LandmarkLaneAttributeMap::ZserioElementFactory_attributeConditions::create(LandmarkLaneAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void LandmarkLaneAttributeMap::ZserioElementFactory_attributeConditions::create(LandmarkLaneAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::nds::core::attributemap::ConditionList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::localization::attributes::LandmarkRelationAttributeType LandmarkLaneAttributeMap::readAttributeTypeCode(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::localization::attributes::LandmarkRelationAttributeType>(in);
}

::nds::localization::attributes::LandmarkRelationAttributeType LandmarkLaneAttributeMap::readAttributeTypeCode(LandmarkLaneAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::localization::attributes::LandmarkRelationAttributeType>(context.getAttributeTypeCode(), in);
}
::nds::core::attributemap::FeatureIterator LandmarkLaneAttributeMap::readFeature(::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return static_cast<::nds::core::attributemap::FeatureIterator>(in.readVarSize());
}

::nds::core::attributemap::FeatureIterator LandmarkLaneAttributeMap::readFeature(LandmarkLaneAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return context.getFeature().read<::zserio::VarSizeArrayTraits>(in);
}
LandmarkLaneAttributeMap::ZserioArrayType_featureReferences LandmarkLaneAttributeMap::readFeatureReferences(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

LandmarkLaneAttributeMap::ZserioArrayType_featureReferences LandmarkLaneAttributeMap::readFeatureReferences(LandmarkLaneAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
LandmarkLaneAttributeMap::ZserioArrayType_featureValidities LandmarkLaneAttributeMap::readFeatureValidities(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValidities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

LandmarkLaneAttributeMap::ZserioArrayType_featureValidities LandmarkLaneAttributeMap::readFeatureValidities(LandmarkLaneAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValidities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
LandmarkLaneAttributeMap::ZserioArrayType_featureValuePtr LandmarkLaneAttributeMap::readFeatureValuePtr(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}

LandmarkLaneAttributeMap::ZserioArrayType_featureValuePtr LandmarkLaneAttributeMap::readFeatureValuePtr(LandmarkLaneAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}
::nds::core::attributemap::AttributeIterator LandmarkLaneAttributeMap::readAttribute(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::attributemap::AttributeIterator>(in.readVarSize());
}

::nds::core::attributemap::AttributeIterator LandmarkLaneAttributeMap::readAttribute(LandmarkLaneAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getAttribute().read<::zserio::VarSizeArrayTraits>(in);
}
LandmarkLaneAttributeMap::ZserioArrayType_attributeValues LandmarkLaneAttributeMap::readAttributeValues(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributeValues readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

LandmarkLaneAttributeMap::ZserioArrayType_attributeValues LandmarkLaneAttributeMap::readAttributeValues(LandmarkLaneAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributeValues readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
LandmarkLaneAttributeMap::ZserioArrayType_attributeProperties LandmarkLaneAttributeMap::readAttributeProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

LandmarkLaneAttributeMap::ZserioArrayType_attributeProperties LandmarkLaneAttributeMap::readAttributeProperties(LandmarkLaneAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
LandmarkLaneAttributeMap::ZserioArrayType_attributeConditions LandmarkLaneAttributeMap::readAttributeConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

LandmarkLaneAttributeMap::ZserioArrayType_attributeConditions LandmarkLaneAttributeMap::readAttributeConditions(LandmarkLaneAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

} // namespace instantiations
} // namespace localization
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/localization/instantiations/LandmarkRoadAttributeMap.h>

namespace nds
{
namespace localization
{
namespace instantiations
{

LandmarkRoadAttributeMap::LandmarkRoadAttributeMap(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeTypeCode_(::nds::localization::attributes::LandmarkRelationAttributeType()),
        m_feature_(::nds::core::attributemap::FeatureIterator()),
        m_featureReferences_(allocator),
        m_featureValidities_(allocator),
        m_featureValuePtr_(allocator),
        m_attribute_(::nds::core::attributemap::AttributeIterator()),
        m_attributeValues_(allocator),
        m_attributeProperties_(allocator),
        m_attributeConditions_(allocator)
{
}

LandmarkRoadAttributeMap::LandmarkRoadAttributeMap(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in)),
        m_feature_(readFeature(in)),
        m_featureReferences_(readFeatureReferences(in, allocator)),
        m_featureValidities_(readFeatureValidities(in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(in, allocator)),
        m_attribute_(readAttribute(in)),
        m_attributeValues_(readAttributeValues(in, allocator)),
        m_attributeProperties_(readAttributeProperties(in, allocator)),
        m_attributeConditions_(readAttributeConditions(in, allocator))
{
}

LandmarkRoadAttributeMap::LandmarkRoadAttributeMap(LandmarkRoadAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in)),
        m_feature_(readFeature(context, in)),
        m_featureReferences_(readFeatureReferences(context, in, allocator)),
        m_featureValidities_(readFeatureValidities(context, in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(context, in, allocator)),
        m_attribute_(readAttribute(context, in)),
        m_attributeValues_(readAttributeValues(context, in, allocator)),
        m_attributeProperties_(readAttributeProperties(context, in, allocator)),
        m_attributeConditions_(readAttributeConditions(context, in, allocator))
{
}

LandmarkRoadAttributeMap::LandmarkRoadAttributeMap(const LandmarkRoadAttributeMap& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_feature_(other.m_feature_),
        m_featureReferences_(other.m_featureReferences_),
        m_featureValidities_(other.m_featureValidities_),
        m_featureValuePtr_(other.m_featureValuePtr_),
        m_attribute_(other.m_attribute_),
        m_attributeValues_(other.m_attributeValues_),
        m_attributeProperties_(other.m_attributeProperties_),
        m_attributeConditions_(other.m_attributeConditions_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

LandmarkRoadAttributeMap& LandmarkRoadAttributeMap::operator=(const LandmarkRoadAttributeMap& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_feature_ = other.m_feature_;
    m_featureReferences_ = other.m_featureReferences_;
    m_featureValidities_ = other.m_featureValidities_;
    m_featureValuePtr_ = other.m_featureValuePtr_;
    m_attribute_ = other.m_attribute_;
    m_attributeValues_ = other.m_attributeValues_;
    m_attributeProperties_ = other.m_attributeProperties_;
    m_attributeConditions_ = other.m_attributeConditions_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

LandmarkRoadAttributeMap::LandmarkRoadAttributeMap(LandmarkRoadAttributeMap&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_feature_(::std::move(other.m_feature_)),
        m_featureReferences_(::std::move(other.m_featureReferences_)),
        m_featureValidities_(::std::move(other.m_featureValidities_)),
        m_featureValuePtr_(::std::move(other.m_featureValuePtr_)),
        m_attribute_(::std::move(other.m_attribute_)),
        m_attributeValues_(::std::move(other.m_attributeValues_)),
        m_attributeProperties_(::std::move(other.m_attributeProperties_)),
        m_attributeConditions_(::std::move(other.m_attributeConditions_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

LandmarkRoadAttributeMap& LandmarkRoadAttributeMap::operator=(LandmarkRoadAttributeMap&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_feature_ = ::std::move(other.m_feature_);
    m_featureReferences_ = ::std::move(other.m_featureReferences_);
    m_featureValidities_ = ::std::move(other.m_featureValidities_);
    m_featureValuePtr_ = ::std::move(other.m_featureValuePtr_);
    m_attribute_ = ::std::move(other.m_attribute_);
    m_attributeValues_ = ::std::move(other.m_attributeValues_);
    m_attributeProperties_ = ::std::move(other.m_attributeProperties_);
    m_attributeConditions_ = ::std::move(other.m_attributeConditions_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

LandmarkRoadAttributeMap::LandmarkRoadAttributeMap(::zserio::PropagateAllocatorT,
        const LandmarkRoadAttributeMap& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_feature_(::zserio::allocatorPropagatingCopy(other.m_feature_, allocator)),
        m_featureReferences_(::zserio::allocatorPropagatingCopy(other.m_featureReferences_, allocator)),
        m_featureValidities_(::zserio::allocatorPropagatingCopy(other.m_featureValidities_, allocator)),
        m_featureValuePtr_(::zserio::allocatorPropagatingCopy(other.m_featureValuePtr_, allocator)),
        m_attribute_(::zserio::allocatorPropagatingCopy(other.m_attribute_, allocator)),
        m_attributeValues_(::zserio::allocatorPropagatingCopy(other.m_attributeValues_, allocator)),
        m_attributeProperties_(::zserio::allocatorPropagatingCopy(other.m_attributeProperties_, allocator)),
        m_attributeConditions_(::zserio::allocatorPropagatingCopy(other.m_attributeConditions_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void LandmarkRoadAttributeMap::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool LandmarkRoadAttributeMap::isInitialized() const
{
    return m_isInitialized;
}

void LandmarkRoadAttributeMap::initializeChildren()
{
    m_featureValidities_.initializeElements(*this);
    m_attributeValues_.initializeElements(*this);
    m_attributeProperties_.initializeElements(*this);
    m_attributeConditions_.initializeElements(*this);
}

::nds::core::geometry::CoordShift LandmarkRoadAttributeMap::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'LandmarkRoadAttributeMap' is not initialized!");

    return m_coordShift_;
}

::nds::localization::attributes::LandmarkRelationAttributeType LandmarkRoadAttributeMap::getAttributeTypeCode() const
{
    return m_attributeTypeCode_;
}

void LandmarkRoadAttributeMap::setAttributeTypeCode(::nds::localization::attributes::LandmarkRelationAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
}

::nds::core::attributemap::FeatureIterator LandmarkRoadAttributeMap::getFeature() const
{
    return m_feature_;
}

void LandmarkRoadAttributeMap::setFeature(::nds::core::attributemap::FeatureIterator feature_)
{
    m_feature_ = feature_;
}

::zserio::vector<::nds::road::reference::types::RoadReference>& LandmarkRoadAttributeMap::getFeatureReferences()
{
    return m_featureReferences_.getRawArray();
}

const ::zserio::vector<::nds::road::reference::types::RoadReference>& LandmarkRoadAttributeMap::getFeatureReferences() const
{
    return m_featureReferences_.getRawArray();
}

void LandmarkRoadAttributeMap::setFeatureReferences(const ::zserio::vector<::nds::road::reference::types::RoadReference>& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(featureReferences_);
}

void LandmarkRoadAttributeMap::setFeatureReferences(::zserio::vector<::nds::road::reference::types::RoadReference>&& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(std::move(featureReferences_));
}

::zserio::vector<::nds::road::reference::types::RoadValidityRange>& LandmarkRoadAttributeMap::getFeatureValidities()
{
    return m_featureValidities_.getRawArray();
}

const ::zserio::vector<::nds::road::reference::types::RoadValidityRange>& LandmarkRoadAttributeMap::getFeatureValidities() const
{
    return m_featureValidities_.getRawArray();
}

void LandmarkRoadAttributeMap::setFeatureValidities(const ::zserio::vector<::nds::road::reference::types::RoadValidityRange>& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(featureValidities_);
}

void LandmarkRoadAttributeMap::setFeatureValidities(::zserio::vector<::nds::road::reference::types::RoadValidityRange>&& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(std::move(featureValidities_));
}

::zserio::vector<::nds::core::attributemap::AttributeIterator>& LandmarkRoadAttributeMap::getFeatureValuePtr()
{
    return m_featureValuePtr_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& LandmarkRoadAttributeMap::getFeatureValuePtr() const
{
    return m_featureValuePtr_.getRawArray();
}

void LandmarkRoadAttributeMap::setFeatureValuePtr(const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(featureValuePtr_);
}

void LandmarkRoadAttributeMap::setFeatureValuePtr(::zserio::vector<::nds::core::attributemap::AttributeIterator>&& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(std::move(featureValuePtr_));
}

::nds::core::attributemap::AttributeIterator LandmarkRoadAttributeMap::getAttribute() const
{
    return m_attribute_;
}

void LandmarkRoadAttributeMap::setAttribute(::nds::core::attributemap::AttributeIterator attribute_)
{
    m_attribute_ = attribute_;
}

::zserio::vector<::nds::localization::instantiations::LandmarkAttribute>& LandmarkRoadAttributeMap::getAttributeValues()
{
    return m_attributeValues_.getRawArray();
}

const ::zserio::vector<::nds::localization::instantiations::LandmarkAttribute>& LandmarkRoadAttributeMap::getAttributeValues() const
{
    return m_attributeValues_.getRawArray();
}

void LandmarkRoadAttributeMap::setAttributeValues(const ::zserio::vector<::nds::localization::instantiations::LandmarkAttribute>& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(attributeValues_);
}

void LandmarkRoadAttributeMap::setAttributeValues(::zserio::vector<::nds::localization::instantiations::LandmarkAttribute>&& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(std::move(attributeValues_));
}

::zserio::vector<::nds::localization::instantiations::LandmarkPropertyList>& LandmarkRoadAttributeMap::getAttributeProperties()
{
    return m_attributeProperties_.getRawArray();
}

const ::zserio::vector<::nds::localization::instantiations::LandmarkPropertyList>& LandmarkRoadAttributeMap::getAttributeProperties() const
{
    return m_attributeProperties_.getRawArray();
}

void LandmarkRoadAttributeMap::setAttributeProperties(const ::zserio::vector<::nds::localization::instantiations::LandmarkPropertyList>& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(attributeProperties_);
}

void LandmarkRoadAttributeMap::setAttributeProperties(::zserio::vector<::nds::localization::instantiations::LandmarkPropertyList>&& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(std::move(attributeProperties_));
}

::zserio::vector<::nds::core::attributemap::ConditionList>& LandmarkRoadAttributeMap::getAttributeConditions()
{
    return m_attributeConditions_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::ConditionList>& LandmarkRoadAttributeMap::getAttributeConditions() const
{
    return m_attributeConditions_.getRawArray();
}

void LandmarkRoadAttributeMap::setAttributeConditions(const ::zserio::vector<::nds::core::attributemap::ConditionList>& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(attributeConditions_);
}

void LandmarkRoadAttributeMap::setAttributeConditions(::zserio::vector<::nds::core::attributemap::ConditionList>&& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(std::move(attributeConditions_));
}

void LandmarkRoadAttributeMap::initPackingContext(LandmarkRoadAttributeMap::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getAttributeTypeCode(), m_attributeTypeCode_);
    context.getFeature().init<::zserio::VarSizeArrayTraits>(m_feature_);
    context.getAttribute().init<::zserio::VarSizeArrayTraits>(m_attribute_);
}

size_t LandmarkRoadAttributeMap::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LandmarkRoadAttributeMap::bitSizeOf(LandmarkRoadAttributeMap::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getAttributeTypeCode(), m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LandmarkRoadAttributeMap::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t LandmarkRoadAttributeMap::initializeOffsets(LandmarkRoadAttributeMap::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getAttributeTypeCode(), endBitPosition,
        m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool LandmarkRoadAttributeMap::operator==(const LandmarkRoadAttributeMap& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_feature_ == other.m_feature_) &&
                (m_featureReferences_ == other.m_featureReferences_) &&
                (m_featureValidities_ == other.m_featureValidities_) &&
                (m_featureValuePtr_ == other.m_featureValuePtr_) &&
                (m_attribute_ == other.m_attribute_) &&
                (m_attributeValues_ == other.m_attributeValues_) &&
                (m_attributeProperties_ == other.m_attributeProperties_) &&
                (m_attributeConditions_ == other.m_attributeConditions_);
    }

    return true;
}

uint32_t LandmarkRoadAttributeMap::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_feature_);
    result = ::zserio::calcHashCode(result, m_featureReferences_);
    result = ::zserio::calcHashCode(result, m_featureValidities_);
    result = ::zserio::calcHashCode(result, m_featureValuePtr_);
    result = ::zserio::calcHashCode(result, m_attribute_);
    result = ::zserio::calcHashCode(result, m_attributeValues_);
    result = ::zserio::calcHashCode(result, m_attributeProperties_);
    result = ::zserio::calcHashCode(result, m_attributeConditions_);

    return result;
}

void LandmarkRoadAttributeMap::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_attributeTypeCode_);

    out.alignTo(8);
    out.writeVarSize(m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field LandmarkRoadAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field LandmarkRoadAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field LandmarkRoadAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    out.writeVarSize(m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field LandmarkRoadAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field LandmarkRoadAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field LandmarkRoadAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void LandmarkRoadAttributeMap::write(LandmarkRoadAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getAttributeTypeCode(), out, m_attributeTypeCode_);

    out.alignTo(8);
    context.getFeature().write<::zserio::VarSizeArrayTraits>(out, m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field LandmarkRoadAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field LandmarkRoadAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field LandmarkRoadAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    context.getAttribute().write<::zserio::VarSizeArrayTraits>(out, m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field LandmarkRoadAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field LandmarkRoadAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field LandmarkRoadAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void LandmarkRoadAttributeMap::ZserioElementFactory_featureReferences::create(LandmarkRoadAttributeMap&        ,
        ::zserio::vector<::nds::road::reference::types::RoadReference>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void LandmarkRoadAttributeMap::ZserioElementFactory_featureReferences::create(LandmarkRoadAttributeMap&        ,
        ::zserio::vector<::nds::road::reference::types::RoadReference>& array,
        ::nds::road::reference::types::RoadReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void LandmarkRoadAttributeMap::ZserioArrayExpressions_featureValidities::initializeElement(LandmarkRoadAttributeMap& owner,
        ::nds::road::reference::types::RoadValidityRange& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void LandmarkRoadAttributeMap::ZserioElementFactory_featureValidities::create(LandmarkRoadAttributeMap&         owner,
        ::zserio::vector<::nds::road::reference::types::RoadValidityRange>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void LandmarkRoadAttributeMap::ZserioElementFactory_featureValidities::create(LandmarkRoadAttributeMap&         owner,
        ::zserio::vector<::nds::road::reference::types::RoadValidityRange>& array,
        ::nds::road::reference::types::RoadValidityRange::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void LandmarkRoadAttributeMap::ZserioArrayExpressions_attributeValues::initializeElement(LandmarkRoadAttributeMap& owner,
        ::nds::localization::instantiations::LandmarkAttribute& element, size_t)
{
    element.initialize(static_cast<::nds::localization::attributes::LandmarkRelationAttributeType>(owner.getAttributeTypeCode()));
}

void LandmarkRoadAttributeMap::ZserioElementFactory_attributeValues::create(LandmarkRoadAttributeMap&         owner,
        ::zserio::vector<::nds::localization::instantiations::LandmarkAttribute>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::localization::attributes::LandmarkRelationAttributeType>(owner.getAttributeTypeCode()), array.get_allocator());
}

void LandmarkRoadAttributeMap::ZserioElementFactory_attributeValues::create(LandmarkRoadAttributeMap&         owner,
        ::zserio::vector<::nds::localization::instantiations::LandmarkAttribute>& array,
        ::nds::localization::instantiations::LandmarkAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::localization::attributes::LandmarkRelationAttributeType>(owner.getAttributeTypeCode()), array.get_allocator());
}

void LandmarkRoadAttributeMap::ZserioArrayExpressions_attributeProperties::initializeElement(LandmarkRoadAttributeMap&,
        ::nds::localization::instantiations::LandmarkPropertyList& element, size_t)
{
    element.initializeChildren();
}

void LandmarkRoadAttributeMap::ZserioElementFactory_attributeProperties::create(LandmarkRoadAttributeMap&        ,
        ::zserio::vector<::nds::localization::instantiations::LandmarkPropertyList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void LandmarkRoadAttributeMap::ZserioElementFactory_attributeProperties::create(LandmarkRoadAttributeMap&        ,
        ::zserio::vector<::nds::localization::instantiations::LandmarkPropertyList>& array,
        ::nds::localization::instantiations::LandmarkPropertyList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void LandmarkRoadAttributeMap::ZserioArrayExpressions_attributeConditions::initializeElement(LandmarkRoadAttributeMap&,
        ::nds::core::attributemap::ConditionList& element, size_t)
{
    element.initializeChildren();
}

void LandmarkRoadAttributeMap::ZserioElementFactory_attributeConditions::create(LandmarkRoadAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void LandmarkRoadAttributeMap::ZserioElementFactory_attributeConditions::create(LandmarkRoadAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::nds::core::attributemap::ConditionList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::localization::attributes::LandmarkRelationAttributeType LandmarkRoadAttributeMap::readAttributeTypeCode(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::localization::attributes::LandmarkRelationAttributeType>(in);
}

::nds::localization::attributes::LandmarkRelationAttributeType LandmarkRoadAttributeMap::readAttributeTypeCode(LandmarkRoadAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::localization::attributes::LandmarkRelationAttributeType>(context.getAttributeTypeCode(), in);
}
::nds::core::attributemap::FeatureIterator LandmarkRoadAttributeMap::readFeature(::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return static_cast<::nds::core::attributemap::FeatureIterator>(in.readVarSize());
}

::nds::core::attributemap::FeatureIterator LandmarkRoadAttributeMap::readFeature(LandmarkRoadAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return context.getFeature().read<::zserio::VarSizeArrayTraits>(in);
}
LandmarkRoadAttributeMap::ZserioArrayType_featureReferences LandmarkRoadAttributeMap::readFeatureReferences(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

LandmarkRoadAttributeMap::ZserioArrayType_featureReferences LandmarkRoadAttributeMap::readFeatureReferences(LandmarkRoadAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
LandmarkRoadAttributeMap::ZserioArrayType_featureValidities LandmarkRoadAttributeMap::readFeatureValidities(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValidities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

LandmarkRoadAttributeMap::ZserioArrayType_featureValidities LandmarkRoadAttributeMap::readFeatureValidities(LandmarkRoadAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValidities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
LandmarkRoadAttributeMap::ZserioArrayType_featureValuePtr LandmarkRoadAttributeMap::readFeatureValuePtr(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}

LandmarkRoadAttributeMap::ZserioArrayType_featureValuePtr LandmarkRoadAttributeMap::readFeatureValuePtr(LandmarkRoadAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}
::nds::core::attributemap::AttributeIterator LandmarkRoadAttributeMap::readAttribute(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::attributemap::AttributeIterator>(in.readVarSize());
}

::nds::core::attributemap::AttributeIterator LandmarkRoadAttributeMap::readAttribute(LandmarkRoadAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getAttribute().read<::zserio::VarSizeArrayTraits>(in);
}
LandmarkRoadAttributeMap::ZserioArrayType_attributeValues LandmarkRoadAttributeMap::readAttributeValues(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributeValues readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

LandmarkRoadAttributeMap::ZserioArrayType_attributeValues LandmarkRoadAttributeMap::readAttributeValues(LandmarkRoadAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributeValues readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
LandmarkRoadAttributeMap::ZserioArrayType_attributeProperties LandmarkRoadAttributeMap::readAttributeProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

LandmarkRoadAttributeMap::ZserioArrayType_attributeProperties LandmarkRoadAttributeMap::readAttributeProperties(LandmarkRoadAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
LandmarkRoadAttributeMap::ZserioArrayType_attributeConditions LandmarkRoadAttributeMap::readAttributeConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

LandmarkRoadAttributeMap::ZserioArrayType_attributeConditions LandmarkRoadAttributeMap::readAttributeConditions(LandmarkRoadAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

} // namespace instantiations
} // namespace localization
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/localization/instantiations/LandmarkRoadSurfaceAttributeMap.h>

namespace nds
{
namespace localization
{
namespace instantiations
{

LandmarkRoadSurfaceAttributeMap::LandmarkRoadSurfaceAttributeMap(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeTypeCode_(::nds::localization::attributes::LandmarkRelationAttributeType()),
        m_feature_(::nds::core::attributemap::FeatureIterator()),
        m_featureReferences_(allocator),
        m_featureValidities_(allocator),
        m_featureValuePtr_(allocator),
        m_attribute_(::nds::core::attributemap::AttributeIterator()),
        m_attributeValues_(allocator),
        m_attributeProperties_(allocator),
        m_attributeConditions_(allocator)
{
}

LandmarkRoadSurfaceAttributeMap::LandmarkRoadSurfaceAttributeMap(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in)),
        m_feature_(readFeature(in)),
        m_featureReferences_(readFeatureReferences(in, allocator)),
        m_featureValidities_(readFeatureValidities(in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(in, allocator)),
        m_attribute_(readAttribute(in)),
        m_attributeValues_(readAttributeValues(in, allocator)),
        m_attributeProperties_(readAttributeProperties(in, allocator)),
        m_attributeConditions_(readAttributeConditions(in, allocator))
{
}

LandmarkRoadSurfaceAttributeMap::LandmarkRoadSurfaceAttributeMap(LandmarkRoadSurfaceAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in)),
        m_feature_(readFeature(context, in)),
        m_featureReferences_(readFeatureReferences(context, in, allocator)),
        m_featureValidities_(readFeatureValidities(in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(context, in, allocator)),
        m_attribute_(readAttribute(context, in)),
        m_attributeValues_(readAttributeValues(context, in, allocator)),
        m_attributeProperties_(readAttributeProperties(context, in, allocator)),
        m_attributeConditions_(readAttributeConditions(context, in, allocator))
{
}

LandmarkRoadSurfaceAttributeMap::LandmarkRoadSurfaceAttributeMap(const LandmarkRoadSurfaceAttributeMap& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_feature_(other.m_feature_),
        m_featureReferences_(other.m_featureReferences_),
        m_featureValidities_(other.m_featureValidities_),
        m_featureValuePtr_(other.m_featureValuePtr_),
        m_attribute_(other.m_attribute_),
        m_attributeValues_(other.m_attributeValues_),
        m_attributeProperties_(other.m_attributeProperties_),
        m_attributeConditions_(other.m_attributeConditions_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

LandmarkRoadSurfaceAttributeMap& LandmarkRoadSurfaceAttributeMap::operator=(const LandmarkRoadSurfaceAttributeMap& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_feature_ = other.m_feature_;
    m_featureReferences_ = other.m_featureReferences_;
    m_featureValidities_ = other.m_featureValidities_;
    m_featureValuePtr_ = other.m_featureValuePtr_;
    m_attribute_ = other.m_attribute_;
    m_attributeValues_ = other.m_attributeValues_;
    m_attributeProperties_ = other.m_attributeProperties_;
    m_attributeConditions_ = other.m_attributeConditions_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

LandmarkRoadSurfaceAttributeMap::LandmarkRoadSurfaceAttributeMap(LandmarkRoadSurfaceAttributeMap&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_feature_(::std::move(other.m_feature_)),
        m_featureReferences_(::std::move(other.m_featureReferences_)),
        m_featureValidities_(::std::move(other.m_featureValidities_)),
        m_featureValuePtr_(::std::move(other.m_featureValuePtr_)),
        m_attribute_(::std::move(other.m_attribute_)),
        m_attributeValues_(::std::move(other.m_attributeValues_)),
        m_attributeProperties_(::std::move(other.m_attributeProperties_)),
        m_attributeConditions_(::std::move(other.m_attributeConditions_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

LandmarkRoadSurfaceAttributeMap& LandmarkRoadSurfaceAttributeMap::operator=(LandmarkRoadSurfaceAttributeMap&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_feature_ = ::std::move(other.m_feature_);
    m_featureReferences_ = ::std::move(other.m_featureReferences_);
    m_featureValidities_ = ::std::move(other.m_featureValidities_);
    m_featureValuePtr_ = ::std::move(other.m_featureValuePtr_);
    m_attribute_ = ::std::move(other.m_attribute_);
    m_attributeValues_ = ::std::move(other.m_attributeValues_);
    m_attributeProperties_ = ::std::move(other.m_attributeProperties_);
    m_attributeConditions_ = ::std::move(other.m_attributeConditions_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

LandmarkRoadSurfaceAttributeMap::LandmarkRoadSurfaceAttributeMap(::zserio::PropagateAllocatorT,
        const LandmarkRoadSurfaceAttributeMap& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_feature_(::zserio::allocatorPropagatingCopy(other.m_feature_, allocator)),
        m_featureReferences_(::zserio::allocatorPropagatingCopy(other.m_featureReferences_, allocator)),
        m_featureValidities_(::zserio::allocatorPropagatingCopy(other.m_featureValidities_, allocator)),
        m_featureValuePtr_(::zserio::allocatorPropagatingCopy(other.m_featureValuePtr_, allocator)),
        m_attribute_(::zserio::allocatorPropagatingCopy(other.m_attribute_, allocator)),
        m_attributeValues_(::zserio::allocatorPropagatingCopy(other.m_attributeValues_, allocator)),
        m_attributeProperties_(::zserio::allocatorPropagatingCopy(other.m_attributeProperties_, allocator)),
        m_attributeConditions_(::zserio::allocatorPropagatingCopy(other.m_attributeConditions_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void LandmarkRoadSurfaceAttributeMap::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool LandmarkRoadSurfaceAttributeMap::isInitialized() const
{
    return m_isInitialized;
}

void LandmarkRoadSurfaceAttributeMap::initializeChildren()
{
    m_featureValidities_.initializeElements(*this);
    m_attributeValues_.initializeElements(*this);
    m_attributeProperties_.initializeElements(*this);
    m_attributeConditions_.initializeElements(*this);
}

::nds::core::geometry::CoordShift LandmarkRoadSurfaceAttributeMap::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'LandmarkRoadSurfaceAttributeMap' is not initialized!");

    return m_coordShift_;
}

::nds::localization::attributes::LandmarkRelationAttributeType LandmarkRoadSurfaceAttributeMap::getAttributeTypeCode() const
{
    return m_attributeTypeCode_;
}

void LandmarkRoadSurfaceAttributeMap::setAttributeTypeCode(::nds::localization::attributes::LandmarkRelationAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
}

::nds::core::attributemap::FeatureIterator LandmarkRoadSurfaceAttributeMap::getFeature() const
{
    return m_feature_;
}

void LandmarkRoadSurfaceAttributeMap::setFeature(::nds::core::attributemap::FeatureIterator feature_)
{
    m_feature_ = feature_;
}

::zserio::vector<::nds::lane::reference::types::RoadSurfaceId>& LandmarkRoadSurfaceAttributeMap::getFeatureReferences()
{
    return m_featureReferences_.getRawArray();
}

const ::zserio::vector<::nds::lane::reference::types::RoadSurfaceId>& LandmarkRoadSurfaceAttributeMap::getFeatureReferences() const
{
    return m_featureReferences_.getRawArray();
}

void LandmarkRoadSurfaceAttributeMap::setFeatureReferences(const ::zserio::vector<::nds::lane::reference::types::RoadSurfaceId>& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(featureReferences_);
}

void LandmarkRoadSurfaceAttributeMap::setFeatureReferences(::zserio::vector<::nds::lane::reference::types::RoadSurfaceId>&& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(std::move(featureReferences_));
}

::zserio::vector<::nds::core::attributemap::Validity>& LandmarkRoadSurfaceAttributeMap::getFeatureValidities()
{
    return m_featureValidities_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::Validity>& LandmarkRoadSurfaceAttributeMap::getFeatureValidities() const
{
    return m_featureValidities_.getRawArray();
}

void LandmarkRoadSurfaceAttributeMap::setFeatureValidities(const ::zserio::vector<::nds::core::attributemap::Validity>& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(featureValidities_);
}

void LandmarkRoadSurfaceAttributeMap::setFeatureValidities(::zserio::vector<::nds::core::attributemap::Validity>&& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(std::move(featureValidities_));
}

::zserio::vector<::nds::core::attributemap::AttributeIterator>& LandmarkRoadSurfaceAttributeMap::getFeatureValuePtr()
{
    return m_featureValuePtr_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& LandmarkRoadSurfaceAttributeMap::getFeatureValuePtr() const
{
    return m_featureValuePtr_.getRawArray();
}

void LandmarkRoadSurfaceAttributeMap::setFeatureValuePtr(const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(featureValuePtr_);
}

void LandmarkRoadSurfaceAttributeMap::setFeatureValuePtr(::zserio::vector<::nds::core::attributemap::AttributeIterator>&& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(std::move(featureValuePtr_));
}

::nds::core::attributemap::AttributeIterator LandmarkRoadSurfaceAttributeMap::getAttribute() const
{
    return m_attribute_;
}

void LandmarkRoadSurfaceAttributeMap::setAttribute(::nds::core::attributemap::AttributeIterator attribute_)
{
    m_attribute_ = attribute_;
}

::zserio::vector<::nds::localization::instantiations::LandmarkAttribute>& LandmarkRoadSurfaceAttributeMap::getAttributeValues()
{
    return m_attributeValues_.getRawArray();
}

const ::zserio::vector<::nds::localization::instantiations::LandmarkAttribute>& LandmarkRoadSurfaceAttributeMap::getAttributeValues() const
{
    return m_attributeValues_.getRawArray();
}

void LandmarkRoadSurfaceAttributeMap::setAttributeValues(const ::zserio::vector<::nds::localization::instantiations::LandmarkAttribute>& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(attributeValues_);
}

void LandmarkRoadSurfaceAttributeMap::setAttributeValues(::zserio::vector<::nds::localization::instantiations::LandmarkAttribute>&& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(std::move(attributeValues_));
}

::zserio::vector<::nds::localization::instantiations::LandmarkPropertyList>& LandmarkRoadSurfaceAttributeMap::getAttributeProperties()
{
    return m_attributeProperties_.getRawArray();
}

const ::zserio::vector<::nds::localization::instantiations::LandmarkPropertyList>& LandmarkRoadSurfaceAttributeMap::getAttributeProperties() const
{
    return m_attributeProperties_.getRawArray();
}

void LandmarkRoadSurfaceAttributeMap::setAttributeProperties(const ::zserio::vector<::nds::localization::instantiations::LandmarkPropertyList>& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(attributeProperties_);
}

void LandmarkRoadSurfaceAttributeMap::setAttributeProperties(::zserio::vector<::nds::localization::instantiations::LandmarkPropertyList>&& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(std::move(attributeProperties_));
}

::zserio::vector<::nds::core::attributemap::ConditionList>& LandmarkRoadSurfaceAttributeMap::getAttributeConditions()
{
    return m_attributeConditions_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::ConditionList>& LandmarkRoadSurfaceAttributeMap::getAttributeConditions() const
{
    return m_attributeConditions_.getRawArray();
}

void LandmarkRoadSurfaceAttributeMap::setAttributeConditions(const ::zserio::vector<::nds::core::attributemap::ConditionList>& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(attributeConditions_);
}

void LandmarkRoadSurfaceAttributeMap::setAttributeConditions(::zserio::vector<::nds::core::attributemap::ConditionList>&& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(std::move(attributeConditions_));
}

void LandmarkRoadSurfaceAttributeMap::initPackingContext(LandmarkRoadSurfaceAttributeMap::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getAttributeTypeCode(), m_attributeTypeCode_);
    context.getFeature().init<::zserio::VarSizeArrayTraits>(m_feature_);
    context.getAttribute().init<::zserio::VarSizeArrayTraits>(m_attribute_);
}

size_t LandmarkRoadSurfaceAttributeMap::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOf(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LandmarkRoadSurfaceAttributeMap::bitSizeOf(LandmarkRoadSurfaceAttributeMap::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getAttributeTypeCode(), m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOf(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LandmarkRoadSurfaceAttributeMap::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsets(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t LandmarkRoadSurfaceAttributeMap::initializeOffsets(LandmarkRoadSurfaceAttributeMap::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getAttributeTypeCode(), endBitPosition,
        m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsets(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool LandmarkRoadSurfaceAttributeMap::operator==(const LandmarkRoadSurfaceAttributeMap& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_feature_ == other.m_feature_) &&
                (m_featureReferences_ == other.m_featureReferences_) &&
                (m_featureValidities_ == other.m_featureValidities_) &&
                (m_featureValuePtr_ == other.m_featureValuePtr_) &&
                (m_attribute_ == other.m_attribute_) &&
                (m_attributeValues_ == other.m_attributeValues_) &&
                (m_attributeProperties_ == other.m_attributeProperties_) &&
                (m_attributeConditions_ == other.m_attributeConditions_);
    }

    return true;
}

uint32_t LandmarkRoadSurfaceAttributeMap::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_feature_);
    result = ::zserio::calcHashCode(result, m_featureReferences_);
    result = ::zserio::calcHashCode(result, m_featureValidities_);
    result = ::zserio::calcHashCode(result, m_featureValuePtr_);
    result = ::zserio::calcHashCode(result, m_attribute_);
    result = ::zserio::calcHashCode(result, m_attributeValues_);
    result = ::zserio::calcHashCode(result, m_attributeProperties_);
    result = ::zserio::calcHashCode(result, m_attributeConditions_);

    return result;
}

void LandmarkRoadSurfaceAttributeMap::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_attributeTypeCode_);

    out.alignTo(8);
    out.writeVarSize(m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field LandmarkRoadSurfaceAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field LandmarkRoadSurfaceAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.write(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field LandmarkRoadSurfaceAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    out.writeVarSize(m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field LandmarkRoadSurfaceAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field LandmarkRoadSurfaceAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field LandmarkRoadSurfaceAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void LandmarkRoadSurfaceAttributeMap::write(LandmarkRoadSurfaceAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getAttributeTypeCode(), out, m_attributeTypeCode_);

    out.alignTo(8);
    context.getFeature().write<::zserio::VarSizeArrayTraits>(out, m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field LandmarkRoadSurfaceAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field LandmarkRoadSurfaceAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.write(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field LandmarkRoadSurfaceAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    context.getAttribute().write<::zserio::VarSizeArrayTraits>(out, m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field LandmarkRoadSurfaceAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field LandmarkRoadSurfaceAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field LandmarkRoadSurfaceAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void LandmarkRoadSurfaceAttributeMap::ZserioElementFactory_featureReferences::create(LandmarkRoadSurfaceAttributeMap&        ,
        ::zserio::vector<::nds::lane::reference::types::RoadSurfaceId>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void LandmarkRoadSurfaceAttributeMap::ZserioElementFactory_featureReferences::create(LandmarkRoadSurfaceAttributeMap&        ,
        ::zserio::vector<::nds::lane::reference::types::RoadSurfaceId>& array,
        ::nds::lane::reference::types::RoadSurfaceId::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void LandmarkRoadSurfaceAttributeMap::ZserioArrayExpressions_featureValidities::initializeElement(LandmarkRoadSurfaceAttributeMap& owner,
        ::nds::core::attributemap::Validity& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void LandmarkRoadSurfaceAttributeMap::ZserioElementFactory_featureValidities::create(LandmarkRoadSurfaceAttributeMap&         owner,
        ::zserio::vector<::nds::core::attributemap::Validity>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void LandmarkRoadSurfaceAttributeMap::ZserioArrayExpressions_attributeValues::initializeElement(LandmarkRoadSurfaceAttributeMap& owner,
        ::nds::localization::instantiations::LandmarkAttribute& element, size_t)
{
    element.initialize(static_cast<::nds::localization::attributes::LandmarkRelationAttributeType>(owner.getAttributeTypeCode()));
}

void LandmarkRoadSurfaceAttributeMap::ZserioElementFactory_attributeValues::create(LandmarkRoadSurfaceAttributeMap&         owner,
        ::zserio::vector<::nds::localization::instantiations::LandmarkAttribute>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::localization::attributes::LandmarkRelationAttributeType>(owner.getAttributeTypeCode()), array.get_allocator());
}

void LandmarkRoadSurfaceAttributeMap::ZserioElementFactory_attributeValues::create(LandmarkRoadSurfaceAttributeMap&         owner,
        ::zserio::vector<::nds::localization::instantiations::LandmarkAttribute>& array,
        ::nds::localization::instantiations::LandmarkAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::localization::attributes::LandmarkRelationAttributeType>(owner.getAttributeTypeCode()), array.get_allocator());
}

void LandmarkRoadSurfaceAttributeMap::ZserioArrayExpressions_attributeProperties::initializeElement(LandmarkRoadSurfaceAttributeMap&,
        ::nds::localization::instantiations::LandmarkPropertyList& element, size_t)
{
    element.initializeChildren();
}

void LandmarkRoadSurfaceAttributeMap::ZserioElementFactory_attributeProperties::create(LandmarkRoadSurfaceAttributeMap&        ,
        ::zserio::vector<::nds::localization::instantiations::LandmarkPropertyList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void LandmarkRoadSurfaceAttributeMap::ZserioElementFactory_attributeProperties::create(LandmarkRoadSurfaceAttributeMap&        ,
        ::zserio::vector<::nds::localization::instantiations::LandmarkPropertyList>& array,
        ::nds::localization::instantiations::LandmarkPropertyList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void LandmarkRoadSurfaceAttributeMap::ZserioArrayExpressions_attributeConditions::initializeElement(LandmarkRoadSurfaceAttributeMap&,
        ::nds::core::attributemap::ConditionList& element, size_t)
{
    element.initializeChildren();
}

void LandmarkRoadSurfaceAttributeMap::ZserioElementFactory_attributeConditions::create(LandmarkRoadSurfaceAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void LandmarkRoadSurfaceAttributeMap::ZserioElementFactory_attributeConditions::create(LandmarkRoadSurfaceAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::nds::core::attributemap::ConditionList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::localization::attributes::LandmarkRelationAttributeType LandmarkRoadSurfaceAttributeMap::readAttributeTypeCode(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::localization::attributes::LandmarkRelationAttributeType>(in);
}

::nds::localization::attributes::LandmarkRelationAttributeType LandmarkRoadSurfaceAttributeMap::readAttributeTypeCode(LandmarkRoadSurfaceAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::localization::attributes::LandmarkRelationAttributeType>(context.getAttributeTypeCode(), in);
}
::nds::core::attributemap::FeatureIterator LandmarkRoadSurfaceAttributeMap::readFeature(::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return static_cast<::nds::core::attributemap::FeatureIterator>(in.readVarSize());
}

::nds::core::attributemap::FeatureIterator LandmarkRoadSurfaceAttributeMap::readFeature(LandmarkRoadSurfaceAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return context.getFeature().read<::zserio::VarSizeArrayTraits>(in);
}
LandmarkRoadSurfaceAttributeMap::ZserioArrayType_featureReferences LandmarkRoadSurfaceAttributeMap::readFeatureReferences(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

LandmarkRoadSurfaceAttributeMap::ZserioArrayType_featureReferences LandmarkRoadSurfaceAttributeMap::readFeatureReferences(LandmarkRoadSurfaceAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
LandmarkRoadSurfaceAttributeMap::ZserioArrayType_featureValidities LandmarkRoadSurfaceAttributeMap::readFeatureValidities(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValidities readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
LandmarkRoadSurfaceAttributeMap::ZserioArrayType_featureValuePtr LandmarkRoadSurfaceAttributeMap::readFeatureValuePtr(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}

LandmarkRoadSurfaceAttributeMap::ZserioArrayType_featureValuePtr LandmarkRoadSurfaceAttributeMap::readFeatureValuePtr(LandmarkRoadSurfaceAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}
::nds::core::attributemap::AttributeIterator LandmarkRoadSurfaceAttributeMap::readAttribute(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::attributemap::AttributeIterator>(in.readVarSize());
}

::nds::core::attributemap::AttributeIterator LandmarkRoadSurfaceAttributeMap::readAttribute(LandmarkRoadSurfaceAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getAttribute().read<::zserio::VarSizeArrayTraits>(in);
}
LandmarkRoadSurfaceAttributeMap::ZserioArrayType_attributeValues LandmarkRoadSurfaceAttributeMap::readAttributeValues(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributeValues readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

LandmarkRoadSurfaceAttributeMap::ZserioArrayType_attributeValues LandmarkRoadSurfaceAttributeMap::readAttributeValues(LandmarkRoadSurfaceAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributeValues readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
LandmarkRoadSurfaceAttributeMap::ZserioArrayType_attributeProperties LandmarkRoadSurfaceAttributeMap::readAttributeProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

LandmarkRoadSurfaceAttributeMap::ZserioArrayType_attributeProperties LandmarkRoadSurfaceAttributeMap::readAttributeProperties(LandmarkRoadSurfaceAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
LandmarkRoadSurfaceAttributeMap::ZserioArrayType_attributeConditions LandmarkRoadSurfaceAttributeMap::readAttributeConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

LandmarkRoadSurfaceAttributeMap::ZserioArrayType_attributeConditions LandmarkRoadSurfaceAttributeMap::readAttributeConditions(LandmarkRoadSurfaceAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

} // namespace instantiations
} // namespace localization
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/localization/instantiations/LandmarkAttribute.h>

namespace nds
{
namespace localization
{
namespace instantiations
{

LandmarkAttribute::LandmarkAttribute(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeValue_(allocator)
{
}

LandmarkAttribute::LandmarkAttribute(::zserio::BitStreamReader& in,
        ::nds::localization::attributes::LandmarkRelationAttributeType attributeTypeCode_, const allocator_type& allocator) :
        m_attributeTypeCode_(attributeTypeCode_),
        m_isInitialized(true),
        m_attributeValue_(readAttributeValue(in, allocator))
{
}

LandmarkAttribute::LandmarkAttribute(LandmarkAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::localization::attributes::LandmarkRelationAttributeType attributeTypeCode_, const allocator_type& allocator) :
        m_attributeTypeCode_(attributeTypeCode_),
        m_isInitialized(true),
        m_attributeValue_(readAttributeValue(context, in, allocator))
{
}

LandmarkAttribute::LandmarkAttribute(const LandmarkAttribute& other) :
        m_attributeValue_(other.m_attributeValue_)
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

LandmarkAttribute& LandmarkAttribute::operator=(const LandmarkAttribute& other)
{
    m_attributeValue_ = other.m_attributeValue_;
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;

    return *this;
}

LandmarkAttribute::LandmarkAttribute(LandmarkAttribute&& other) :
        m_attributeValue_(::std::move(other.m_attributeValue_))
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

LandmarkAttribute& LandmarkAttribute::operator=(LandmarkAttribute&& other)
{
    m_attributeValue_ = ::std::move(other.m_attributeValue_);
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;

    return *this;
}

LandmarkAttribute::LandmarkAttribute(::zserio::PropagateAllocatorT,
        const LandmarkAttribute& other, const allocator_type& allocator) :
        m_attributeValue_(::zserio::allocatorPropagatingCopy(other.m_attributeValue_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

void LandmarkAttribute::initialize(
        ::nds::localization::attributes::LandmarkRelationAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
    m_isInitialized = true;

    initializeChildren();
}

bool LandmarkAttribute::isInitialized() const
{
    return m_isInitialized;
}

void LandmarkAttribute::initializeChildren()
{
    m_attributeValue_.initialize(static_cast<::nds::localization::attributes::LandmarkRelationAttributeType>(getAttributeTypeCode()));
}

::nds::localization::attributes::LandmarkRelationAttributeType LandmarkAttribute::getAttributeTypeCode() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'attributeTypeCode' of compound 'LandmarkAttribute' is not initialized!");

    return m_attributeTypeCode_;
}

::nds::localization::attributes::LandmarkRelationAttributeValue& LandmarkAttribute::getAttributeValue()
{
    return m_attributeValue_;
}

const ::nds::localization::attributes::LandmarkRelationAttributeValue& LandmarkAttribute::getAttributeValue() const
{
    return m_attributeValue_;
}

void LandmarkAttribute::setAttributeValue(const ::nds::localization::attributes::LandmarkRelationAttributeValue& attributeValue_)
{
    m_attributeValue_ = attributeValue_;
}

void LandmarkAttribute::setAttributeValue(::nds::localization::attributes::LandmarkRelationAttributeValue&& attributeValue_)
{
    m_attributeValue_ = ::std::move(attributeValue_);
}

void LandmarkAttribute::initPackingContext(LandmarkAttribute::ZserioPackingContext& context) const
{
    m_attributeValue_.initPackingContext(context.getAttributeValue());
}

size_t LandmarkAttribute::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeValue_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LandmarkAttribute::bitSizeOf(LandmarkAttribute::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeValue_.bitSizeOf(context.getAttributeValue(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LandmarkAttribute::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeValue_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t LandmarkAttribute::initializeOffsets(LandmarkAttribute::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeValue_.initializeOffsets(context.getAttributeValue(), endBitPosition);

    return endBitPosition;
}

bool LandmarkAttribute::operator==(const LandmarkAttribute& other) const
{
    if (this != &other)
    {
        return
                (getAttributeTypeCode() == other.getAttributeTypeCode()) &&
                (m_attributeValue_ == other.m_attributeValue_);
    }

    return true;
}

uint32_t LandmarkAttribute::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getAttributeTypeCode());
    result = ::zserio::calcHashCode(result, m_attributeValue_);

    return result;
}

void LandmarkAttribute::write(::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::localization::attributes::LandmarkRelationAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field LandmarkAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::localization::attributes::LandmarkRelationAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(out);
}

void LandmarkAttribute::write(LandmarkAttribute::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::localization::attributes::LandmarkRelationAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field LandmarkAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::localization::attributes::LandmarkRelationAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(context.getAttributeValue(), out);
}

::nds::localization::attributes::LandmarkRelationAttributeValue LandmarkAttribute::readAttributeValue(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::localization::attributes::LandmarkRelationAttributeValue(in, static_cast<::nds::localization::attributes::LandmarkRelationAttributeType>(getAttributeTypeCode()), allocator);
}

::nds::localization::attributes::LandmarkRelationAttributeValue LandmarkAttribute::readAttributeValue(LandmarkAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::localization::attributes::LandmarkRelationAttributeValue(context.getAttributeValue(), in, static_cast<::nds::localization::attributes::LandmarkRelationAttributeType>(getAttributeTypeCode()), allocator);
}

} // namespace instantiations
} // namespace localization
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/localization/instantiations/LocalizationProperty.h>

namespace nds
{
namespace localization
{
namespace instantiations
{

LocalizationProperty::LocalizationProperty(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_propertyTypeCode_(allocator),
        m_propertyValue_(allocator)
{
}

LocalizationProperty::LocalizationProperty(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_propertyTypeCode_(readPropertyTypeCode(in, allocator)),
        m_propertyValue_(readPropertyValue(in, allocator))
{
}

LocalizationProperty::LocalizationProperty(LocalizationProperty::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_propertyTypeCode_(readPropertyTypeCode(context, in, allocator)),
        m_propertyValue_(readPropertyValue(context, in, allocator))
{
}

LocalizationProperty::LocalizationProperty(const LocalizationProperty& other) :
        m_propertyTypeCode_(other.m_propertyTypeCode_),
        m_propertyValue_(other.m_propertyValue_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

LocalizationProperty& LocalizationProperty::operator=(const LocalizationProperty& other)
{
    m_propertyTypeCode_ = other.m_propertyTypeCode_;
    m_propertyValue_ = other.m_propertyValue_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

LocalizationProperty::LocalizationProperty(LocalizationProperty&& other) :
        m_propertyTypeCode_(::std::move(other.m_propertyTypeCode_)),
        m_propertyValue_(::std::move(other.m_propertyValue_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

LocalizationProperty& LocalizationProperty::operator=(LocalizationProperty&& other)
{
    m_propertyTypeCode_ = ::std::move(other.m_propertyTypeCode_);
    m_propertyValue_ = ::std::move(other.m_propertyValue_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

LocalizationProperty::LocalizationProperty(::zserio::PropagateAllocatorT,
        const LocalizationProperty& other, const allocator_type& allocator) :
        m_propertyTypeCode_(::zserio::allocatorPropagatingCopy(other.m_propertyTypeCode_, allocator)),
        m_propertyValue_(::zserio::allocatorPropagatingCopy(other.m_propertyValue_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void LocalizationProperty::initializeChildren()
{
    m_propertyValue_.initialize(getPropertyTypeCode());

    m_areChildrenInitialized = true;
}

::nds::localization::properties::LocalizationPropertyType& LocalizationProperty::getPropertyTypeCode()
{
    return m_propertyTypeCode_;
}

const ::nds::localization::properties::LocalizationPropertyType& LocalizationProperty::getPropertyTypeCode() const
{
    return m_propertyTypeCode_;
}

void LocalizationProperty::setPropertyTypeCode(const ::nds::localization::properties::LocalizationPropertyType& propertyTypeCode_)
{
    m_propertyTypeCode_ = propertyTypeCode_;
}

void LocalizationProperty::setPropertyTypeCode(::nds::localization::properties::LocalizationPropertyType&& propertyTypeCode_)
{
    m_propertyTypeCode_ = ::std::move(propertyTypeCode_);
}

::nds::localization::properties::LocalizationPropertyValue& LocalizationProperty::getPropertyValue()
{
    return m_propertyValue_;
}

const ::nds::localization::properties::LocalizationPropertyValue& LocalizationProperty::getPropertyValue() const
{
    return m_propertyValue_;
}

void LocalizationProperty::setPropertyValue(const ::nds::localization::properties::LocalizationPropertyValue& propertyValue_)
{
    m_propertyValue_ = propertyValue_;
}

void LocalizationProperty::setPropertyValue(::nds::localization::properties::LocalizationPropertyValue&& propertyValue_)
{
    m_propertyValue_ = ::std::move(propertyValue_);
}

void LocalizationProperty::initPackingContext(LocalizationProperty::ZserioPackingContext& context) const
{
    m_propertyTypeCode_.initPackingContext(context.getPropertyTypeCode());
    m_propertyValue_.initPackingContext(context.getPropertyValue());
}

size_t LocalizationProperty::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_propertyTypeCode_.bitSizeOf(endBitPosition);
    endBitPosition += m_propertyValue_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LocalizationProperty::bitSizeOf(LocalizationProperty::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_propertyTypeCode_.bitSizeOf(context.getPropertyTypeCode(), endBitPosition);
    endBitPosition += m_propertyValue_.bitSizeOf(context.getPropertyValue(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LocalizationProperty::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_propertyTypeCode_.initializeOffsets(endBitPosition);
    endBitPosition = m_propertyValue_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t LocalizationProperty::initializeOffsets(LocalizationProperty::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_propertyTypeCode_.initializeOffsets(context.getPropertyTypeCode(), endBitPosition);
    endBitPosition = m_propertyValue_.initializeOffsets(context.getPropertyValue(), endBitPosition);

    return endBitPosition;
}

bool LocalizationProperty::operator==(const LocalizationProperty& other) const
{
    if (this != &other)
    {
        return
                (m_propertyTypeCode_ == other.m_propertyTypeCode_) &&
                (m_propertyValue_ == other.m_propertyValue_);
    }

    return true;
}

uint32_t LocalizationProperty::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_propertyTypeCode_);
    result = ::zserio::calcHashCode(result, m_propertyValue_);

    return result;
}

void LocalizationProperty::write(::zserio::BitStreamWriter& out) const
{
    m_propertyTypeCode_.write(out);

    // check parameters
    if (&(m_propertyValue_.getType()) != &(getPropertyTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Inconsistent parameter type for field LocalizationProperty.propertyValue!");
    }
    m_propertyValue_.write(out);
}

void LocalizationProperty::write(LocalizationProperty::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_propertyTypeCode_.write(context.getPropertyTypeCode(), out);

    // check parameters
    if (&(m_propertyValue_.getType()) != &(getPropertyTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Inconsistent parameter type for field LocalizationProperty.propertyValue!");
    }
    m_propertyValue_.write(context.getPropertyValue(), out);
}

::nds::localization::properties::LocalizationPropertyType LocalizationProperty::readPropertyTypeCode(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::localization::properties::LocalizationPropertyType(in, allocator);
}

::nds::localization::properties::LocalizationPropertyType LocalizationProperty::readPropertyTypeCode(LocalizationProperty::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::localization::properties::LocalizationPropertyType(context.getPropertyTypeCode(), in, allocator);
}
::nds::localization::properties::LocalizationPropertyValue LocalizationProperty::readPropertyValue(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::localization::properties::LocalizationPropertyValue(in, getPropertyTypeCode(), allocator);
}

::nds::localization::properties::LocalizationPropertyValue LocalizationProperty::readPropertyValue(LocalizationProperty::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::localization::properties::LocalizationPropertyValue(context.getPropertyValue(), in, getPropertyTypeCode(), allocator);
}

} // namespace instantiations
} // namespace localization
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/localization/instantiations/LandmarkAttributeSet.h>

namespace nds
{
namespace localization
{
namespace instantiations
{

LandmarkAttributeSet::LandmarkAttributeSet(const allocator_type& allocator) noexcept :
        m_numEntries_(uint32_t()),
        m_attributes_(allocator)
{
}

LandmarkAttributeSet::LandmarkAttributeSet(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numEntries_(readNumEntries(in)),
        m_attributes_(readAttributes(in, allocator))
{
}

LandmarkAttributeSet::LandmarkAttributeSet(LandmarkAttributeSet::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numEntries_(readNumEntries(context, in)),
        m_attributes_(readAttributes(context, in, allocator))
{
}

LandmarkAttributeSet::LandmarkAttributeSet(::zserio::PropagateAllocatorT,
        const LandmarkAttributeSet& other, const allocator_type& allocator) :
        m_numEntries_(::zserio::allocatorPropagatingCopy(other.m_numEntries_, allocator)),
        m_attributes_(::zserio::allocatorPropagatingCopy(other.m_attributes_, allocator))
{
}

void LandmarkAttributeSet::initializeChildren()
{
    m_attributes_.initializeElements(*this);
}

uint32_t LandmarkAttributeSet::getNumEntries() const
{
    return m_numEntries_;
}

void LandmarkAttributeSet::setNumEntries(uint32_t numEntries_)
{
    m_numEntries_ = numEntries_;
}

::zserio::vector<::nds::localization::instantiations::LandmarkFullAttribute>& LandmarkAttributeSet::getAttributes()
{
    return m_attributes_.getRawArray();
}

const ::zserio::vector<::nds::localization::instantiations::LandmarkFullAttribute>& LandmarkAttributeSet::getAttributes() const
{
    return m_attributes_.getRawArray();
}

void LandmarkAttributeSet::setAttributes(const ::zserio::vector<::nds::localization::instantiations::LandmarkFullAttribute>& attributes_)
{
    m_attributes_ = ZserioArrayType_attributes(attributes_);
}

void LandmarkAttributeSet::setAttributes(::zserio::vector<::nds::localization::instantiations::LandmarkFullAttribute>&& attributes_)
{
    m_attributes_ = ZserioArrayType_attributes(std::move(attributes_));
}

void LandmarkAttributeSet::initPackingContext(LandmarkAttributeSet::ZserioPackingContext& context) const
{
    context.getNumEntries().init<::zserio::VarSizeArrayTraits>(m_numEntries_);
}

size_t LandmarkAttributeSet::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numEntries_);
    endBitPosition += m_attributes_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LandmarkAttributeSet::bitSizeOf(LandmarkAttributeSet::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumEntries().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numEntries_);
    endBitPosition += m_attributes_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LandmarkAttributeSet::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numEntries_);
    endBitPosition = m_attributes_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t LandmarkAttributeSet::initializeOffsets(LandmarkAttributeSet::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumEntries().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numEntries_);
    endBitPosition = m_attributes_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool LandmarkAttributeSet::operator==(const LandmarkAttributeSet& other) const
{
    if (this != &other)
    {
        return
                (m_numEntries_ == other.m_numEntries_) &&
                (m_attributes_ == other.m_attributes_);
    }

    return true;
}

uint32_t LandmarkAttributeSet::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_numEntries_);
    result = ::zserio::calcHashCode(result, m_attributes_);

    return result;
}

void LandmarkAttributeSet::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numEntries_);

    // check array length
    if (m_attributes_.getRawArray().size() != static_cast<size_t>(getNumEntries()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field LandmarkAttributeSet.attributes: ") <<
                m_attributes_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumEntries()) << "!";
    }
    m_attributes_.writePacked(*this, out);
}

void LandmarkAttributeSet::write(LandmarkAttributeSet::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumEntries().write<::zserio::VarSizeArrayTraits>(out, m_numEntries_);

    // check array length
    if (m_attributes_.getRawArray().size() != static_cast<size_t>(getNumEntries()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field LandmarkAttributeSet.attributes: ") <<
                m_attributes_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumEntries()) << "!";
    }
    m_attributes_.writePacked(*this, out);
}

void LandmarkAttributeSet::ZserioArrayExpressions_attributes::initializeElement(LandmarkAttributeSet&,
        ::nds::localization::instantiations::LandmarkFullAttribute& element, size_t)
{
    element.initializeChildren();
}

void LandmarkAttributeSet::ZserioElementFactory_attributes::create(LandmarkAttributeSet&        ,
        ::zserio::vector<::nds::localization::instantiations::LandmarkFullAttribute>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void LandmarkAttributeSet::ZserioElementFactory_attributes::create(LandmarkAttributeSet&        ,
        ::zserio::vector<::nds::localization::instantiations::LandmarkFullAttribute>& array,
        ::nds::localization::instantiations::LandmarkFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

uint32_t LandmarkAttributeSet::readNumEntries(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t LandmarkAttributeSet::readNumEntries(LandmarkAttributeSet::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumEntries().read<::zserio::VarSizeArrayTraits>(in);
}
LandmarkAttributeSet::ZserioArrayType_attributes LandmarkAttributeSet::readAttributes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributes readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumEntries()));

    return readField;
}

LandmarkAttributeSet::ZserioArrayType_attributes LandmarkAttributeSet::readAttributes(LandmarkAttributeSet::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributes readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumEntries()));

    return readField;
}

} // namespace instantiations
} // namespace localization
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/localization/instantiations/LandmarkFullAttribute.h>

namespace nds
{
namespace localization
{
namespace instantiations
{

LandmarkFullAttribute::LandmarkFullAttribute(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_attributeTypeCode_(::nds::localization::attributes::LandmarkRelationAttributeType()),
        m_attributeValue_(allocator),
        m_properties_(::zserio::NullOpt),
        m_conditions_(::zserio::NullOpt)
{
}

LandmarkFullAttribute::LandmarkFullAttribute(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in)),
        m_attributeValue_(readAttributeValue(in, allocator)),
        m_properties_(readProperties(in, allocator)),
        m_conditions_(readConditions(in, allocator))
{
}

LandmarkFullAttribute::LandmarkFullAttribute(LandmarkFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in)),
        m_attributeValue_(readAttributeValue(context, in, allocator)),
        m_properties_(readProperties(context, in, allocator)),
        m_conditions_(readConditions(context, in, allocator))
{
}

LandmarkFullAttribute::LandmarkFullAttribute(const LandmarkFullAttribute& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_attributeValue_(other.m_attributeValue_),
        m_properties_(other.m_properties_),
        m_conditions_(other.m_conditions_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

LandmarkFullAttribute& LandmarkFullAttribute::operator=(const LandmarkFullAttribute& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_attributeValue_ = other.m_attributeValue_;
    m_properties_ = other.m_properties_;
    m_conditions_ = other.m_conditions_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

LandmarkFullAttribute::LandmarkFullAttribute(LandmarkFullAttribute&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_attributeValue_(::std::move(other.m_attributeValue_)),
        m_properties_(::std::move(other.m_properties_)),
        m_conditions_(::std::move(other.m_conditions_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

LandmarkFullAttribute& LandmarkFullAttribute::operator=(LandmarkFullAttribute&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_attributeValue_ = ::std::move(other.m_attributeValue_);
    m_properties_ = ::std::move(other.m_properties_);
    m_conditions_ = ::std::move(other.m_conditions_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

LandmarkFullAttribute::LandmarkFullAttribute(::zserio::PropagateAllocatorT,
        const LandmarkFullAttribute& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_attributeValue_(::zserio::allocatorPropagatingCopy(other.m_attributeValue_, allocator)),
        m_properties_(::zserio::allocatorPropagatingCopy(other.m_properties_, allocator)),
        m_conditions_(::zserio::allocatorPropagatingCopy(other.m_conditions_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void LandmarkFullAttribute::initializeChildren()
{
    m_attributeValue_.initialize(static_cast<::nds::localization::attributes::LandmarkRelationAttributeType>(getAttributeTypeCode()));
    if (isPropertiesSet())
        m_properties_.value().initializeChildren();
    if (isConditionsSet())
        m_conditions_.value().initializeChildren();

    m_areChildrenInitialized = true;
}

::nds::localization::attributes::LandmarkRelationAttributeType LandmarkFullAttribute::getAttributeTypeCode() const
{
    return m_attributeTypeCode_;
}

void LandmarkFullAttribute::setAttributeTypeCode(::nds::localization::attributes::LandmarkRelationAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
}

::nds::localization::attributes::LandmarkRelationAttributeValue& LandmarkFullAttribute::getAttributeValue()
{
    return m_attributeValue_;
}

const ::nds::localization::attributes::LandmarkRelationAttributeValue& LandmarkFullAttribute::getAttributeValue() const
{
    return m_attributeValue_;
}

void LandmarkFullAttribute::setAttributeValue(const ::nds::localization::attributes::LandmarkRelationAttributeValue& attributeValue_)
{
    m_attributeValue_ = attributeValue_;
}

void LandmarkFullAttribute::setAttributeValue(::nds::localization::attributes::LandmarkRelationAttributeValue&& attributeValue_)
{
    m_attributeValue_ = ::std::move(attributeValue_);
}

::nds::localization::instantiations::LandmarkPropertyList& LandmarkFullAttribute::getProperties()
{
    return m_properties_.value();
}

const ::nds::localization::instantiations::LandmarkPropertyList& LandmarkFullAttribute::getProperties() const
{
    return m_properties_.value();
}

void LandmarkFullAttribute::setProperties(const ::nds::localization::instantiations::LandmarkPropertyList& properties_)
{
    m_properties_ = properties_;
}

void LandmarkFullAttribute::setProperties(::nds::localization::instantiations::LandmarkPropertyList&& properties_)
{
    m_properties_ = ::std::move(properties_);
}

bool LandmarkFullAttribute::isPropertiesUsed() const
{
    return (isPropertiesSet());
}

bool LandmarkFullAttribute::isPropertiesSet() const
{
    return m_properties_.hasValue();
}

void LandmarkFullAttribute::resetProperties()
{
    m_properties_.reset();
}

::nds::core::attributemap::ConditionList& LandmarkFullAttribute::getConditions()
{
    return m_conditions_.value();
}

const ::nds::core::attributemap::ConditionList& LandmarkFullAttribute::getConditions() const
{
    return m_conditions_.value();
}

void LandmarkFullAttribute::setConditions(const ::nds::core::attributemap::ConditionList& conditions_)
{
    m_conditions_ = conditions_;
}

void LandmarkFullAttribute::setConditions(::nds::core::attributemap::ConditionList&& conditions_)
{
    m_conditions_ = ::std::move(conditions_);
}

bool LandmarkFullAttribute::isConditionsUsed() const
{
    return (isConditionsSet());
}

bool LandmarkFullAttribute::isConditionsSet() const
{
    return m_conditions_.hasValue();
}

void LandmarkFullAttribute::resetConditions()
{
    m_conditions_.reset();
}

void LandmarkFullAttribute::initPackingContext(LandmarkFullAttribute::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getAttributeTypeCode(), m_attributeTypeCode_);
    m_attributeValue_.initPackingContext(context.getAttributeValue());
    if (isPropertiesSet())
    {
        m_properties_.value().initPackingContext(context.getProperties());
    }
    if (isConditionsSet())
    {
        m_conditions_.value().initPackingContext(context.getConditions());
    }
}

size_t LandmarkFullAttribute::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_attributeTypeCode_);
    endBitPosition += m_attributeValue_.bitSizeOf(endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition += m_properties_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition += m_conditions_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t LandmarkFullAttribute::bitSizeOf(LandmarkFullAttribute::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getAttributeTypeCode(), m_attributeTypeCode_);
    endBitPosition += m_attributeValue_.bitSizeOf(context.getAttributeValue(), endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition += m_properties_.value().bitSizeOf(context.getProperties(), endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition += m_conditions_.value().bitSizeOf(context.getConditions(), endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t LandmarkFullAttribute::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_attributeTypeCode_);
    endBitPosition = m_attributeValue_.initializeOffsets(endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition = m_properties_.value().initializeOffsets(endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition = m_conditions_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

size_t LandmarkFullAttribute::initializeOffsets(LandmarkFullAttribute::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getAttributeTypeCode(), endBitPosition,
        m_attributeTypeCode_);
    endBitPosition = m_attributeValue_.initializeOffsets(context.getAttributeValue(), endBitPosition);
    endBitPosition += 1;
    if (isPropertiesSet())
    {
        endBitPosition = m_properties_.value().initializeOffsets(context.getProperties(), endBitPosition);
    }
    endBitPosition += 1;
    if (isConditionsSet())
    {
        endBitPosition = m_conditions_.value().initializeOffsets(context.getConditions(), endBitPosition);
    }

    return endBitPosition;
}

bool LandmarkFullAttribute::operator==(const LandmarkFullAttribute& other) const
{
    if (this != &other)
    {
        return
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_attributeValue_ == other.m_attributeValue_) &&
                (!isPropertiesUsed() ? !other.isPropertiesUsed() : (m_properties_ == other.m_properties_)) &&
                (!isConditionsUsed() ? !other.isConditionsUsed() : (m_conditions_ == other.m_conditions_));
    }

    return true;
}

uint32_t LandmarkFullAttribute::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_attributeValue_);
    if (isPropertiesUsed())
        result = ::zserio::calcHashCode(result, m_properties_);
    if (isConditionsUsed())
        result = ::zserio::calcHashCode(result, m_conditions_);

    return result;
}

void LandmarkFullAttribute::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_attributeTypeCode_);

    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::localization::attributes::LandmarkRelationAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field LandmarkFullAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::localization::attributes::LandmarkRelationAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(out);

    if (isPropertiesSet())
    {
        out.writeBool(true);
        m_properties_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isConditionsSet())
    {
        out.writeBool(true);
        m_conditions_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
}

void LandmarkFullAttribute::write(LandmarkFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getAttributeTypeCode(), out, m_attributeTypeCode_);

    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::localization::attributes::LandmarkRelationAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field LandmarkFullAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::localization::attributes::LandmarkRelationAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(context.getAttributeValue(), out);

    if (isPropertiesSet())
    {
        out.writeBool(true);
        m_properties_.value().write(context.getProperties(), out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isConditionsSet())
    {
        out.writeBool(true);
        m_conditions_.value().write(context.getConditions(), out);
    }
    else
    {
        out.writeBool(false);
    }
}

::nds::localization::attributes::LandmarkRelationAttributeType LandmarkFullAttribute::readAttributeTypeCode(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::localization::attributes::LandmarkRelationAttributeType>(in);
}

::nds::localization::attributes::LandmarkRelationAttributeType LandmarkFullAttribute::readAttributeTypeCode(LandmarkFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::localization::attributes::LandmarkRelationAttributeType>(context.getAttributeTypeCode(), in);
}
::nds::localization::attributes::LandmarkRelationAttributeValue LandmarkFullAttribute::readAttributeValue(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::localization::attributes::LandmarkRelationAttributeValue(in, static_cast<::nds::localization::attributes::LandmarkRelationAttributeType>(getAttributeTypeCode()), allocator);
}

::nds::localization::attributes::LandmarkRelationAttributeValue LandmarkFullAttribute::readAttributeValue(LandmarkFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::localization::attributes::LandmarkRelationAttributeValue(context.getAttributeValue(), in, static_cast<::nds::localization::attributes::LandmarkRelationAttributeType>(getAttributeTypeCode()), allocator);
}
::zserio::InplaceOptionalHolder<::nds::localization::instantiations::LandmarkPropertyList> LandmarkFullAttribute::readProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::localization::instantiations::LandmarkPropertyList>(::nds::localization::instantiations::LandmarkPropertyList(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::localization::instantiations::LandmarkPropertyList>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::localization::instantiations::LandmarkPropertyList> LandmarkFullAttribute::readProperties(LandmarkFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::localization::instantiations::LandmarkPropertyList>(::nds::localization::instantiations::LandmarkPropertyList(context.getProperties(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::localization::instantiations::LandmarkPropertyList>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList> LandmarkFullAttribute::readConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::nds::core::attributemap::ConditionList(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList> LandmarkFullAttribute::readConditions(LandmarkFullAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::nds::core::attributemap::ConditionList(context.getConditions(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::attributemap::ConditionList>(::zserio::NullOpt);
}

} // namespace instantiations
} // namespace localization
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/localization/instantiations/LandmarkPropertyList.h>

namespace nds
{
namespace localization
{
namespace instantiations
{

LandmarkPropertyList::LandmarkPropertyList(const allocator_type&) noexcept :
        m_numProperties_(uint8_t()),
        m_property_(::zserio::NullOpt)
{
}

LandmarkPropertyList::LandmarkPropertyList(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numProperties_(readNumProperties(in)),
        m_property_(readProperty(in, allocator))
{
}

LandmarkPropertyList::LandmarkPropertyList(LandmarkPropertyList::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numProperties_(readNumProperties(context, in)),
        m_property_(readProperty(context, in, allocator))
{
}

LandmarkPropertyList::LandmarkPropertyList(::zserio::PropagateAllocatorT,
        const LandmarkPropertyList& other, const allocator_type& allocator) :
        m_numProperties_(::zserio::allocatorPropagatingCopy(other.m_numProperties_, allocator)),
        m_property_(::zserio::allocatorPropagatingCopy(other.m_property_, allocator))
{
}

void LandmarkPropertyList::initializeChildren()
{
    if (getNumProperties() > 0)
        m_property_.value().initializeElements(*this);
}

uint8_t LandmarkPropertyList::getNumProperties() const
{
    return m_numProperties_;
}

void LandmarkPropertyList::setNumProperties(uint8_t numProperties_)
{
    m_numProperties_ = numProperties_;
}

::zserio::vector<::nds::localization::instantiations::LocalizationProperty>& LandmarkPropertyList::getProperty()
{
    return m_property_.value().getRawArray();
}

const ::zserio::vector<::nds::localization::instantiations::LocalizationProperty>& LandmarkPropertyList::getProperty() const
{
    return m_property_.value().getRawArray();
}

void LandmarkPropertyList::setProperty(const ::zserio::vector<::nds::localization::instantiations::LocalizationProperty>& property_)
{
    m_property_ = ZserioArrayType_property(property_);
}

void LandmarkPropertyList::setProperty(::zserio::vector<::nds::localization::instantiations::LocalizationProperty>&& property_)
{
    m_property_ = ZserioArrayType_property(std::move(property_));
}

bool LandmarkPropertyList::isPropertyUsed() const
{
    return (getNumProperties() > 0);
}

bool LandmarkPropertyList::isPropertySet() const
{
    return m_property_.hasValue();
}

void LandmarkPropertyList::resetProperty()
{
    m_property_.reset();
}

void LandmarkPropertyList::initPackingContext(LandmarkPropertyList::ZserioPackingContext& context) const
{
    context.getNumProperties().init<::zserio::StdIntArrayTraits<uint8_t>>(m_numProperties_);
}

size_t LandmarkPropertyList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(8);
    if (getNumProperties() > 0)
    {
        endBitPosition += m_property_.value().bitSizeOfPacked(*this, endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t LandmarkPropertyList::bitSizeOf(LandmarkPropertyList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumProperties().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_numProperties_);
    if (getNumProperties() > 0)
    {
        endBitPosition += m_property_.value().bitSizeOfPacked(*this, endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t LandmarkPropertyList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(8);
    if (getNumProperties() > 0)
    {
        endBitPosition = m_property_.value().initializeOffsetsPacked(*this, endBitPosition);
    }

    return endBitPosition;
}

size_t LandmarkPropertyList::initializeOffsets(LandmarkPropertyList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumProperties().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_numProperties_);
    if (getNumProperties() > 0)
    {
        endBitPosition = m_property_.value().initializeOffsetsPacked(*this, endBitPosition);
    }

    return endBitPosition;
}

bool LandmarkPropertyList::operator==(const LandmarkPropertyList& other) const
{
    if (this != &other)
    {
        return
                (m_numProperties_ == other.m_numProperties_) &&
                (!isPropertyUsed() ? !other.isPropertyUsed() : (m_property_ == other.m_property_));
    }

    return true;
}

uint32_t LandmarkPropertyList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_numProperties_);
    if (isPropertyUsed())
        result = ::zserio::calcHashCode(result, m_property_);

    return result;
}

void LandmarkPropertyList::write(::zserio::BitStreamWriter& out) const
{
    out.writeBits(m_numProperties_, UINT8_C(8));

    if (getNumProperties() > 0)
    {
        // check array length
        if (m_property_.value().getRawArray().size() != static_cast<size_t>(getNumProperties()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field LandmarkPropertyList.property: ") <<
                    m_property_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumProperties()) << "!";
        }
        m_property_.value().writePacked(*this, out);
    }
}

void LandmarkPropertyList::write(LandmarkPropertyList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumProperties().write<::zserio::StdIntArrayTraits<uint8_t>>(out, m_numProperties_);

    if (getNumProperties() > 0)
    {
        // check array length
        if (m_property_.value().getRawArray().size() != static_cast<size_t>(getNumProperties()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field LandmarkPropertyList.property: ") <<
                    m_property_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumProperties()) << "!";
        }
        m_property_.value().writePacked(*this, out);
    }
}

void LandmarkPropertyList::ZserioArrayExpressions_property::initializeElement(LandmarkPropertyList&,
        ::nds::localization::instantiations::LocalizationProperty& element, size_t)
{
    element.initializeChildren();
}

void LandmarkPropertyList::ZserioElementFactory_property::create(LandmarkPropertyList&        ,
        ::zserio::vector<::nds::localization::instantiations::LocalizationProperty>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void LandmarkPropertyList::ZserioElementFactory_property::create(LandmarkPropertyList&        ,
        ::zserio::vector<::nds::localization::instantiations::LocalizationProperty>& array,
        ::nds::localization::instantiations::LocalizationProperty::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

uint8_t LandmarkPropertyList::readNumProperties(::zserio::BitStreamReader& in)
{
    return static_cast<uint8_t>(in.readBits(UINT8_C(8)));
}

uint8_t LandmarkPropertyList::readNumProperties(LandmarkPropertyList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumProperties().read<::zserio::StdIntArrayTraits<uint8_t>>(in);
}
::zserio::InplaceOptionalHolder<LandmarkPropertyList::ZserioArrayType_property> LandmarkPropertyList::readProperty(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getNumProperties() > 0)
    {
        ZserioArrayType_property readField(allocator);
        readField.readPacked(*this, in, static_cast<size_t>(getNumProperties()));

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_property>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_property>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<LandmarkPropertyList::ZserioArrayType_property> LandmarkPropertyList::readProperty(LandmarkPropertyList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getNumProperties() > 0)
    {
        ZserioArrayType_property readField(allocator);
        readField.readPacked(*this, in, static_cast<size_t>(getNumProperties()));

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_property>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_property>(::zserio::NullOpt);
}

} // namespace instantiations
} // namespace localization
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/localization/instantiations/LandmarkLaneAttributeSetMap.h>

namespace nds
{
namespace localization
{
namespace instantiations
{

LandmarkLaneAttributeSetMap::LandmarkLaneAttributeSetMap(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeSet_(allocator),
        m_feature_(::nds::core::attributemap::FeatureIterator()),
        m_references_(allocator),
        m_validities_(allocator)
{
}

LandmarkLaneAttributeSetMap::LandmarkLaneAttributeSetMap(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeSet_(readAttributeSet(in, allocator)),
        m_feature_(readFeature(in)),
        m_references_(readReferences(in, allocator)),
        m_validities_(readValidities(in, allocator))
{
}

LandmarkLaneAttributeSetMap::LandmarkLaneAttributeSetMap(LandmarkLaneAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeSet_(readAttributeSet(context, in, allocator)),
        m_feature_(readFeature(context, in)),
        m_references_(readReferences(context, in, allocator)),
        m_validities_(readValidities(context, in, allocator))
{
}

LandmarkLaneAttributeSetMap::LandmarkLaneAttributeSetMap(const LandmarkLaneAttributeSetMap& other) :
        m_attributeSet_(other.m_attributeSet_),
        m_feature_(other.m_feature_),
        m_references_(other.m_references_),
        m_validities_(other.m_validities_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

LandmarkLaneAttributeSetMap& LandmarkLaneAttributeSetMap::operator=(const LandmarkLaneAttributeSetMap& other)
{
    m_attributeSet_ = other.m_attributeSet_;
    m_feature_ = other.m_feature_;
    m_references_ = other.m_references_;
    m_validities_ = other.m_validities_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

LandmarkLaneAttributeSetMap::LandmarkLaneAttributeSetMap(LandmarkLaneAttributeSetMap&& other) :
        m_attributeSet_(::std::move(other.m_attributeSet_)),
        m_feature_(::std::move(other.m_feature_)),
        m_references_(::std::move(other.m_references_)),
        m_validities_(::std::move(other.m_validities_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

LandmarkLaneAttributeSetMap& LandmarkLaneAttributeSetMap::operator=(LandmarkLaneAttributeSetMap&& other)
{
    m_attributeSet_ = ::std::move(other.m_attributeSet_);
    m_feature_ = ::std::move(other.m_feature_);
    m_references_ = ::std::move(other.m_references_);
    m_validities_ = ::std::move(other.m_validities_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

LandmarkLaneAttributeSetMap::LandmarkLaneAttributeSetMap(::zserio::PropagateAllocatorT,
        const LandmarkLaneAttributeSetMap& other, const allocator_type& allocator) :
        m_attributeSet_(::zserio::allocatorPropagatingCopy(other.m_attributeSet_, allocator)),
        m_feature_(::zserio::allocatorPropagatingCopy(other.m_feature_, allocator)),
        m_references_(::zserio::allocatorPropagatingCopy(other.m_references_, allocator)),
        m_validities_(::zserio::allocatorPropagatingCopy(other.m_validities_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void LandmarkLaneAttributeSetMap::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool LandmarkLaneAttributeSetMap::isInitialized() const
{
    return m_isInitialized;
}

void LandmarkLaneAttributeSetMap::initializeChildren()
{
    m_attributeSet_.initializeChildren();
    m_validities_.initializeElements(*this);
}

::nds::core::geometry::CoordShift LandmarkLaneAttributeSetMap::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'LandmarkLaneAttributeSetMap' is not initialized!");

    return m_coordShift_;
}

::nds::localization::instantiations::LandmarkAttributeSet& LandmarkLaneAttributeSetMap::getAttributeSet()
{
    return m_attributeSet_;
}

const ::nds::localization::instantiations::LandmarkAttributeSet& LandmarkLaneAttributeSetMap::getAttributeSet() const
{
    return m_attributeSet_;
}

void LandmarkLaneAttributeSetMap::setAttributeSet(const ::nds::localization::instantiations::LandmarkAttributeSet& attributeSet_)
{
    m_attributeSet_ = attributeSet_;
}

void LandmarkLaneAttributeSetMap::setAttributeSet(::nds::localization::instantiations::LandmarkAttributeSet&& attributeSet_)
{
    m_attributeSet_ = ::std::move(attributeSet_);
}

::nds::core::attributemap::FeatureIterator LandmarkLaneAttributeSetMap::getFeature() const
{
    return m_feature_;
}

void LandmarkLaneAttributeSetMap::setFeature(::nds::core::attributemap::FeatureIterator feature_)
{
    m_feature_ = feature_;
}

::zserio::vector<::nds::lane::reference::types::LaneGroupId>& LandmarkLaneAttributeSetMap::getReferences()
{
    return m_references_.getRawArray();
}

const ::zserio::vector<::nds::lane::reference::types::LaneGroupId>& LandmarkLaneAttributeSetMap::getReferences() const
{
    return m_references_.getRawArray();
}

void LandmarkLaneAttributeSetMap::setReferences(const ::zserio::vector<::nds::lane::reference::types::LaneGroupId>& references_)
{
    m_references_ = ZserioArrayType_references(references_);
}

void LandmarkLaneAttributeSetMap::setReferences(::zserio::vector<::nds::lane::reference::types::LaneGroupId>&& references_)
{
    m_references_ = ZserioArrayType_references(std::move(references_));
}

::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>& LandmarkLaneAttributeSetMap::getValidities()
{
    return m_validities_.getRawArray();
}

const ::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>& LandmarkLaneAttributeSetMap::getValidities() const
{
    return m_validities_.getRawArray();
}

void LandmarkLaneAttributeSetMap::setValidities(const ::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>& validities_)
{
    m_validities_ = ZserioArrayType_validities(validities_);
}

void LandmarkLaneAttributeSetMap::setValidities(::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>&& validities_)
{
    m_validities_ = ZserioArrayType_validities(std::move(validities_));
}

void LandmarkLaneAttributeSetMap::initPackingContext(LandmarkLaneAttributeSetMap::ZserioPackingContext& context) const
{
    m_attributeSet_.initPackingContext(context.getAttributeSet());
    context.getFeature().init<::zserio::VarSizeArrayTraits>(m_feature_);
}

size_t LandmarkLaneAttributeSetMap::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeSet_.bitSizeOf(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition += m_references_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_validities_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LandmarkLaneAttributeSetMap::bitSizeOf(LandmarkLaneAttributeSetMap::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeSet_.bitSizeOf(context.getAttributeSet(), endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition += m_references_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_validities_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LandmarkLaneAttributeSetMap::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeSet_.initializeOffsets(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition = m_references_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_validities_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t LandmarkLaneAttributeSetMap::initializeOffsets(LandmarkLaneAttributeSetMap::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeSet_.initializeOffsets(context.getAttributeSet(), endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition = m_references_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_validities_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool LandmarkLaneAttributeSetMap::operator==(const LandmarkLaneAttributeSetMap& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_attributeSet_ == other.m_attributeSet_) &&
                (m_feature_ == other.m_feature_) &&
                (m_references_ == other.m_references_) &&
                (m_validities_ == other.m_validities_);
    }

    return true;
}

uint32_t LandmarkLaneAttributeSetMap::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_attributeSet_);
    result = ::zserio::calcHashCode(result, m_feature_);
    result = ::zserio::calcHashCode(result, m_references_);
    result = ::zserio::calcHashCode(result, m_validities_);

    return result;
}

void LandmarkLaneAttributeSetMap::write(::zserio::BitStreamWriter& out) const
{
    m_attributeSet_.write(out);

    out.writeVarSize(m_feature_);

    // check array length
    if (m_references_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field LandmarkLaneAttributeSetMap.references: ") <<
                m_references_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_references_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_validities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field LandmarkLaneAttributeSetMap.validities: ") <<
                m_validities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_validities_.writePacked(*this, out);
}

void LandmarkLaneAttributeSetMap::write(LandmarkLaneAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_attributeSet_.write(context.getAttributeSet(), out);

    context.getFeature().write<::zserio::VarSizeArrayTraits>(out, m_feature_);

    // check array length
    if (m_references_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field LandmarkLaneAttributeSetMap.references: ") <<
                m_references_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_references_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_validities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field LandmarkLaneAttributeSetMap.validities: ") <<
                m_validities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_validities_.writePacked(*this, out);
}

void LandmarkLaneAttributeSetMap::ZserioElementFactory_references::create(LandmarkLaneAttributeSetMap&        ,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupId>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void LandmarkLaneAttributeSetMap::ZserioElementFactory_references::create(LandmarkLaneAttributeSetMap&        ,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupId>& array,
        ::nds::lane::reference::types::LaneGroupId::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void LandmarkLaneAttributeSetMap::ZserioArrayExpressions_validities::initializeElement(LandmarkLaneAttributeSetMap& owner,
        ::nds::lane::reference::types::LaneGroupRangeValidity& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void LandmarkLaneAttributeSetMap::ZserioElementFactory_validities::create(LandmarkLaneAttributeSetMap&         owner,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void LandmarkLaneAttributeSetMap::ZserioElementFactory_validities::create(LandmarkLaneAttributeSetMap&         owner,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>& array,
        ::nds::lane::reference::types::LaneGroupRangeValidity::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

::nds::localization::instantiations::LandmarkAttributeSet LandmarkLaneAttributeSetMap::readAttributeSet(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::localization::instantiations::LandmarkAttributeSet(in, allocator);
}

::nds::localization::instantiations::LandmarkAttributeSet LandmarkLaneAttributeSetMap::readAttributeSet(LandmarkLaneAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::localization::instantiations::LandmarkAttributeSet(context.getAttributeSet(), in, allocator);
}
::nds::core::attributemap::FeatureIterator LandmarkLaneAttributeSetMap::readFeature(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::attributemap::FeatureIterator>(in.readVarSize());
}

::nds::core::attributemap::FeatureIterator LandmarkLaneAttributeSetMap::readFeature(LandmarkLaneAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getFeature().read<::zserio::VarSizeArrayTraits>(in);
}
LandmarkLaneAttributeSetMap::ZserioArrayType_references LandmarkLaneAttributeSetMap::readReferences(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_references readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

LandmarkLaneAttributeSetMap::ZserioArrayType_references LandmarkLaneAttributeSetMap::readReferences(LandmarkLaneAttributeSetMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_references readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
LandmarkLaneAttributeSetMap::ZserioArrayType_validities LandmarkLaneAttributeSetMap::readValidities(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_validities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

LandmarkLaneAttributeSetMap::ZserioArrayType_validities LandmarkLaneAttributeSetMap::readValidities(LandmarkLaneAttributeSetMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_validities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

} // namespace instantiations
} // namespace localization
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/localization/instantiations/LandmarkRoadAttributeSetMap.h>

namespace nds
{
namespace localization
{
namespace instantiations
{

LandmarkRoadAttributeSetMap::LandmarkRoadAttributeSetMap(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeSet_(allocator),
        m_feature_(::nds::core::attributemap::FeatureIterator()),
        m_references_(allocator),
        m_validities_(allocator)
{
}

LandmarkRoadAttributeSetMap::LandmarkRoadAttributeSetMap(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeSet_(readAttributeSet(in, allocator)),
        m_feature_(readFeature(in)),
        m_references_(readReferences(in, allocator)),
        m_validities_(readValidities(in, allocator))
{
}

LandmarkRoadAttributeSetMap::LandmarkRoadAttributeSetMap(LandmarkRoadAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeSet_(readAttributeSet(context, in, allocator)),
        m_feature_(readFeature(context, in)),
        m_references_(readReferences(context, in, allocator)),
        m_validities_(readValidities(context, in, allocator))
{
}

LandmarkRoadAttributeSetMap::LandmarkRoadAttributeSetMap(const LandmarkRoadAttributeSetMap& other) :
        m_attributeSet_(other.m_attributeSet_),
        m_feature_(other.m_feature_),
        m_references_(other.m_references_),
        m_validities_(other.m_validities_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

LandmarkRoadAttributeSetMap& LandmarkRoadAttributeSetMap::operator=(const LandmarkRoadAttributeSetMap& other)
{
    m_attributeSet_ = other.m_attributeSet_;
    m_feature_ = other.m_feature_;
    m_references_ = other.m_references_;
    m_validities_ = other.m_validities_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

LandmarkRoadAttributeSetMap::LandmarkRoadAttributeSetMap(LandmarkRoadAttributeSetMap&& other) :
        m_attributeSet_(::std::move(other.m_attributeSet_)),
        m_feature_(::std::move(other.m_feature_)),
        m_references_(::std::move(other.m_references_)),
        m_validities_(::std::move(other.m_validities_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

LandmarkRoadAttributeSetMap& LandmarkRoadAttributeSetMap::operator=(LandmarkRoadAttributeSetMap&& other)
{
    m_attributeSet_ = ::std::move(other.m_attributeSet_);
    m_feature_ = ::std::move(other.m_feature_);
    m_references_ = ::std::move(other.m_references_);
    m_validities_ = ::std::move(other.m_validities_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

LandmarkRoadAttributeSetMap::LandmarkRoadAttributeSetMap(::zserio::PropagateAllocatorT,
        const LandmarkRoadAttributeSetMap& other, const allocator_type& allocator) :
        m_attributeSet_(::zserio::allocatorPropagatingCopy(other.m_attributeSet_, allocator)),
        m_feature_(::zserio::allocatorPropagatingCopy(other.m_feature_, allocator)),
        m_references_(::zserio::allocatorPropagatingCopy(other.m_references_, allocator)),
        m_validities_(::zserio::allocatorPropagatingCopy(other.m_validities_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void LandmarkRoadAttributeSetMap::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool LandmarkRoadAttributeSetMap::isInitialized() const
{
    return m_isInitialized;
}

void LandmarkRoadAttributeSetMap::initializeChildren()
{
    m_attributeSet_.initializeChildren();
    m_validities_.initializeElements(*this);
}

::nds::core::geometry::CoordShift LandmarkRoadAttributeSetMap::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'LandmarkRoadAttributeSetMap' is not initialized!");

    return m_coordShift_;
}

::nds::localization::instantiations::LandmarkAttributeSet& LandmarkRoadAttributeSetMap::getAttributeSet()
{
    return m_attributeSet_;
}

const ::nds::localization::instantiations::LandmarkAttributeSet& LandmarkRoadAttributeSetMap::getAttributeSet() const
{
    return m_attributeSet_;
}

void LandmarkRoadAttributeSetMap::setAttributeSet(const ::nds::localization::instantiations::LandmarkAttributeSet& attributeSet_)
{
    m_attributeSet_ = attributeSet_;
}

void LandmarkRoadAttributeSetMap::setAttributeSet(::nds::localization::instantiations::LandmarkAttributeSet&& attributeSet_)
{
    m_attributeSet_ = ::std::move(attributeSet_);
}

::nds::core::attributemap::FeatureIterator LandmarkRoadAttributeSetMap::getFeature() const
{
    return m_feature_;
}

void LandmarkRoadAttributeSetMap::setFeature(::nds::core::attributemap::FeatureIterator feature_)
{
    m_feature_ = feature_;
}

::zserio::vector<::nds::road::reference::types::RoadReference>& LandmarkRoadAttributeSetMap::getReferences()
{
    return m_references_.getRawArray();
}

const ::zserio::vector<::nds::road::reference::types::RoadReference>& LandmarkRoadAttributeSetMap::getReferences() const
{
    return m_references_.getRawArray();
}

void LandmarkRoadAttributeSetMap::setReferences(const ::zserio::vector<::nds::road::reference::types::RoadReference>& references_)
{
    m_references_ = ZserioArrayType_references(references_);
}

void LandmarkRoadAttributeSetMap::setReferences(::zserio::vector<::nds::road::reference::types::RoadReference>&& references_)
{
    m_references_ = ZserioArrayType_references(std::move(references_));
}

::zserio::vector<::nds::road::reference::types::RoadValidityRange>& LandmarkRoadAttributeSetMap::getValidities()
{
    return m_validities_.getRawArray();
}

const ::zserio::vector<::nds::road::reference::types::RoadValidityRange>& LandmarkRoadAttributeSetMap::getValidities() const
{
    return m_validities_.getRawArray();
}

void LandmarkRoadAttributeSetMap::setValidities(const ::zserio::vector<::nds::road::reference::types::RoadValidityRange>& validities_)
{
    m_validities_ = ZserioArrayType_validities(validities_);
}

void LandmarkRoadAttributeSetMap::setValidities(::zserio::vector<::nds::road::reference::types::RoadValidityRange>&& validities_)
{
    m_validities_ = ZserioArrayType_validities(std::move(validities_));
}

void LandmarkRoadAttributeSetMap::initPackingContext(LandmarkRoadAttributeSetMap::ZserioPackingContext& context) const
{
    m_attributeSet_.initPackingContext(context.getAttributeSet());
    context.getFeature().init<::zserio::VarSizeArrayTraits>(m_feature_);
}

size_t LandmarkRoadAttributeSetMap::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeSet_.bitSizeOf(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition += m_references_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_validities_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LandmarkRoadAttributeSetMap::bitSizeOf(LandmarkRoadAttributeSetMap::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeSet_.bitSizeOf(context.getAttributeSet(), endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition += m_references_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_validities_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LandmarkRoadAttributeSetMap::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeSet_.initializeOffsets(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition = m_references_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_validities_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t LandmarkRoadAttributeSetMap::initializeOffsets(LandmarkRoadAttributeSetMap::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeSet_.initializeOffsets(context.getAttributeSet(), endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition = m_references_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_validities_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool LandmarkRoadAttributeSetMap::operator==(const LandmarkRoadAttributeSetMap& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_attributeSet_ == other.m_attributeSet_) &&
                (m_feature_ == other.m_feature_) &&
                (m_references_ == other.m_references_) &&
                (m_validities_ == other.m_validities_);
    }

    return true;
}

uint32_t LandmarkRoadAttributeSetMap::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_attributeSet_);
    result = ::zserio::calcHashCode(result, m_feature_);
    result = ::zserio::calcHashCode(result, m_references_);
    result = ::zserio::calcHashCode(result, m_validities_);

    return result;
}

void LandmarkRoadAttributeSetMap::write(::zserio::BitStreamWriter& out) const
{
    m_attributeSet_.write(out);

    out.writeVarSize(m_feature_);

    // check array length
    if (m_references_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field LandmarkRoadAttributeSetMap.references: ") <<
                m_references_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_references_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_validities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field LandmarkRoadAttributeSetMap.validities: ") <<
                m_validities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_validities_.writePacked(*this, out);
}

void LandmarkRoadAttributeSetMap::write(LandmarkRoadAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_attributeSet_.write(context.getAttributeSet(), out);

    context.getFeature().write<::zserio::VarSizeArrayTraits>(out, m_feature_);

    // check array length
    if (m_references_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field LandmarkRoadAttributeSetMap.references: ") <<
                m_references_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_references_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_validities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field LandmarkRoadAttributeSetMap.validities: ") <<
                m_validities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_validities_.writePacked(*this, out);
}

void LandmarkRoadAttributeSetMap::ZserioElementFactory_references::create(LandmarkRoadAttributeSetMap&        ,
        ::zserio::vector<::nds::road::reference::types::RoadReference>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void LandmarkRoadAttributeSetMap::ZserioElementFactory_references::create(LandmarkRoadAttributeSetMap&        ,
        ::zserio::vector<::nds::road::reference::types::RoadReference>& array,
        ::nds::road::reference::types::RoadReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void LandmarkRoadAttributeSetMap::ZserioArrayExpressions_validities::initializeElement(LandmarkRoadAttributeSetMap& owner,
        ::nds::road::reference::types::RoadValidityRange& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void LandmarkRoadAttributeSetMap::ZserioElementFactory_validities::create(LandmarkRoadAttributeSetMap&         owner,
        ::zserio::vector<::nds::road::reference::types::RoadValidityRange>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void LandmarkRoadAttributeSetMap::ZserioElementFactory_validities::create(LandmarkRoadAttributeSetMap&         owner,
        ::zserio::vector<::nds::road::reference::types::RoadValidityRange>& array,
        ::nds::road::reference::types::RoadValidityRange::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

::nds::localization::instantiations::LandmarkAttributeSet LandmarkRoadAttributeSetMap::readAttributeSet(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::localization::instantiations::LandmarkAttributeSet(in, allocator);
}

::nds::localization::instantiations::LandmarkAttributeSet LandmarkRoadAttributeSetMap::readAttributeSet(LandmarkRoadAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::localization::instantiations::LandmarkAttributeSet(context.getAttributeSet(), in, allocator);
}
::nds::core::attributemap::FeatureIterator LandmarkRoadAttributeSetMap::readFeature(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::attributemap::FeatureIterator>(in.readVarSize());
}

::nds::core::attributemap::FeatureIterator LandmarkRoadAttributeSetMap::readFeature(LandmarkRoadAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getFeature().read<::zserio::VarSizeArrayTraits>(in);
}
LandmarkRoadAttributeSetMap::ZserioArrayType_references LandmarkRoadAttributeSetMap::readReferences(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_references readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

LandmarkRoadAttributeSetMap::ZserioArrayType_references LandmarkRoadAttributeSetMap::readReferences(LandmarkRoadAttributeSetMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_references readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
LandmarkRoadAttributeSetMap::ZserioArrayType_validities LandmarkRoadAttributeSetMap::readValidities(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_validities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

LandmarkRoadAttributeSetMap::ZserioArrayType_validities LandmarkRoadAttributeSetMap::readValidities(LandmarkRoadAttributeSetMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_validities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

} // namespace instantiations
} // namespace localization
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/localization/instantiations/LandmarkLaneAttributeSetList.h>

namespace nds
{
namespace localization
{
namespace instantiations
{

LandmarkLaneAttributeSetList::LandmarkLaneAttributeSetList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numAttributeSets_(uint32_t()),
        m_sets_(allocator)
{
}

LandmarkLaneAttributeSetList::LandmarkLaneAttributeSetList(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numAttributeSets_(readNumAttributeSets(in)),
        m_sets_(readSets(in, allocator))
{
}

LandmarkLaneAttributeSetList::LandmarkLaneAttributeSetList(LandmarkLaneAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numAttributeSets_(readNumAttributeSets(context, in)),
        m_sets_(readSets(context, in, allocator))
{
}

LandmarkLaneAttributeSetList::LandmarkLaneAttributeSetList(const LandmarkLaneAttributeSetList& other) :
        m_numAttributeSets_(other.m_numAttributeSets_),
        m_sets_(other.m_sets_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

LandmarkLaneAttributeSetList& LandmarkLaneAttributeSetList::operator=(const LandmarkLaneAttributeSetList& other)
{
    m_numAttributeSets_ = other.m_numAttributeSets_;
    m_sets_ = other.m_sets_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

LandmarkLaneAttributeSetList::LandmarkLaneAttributeSetList(LandmarkLaneAttributeSetList&& other) :
        m_numAttributeSets_(::std::move(other.m_numAttributeSets_)),
        m_sets_(::std::move(other.m_sets_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

LandmarkLaneAttributeSetList& LandmarkLaneAttributeSetList::operator=(LandmarkLaneAttributeSetList&& other)
{
    m_numAttributeSets_ = ::std::move(other.m_numAttributeSets_);
    m_sets_ = ::std::move(other.m_sets_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

LandmarkLaneAttributeSetList::LandmarkLaneAttributeSetList(::zserio::PropagateAllocatorT,
        const LandmarkLaneAttributeSetList& other, const allocator_type& allocator) :
        m_numAttributeSets_(::zserio::allocatorPropagatingCopy(other.m_numAttributeSets_, allocator)),
        m_sets_(::zserio::allocatorPropagatingCopy(other.m_sets_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void LandmarkLaneAttributeSetList::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool LandmarkLaneAttributeSetList::isInitialized() const
{
    return m_isInitialized;
}

void LandmarkLaneAttributeSetList::initializeChildren()
{
    m_sets_.initializeElements(*this);
}

::nds::core::geometry::CoordShift LandmarkLaneAttributeSetList::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'LandmarkLaneAttributeSetList' is not initialized!");

    return m_coordShift_;
}

uint32_t LandmarkLaneAttributeSetList::getNumAttributeSets() const
{
    return m_numAttributeSets_;
}

void LandmarkLaneAttributeSetList::setNumAttributeSets(uint32_t numAttributeSets_)
{
    m_numAttributeSets_ = numAttributeSets_;
}

::zserio::vector<::nds::localization::instantiations::LandmarkLaneAttributeSetMap>& LandmarkLaneAttributeSetList::getSets()
{
    return m_sets_.getRawArray();
}

const ::zserio::vector<::nds::localization::instantiations::LandmarkLaneAttributeSetMap>& LandmarkLaneAttributeSetList::getSets() const
{
    return m_sets_.getRawArray();
}

void LandmarkLaneAttributeSetList::setSets(const ::zserio::vector<::nds::localization::instantiations::LandmarkLaneAttributeSetMap>& sets_)
{
    m_sets_ = ZserioArrayType_sets(sets_);
}

void LandmarkLaneAttributeSetList::setSets(::zserio::vector<::nds::localization::instantiations::LandmarkLaneAttributeSetMap>&& sets_)
{
    m_sets_ = ZserioArrayType_sets(std::move(sets_));
}

void LandmarkLaneAttributeSetList::initPackingContext(LandmarkLaneAttributeSetList::ZserioPackingContext& context) const
{
    context.getNumAttributeSets().init<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
}

size_t LandmarkLaneAttributeSetList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numAttributeSets_);
    endBitPosition += m_sets_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LandmarkLaneAttributeSetList::bitSizeOf(LandmarkLaneAttributeSetList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumAttributeSets().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
    endBitPosition += m_sets_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LandmarkLaneAttributeSetList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numAttributeSets_);
    endBitPosition = m_sets_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t LandmarkLaneAttributeSetList::initializeOffsets(LandmarkLaneAttributeSetList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumAttributeSets().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
    endBitPosition = m_sets_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool LandmarkLaneAttributeSetList::operator==(const LandmarkLaneAttributeSetList& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_numAttributeSets_ == other.m_numAttributeSets_) &&
                (m_sets_ == other.m_sets_);
    }

    return true;
}

uint32_t LandmarkLaneAttributeSetList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_numAttributeSets_);
    result = ::zserio::calcHashCode(result, m_sets_);

    return result;
}

void LandmarkLaneAttributeSetList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numAttributeSets_);

    // check array length
    if (m_sets_.getRawArray().size() != static_cast<size_t>(getNumAttributeSets()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field LandmarkLaneAttributeSetList.sets: ") <<
                m_sets_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumAttributeSets()) << "!";
    }
    m_sets_.writePacked(*this, out);
}

void LandmarkLaneAttributeSetList::write(LandmarkLaneAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumAttributeSets().write<::zserio::VarSizeArrayTraits>(out, m_numAttributeSets_);

    // check array length
    if (m_sets_.getRawArray().size() != static_cast<size_t>(getNumAttributeSets()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field LandmarkLaneAttributeSetList.sets: ") <<
                m_sets_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumAttributeSets()) << "!";
    }
    m_sets_.writePacked(*this, out);
}

void LandmarkLaneAttributeSetList::ZserioArrayExpressions_sets::initializeElement(LandmarkLaneAttributeSetList& owner,
        ::nds::localization::instantiations::LandmarkLaneAttributeSetMap& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void LandmarkLaneAttributeSetList::ZserioElementFactory_sets::create(LandmarkLaneAttributeSetList&         owner,
        ::zserio::vector<::nds::localization::instantiations::LandmarkLaneAttributeSetMap>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void LandmarkLaneAttributeSetList::ZserioElementFactory_sets::create(LandmarkLaneAttributeSetList&         owner,
        ::zserio::vector<::nds::localization::instantiations::LandmarkLaneAttributeSetMap>& array,
        ::nds::localization::instantiations::LandmarkLaneAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

uint32_t LandmarkLaneAttributeSetList::readNumAttributeSets(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t LandmarkLaneAttributeSetList::readNumAttributeSets(LandmarkLaneAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumAttributeSets().read<::zserio::VarSizeArrayTraits>(in);
}
LandmarkLaneAttributeSetList::ZserioArrayType_sets LandmarkLaneAttributeSetList::readSets(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_sets readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumAttributeSets()));

    return readField;
}

LandmarkLaneAttributeSetList::ZserioArrayType_sets LandmarkLaneAttributeSetList::readSets(LandmarkLaneAttributeSetList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_sets readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumAttributeSets()));

    return readField;
}

} // namespace instantiations
} // namespace localization
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/localization/instantiations/LandmarkRoadAttributeSetList.h>

namespace nds
{
namespace localization
{
namespace instantiations
{

LandmarkRoadAttributeSetList::LandmarkRoadAttributeSetList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numAttributeSets_(uint32_t()),
        m_sets_(allocator)
{
}

LandmarkRoadAttributeSetList::LandmarkRoadAttributeSetList(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numAttributeSets_(readNumAttributeSets(in)),
        m_sets_(readSets(in, allocator))
{
}

LandmarkRoadAttributeSetList::LandmarkRoadAttributeSetList(LandmarkRoadAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numAttributeSets_(readNumAttributeSets(context, in)),
        m_sets_(readSets(context, in, allocator))
{
}

LandmarkRoadAttributeSetList::LandmarkRoadAttributeSetList(const LandmarkRoadAttributeSetList& other) :
        m_numAttributeSets_(other.m_numAttributeSets_),
        m_sets_(other.m_sets_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

LandmarkRoadAttributeSetList& LandmarkRoadAttributeSetList::operator=(const LandmarkRoadAttributeSetList& other)
{
    m_numAttributeSets_ = other.m_numAttributeSets_;
    m_sets_ = other.m_sets_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

LandmarkRoadAttributeSetList::LandmarkRoadAttributeSetList(LandmarkRoadAttributeSetList&& other) :
        m_numAttributeSets_(::std::move(other.m_numAttributeSets_)),
        m_sets_(::std::move(other.m_sets_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

LandmarkRoadAttributeSetList& LandmarkRoadAttributeSetList::operator=(LandmarkRoadAttributeSetList&& other)
{
    m_numAttributeSets_ = ::std::move(other.m_numAttributeSets_);
    m_sets_ = ::std::move(other.m_sets_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

LandmarkRoadAttributeSetList::LandmarkRoadAttributeSetList(::zserio::PropagateAllocatorT,
        const LandmarkRoadAttributeSetList& other, const allocator_type& allocator) :
        m_numAttributeSets_(::zserio::allocatorPropagatingCopy(other.m_numAttributeSets_, allocator)),
        m_sets_(::zserio::allocatorPropagatingCopy(other.m_sets_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void LandmarkRoadAttributeSetList::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool LandmarkRoadAttributeSetList::isInitialized() const
{
    return m_isInitialized;
}

void LandmarkRoadAttributeSetList::initializeChildren()
{
    m_sets_.initializeElements(*this);
}

::nds::core::geometry::CoordShift LandmarkRoadAttributeSetList::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'LandmarkRoadAttributeSetList' is not initialized!");

    return m_coordShift_;
}

uint32_t LandmarkRoadAttributeSetList::getNumAttributeSets() const
{
    return m_numAttributeSets_;
}

void LandmarkRoadAttributeSetList::setNumAttributeSets(uint32_t numAttributeSets_)
{
    m_numAttributeSets_ = numAttributeSets_;
}

::zserio::vector<::nds::localization::instantiations::LandmarkRoadAttributeSetMap>& LandmarkRoadAttributeSetList::getSets()
{
    return m_sets_.getRawArray();
}

const ::zserio::vector<::nds::localization::instantiations::LandmarkRoadAttributeSetMap>& LandmarkRoadAttributeSetList::getSets() const
{
    return m_sets_.getRawArray();
}

void LandmarkRoadAttributeSetList::setSets(const ::zserio::vector<::nds::localization::instantiations::LandmarkRoadAttributeSetMap>& sets_)
{
    m_sets_ = ZserioArrayType_sets(sets_);
}

void LandmarkRoadAttributeSetList::setSets(::zserio::vector<::nds::localization::instantiations::LandmarkRoadAttributeSetMap>&& sets_)
{
    m_sets_ = ZserioArrayType_sets(std::move(sets_));
}

void LandmarkRoadAttributeSetList::initPackingContext(LandmarkRoadAttributeSetList::ZserioPackingContext& context) const
{
    context.getNumAttributeSets().init<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
}

size_t LandmarkRoadAttributeSetList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numAttributeSets_);
    endBitPosition += m_sets_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LandmarkRoadAttributeSetList::bitSizeOf(LandmarkRoadAttributeSetList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumAttributeSets().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
    endBitPosition += m_sets_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LandmarkRoadAttributeSetList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numAttributeSets_);
    endBitPosition = m_sets_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t LandmarkRoadAttributeSetList::initializeOffsets(LandmarkRoadAttributeSetList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumAttributeSets().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numAttributeSets_);
    endBitPosition = m_sets_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool LandmarkRoadAttributeSetList::operator==(const LandmarkRoadAttributeSetList& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_numAttributeSets_ == other.m_numAttributeSets_) &&
                (m_sets_ == other.m_sets_);
    }

    return true;
}

uint32_t LandmarkRoadAttributeSetList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_numAttributeSets_);
    result = ::zserio::calcHashCode(result, m_sets_);

    return result;
}

void LandmarkRoadAttributeSetList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numAttributeSets_);

    // check array length
    if (m_sets_.getRawArray().size() != static_cast<size_t>(getNumAttributeSets()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field LandmarkRoadAttributeSetList.sets: ") <<
                m_sets_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumAttributeSets()) << "!";
    }
    m_sets_.writePacked(*this, out);
}

void LandmarkRoadAttributeSetList::write(LandmarkRoadAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumAttributeSets().write<::zserio::VarSizeArrayTraits>(out, m_numAttributeSets_);

    // check array length
    if (m_sets_.getRawArray().size() != static_cast<size_t>(getNumAttributeSets()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field LandmarkRoadAttributeSetList.sets: ") <<
                m_sets_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumAttributeSets()) << "!";
    }
    m_sets_.writePacked(*this, out);
}

void LandmarkRoadAttributeSetList::ZserioArrayExpressions_sets::initializeElement(LandmarkRoadAttributeSetList& owner,
        ::nds::localization::instantiations::LandmarkRoadAttributeSetMap& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void LandmarkRoadAttributeSetList::ZserioElementFactory_sets::create(LandmarkRoadAttributeSetList&         owner,
        ::zserio::vector<::nds::localization::instantiations::LandmarkRoadAttributeSetMap>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void LandmarkRoadAttributeSetList::ZserioElementFactory_sets::create(LandmarkRoadAttributeSetList&         owner,
        ::zserio::vector<::nds::localization::instantiations::LandmarkRoadAttributeSetMap>& array,
        ::nds::localization::instantiations::LandmarkRoadAttributeSetMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

uint32_t LandmarkRoadAttributeSetList::readNumAttributeSets(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t LandmarkRoadAttributeSetList::readNumAttributeSets(LandmarkRoadAttributeSetList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumAttributeSets().read<::zserio::VarSizeArrayTraits>(in);
}
LandmarkRoadAttributeSetList::ZserioArrayType_sets LandmarkRoadAttributeSetList::readSets(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_sets readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumAttributeSets()));

    return readField;
}

LandmarkRoadAttributeSetList::ZserioArrayType_sets LandmarkRoadAttributeSetList::readSets(LandmarkRoadAttributeSetList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_sets readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumAttributeSets()));

    return readField;
}

} // namespace instantiations
} // namespace localization
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/localization/instantiations/OccupancyGridAttributeMetadata.h>

namespace nds
{
namespace localization
{
namespace instantiations
{

OccupancyGridAttributeMetadata::OccupancyGridAttributeMetadata(const allocator_type& allocator) noexcept :
        m_availableAttributes_(allocator),
        m_availableProperties_(allocator),
        m_availableConditions_(allocator)
{
}

OccupancyGridAttributeMetadata::OccupancyGridAttributeMetadata(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_availableAttributes_(readAvailableAttributes(in, allocator)),
        m_availableProperties_(readAvailableProperties(in, allocator)),
        m_availableConditions_(readAvailableConditions(in, allocator))
{
}

OccupancyGridAttributeMetadata::OccupancyGridAttributeMetadata(OccupancyGridAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_availableAttributes_(readAvailableAttributes(context, in, allocator)),
        m_availableProperties_(readAvailableProperties(context, in, allocator)),
        m_availableConditions_(readAvailableConditions(context, in, allocator))
{
}

OccupancyGridAttributeMetadata::OccupancyGridAttributeMetadata(::zserio::PropagateAllocatorT,
        const OccupancyGridAttributeMetadata& other, const allocator_type& allocator) :
        m_availableAttributes_(::zserio::allocatorPropagatingCopy(other.m_availableAttributes_, allocator)),
        m_availableProperties_(::zserio::allocatorPropagatingCopy(other.m_availableProperties_, allocator)),
        m_availableConditions_(::zserio::allocatorPropagatingCopy(other.m_availableConditions_, allocator))
{
}

::zserio::vector<::nds::localization::attributes::OccupancyGridRelationAttributeType>& OccupancyGridAttributeMetadata::getAvailableAttributes()
{
    return m_availableAttributes_.getRawArray();
}

const ::zserio::vector<::nds::localization::attributes::OccupancyGridRelationAttributeType>& OccupancyGridAttributeMetadata::getAvailableAttributes() const
{
    return m_availableAttributes_.getRawArray();
}

void OccupancyGridAttributeMetadata::setAvailableAttributes(const ::zserio::vector<::nds::localization::attributes::OccupancyGridRelationAttributeType>& availableAttributes_)
{
    m_availableAttributes_ = ZserioArrayType_availableAttributes(availableAttributes_);
}

void OccupancyGridAttributeMetadata::setAvailableAttributes(::zserio::vector<::nds::localization::attributes::OccupancyGridRelationAttributeType>&& availableAttributes_)
{
    m_availableAttributes_ = ZserioArrayType_availableAttributes(std::move(availableAttributes_));
}

::zserio::vector<::nds::localization::properties::LocalizationPropertyType>& OccupancyGridAttributeMetadata::getAvailableProperties()
{
    return m_availableProperties_.getRawArray();
}

const ::zserio::vector<::nds::localization::properties::LocalizationPropertyType>& OccupancyGridAttributeMetadata::getAvailableProperties() const
{
    return m_availableProperties_.getRawArray();
}

void OccupancyGridAttributeMetadata::setAvailableProperties(const ::zserio::vector<::nds::localization::properties::LocalizationPropertyType>& availableProperties_)
{
    m_availableProperties_ = ZserioArrayType_availableProperties(availableProperties_);
}

void OccupancyGridAttributeMetadata::setAvailableProperties(::zserio::vector<::nds::localization::properties::LocalizationPropertyType>&& availableProperties_)
{
    m_availableProperties_ = ZserioArrayType_availableProperties(std::move(availableProperties_));
}

::nds::core::attributemap::ConditionTypeCodeCollection& OccupancyGridAttributeMetadata::getAvailableConditions()
{
    return m_availableConditions_;
}

const ::nds::core::attributemap::ConditionTypeCodeCollection& OccupancyGridAttributeMetadata::getAvailableConditions() const
{
    return m_availableConditions_;
}

void OccupancyGridAttributeMetadata::setAvailableConditions(const ::nds::core::attributemap::ConditionTypeCodeCollection& availableConditions_)
{
    m_availableConditions_ = availableConditions_;
}

void OccupancyGridAttributeMetadata::setAvailableConditions(::nds::core::attributemap::ConditionTypeCodeCollection&& availableConditions_)
{
    m_availableConditions_ = ::std::move(availableConditions_);
}

void OccupancyGridAttributeMetadata::initPackingContext(OccupancyGridAttributeMetadata::ZserioPackingContext& context) const
{
    m_availableConditions_.initPackingContext(context.getAvailableConditions());
}

size_t OccupancyGridAttributeMetadata::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_availableAttributes_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_availableProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_availableConditions_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t OccupancyGridAttributeMetadata::bitSizeOf(OccupancyGridAttributeMetadata::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_availableAttributes_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_availableProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_availableConditions_.bitSizeOf(context.getAvailableConditions(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t OccupancyGridAttributeMetadata::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_availableAttributes_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_availableProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_availableConditions_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t OccupancyGridAttributeMetadata::initializeOffsets(OccupancyGridAttributeMetadata::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_availableAttributes_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_availableProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_availableConditions_.initializeOffsets(context.getAvailableConditions(), endBitPosition);

    return endBitPosition;
}

bool OccupancyGridAttributeMetadata::operator==(const OccupancyGridAttributeMetadata& other) const
{
    if (this != &other)
    {
        return
                (m_availableAttributes_ == other.m_availableAttributes_) &&
                (m_availableProperties_ == other.m_availableProperties_) &&
                (m_availableConditions_ == other.m_availableConditions_);
    }

    return true;
}

uint32_t OccupancyGridAttributeMetadata::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_availableAttributes_);
    result = ::zserio::calcHashCode(result, m_availableProperties_);
    result = ::zserio::calcHashCode(result, m_availableConditions_);

    return result;
}

void OccupancyGridAttributeMetadata::write(::zserio::BitStreamWriter& out) const
{
    m_availableAttributes_.writePacked(out);
    m_availableProperties_.writePacked(*this, out);
    m_availableConditions_.write(out);
}

void OccupancyGridAttributeMetadata::write(OccupancyGridAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_availableAttributes_.writePacked(out);
    m_availableProperties_.writePacked(*this, out);
    m_availableConditions_.write(context.getAvailableConditions(), out);
}

void OccupancyGridAttributeMetadata::ZserioElementFactory_availableProperties::create(OccupancyGridAttributeMetadata&        ,
        ::zserio::vector<::nds::localization::properties::LocalizationPropertyType>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void OccupancyGridAttributeMetadata::ZserioElementFactory_availableProperties::create(OccupancyGridAttributeMetadata&        ,
        ::zserio::vector<::nds::localization::properties::LocalizationPropertyType>& array,
        ::nds::localization::properties::LocalizationPropertyType::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

OccupancyGridAttributeMetadata::ZserioArrayType_availableAttributes OccupancyGridAttributeMetadata::readAvailableAttributes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_availableAttributes readField(allocator);
    readField.readPacked(in);

    return readField;
}

OccupancyGridAttributeMetadata::ZserioArrayType_availableAttributes OccupancyGridAttributeMetadata::readAvailableAttributes(OccupancyGridAttributeMetadata::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_availableAttributes readField(allocator);
    readField.readPacked(in);

    return readField;
}
OccupancyGridAttributeMetadata::ZserioArrayType_availableProperties OccupancyGridAttributeMetadata::readAvailableProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_availableProperties readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}

OccupancyGridAttributeMetadata::ZserioArrayType_availableProperties OccupancyGridAttributeMetadata::readAvailableProperties(OccupancyGridAttributeMetadata::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_availableProperties readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}
::nds::core::attributemap::ConditionTypeCodeCollection OccupancyGridAttributeMetadata::readAvailableConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::attributemap::ConditionTypeCodeCollection(in, allocator);
}

::nds::core::attributemap::ConditionTypeCodeCollection OccupancyGridAttributeMetadata::readAvailableConditions(OccupancyGridAttributeMetadata::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::attributemap::ConditionTypeCodeCollection(context.getAvailableConditions(), in, allocator);
}

} // namespace instantiations
} // namespace localization
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/localization/instantiations/OccupancyGridLaneAttributeMapList.h>

namespace nds
{
namespace localization
{
namespace instantiations
{

OccupancyGridLaneAttributeMapList::OccupancyGridLaneAttributeMapList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numMaps_(uint32_t()),
        m_header_(allocator),
        m_maps_(allocator)
{
}

OccupancyGridLaneAttributeMapList::OccupancyGridLaneAttributeMapList(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(in)),
        m_header_(readHeader(in, allocator)),
        m_maps_(readMaps(in, allocator))
{
}

OccupancyGridLaneAttributeMapList::OccupancyGridLaneAttributeMapList(OccupancyGridLaneAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(context, in)),
        m_header_(readHeader(context, in, allocator)),
        m_maps_(readMaps(context, in, allocator))
{
}

OccupancyGridLaneAttributeMapList::OccupancyGridLaneAttributeMapList(const OccupancyGridLaneAttributeMapList& other) :
        m_numMaps_(other.m_numMaps_),
        m_header_(other.m_header_),
        m_maps_(other.m_maps_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

OccupancyGridLaneAttributeMapList& OccupancyGridLaneAttributeMapList::operator=(const OccupancyGridLaneAttributeMapList& other)
{
    m_numMaps_ = other.m_numMaps_;
    m_header_ = other.m_header_;
    m_maps_ = other.m_maps_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

OccupancyGridLaneAttributeMapList::OccupancyGridLaneAttributeMapList(OccupancyGridLaneAttributeMapList&& other) :
        m_numMaps_(::std::move(other.m_numMaps_)),
        m_header_(::std::move(other.m_header_)),
        m_maps_(::std::move(other.m_maps_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

OccupancyGridLaneAttributeMapList& OccupancyGridLaneAttributeMapList::operator=(OccupancyGridLaneAttributeMapList&& other)
{
    m_numMaps_ = ::std::move(other.m_numMaps_);
    m_header_ = ::std::move(other.m_header_);
    m_maps_ = ::std::move(other.m_maps_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

OccupancyGridLaneAttributeMapList::OccupancyGridLaneAttributeMapList(::zserio::PropagateAllocatorT,
        const OccupancyGridLaneAttributeMapList& other, const allocator_type& allocator) :
        m_numMaps_(::zserio::allocatorPropagatingCopy(other.m_numMaps_, allocator)),
        m_header_(::zserio::allocatorPropagatingCopy(other.m_header_, allocator)),
        m_maps_(::zserio::allocatorPropagatingCopy(other.m_maps_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void OccupancyGridLaneAttributeMapList::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool OccupancyGridLaneAttributeMapList::isInitialized() const
{
    return m_isInitialized;
}

void OccupancyGridLaneAttributeMapList::initializeChildren()
{
    m_header_.initialize(static_cast<uint16_t>(getNumMaps()));
    m_maps_.initializeElements(*this);
}

::nds::core::geometry::CoordShift OccupancyGridLaneAttributeMapList::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'OccupancyGridLaneAttributeMapList' is not initialized!");

    return m_coordShift_;
}

uint32_t OccupancyGridLaneAttributeMapList::getNumMaps() const
{
    return m_numMaps_;
}

void OccupancyGridLaneAttributeMapList::setNumMaps(uint32_t numMaps_)
{
    m_numMaps_ = numMaps_;
}

::nds::localization::instantiations::OccupancyGridAttributeMapListHeader& OccupancyGridLaneAttributeMapList::getHeader()
{
    return m_header_;
}

const ::nds::localization::instantiations::OccupancyGridAttributeMapListHeader& OccupancyGridLaneAttributeMapList::getHeader() const
{
    return m_header_;
}

void OccupancyGridLaneAttributeMapList::setHeader(const ::nds::localization::instantiations::OccupancyGridAttributeMapListHeader& header_)
{
    m_header_ = header_;
}

void OccupancyGridLaneAttributeMapList::setHeader(::nds::localization::instantiations::OccupancyGridAttributeMapListHeader&& header_)
{
    m_header_ = ::std::move(header_);
}

::zserio::vector<::nds::localization::instantiations::OccupancyGridLaneAttributeMap>& OccupancyGridLaneAttributeMapList::getMaps()
{
    return m_maps_.getRawArray();
}

const ::zserio::vector<::nds::localization::instantiations::OccupancyGridLaneAttributeMap>& OccupancyGridLaneAttributeMapList::getMaps() const
{
    return m_maps_.getRawArray();
}

void OccupancyGridLaneAttributeMapList::setMaps(const ::zserio::vector<::nds::localization::instantiations::OccupancyGridLaneAttributeMap>& maps_)
{
    m_maps_ = ZserioArrayType_maps(maps_);
}

void OccupancyGridLaneAttributeMapList::setMaps(::zserio::vector<::nds::localization::instantiations::OccupancyGridLaneAttributeMap>&& maps_)
{
    m_maps_ = ZserioArrayType_maps(std::move(maps_));
}

void OccupancyGridLaneAttributeMapList::initPackingContext(OccupancyGridLaneAttributeMapList::ZserioPackingContext& context) const
{
    context.getNumMaps().init<::zserio::VarSizeArrayTraits>(m_numMaps_);
    m_header_.initPackingContext(context.getHeader());
}

size_t OccupancyGridLaneAttributeMapList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t OccupancyGridLaneAttributeMapList::bitSizeOf(OccupancyGridLaneAttributeMapList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(context.getHeader(), endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t OccupancyGridLaneAttributeMapList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t OccupancyGridLaneAttributeMapList::initializeOffsets(OccupancyGridLaneAttributeMapList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(context.getHeader(), endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool OccupancyGridLaneAttributeMapList::operator==(const OccupancyGridLaneAttributeMapList& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_numMaps_ == other.m_numMaps_) &&
                (m_header_ == other.m_header_) &&
                (m_maps_ == other.m_maps_);
    }

    return true;
}

uint32_t OccupancyGridLaneAttributeMapList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_numMaps_);
    result = ::zserio::calcHashCode(result, m_header_);
    result = ::zserio::calcHashCode(result, m_maps_);

    return result;
}

void OccupancyGridLaneAttributeMapList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field OccupancyGridLaneAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field OccupancyGridLaneAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void OccupancyGridLaneAttributeMapList::write(OccupancyGridLaneAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumMaps().write<::zserio::VarSizeArrayTraits>(out, m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field OccupancyGridLaneAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(context.getHeader(), out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field OccupancyGridLaneAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void OccupancyGridLaneAttributeMapList::ZserioArrayExpressions_maps::initializeElement(OccupancyGridLaneAttributeMapList& owner,
        ::nds::localization::instantiations::OccupancyGridLaneAttributeMap& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void OccupancyGridLaneAttributeMapList::ZserioElementFactory_maps::create(OccupancyGridLaneAttributeMapList&         owner,
        ::zserio::vector<::nds::localization::instantiations::OccupancyGridLaneAttributeMap>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void OccupancyGridLaneAttributeMapList::ZserioElementFactory_maps::create(OccupancyGridLaneAttributeMapList&         owner,
        ::zserio::vector<::nds::localization::instantiations::OccupancyGridLaneAttributeMap>& array,
        ::nds::localization::instantiations::OccupancyGridLaneAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

uint32_t OccupancyGridLaneAttributeMapList::readNumMaps(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t OccupancyGridLaneAttributeMapList::readNumMaps(OccupancyGridLaneAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumMaps().read<::zserio::VarSizeArrayTraits>(in);
}
::nds::localization::instantiations::OccupancyGridAttributeMapListHeader OccupancyGridLaneAttributeMapList::readHeader(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::localization::instantiations::OccupancyGridAttributeMapListHeader(in, static_cast<uint16_t>(getNumMaps()), allocator);
}

::nds::localization::instantiations::OccupancyGridAttributeMapListHeader OccupancyGridLaneAttributeMapList::readHeader(OccupancyGridLaneAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::localization::instantiations::OccupancyGridAttributeMapListHeader(context.getHeader(), in, static_cast<uint16_t>(getNumMaps()), allocator);
}
OccupancyGridLaneAttributeMapList::ZserioArrayType_maps OccupancyGridLaneAttributeMapList::readMaps(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

OccupancyGridLaneAttributeMapList::ZserioArrayType_maps OccupancyGridLaneAttributeMapList::readMaps(OccupancyGridLaneAttributeMapList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

} // namespace instantiations
} // namespace localization
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/localization/instantiations/OccupancyGridRoadAttributeMapList.h>

namespace nds
{
namespace localization
{
namespace instantiations
{

OccupancyGridRoadAttributeMapList::OccupancyGridRoadAttributeMapList(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numMaps_(uint32_t()),
        m_header_(allocator),
        m_maps_(allocator)
{
}

OccupancyGridRoadAttributeMapList::OccupancyGridRoadAttributeMapList(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(in)),
        m_header_(readHeader(in, allocator)),
        m_maps_(readMaps(in, allocator))
{
}

OccupancyGridRoadAttributeMapList::OccupancyGridRoadAttributeMapList(OccupancyGridRoadAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_numMaps_(readNumMaps(context, in)),
        m_header_(readHeader(context, in, allocator)),
        m_maps_(readMaps(context, in, allocator))
{
}

OccupancyGridRoadAttributeMapList::OccupancyGridRoadAttributeMapList(const OccupancyGridRoadAttributeMapList& other) :
        m_numMaps_(other.m_numMaps_),
        m_header_(other.m_header_),
        m_maps_(other.m_maps_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

OccupancyGridRoadAttributeMapList& OccupancyGridRoadAttributeMapList::operator=(const OccupancyGridRoadAttributeMapList& other)
{
    m_numMaps_ = other.m_numMaps_;
    m_header_ = other.m_header_;
    m_maps_ = other.m_maps_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

OccupancyGridRoadAttributeMapList::OccupancyGridRoadAttributeMapList(OccupancyGridRoadAttributeMapList&& other) :
        m_numMaps_(::std::move(other.m_numMaps_)),
        m_header_(::std::move(other.m_header_)),
        m_maps_(::std::move(other.m_maps_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

OccupancyGridRoadAttributeMapList& OccupancyGridRoadAttributeMapList::operator=(OccupancyGridRoadAttributeMapList&& other)
{
    m_numMaps_ = ::std::move(other.m_numMaps_);
    m_header_ = ::std::move(other.m_header_);
    m_maps_ = ::std::move(other.m_maps_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

OccupancyGridRoadAttributeMapList::OccupancyGridRoadAttributeMapList(::zserio::PropagateAllocatorT,
        const OccupancyGridRoadAttributeMapList& other, const allocator_type& allocator) :
        m_numMaps_(::zserio::allocatorPropagatingCopy(other.m_numMaps_, allocator)),
        m_header_(::zserio::allocatorPropagatingCopy(other.m_header_, allocator)),
        m_maps_(::zserio::allocatorPropagatingCopy(other.m_maps_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void OccupancyGridRoadAttributeMapList::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool OccupancyGridRoadAttributeMapList::isInitialized() const
{
    return m_isInitialized;
}

void OccupancyGridRoadAttributeMapList::initializeChildren()
{
    m_header_.initialize(static_cast<uint16_t>(getNumMaps()));
    m_maps_.initializeElements(*this);
}

::nds::core::geometry::CoordShift OccupancyGridRoadAttributeMapList::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'OccupancyGridRoadAttributeMapList' is not initialized!");

    return m_coordShift_;
}

uint32_t OccupancyGridRoadAttributeMapList::getNumMaps() const
{
    return m_numMaps_;
}

void OccupancyGridRoadAttributeMapList::setNumMaps(uint32_t numMaps_)
{
    m_numMaps_ = numMaps_;
}

::nds::localization::instantiations::OccupancyGridAttributeMapListHeader& OccupancyGridRoadAttributeMapList::getHeader()
{
    return m_header_;
}

const ::nds::localization::instantiations::OccupancyGridAttributeMapListHeader& OccupancyGridRoadAttributeMapList::getHeader() const
{
    return m_header_;
}

void OccupancyGridRoadAttributeMapList::setHeader(const ::nds::localization::instantiations::OccupancyGridAttributeMapListHeader& header_)
{
    m_header_ = header_;
}

void OccupancyGridRoadAttributeMapList::setHeader(::nds::localization::instantiations::OccupancyGridAttributeMapListHeader&& header_)
{
    m_header_ = ::std::move(header_);
}

::zserio::vector<::nds::localization::instantiations::OccupancyGridRoadAttributeMap>& OccupancyGridRoadAttributeMapList::getMaps()
{
    return m_maps_.getRawArray();
}

const ::zserio::vector<::nds::localization::instantiations::OccupancyGridRoadAttributeMap>& OccupancyGridRoadAttributeMapList::getMaps() const
{
    return m_maps_.getRawArray();
}

void OccupancyGridRoadAttributeMapList::setMaps(const ::zserio::vector<::nds::localization::instantiations::OccupancyGridRoadAttributeMap>& maps_)
{
    m_maps_ = ZserioArrayType_maps(maps_);
}

void OccupancyGridRoadAttributeMapList::setMaps(::zserio::vector<::nds::localization::instantiations::OccupancyGridRoadAttributeMap>&& maps_)
{
    m_maps_ = ZserioArrayType_maps(std::move(maps_));
}

void OccupancyGridRoadAttributeMapList::initPackingContext(OccupancyGridRoadAttributeMapList::ZserioPackingContext& context) const
{
    context.getNumMaps().init<::zserio::VarSizeArrayTraits>(m_numMaps_);
    m_header_.initPackingContext(context.getHeader());
}

size_t OccupancyGridRoadAttributeMapList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t OccupancyGridRoadAttributeMapList::bitSizeOf(OccupancyGridRoadAttributeMapList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition += m_header_.bitSizeOf(context.getHeader(), endBitPosition);
    endBitPosition += m_maps_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t OccupancyGridRoadAttributeMapList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t OccupancyGridRoadAttributeMapList::initializeOffsets(OccupancyGridRoadAttributeMapList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumMaps().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numMaps_);
    endBitPosition = m_header_.initializeOffsets(context.getHeader(), endBitPosition);
    endBitPosition = m_maps_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool OccupancyGridRoadAttributeMapList::operator==(const OccupancyGridRoadAttributeMapList& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_numMaps_ == other.m_numMaps_) &&
                (m_header_ == other.m_header_) &&
                (m_maps_ == other.m_maps_);
    }

    return true;
}

uint32_t OccupancyGridRoadAttributeMapList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_numMaps_);
    result = ::zserio::calcHashCode(result, m_header_);
    result = ::zserio::calcHashCode(result, m_maps_);

    return result;
}

void OccupancyGridRoadAttributeMapList::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field OccupancyGridRoadAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field OccupancyGridRoadAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void OccupancyGridRoadAttributeMapList::write(OccupancyGridRoadAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumMaps().write<::zserio::VarSizeArrayTraits>(out, m_numMaps_);

    // check parameters
    if (m_header_.getNumMaps() != static_cast<uint16_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numMaps for field OccupancyGridRoadAttributeMapList.header: ") <<
                m_header_.getNumMaps() << " != " << static_cast<uint16_t>(getNumMaps()) << "!";
    }
    m_header_.write(context.getHeader(), out);

    // check array length
    if (m_maps_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field OccupancyGridRoadAttributeMapList.maps: ") <<
                m_maps_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_maps_.writePacked(*this, out);
}

void OccupancyGridRoadAttributeMapList::ZserioArrayExpressions_maps::initializeElement(OccupancyGridRoadAttributeMapList& owner,
        ::nds::localization::instantiations::OccupancyGridRoadAttributeMap& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void OccupancyGridRoadAttributeMapList::ZserioElementFactory_maps::create(OccupancyGridRoadAttributeMapList&         owner,
        ::zserio::vector<::nds::localization::instantiations::OccupancyGridRoadAttributeMap>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void OccupancyGridRoadAttributeMapList::ZserioElementFactory_maps::create(OccupancyGridRoadAttributeMapList&         owner,
        ::zserio::vector<::nds::localization::instantiations::OccupancyGridRoadAttributeMap>& array,
        ::nds::localization::instantiations::OccupancyGridRoadAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

uint32_t OccupancyGridRoadAttributeMapList::readNumMaps(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t OccupancyGridRoadAttributeMapList::readNumMaps(OccupancyGridRoadAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumMaps().read<::zserio::VarSizeArrayTraits>(in);
}
::nds::localization::instantiations::OccupancyGridAttributeMapListHeader OccupancyGridRoadAttributeMapList::readHeader(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::localization::instantiations::OccupancyGridAttributeMapListHeader(in, static_cast<uint16_t>(getNumMaps()), allocator);
}

::nds::localization::instantiations::OccupancyGridAttributeMapListHeader OccupancyGridRoadAttributeMapList::readHeader(OccupancyGridRoadAttributeMapList::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::localization::instantiations::OccupancyGridAttributeMapListHeader(context.getHeader(), in, static_cast<uint16_t>(getNumMaps()), allocator);
}
OccupancyGridRoadAttributeMapList::ZserioArrayType_maps OccupancyGridRoadAttributeMapList::readMaps(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

OccupancyGridRoadAttributeMapList::ZserioArrayType_maps OccupancyGridRoadAttributeMapList::readMaps(OccupancyGridRoadAttributeMapList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_maps readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

} // namespace instantiations
} // namespace localization
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/localization/instantiations/OccupancyGridAttributeMapListHeader.h>

namespace nds
{
namespace localization
{
namespace instantiations
{

OccupancyGridAttributeMapListHeader::OccupancyGridAttributeMapListHeader(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeTypeCode_(allocator),
        m_conditionType_(allocator)
{
}

OccupancyGridAttributeMapListHeader::OccupancyGridAttributeMapListHeader(::zserio::BitStreamReader& in,
        uint16_t numMaps_, const allocator_type& allocator) :
        m_numMaps_(numMaps_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in, allocator)),
        m_conditionType_(readConditionType(in, allocator))
{
}

OccupancyGridAttributeMapListHeader::OccupancyGridAttributeMapListHeader(OccupancyGridAttributeMapListHeader::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        uint16_t numMaps_, const allocator_type& allocator) :
        m_numMaps_(numMaps_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in, allocator)),
        m_conditionType_(readConditionType(context, in, allocator))
{
}

OccupancyGridAttributeMapListHeader::OccupancyGridAttributeMapListHeader(const OccupancyGridAttributeMapListHeader& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_conditionType_(other.m_conditionType_)
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

OccupancyGridAttributeMapListHeader& OccupancyGridAttributeMapListHeader::operator=(const OccupancyGridAttributeMapListHeader& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_conditionType_ = other.m_conditionType_;
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;

    return *this;
}

OccupancyGridAttributeMapListHeader::OccupancyGridAttributeMapListHeader(OccupancyGridAttributeMapListHeader&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_conditionType_(::std::move(other.m_conditionType_))
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

OccupancyGridAttributeMapListHeader& OccupancyGridAttributeMapListHeader::operator=(OccupancyGridAttributeMapListHeader&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_conditionType_ = ::std::move(other.m_conditionType_);
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;

    return *this;
}

OccupancyGridAttributeMapListHeader::OccupancyGridAttributeMapListHeader(::zserio::PropagateAllocatorT,
        const OccupancyGridAttributeMapListHeader& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_conditionType_(::zserio::allocatorPropagatingCopy(other.m_conditionType_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_numMaps_);
    else
        m_isInitialized = false;
}

void OccupancyGridAttributeMapListHeader::initialize(
        uint16_t numMaps_)
{
    m_numMaps_ = numMaps_;
    m_isInitialized = true;
}

bool OccupancyGridAttributeMapListHeader::isInitialized() const
{
    return m_isInitialized;
}

uint16_t OccupancyGridAttributeMapListHeader::getNumMaps() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'numMaps' of compound 'OccupancyGridAttributeMapListHeader' is not initialized!");

    return m_numMaps_;
}

::zserio::vector<::nds::localization::attributes::OccupancyGridRelationAttributeType>& OccupancyGridAttributeMapListHeader::getAttributeTypeCode()
{
    return m_attributeTypeCode_.getRawArray();
}

const ::zserio::vector<::nds::localization::attributes::OccupancyGridRelationAttributeType>& OccupancyGridAttributeMapListHeader::getAttributeTypeCode() const
{
    return m_attributeTypeCode_.getRawArray();
}

void OccupancyGridAttributeMapListHeader::setAttributeTypeCode(const ::zserio::vector<::nds::localization::attributes::OccupancyGridRelationAttributeType>& attributeTypeCode_)
{
    m_attributeTypeCode_ = ZserioArrayType_attributeTypeCode(attributeTypeCode_);
}

void OccupancyGridAttributeMapListHeader::setAttributeTypeCode(::zserio::vector<::nds::localization::attributes::OccupancyGridRelationAttributeType>&& attributeTypeCode_)
{
    m_attributeTypeCode_ = ZserioArrayType_attributeTypeCode(std::move(attributeTypeCode_));
}

::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& OccupancyGridAttributeMapListHeader::getConditionType()
{
    return m_conditionType_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& OccupancyGridAttributeMapListHeader::getConditionType() const
{
    return m_conditionType_.getRawArray();
}

void OccupancyGridAttributeMapListHeader::setConditionType(const ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& conditionType_)
{
    m_conditionType_ = ZserioArrayType_conditionType(conditionType_);
}

void OccupancyGridAttributeMapListHeader::setConditionType(::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>&& conditionType_)
{
    m_conditionType_ = ZserioArrayType_conditionType(std::move(conditionType_));
}

void OccupancyGridAttributeMapListHeader::initPackingContext(OccupancyGridAttributeMapListHeader::ZserioPackingContext&) const
{
}

size_t OccupancyGridAttributeMapListHeader::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeTypeCode_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_conditionType_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t OccupancyGridAttributeMapListHeader::bitSizeOf(OccupancyGridAttributeMapListHeader::ZserioPackingContext&, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeTypeCode_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_conditionType_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t OccupancyGridAttributeMapListHeader::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeTypeCode_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_conditionType_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t OccupancyGridAttributeMapListHeader::initializeOffsets(OccupancyGridAttributeMapListHeader::ZserioPackingContext&, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeTypeCode_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_conditionType_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool OccupancyGridAttributeMapListHeader::operator==(const OccupancyGridAttributeMapListHeader& other) const
{
    if (this != &other)
    {
        return
                (getNumMaps() == other.getNumMaps()) &&
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_conditionType_ == other.m_conditionType_);
    }

    return true;
}

uint32_t OccupancyGridAttributeMapListHeader::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getNumMaps());
    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_conditionType_);

    return result;
}

void OccupancyGridAttributeMapListHeader::write(::zserio::BitStreamWriter& out) const
{
    // check array length
    if (m_attributeTypeCode_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field OccupancyGridAttributeMapListHeader.attributeTypeCode: ") <<
                m_attributeTypeCode_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_attributeTypeCode_.writePacked(out);

    // check array length
    if (m_conditionType_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field OccupancyGridAttributeMapListHeader.conditionType: ") <<
                m_conditionType_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_conditionType_.writePacked(*this, out);
}

void OccupancyGridAttributeMapListHeader::write(OccupancyGridAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamWriter& out) const
{
    // check array length
    if (m_attributeTypeCode_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field OccupancyGridAttributeMapListHeader.attributeTypeCode: ") <<
                m_attributeTypeCode_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_attributeTypeCode_.writePacked(out);

    // check array length
    if (m_conditionType_.getRawArray().size() != static_cast<size_t>(getNumMaps()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field OccupancyGridAttributeMapListHeader.conditionType: ") <<
                m_conditionType_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumMaps()) << "!";
    }
    m_conditionType_.writePacked(*this, out);
}

void OccupancyGridAttributeMapListHeader::ZserioElementFactory_conditionType::create(OccupancyGridAttributeMapListHeader&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void OccupancyGridAttributeMapListHeader::ZserioElementFactory_conditionType::create(OccupancyGridAttributeMapListHeader&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionTypeCodeCollection>& array,
        ::nds::core::attributemap::ConditionTypeCodeCollection::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

OccupancyGridAttributeMapListHeader::ZserioArrayType_attributeTypeCode OccupancyGridAttributeMapListHeader::readAttributeTypeCode(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributeTypeCode readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumMaps()));

    return readField;
}

OccupancyGridAttributeMapListHeader::ZserioArrayType_attributeTypeCode OccupancyGridAttributeMapListHeader::readAttributeTypeCode(OccupancyGridAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributeTypeCode readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumMaps()));

    return readField;
}
OccupancyGridAttributeMapListHeader::ZserioArrayType_conditionType OccupancyGridAttributeMapListHeader::readConditionType(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_conditionType readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

OccupancyGridAttributeMapListHeader::ZserioArrayType_conditionType OccupancyGridAttributeMapListHeader::readConditionType(OccupancyGridAttributeMapListHeader::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_conditionType readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumMaps()));

    return readField;
}

} // namespace instantiations
} // namespace localization
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/localization/instantiations/OccupancyGridLaneAttributeMap.h>

namespace nds
{
namespace localization
{
namespace instantiations
{

OccupancyGridLaneAttributeMap::OccupancyGridLaneAttributeMap(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeTypeCode_(::nds::localization::attributes::OccupancyGridRelationAttributeType()),
        m_feature_(::nds::core::attributemap::FeatureIterator()),
        m_featureReferences_(allocator),
        m_featureValidities_(allocator),
        m_featureValuePtr_(allocator),
        m_attribute_(::nds::core::attributemap::AttributeIterator()),
        m_attributeValues_(allocator),
        m_attributeProperties_(allocator),
        m_attributeConditions_(allocator)
{
}

OccupancyGridLaneAttributeMap::OccupancyGridLaneAttributeMap(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in)),
        m_feature_(readFeature(in)),
        m_featureReferences_(readFeatureReferences(in, allocator)),
        m_featureValidities_(readFeatureValidities(in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(in, allocator)),
        m_attribute_(readAttribute(in)),
        m_attributeValues_(readAttributeValues(in, allocator)),
        m_attributeProperties_(readAttributeProperties(in, allocator)),
        m_attributeConditions_(readAttributeConditions(in, allocator))
{
}

OccupancyGridLaneAttributeMap::OccupancyGridLaneAttributeMap(OccupancyGridLaneAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in)),
        m_feature_(readFeature(context, in)),
        m_featureReferences_(readFeatureReferences(context, in, allocator)),
        m_featureValidities_(readFeatureValidities(context, in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(context, in, allocator)),
        m_attribute_(readAttribute(context, in)),
        m_attributeValues_(readAttributeValues(context, in, allocator)),
        m_attributeProperties_(readAttributeProperties(context, in, allocator)),
        m_attributeConditions_(readAttributeConditions(context, in, allocator))
{
}

OccupancyGridLaneAttributeMap::OccupancyGridLaneAttributeMap(const OccupancyGridLaneAttributeMap& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_feature_(other.m_feature_),
        m_featureReferences_(other.m_featureReferences_),
        m_featureValidities_(other.m_featureValidities_),
        m_featureValuePtr_(other.m_featureValuePtr_),
        m_attribute_(other.m_attribute_),
        m_attributeValues_(other.m_attributeValues_),
        m_attributeProperties_(other.m_attributeProperties_),
        m_attributeConditions_(other.m_attributeConditions_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

OccupancyGridLaneAttributeMap& OccupancyGridLaneAttributeMap::operator=(const OccupancyGridLaneAttributeMap& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_feature_ = other.m_feature_;
    m_featureReferences_ = other.m_featureReferences_;
    m_featureValidities_ = other.m_featureValidities_;
    m_featureValuePtr_ = other.m_featureValuePtr_;
    m_attribute_ = other.m_attribute_;
    m_attributeValues_ = other.m_attributeValues_;
    m_attributeProperties_ = other.m_attributeProperties_;
    m_attributeConditions_ = other.m_attributeConditions_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

OccupancyGridLaneAttributeMap::OccupancyGridLaneAttributeMap(OccupancyGridLaneAttributeMap&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_feature_(::std::move(other.m_feature_)),
        m_featureReferences_(::std::move(other.m_featureReferences_)),
        m_featureValidities_(::std::move(other.m_featureValidities_)),
        m_featureValuePtr_(::std::move(other.m_featureValuePtr_)),
        m_attribute_(::std::move(other.m_attribute_)),
        m_attributeValues_(::std::move(other.m_attributeValues_)),
        m_attributeProperties_(::std::move(other.m_attributeProperties_)),
        m_attributeConditions_(::std::move(other.m_attributeConditions_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

OccupancyGridLaneAttributeMap& OccupancyGridLaneAttributeMap::operator=(OccupancyGridLaneAttributeMap&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_feature_ = ::std::move(other.m_feature_);
    m_featureReferences_ = ::std::move(other.m_featureReferences_);
    m_featureValidities_ = ::std::move(other.m_featureValidities_);
    m_featureValuePtr_ = ::std::move(other.m_featureValuePtr_);
    m_attribute_ = ::std::move(other.m_attribute_);
    m_attributeValues_ = ::std::move(other.m_attributeValues_);
    m_attributeProperties_ = ::std::move(other.m_attributeProperties_);
    m_attributeConditions_ = ::std::move(other.m_attributeConditions_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

OccupancyGridLaneAttributeMap::OccupancyGridLaneAttributeMap(::zserio::PropagateAllocatorT,
        const OccupancyGridLaneAttributeMap& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_feature_(::zserio::allocatorPropagatingCopy(other.m_feature_, allocator)),
        m_featureReferences_(::zserio::allocatorPropagatingCopy(other.m_featureReferences_, allocator)),
        m_featureValidities_(::zserio::allocatorPropagatingCopy(other.m_featureValidities_, allocator)),
        m_featureValuePtr_(::zserio::allocatorPropagatingCopy(other.m_featureValuePtr_, allocator)),
        m_attribute_(::zserio::allocatorPropagatingCopy(other.m_attribute_, allocator)),
        m_attributeValues_(::zserio::allocatorPropagatingCopy(other.m_attributeValues_, allocator)),
        m_attributeProperties_(::zserio::allocatorPropagatingCopy(other.m_attributeProperties_, allocator)),
        m_attributeConditions_(::zserio::allocatorPropagatingCopy(other.m_attributeConditions_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void OccupancyGridLaneAttributeMap::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool OccupancyGridLaneAttributeMap::isInitialized() const
{
    return m_isInitialized;
}

void OccupancyGridLaneAttributeMap::initializeChildren()
{
    m_featureValidities_.initializeElements(*this);
    m_attributeValues_.initializeElements(*this);
    m_attributeProperties_.initializeElements(*this);
    m_attributeConditions_.initializeElements(*this);
}

::nds::core::geometry::CoordShift OccupancyGridLaneAttributeMap::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'OccupancyGridLaneAttributeMap' is not initialized!");

    return m_coordShift_;
}

::nds::localization::attributes::OccupancyGridRelationAttributeType OccupancyGridLaneAttributeMap::getAttributeTypeCode() const
{
    return m_attributeTypeCode_;
}

void OccupancyGridLaneAttributeMap::setAttributeTypeCode(::nds::localization::attributes::OccupancyGridRelationAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
}

::nds::core::attributemap::FeatureIterator OccupancyGridLaneAttributeMap::getFeature() const
{
    return m_feature_;
}

void OccupancyGridLaneAttributeMap::setFeature(::nds::core::attributemap::FeatureIterator feature_)
{
    m_feature_ = feature_;
}

::zserio::vector<::nds::lane::reference::types::LaneGroupId>& OccupancyGridLaneAttributeMap::getFeatureReferences()
{
    return m_featureReferences_.getRawArray();
}

const ::zserio::vector<::nds::lane::reference::types::LaneGroupId>& OccupancyGridLaneAttributeMap::getFeatureReferences() const
{
    return m_featureReferences_.getRawArray();
}

void OccupancyGridLaneAttributeMap::setFeatureReferences(const ::zserio::vector<::nds::lane::reference::types::LaneGroupId>& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(featureReferences_);
}

void OccupancyGridLaneAttributeMap::setFeatureReferences(::zserio::vector<::nds::lane::reference::types::LaneGroupId>&& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(std::move(featureReferences_));
}

::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>& OccupancyGridLaneAttributeMap::getFeatureValidities()
{
    return m_featureValidities_.getRawArray();
}

const ::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>& OccupancyGridLaneAttributeMap::getFeatureValidities() const
{
    return m_featureValidities_.getRawArray();
}

void OccupancyGridLaneAttributeMap::setFeatureValidities(const ::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(featureValidities_);
}

void OccupancyGridLaneAttributeMap::setFeatureValidities(::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>&& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(std::move(featureValidities_));
}

::zserio::vector<::nds::core::attributemap::AttributeIterator>& OccupancyGridLaneAttributeMap::getFeatureValuePtr()
{
    return m_featureValuePtr_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& OccupancyGridLaneAttributeMap::getFeatureValuePtr() const
{
    return m_featureValuePtr_.getRawArray();
}

void OccupancyGridLaneAttributeMap::setFeatureValuePtr(const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(featureValuePtr_);
}

void OccupancyGridLaneAttributeMap::setFeatureValuePtr(::zserio::vector<::nds::core::attributemap::AttributeIterator>&& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(std::move(featureValuePtr_));
}

::nds::core::attributemap::AttributeIterator OccupancyGridLaneAttributeMap::getAttribute() const
{
    return m_attribute_;
}

void OccupancyGridLaneAttributeMap::setAttribute(::nds::core::attributemap::AttributeIterator attribute_)
{
    m_attribute_ = attribute_;
}

::zserio::vector<::nds::localization::instantiations::OccupancyGridAttribute>& OccupancyGridLaneAttributeMap::getAttributeValues()
{
    return m_attributeValues_.getRawArray();
}

const ::zserio::vector<::nds::localization::instantiations::OccupancyGridAttribute>& OccupancyGridLaneAttributeMap::getAttributeValues() const
{
    return m_attributeValues_.getRawArray();
}

void OccupancyGridLaneAttributeMap::setAttributeValues(const ::zserio::vector<::nds::localization::instantiations::OccupancyGridAttribute>& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(attributeValues_);
}

void OccupancyGridLaneAttributeMap::setAttributeValues(::zserio::vector<::nds::localization::instantiations::OccupancyGridAttribute>&& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(std::move(attributeValues_));
}

::zserio::vector<::nds::localization::instantiations::LandmarkPropertyList>& OccupancyGridLaneAttributeMap::getAttributeProperties()
{
    return m_attributeProperties_.getRawArray();
}

const ::zserio::vector<::nds::localization::instantiations::LandmarkPropertyList>& OccupancyGridLaneAttributeMap::getAttributeProperties() const
{
    return m_attributeProperties_.getRawArray();
}

void OccupancyGridLaneAttributeMap::setAttributeProperties(const ::zserio::vector<::nds::localization::instantiations::LandmarkPropertyList>& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(attributeProperties_);
}

void OccupancyGridLaneAttributeMap::setAttributeProperties(::zserio::vector<::nds::localization::instantiations::LandmarkPropertyList>&& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(std::move(attributeProperties_));
}

::zserio::vector<::nds::core::attributemap::ConditionList>& OccupancyGridLaneAttributeMap::getAttributeConditions()
{
    return m_attributeConditions_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::ConditionList>& OccupancyGridLaneAttributeMap::getAttributeConditions() const
{
    return m_attributeConditions_.getRawArray();
}

void OccupancyGridLaneAttributeMap::setAttributeConditions(const ::zserio::vector<::nds::core::attributemap::ConditionList>& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(attributeConditions_);
}

void OccupancyGridLaneAttributeMap::setAttributeConditions(::zserio::vector<::nds::core::attributemap::ConditionList>&& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(std::move(attributeConditions_));
}

void OccupancyGridLaneAttributeMap::initPackingContext(OccupancyGridLaneAttributeMap::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getAttributeTypeCode(), m_attributeTypeCode_);
    context.getFeature().init<::zserio::VarSizeArrayTraits>(m_feature_);
    context.getAttribute().init<::zserio::VarSizeArrayTraits>(m_attribute_);
}

size_t OccupancyGridLaneAttributeMap::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t OccupancyGridLaneAttributeMap::bitSizeOf(OccupancyGridLaneAttributeMap::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getAttributeTypeCode(), m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t OccupancyGridLaneAttributeMap::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t OccupancyGridLaneAttributeMap::initializeOffsets(OccupancyGridLaneAttributeMap::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getAttributeTypeCode(), endBitPosition,
        m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool OccupancyGridLaneAttributeMap::operator==(const OccupancyGridLaneAttributeMap& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_feature_ == other.m_feature_) &&
                (m_featureReferences_ == other.m_featureReferences_) &&
                (m_featureValidities_ == other.m_featureValidities_) &&
                (m_featureValuePtr_ == other.m_featureValuePtr_) &&
                (m_attribute_ == other.m_attribute_) &&
                (m_attributeValues_ == other.m_attributeValues_) &&
                (m_attributeProperties_ == other.m_attributeProperties_) &&
                (m_attributeConditions_ == other.m_attributeConditions_);
    }

    return true;
}

uint32_t OccupancyGridLaneAttributeMap::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_feature_);
    result = ::zserio::calcHashCode(result, m_featureReferences_);
    result = ::zserio::calcHashCode(result, m_featureValidities_);
    result = ::zserio::calcHashCode(result, m_featureValuePtr_);
    result = ::zserio::calcHashCode(result, m_attribute_);
    result = ::zserio::calcHashCode(result, m_attributeValues_);
    result = ::zserio::calcHashCode(result, m_attributeProperties_);
    result = ::zserio::calcHashCode(result, m_attributeConditions_);

    return result;
}

void OccupancyGridLaneAttributeMap::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_attributeTypeCode_);

    out.alignTo(8);
    out.writeVarSize(m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field OccupancyGridLaneAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field OccupancyGridLaneAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field OccupancyGridLaneAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    out.writeVarSize(m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field OccupancyGridLaneAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field OccupancyGridLaneAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field OccupancyGridLaneAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void OccupancyGridLaneAttributeMap::write(OccupancyGridLaneAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getAttributeTypeCode(), out, m_attributeTypeCode_);

    out.alignTo(8);
    context.getFeature().write<::zserio::VarSizeArrayTraits>(out, m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field OccupancyGridLaneAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field OccupancyGridLaneAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field OccupancyGridLaneAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    context.getAttribute().write<::zserio::VarSizeArrayTraits>(out, m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field OccupancyGridLaneAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field OccupancyGridLaneAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field OccupancyGridLaneAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void OccupancyGridLaneAttributeMap::ZserioElementFactory_featureReferences::create(OccupancyGridLaneAttributeMap&        ,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupId>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void OccupancyGridLaneAttributeMap::ZserioElementFactory_featureReferences::create(OccupancyGridLaneAttributeMap&        ,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupId>& array,
        ::nds::lane::reference::types::LaneGroupId::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void OccupancyGridLaneAttributeMap::ZserioArrayExpressions_featureValidities::initializeElement(OccupancyGridLaneAttributeMap& owner,
        ::nds::lane::reference::types::LaneGroupRangeValidity& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void OccupancyGridLaneAttributeMap::ZserioElementFactory_featureValidities::create(OccupancyGridLaneAttributeMap&         owner,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void OccupancyGridLaneAttributeMap::ZserioElementFactory_featureValidities::create(OccupancyGridLaneAttributeMap&         owner,
        ::zserio::vector<::nds::lane::reference::types::LaneGroupRangeValidity>& array,
        ::nds::lane::reference::types::LaneGroupRangeValidity::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void OccupancyGridLaneAttributeMap::ZserioArrayExpressions_attributeValues::initializeElement(OccupancyGridLaneAttributeMap& owner,
        ::nds::localization::instantiations::OccupancyGridAttribute& element, size_t)
{
    element.initialize(static_cast<::nds::localization::attributes::OccupancyGridRelationAttributeType>(owner.getAttributeTypeCode()));
}

void OccupancyGridLaneAttributeMap::ZserioElementFactory_attributeValues::create(OccupancyGridLaneAttributeMap&         owner,
        ::zserio::vector<::nds::localization::instantiations::OccupancyGridAttribute>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::localization::attributes::OccupancyGridRelationAttributeType>(owner.getAttributeTypeCode()), array.get_allocator());
}

void OccupancyGridLaneAttributeMap::ZserioElementFactory_attributeValues::create(OccupancyGridLaneAttributeMap&         owner,
        ::zserio::vector<::nds::localization::instantiations::OccupancyGridAttribute>& array,
        ::nds::localization::instantiations::OccupancyGridAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::localization::attributes::OccupancyGridRelationAttributeType>(owner.getAttributeTypeCode()), array.get_allocator());
}

void OccupancyGridLaneAttributeMap::ZserioArrayExpressions_attributeProperties::initializeElement(OccupancyGridLaneAttributeMap&,
        ::nds::localization::instantiations::LandmarkPropertyList& element, size_t)
{
    element.initializeChildren();
}

void OccupancyGridLaneAttributeMap::ZserioElementFactory_attributeProperties::create(OccupancyGridLaneAttributeMap&        ,
        ::zserio::vector<::nds::localization::instantiations::LandmarkPropertyList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void OccupancyGridLaneAttributeMap::ZserioElementFactory_attributeProperties::create(OccupancyGridLaneAttributeMap&        ,
        ::zserio::vector<::nds::localization::instantiations::LandmarkPropertyList>& array,
        ::nds::localization::instantiations::LandmarkPropertyList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void OccupancyGridLaneAttributeMap::ZserioArrayExpressions_attributeConditions::initializeElement(OccupancyGridLaneAttributeMap&,
        ::nds::core::attributemap::ConditionList& element, size_t)
{
    element.initializeChildren();
}

void OccupancyGridLaneAttributeMap::ZserioElementFactory_attributeConditions::create(OccupancyGridLaneAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void OccupancyGridLaneAttributeMap::ZserioElementFactory_attributeConditions::create(OccupancyGridLaneAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::nds::core::attributemap::ConditionList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::localization::attributes::OccupancyGridRelationAttributeType OccupancyGridLaneAttributeMap::readAttributeTypeCode(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::localization::attributes::OccupancyGridRelationAttributeType>(in);
}

::nds::localization::attributes::OccupancyGridRelationAttributeType OccupancyGridLaneAttributeMap::readAttributeTypeCode(OccupancyGridLaneAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::localization::attributes::OccupancyGridRelationAttributeType>(context.getAttributeTypeCode(), in);
}
::nds::core::attributemap::FeatureIterator OccupancyGridLaneAttributeMap::readFeature(::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return static_cast<::nds::core::attributemap::FeatureIterator>(in.readVarSize());
}

::nds::core::attributemap::FeatureIterator OccupancyGridLaneAttributeMap::readFeature(OccupancyGridLaneAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return context.getFeature().read<::zserio::VarSizeArrayTraits>(in);
}
OccupancyGridLaneAttributeMap::ZserioArrayType_featureReferences OccupancyGridLaneAttributeMap::readFeatureReferences(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

OccupancyGridLaneAttributeMap::ZserioArrayType_featureReferences OccupancyGridLaneAttributeMap::readFeatureReferences(OccupancyGridLaneAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
OccupancyGridLaneAttributeMap::ZserioArrayType_featureValidities OccupancyGridLaneAttributeMap::readFeatureValidities(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValidities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

OccupancyGridLaneAttributeMap::ZserioArrayType_featureValidities OccupancyGridLaneAttributeMap::readFeatureValidities(OccupancyGridLaneAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValidities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
OccupancyGridLaneAttributeMap::ZserioArrayType_featureValuePtr OccupancyGridLaneAttributeMap::readFeatureValuePtr(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}

OccupancyGridLaneAttributeMap::ZserioArrayType_featureValuePtr OccupancyGridLaneAttributeMap::readFeatureValuePtr(OccupancyGridLaneAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}
::nds::core::attributemap::AttributeIterator OccupancyGridLaneAttributeMap::readAttribute(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::attributemap::AttributeIterator>(in.readVarSize());
}

::nds::core::attributemap::AttributeIterator OccupancyGridLaneAttributeMap::readAttribute(OccupancyGridLaneAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getAttribute().read<::zserio::VarSizeArrayTraits>(in);
}
OccupancyGridLaneAttributeMap::ZserioArrayType_attributeValues OccupancyGridLaneAttributeMap::readAttributeValues(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributeValues readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

OccupancyGridLaneAttributeMap::ZserioArrayType_attributeValues OccupancyGridLaneAttributeMap::readAttributeValues(OccupancyGridLaneAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributeValues readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
OccupancyGridLaneAttributeMap::ZserioArrayType_attributeProperties OccupancyGridLaneAttributeMap::readAttributeProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

OccupancyGridLaneAttributeMap::ZserioArrayType_attributeProperties OccupancyGridLaneAttributeMap::readAttributeProperties(OccupancyGridLaneAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
OccupancyGridLaneAttributeMap::ZserioArrayType_attributeConditions OccupancyGridLaneAttributeMap::readAttributeConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

OccupancyGridLaneAttributeMap::ZserioArrayType_attributeConditions OccupancyGridLaneAttributeMap::readAttributeConditions(OccupancyGridLaneAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

} // namespace instantiations
} // namespace localization
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/localization/instantiations/OccupancyGridRoadAttributeMap.h>

namespace nds
{
namespace localization
{
namespace instantiations
{

OccupancyGridRoadAttributeMap::OccupancyGridRoadAttributeMap(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeTypeCode_(::nds::localization::attributes::OccupancyGridRelationAttributeType()),
        m_feature_(::nds::core::attributemap::FeatureIterator()),
        m_featureReferences_(allocator),
        m_featureValidities_(allocator),
        m_featureValuePtr_(allocator),
        m_attribute_(::nds::core::attributemap::AttributeIterator()),
        m_attributeValues_(allocator),
        m_attributeProperties_(allocator),
        m_attributeConditions_(allocator)
{
}

OccupancyGridRoadAttributeMap::OccupancyGridRoadAttributeMap(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(in)),
        m_feature_(readFeature(in)),
        m_featureReferences_(readFeatureReferences(in, allocator)),
        m_featureValidities_(readFeatureValidities(in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(in, allocator)),
        m_attribute_(readAttribute(in)),
        m_attributeValues_(readAttributeValues(in, allocator)),
        m_attributeProperties_(readAttributeProperties(in, allocator)),
        m_attributeConditions_(readAttributeConditions(in, allocator))
{
}

OccupancyGridRoadAttributeMap::OccupancyGridRoadAttributeMap(OccupancyGridRoadAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift coordShift_, const allocator_type& allocator) :
        m_coordShift_(coordShift_),
        m_isInitialized(true),
        m_attributeTypeCode_(readAttributeTypeCode(context, in)),
        m_feature_(readFeature(context, in)),
        m_featureReferences_(readFeatureReferences(context, in, allocator)),
        m_featureValidities_(readFeatureValidities(context, in, allocator)),
        m_featureValuePtr_(readFeatureValuePtr(context, in, allocator)),
        m_attribute_(readAttribute(context, in)),
        m_attributeValues_(readAttributeValues(context, in, allocator)),
        m_attributeProperties_(readAttributeProperties(context, in, allocator)),
        m_attributeConditions_(readAttributeConditions(context, in, allocator))
{
}

OccupancyGridRoadAttributeMap::OccupancyGridRoadAttributeMap(const OccupancyGridRoadAttributeMap& other) :
        m_attributeTypeCode_(other.m_attributeTypeCode_),
        m_feature_(other.m_feature_),
        m_featureReferences_(other.m_featureReferences_),
        m_featureValidities_(other.m_featureValidities_),
        m_featureValuePtr_(other.m_featureValuePtr_),
        m_attribute_(other.m_attribute_),
        m_attributeValues_(other.m_attributeValues_),
        m_attributeProperties_(other.m_attributeProperties_),
        m_attributeConditions_(other.m_attributeConditions_)
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

OccupancyGridRoadAttributeMap& OccupancyGridRoadAttributeMap::operator=(const OccupancyGridRoadAttributeMap& other)
{
    m_attributeTypeCode_ = other.m_attributeTypeCode_;
    m_feature_ = other.m_feature_;
    m_featureReferences_ = other.m_featureReferences_;
    m_featureValidities_ = other.m_featureValidities_;
    m_featureValuePtr_ = other.m_featureValuePtr_;
    m_attribute_ = other.m_attribute_;
    m_attributeValues_ = other.m_attributeValues_;
    m_attributeProperties_ = other.m_attributeProperties_;
    m_attributeConditions_ = other.m_attributeConditions_;
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

OccupancyGridRoadAttributeMap::OccupancyGridRoadAttributeMap(OccupancyGridRoadAttributeMap&& other) :
        m_attributeTypeCode_(::std::move(other.m_attributeTypeCode_)),
        m_feature_(::std::move(other.m_feature_)),
        m_featureReferences_(::std::move(other.m_featureReferences_)),
        m_featureValidities_(::std::move(other.m_featureValidities_)),
        m_featureValuePtr_(::std::move(other.m_featureValuePtr_)),
        m_attribute_(::std::move(other.m_attribute_)),
        m_attributeValues_(::std::move(other.m_attributeValues_)),
        m_attributeProperties_(::std::move(other.m_attributeProperties_)),
        m_attributeConditions_(::std::move(other.m_attributeConditions_))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

OccupancyGridRoadAttributeMap& OccupancyGridRoadAttributeMap::operator=(OccupancyGridRoadAttributeMap&& other)
{
    m_attributeTypeCode_ = ::std::move(other.m_attributeTypeCode_);
    m_feature_ = ::std::move(other.m_feature_);
    m_featureReferences_ = ::std::move(other.m_featureReferences_);
    m_featureValidities_ = ::std::move(other.m_featureValidities_);
    m_featureValuePtr_ = ::std::move(other.m_featureValuePtr_);
    m_attribute_ = ::std::move(other.m_attribute_);
    m_attributeValues_ = ::std::move(other.m_attributeValues_);
    m_attributeProperties_ = ::std::move(other.m_attributeProperties_);
    m_attributeConditions_ = ::std::move(other.m_attributeConditions_);
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;

    return *this;
}

OccupancyGridRoadAttributeMap::OccupancyGridRoadAttributeMap(::zserio::PropagateAllocatorT,
        const OccupancyGridRoadAttributeMap& other, const allocator_type& allocator) :
        m_attributeTypeCode_(::zserio::allocatorPropagatingCopy(other.m_attributeTypeCode_, allocator)),
        m_feature_(::zserio::allocatorPropagatingCopy(other.m_feature_, allocator)),
        m_featureReferences_(::zserio::allocatorPropagatingCopy(other.m_featureReferences_, allocator)),
        m_featureValidities_(::zserio::allocatorPropagatingCopy(other.m_featureValidities_, allocator)),
        m_featureValuePtr_(::zserio::allocatorPropagatingCopy(other.m_featureValuePtr_, allocator)),
        m_attribute_(::zserio::allocatorPropagatingCopy(other.m_attribute_, allocator)),
        m_attributeValues_(::zserio::allocatorPropagatingCopy(other.m_attributeValues_, allocator)),
        m_attributeProperties_(::zserio::allocatorPropagatingCopy(other.m_attributeProperties_, allocator)),
        m_attributeConditions_(::zserio::allocatorPropagatingCopy(other.m_attributeConditions_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_coordShift_);
    else
        m_isInitialized = false;
}

void OccupancyGridRoadAttributeMap::initialize(
        ::nds::core::geometry::CoordShift coordShift_)
{
    m_coordShift_ = coordShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool OccupancyGridRoadAttributeMap::isInitialized() const
{
    return m_isInitialized;
}

void OccupancyGridRoadAttributeMap::initializeChildren()
{
    m_featureValidities_.initializeElements(*this);
    m_attributeValues_.initializeElements(*this);
    m_attributeProperties_.initializeElements(*this);
    m_attributeConditions_.initializeElements(*this);
}

::nds::core::geometry::CoordShift OccupancyGridRoadAttributeMap::getCoordShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'coordShift' of compound 'OccupancyGridRoadAttributeMap' is not initialized!");

    return m_coordShift_;
}

::nds::localization::attributes::OccupancyGridRelationAttributeType OccupancyGridRoadAttributeMap::getAttributeTypeCode() const
{
    return m_attributeTypeCode_;
}

void OccupancyGridRoadAttributeMap::setAttributeTypeCode(::nds::localization::attributes::OccupancyGridRelationAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
}

::nds::core::attributemap::FeatureIterator OccupancyGridRoadAttributeMap::getFeature() const
{
    return m_feature_;
}

void OccupancyGridRoadAttributeMap::setFeature(::nds::core::attributemap::FeatureIterator feature_)
{
    m_feature_ = feature_;
}

::zserio::vector<::nds::road::reference::types::RoadReference>& OccupancyGridRoadAttributeMap::getFeatureReferences()
{
    return m_featureReferences_.getRawArray();
}

const ::zserio::vector<::nds::road::reference::types::RoadReference>& OccupancyGridRoadAttributeMap::getFeatureReferences() const
{
    return m_featureReferences_.getRawArray();
}

void OccupancyGridRoadAttributeMap::setFeatureReferences(const ::zserio::vector<::nds::road::reference::types::RoadReference>& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(featureReferences_);
}

void OccupancyGridRoadAttributeMap::setFeatureReferences(::zserio::vector<::nds::road::reference::types::RoadReference>&& featureReferences_)
{
    m_featureReferences_ = ZserioArrayType_featureReferences(std::move(featureReferences_));
}

::zserio::vector<::nds::road::reference::types::RoadValidityRange>& OccupancyGridRoadAttributeMap::getFeatureValidities()
{
    return m_featureValidities_.getRawArray();
}

const ::zserio::vector<::nds::road::reference::types::RoadValidityRange>& OccupancyGridRoadAttributeMap::getFeatureValidities() const
{
    return m_featureValidities_.getRawArray();
}

void OccupancyGridRoadAttributeMap::setFeatureValidities(const ::zserio::vector<::nds::road::reference::types::RoadValidityRange>& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(featureValidities_);
}

void OccupancyGridRoadAttributeMap::setFeatureValidities(::zserio::vector<::nds::road::reference::types::RoadValidityRange>&& featureValidities_)
{
    m_featureValidities_ = ZserioArrayType_featureValidities(std::move(featureValidities_));
}

::zserio::vector<::nds::core::attributemap::AttributeIterator>& OccupancyGridRoadAttributeMap::getFeatureValuePtr()
{
    return m_featureValuePtr_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& OccupancyGridRoadAttributeMap::getFeatureValuePtr() const
{
    return m_featureValuePtr_.getRawArray();
}

void OccupancyGridRoadAttributeMap::setFeatureValuePtr(const ::zserio::vector<::nds::core::attributemap::AttributeIterator>& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(featureValuePtr_);
}

void OccupancyGridRoadAttributeMap::setFeatureValuePtr(::zserio::vector<::nds::core::attributemap::AttributeIterator>&& featureValuePtr_)
{
    m_featureValuePtr_ = ZserioArrayType_featureValuePtr(std::move(featureValuePtr_));
}

::nds::core::attributemap::AttributeIterator OccupancyGridRoadAttributeMap::getAttribute() const
{
    return m_attribute_;
}

void OccupancyGridRoadAttributeMap::setAttribute(::nds::core::attributemap::AttributeIterator attribute_)
{
    m_attribute_ = attribute_;
}

::zserio::vector<::nds::localization::instantiations::OccupancyGridAttribute>& OccupancyGridRoadAttributeMap::getAttributeValues()
{
    return m_attributeValues_.getRawArray();
}

const ::zserio::vector<::nds::localization::instantiations::OccupancyGridAttribute>& OccupancyGridRoadAttributeMap::getAttributeValues() const
{
    return m_attributeValues_.getRawArray();
}

void OccupancyGridRoadAttributeMap::setAttributeValues(const ::zserio::vector<::nds::localization::instantiations::OccupancyGridAttribute>& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(attributeValues_);
}

void OccupancyGridRoadAttributeMap::setAttributeValues(::zserio::vector<::nds::localization::instantiations::OccupancyGridAttribute>&& attributeValues_)
{
    m_attributeValues_ = ZserioArrayType_attributeValues(std::move(attributeValues_));
}

::zserio::vector<::nds::localization::instantiations::LandmarkPropertyList>& OccupancyGridRoadAttributeMap::getAttributeProperties()
{
    return m_attributeProperties_.getRawArray();
}

const ::zserio::vector<::nds::localization::instantiations::LandmarkPropertyList>& OccupancyGridRoadAttributeMap::getAttributeProperties() const
{
    return m_attributeProperties_.getRawArray();
}

void OccupancyGridRoadAttributeMap::setAttributeProperties(const ::zserio::vector<::nds::localization::instantiations::LandmarkPropertyList>& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(attributeProperties_);
}

void OccupancyGridRoadAttributeMap::setAttributeProperties(::zserio::vector<::nds::localization::instantiations::LandmarkPropertyList>&& attributeProperties_)
{
    m_attributeProperties_ = ZserioArrayType_attributeProperties(std::move(attributeProperties_));
}

::zserio::vector<::nds::core::attributemap::ConditionList>& OccupancyGridRoadAttributeMap::getAttributeConditions()
{
    return m_attributeConditions_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::ConditionList>& OccupancyGridRoadAttributeMap::getAttributeConditions() const
{
    return m_attributeConditions_.getRawArray();
}

void OccupancyGridRoadAttributeMap::setAttributeConditions(const ::zserio::vector<::nds::core::attributemap::ConditionList>& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(attributeConditions_);
}

void OccupancyGridRoadAttributeMap::setAttributeConditions(::zserio::vector<::nds::core::attributemap::ConditionList>&& attributeConditions_)
{
    m_attributeConditions_ = ZserioArrayType_attributeConditions(std::move(attributeConditions_));
}

void OccupancyGridRoadAttributeMap::initPackingContext(OccupancyGridRoadAttributeMap::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getAttributeTypeCode(), m_attributeTypeCode_);
    context.getFeature().init<::zserio::VarSizeArrayTraits>(m_feature_);
    context.getAttribute().init<::zserio::VarSizeArrayTraits>(m_attribute_);
}

size_t OccupancyGridRoadAttributeMap::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t OccupancyGridRoadAttributeMap::bitSizeOf(OccupancyGridRoadAttributeMap::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getAttributeTypeCode(), m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition += m_featureReferences_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValidities_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_featureValuePtr_.bitSizeOfPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition += m_attributeValues_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeProperties_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += m_attributeConditions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t OccupancyGridRoadAttributeMap::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t OccupancyGridRoadAttributeMap::initializeOffsets(OccupancyGridRoadAttributeMap::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getAttributeTypeCode(), endBitPosition,
        m_attributeTypeCode_);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition += context.getFeature().bitSizeOf<::zserio::VarSizeArrayTraits>(m_feature_);
    endBitPosition = m_featureReferences_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValidities_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_featureValuePtr_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += context.getAttribute().bitSizeOf<::zserio::VarSizeArrayTraits>(m_attribute_);
    endBitPosition = m_attributeValues_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeProperties_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = ::zserio::alignTo(8, endBitPosition);
    endBitPosition = m_attributeConditions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool OccupancyGridRoadAttributeMap::operator==(const OccupancyGridRoadAttributeMap& other) const
{
    if (this != &other)
    {
        return
                (getCoordShift() == other.getCoordShift()) &&
                (m_attributeTypeCode_ == other.m_attributeTypeCode_) &&
                (m_feature_ == other.m_feature_) &&
                (m_featureReferences_ == other.m_featureReferences_) &&
                (m_featureValidities_ == other.m_featureValidities_) &&
                (m_featureValuePtr_ == other.m_featureValuePtr_) &&
                (m_attribute_ == other.m_attribute_) &&
                (m_attributeValues_ == other.m_attributeValues_) &&
                (m_attributeProperties_ == other.m_attributeProperties_) &&
                (m_attributeConditions_ == other.m_attributeConditions_);
    }

    return true;
}

uint32_t OccupancyGridRoadAttributeMap::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getCoordShift());
    result = ::zserio::calcHashCode(result, m_attributeTypeCode_);
    result = ::zserio::calcHashCode(result, m_feature_);
    result = ::zserio::calcHashCode(result, m_featureReferences_);
    result = ::zserio::calcHashCode(result, m_featureValidities_);
    result = ::zserio::calcHashCode(result, m_featureValuePtr_);
    result = ::zserio::calcHashCode(result, m_attribute_);
    result = ::zserio::calcHashCode(result, m_attributeValues_);
    result = ::zserio::calcHashCode(result, m_attributeProperties_);
    result = ::zserio::calcHashCode(result, m_attributeConditions_);

    return result;
}

void OccupancyGridRoadAttributeMap::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_attributeTypeCode_);

    out.alignTo(8);
    out.writeVarSize(m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field OccupancyGridRoadAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field OccupancyGridRoadAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field OccupancyGridRoadAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    out.writeVarSize(m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field OccupancyGridRoadAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field OccupancyGridRoadAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field OccupancyGridRoadAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void OccupancyGridRoadAttributeMap::write(OccupancyGridRoadAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getAttributeTypeCode(), out, m_attributeTypeCode_);

    out.alignTo(8);
    context.getFeature().write<::zserio::VarSizeArrayTraits>(out, m_feature_);

    // check array length
    if (m_featureReferences_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field OccupancyGridRoadAttributeMap.featureReferences: ") <<
                m_featureReferences_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureReferences_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValidities_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field OccupancyGridRoadAttributeMap.featureValidities: ") <<
                m_featureValidities_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValidities_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_featureValuePtr_.getRawArray().size() != static_cast<size_t>(getFeature()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field OccupancyGridRoadAttributeMap.featureValuePtr: ") <<
                m_featureValuePtr_.getRawArray().size() << " != " <<
                static_cast<size_t>(getFeature()) << "!";
    }
    m_featureValuePtr_.writePacked(out);

    context.getAttribute().write<::zserio::VarSizeArrayTraits>(out, m_attribute_);

    // check array length
    if (m_attributeValues_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field OccupancyGridRoadAttributeMap.attributeValues: ") <<
                m_attributeValues_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeValues_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeProperties_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field OccupancyGridRoadAttributeMap.attributeProperties: ") <<
                m_attributeProperties_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeProperties_.writePacked(*this, out);

    out.alignTo(8);
    // check array length
    if (m_attributeConditions_.getRawArray().size() != static_cast<size_t>(getAttribute()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field OccupancyGridRoadAttributeMap.attributeConditions: ") <<
                m_attributeConditions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getAttribute()) << "!";
    }
    m_attributeConditions_.writePacked(*this, out);
}

void OccupancyGridRoadAttributeMap::ZserioElementFactory_featureReferences::create(OccupancyGridRoadAttributeMap&        ,
        ::zserio::vector<::nds::road::reference::types::RoadReference>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void OccupancyGridRoadAttributeMap::ZserioElementFactory_featureReferences::create(OccupancyGridRoadAttributeMap&        ,
        ::zserio::vector<::nds::road::reference::types::RoadReference>& array,
        ::nds::road::reference::types::RoadReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void OccupancyGridRoadAttributeMap::ZserioArrayExpressions_featureValidities::initializeElement(OccupancyGridRoadAttributeMap& owner,
        ::nds::road::reference::types::RoadValidityRange& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()));
}

void OccupancyGridRoadAttributeMap::ZserioElementFactory_featureValidities::create(OccupancyGridRoadAttributeMap&         owner,
        ::zserio::vector<::nds::road::reference::types::RoadValidityRange>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void OccupancyGridRoadAttributeMap::ZserioElementFactory_featureValidities::create(OccupancyGridRoadAttributeMap&         owner,
        ::zserio::vector<::nds::road::reference::types::RoadValidityRange>& array,
        ::nds::road::reference::types::RoadValidityRange::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getCoordShift()), array.get_allocator());
}

void OccupancyGridRoadAttributeMap::ZserioArrayExpressions_attributeValues::initializeElement(OccupancyGridRoadAttributeMap& owner,
        ::nds::localization::instantiations::OccupancyGridAttribute& element, size_t)
{
    element.initialize(static_cast<::nds::localization::attributes::OccupancyGridRelationAttributeType>(owner.getAttributeTypeCode()));
}

void OccupancyGridRoadAttributeMap::ZserioElementFactory_attributeValues::create(OccupancyGridRoadAttributeMap&         owner,
        ::zserio::vector<::nds::localization::instantiations::OccupancyGridAttribute>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::localization::attributes::OccupancyGridRelationAttributeType>(owner.getAttributeTypeCode()), array.get_allocator());
}

void OccupancyGridRoadAttributeMap::ZserioElementFactory_attributeValues::create(OccupancyGridRoadAttributeMap&         owner,
        ::zserio::vector<::nds::localization::instantiations::OccupancyGridAttribute>& array,
        ::nds::localization::instantiations::OccupancyGridAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::localization::attributes::OccupancyGridRelationAttributeType>(owner.getAttributeTypeCode()), array.get_allocator());
}

void OccupancyGridRoadAttributeMap::ZserioArrayExpressions_attributeProperties::initializeElement(OccupancyGridRoadAttributeMap&,
        ::nds::localization::instantiations::LandmarkPropertyList& element, size_t)
{
    element.initializeChildren();
}

void OccupancyGridRoadAttributeMap::ZserioElementFactory_attributeProperties::create(OccupancyGridRoadAttributeMap&        ,
        ::zserio::vector<::nds::localization::instantiations::LandmarkPropertyList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void OccupancyGridRoadAttributeMap::ZserioElementFactory_attributeProperties::create(OccupancyGridRoadAttributeMap&        ,
        ::zserio::vector<::nds::localization::instantiations::LandmarkPropertyList>& array,
        ::nds::localization::instantiations::LandmarkPropertyList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

void OccupancyGridRoadAttributeMap::ZserioArrayExpressions_attributeConditions::initializeElement(OccupancyGridRoadAttributeMap&,
        ::nds::core::attributemap::ConditionList& element, size_t)
{
    element.initializeChildren();
}

void OccupancyGridRoadAttributeMap::ZserioElementFactory_attributeConditions::create(OccupancyGridRoadAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void OccupancyGridRoadAttributeMap::ZserioElementFactory_attributeConditions::create(OccupancyGridRoadAttributeMap&        ,
        ::zserio::vector<::nds::core::attributemap::ConditionList>& array,
        ::nds::core::attributemap::ConditionList::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::localization::attributes::OccupancyGridRelationAttributeType OccupancyGridRoadAttributeMap::readAttributeTypeCode(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::localization::attributes::OccupancyGridRelationAttributeType>(in);
}

::nds::localization::attributes::OccupancyGridRelationAttributeType OccupancyGridRoadAttributeMap::readAttributeTypeCode(OccupancyGridRoadAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::localization::attributes::OccupancyGridRelationAttributeType>(context.getAttributeTypeCode(), in);
}
::nds::core::attributemap::FeatureIterator OccupancyGridRoadAttributeMap::readFeature(::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return static_cast<::nds::core::attributemap::FeatureIterator>(in.readVarSize());
}

::nds::core::attributemap::FeatureIterator OccupancyGridRoadAttributeMap::readFeature(OccupancyGridRoadAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    in.alignTo(8);
    return context.getFeature().read<::zserio::VarSizeArrayTraits>(in);
}
OccupancyGridRoadAttributeMap::ZserioArrayType_featureReferences OccupancyGridRoadAttributeMap::readFeatureReferences(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

OccupancyGridRoadAttributeMap::ZserioArrayType_featureReferences OccupancyGridRoadAttributeMap::readFeatureReferences(OccupancyGridRoadAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_featureReferences readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
OccupancyGridRoadAttributeMap::ZserioArrayType_featureValidities OccupancyGridRoadAttributeMap::readFeatureValidities(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValidities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}

OccupancyGridRoadAttributeMap::ZserioArrayType_featureValidities OccupancyGridRoadAttributeMap::readFeatureValidities(OccupancyGridRoadAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValidities readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getFeature()));

    return readField;
}
OccupancyGridRoadAttributeMap::ZserioArrayType_featureValuePtr OccupancyGridRoadAttributeMap::readFeatureValuePtr(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}

OccupancyGridRoadAttributeMap::ZserioArrayType_featureValuePtr OccupancyGridRoadAttributeMap::readFeatureValuePtr(OccupancyGridRoadAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_featureValuePtr readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getFeature()));

    return readField;
}
::nds::core::attributemap::AttributeIterator OccupancyGridRoadAttributeMap::readAttribute(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::attributemap::AttributeIterator>(in.readVarSize());
}

::nds::core::attributemap::AttributeIterator OccupancyGridRoadAttributeMap::readAttribute(OccupancyGridRoadAttributeMap::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getAttribute().read<::zserio::VarSizeArrayTraits>(in);
}
OccupancyGridRoadAttributeMap::ZserioArrayType_attributeValues OccupancyGridRoadAttributeMap::readAttributeValues(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_attributeValues readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

OccupancyGridRoadAttributeMap::ZserioArrayType_attributeValues OccupancyGridRoadAttributeMap::readAttributeValues(OccupancyGridRoadAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_attributeValues readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
OccupancyGridRoadAttributeMap::ZserioArrayType_attributeProperties OccupancyGridRoadAttributeMap::readAttributeProperties(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

OccupancyGridRoadAttributeMap::ZserioArrayType_attributeProperties OccupancyGridRoadAttributeMap::readAttributeProperties(OccupancyGridRoadAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeProperties readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}
OccupancyGridRoadAttributeMap::ZserioArrayType_attributeConditions OccupancyGridRoadAttributeMap::readAttributeConditions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

OccupancyGridRoadAttributeMap::ZserioArrayType_attributeConditions OccupancyGridRoadAttributeMap::readAttributeConditions(OccupancyGridRoadAttributeMap::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    in.alignTo(8);
    ZserioArrayType_attributeConditions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getAttribute()));

    return readField;
}

} // namespace instantiations
} // namespace localization
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/localization/instantiations/OccupancyGridAttribute.h>

namespace nds
{
namespace localization
{
namespace instantiations
{

OccupancyGridAttribute::OccupancyGridAttribute(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_attributeValue_(allocator)
{
}

OccupancyGridAttribute::OccupancyGridAttribute(::zserio::BitStreamReader& in,
        ::nds::localization::attributes::OccupancyGridRelationAttributeType attributeTypeCode_, const allocator_type& allocator) :
        m_attributeTypeCode_(attributeTypeCode_),
        m_isInitialized(true),
        m_attributeValue_(readAttributeValue(in, allocator))
{
}

OccupancyGridAttribute::OccupancyGridAttribute(OccupancyGridAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::localization::attributes::OccupancyGridRelationAttributeType attributeTypeCode_, const allocator_type& allocator) :
        m_attributeTypeCode_(attributeTypeCode_),
        m_isInitialized(true),
        m_attributeValue_(readAttributeValue(context, in, allocator))
{
}

OccupancyGridAttribute::OccupancyGridAttribute(const OccupancyGridAttribute& other) :
        m_attributeValue_(other.m_attributeValue_)
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

OccupancyGridAttribute& OccupancyGridAttribute::operator=(const OccupancyGridAttribute& other)
{
    m_attributeValue_ = other.m_attributeValue_;
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;

    return *this;
}

OccupancyGridAttribute::OccupancyGridAttribute(OccupancyGridAttribute&& other) :
        m_attributeValue_(::std::move(other.m_attributeValue_))
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

OccupancyGridAttribute& OccupancyGridAttribute::operator=(OccupancyGridAttribute&& other)
{
    m_attributeValue_ = ::std::move(other.m_attributeValue_);
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;

    return *this;
}

OccupancyGridAttribute::OccupancyGridAttribute(::zserio::PropagateAllocatorT,
        const OccupancyGridAttribute& other, const allocator_type& allocator) :
        m_attributeValue_(::zserio::allocatorPropagatingCopy(other.m_attributeValue_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_attributeTypeCode_);
    else
        m_isInitialized = false;
}

void OccupancyGridAttribute::initialize(
        ::nds::localization::attributes::OccupancyGridRelationAttributeType attributeTypeCode_)
{
    m_attributeTypeCode_ = attributeTypeCode_;
    m_isInitialized = true;

    initializeChildren();
}

bool OccupancyGridAttribute::isInitialized() const
{
    return m_isInitialized;
}

void OccupancyGridAttribute::initializeChildren()
{
    m_attributeValue_.initialize(static_cast<::nds::localization::attributes::OccupancyGridRelationAttributeType>(getAttributeTypeCode()));
}

::nds::localization::attributes::OccupancyGridRelationAttributeType OccupancyGridAttribute::getAttributeTypeCode() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'attributeTypeCode' of compound 'OccupancyGridAttribute' is not initialized!");

    return m_attributeTypeCode_;
}

::nds::localization::attributes::OccupancyGridRelationAttributeValue& OccupancyGridAttribute::getAttributeValue()
{
    return m_attributeValue_;
}

const ::nds::localization::attributes::OccupancyGridRelationAttributeValue& OccupancyGridAttribute::getAttributeValue() const
{
    return m_attributeValue_;
}

void OccupancyGridAttribute::setAttributeValue(const ::nds::localization::attributes::OccupancyGridRelationAttributeValue& attributeValue_)
{
    m_attributeValue_ = attributeValue_;
}

void OccupancyGridAttribute::setAttributeValue(::nds::localization::attributes::OccupancyGridRelationAttributeValue&& attributeValue_)
{
    m_attributeValue_ = ::std::move(attributeValue_);
}

void OccupancyGridAttribute::initPackingContext(OccupancyGridAttribute::ZserioPackingContext& context) const
{
    m_attributeValue_.initPackingContext(context.getAttributeValue());
}

size_t OccupancyGridAttribute::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeValue_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t OccupancyGridAttribute::bitSizeOf(OccupancyGridAttribute::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_attributeValue_.bitSizeOf(context.getAttributeValue(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t OccupancyGridAttribute::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeValue_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t OccupancyGridAttribute::initializeOffsets(OccupancyGridAttribute::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_attributeValue_.initializeOffsets(context.getAttributeValue(), endBitPosition);

    return endBitPosition;
}

bool OccupancyGridAttribute::operator==(const OccupancyGridAttribute& other) const
{
    if (this != &other)
    {
        return
                (getAttributeTypeCode() == other.getAttributeTypeCode()) &&
                (m_attributeValue_ == other.m_attributeValue_);
    }

    return true;
}

uint32_t OccupancyGridAttribute::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getAttributeTypeCode());
    result = ::zserio::calcHashCode(result, m_attributeValue_);

    return result;
}

void OccupancyGridAttribute::write(::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::localization::attributes::OccupancyGridRelationAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field OccupancyGridAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::localization::attributes::OccupancyGridRelationAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(out);
}

void OccupancyGridAttribute::write(OccupancyGridAttribute::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_attributeValue_.getType() != static_cast<::nds::localization::attributes::OccupancyGridRelationAttributeType>(getAttributeTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field OccupancyGridAttribute.attributeValue: ") <<
                m_attributeValue_.getType() << " != " << static_cast<::nds::localization::attributes::OccupancyGridRelationAttributeType>(getAttributeTypeCode()) << "!";
    }
    m_attributeValue_.write(context.getAttributeValue(), out);
}

::nds::localization::attributes::OccupancyGridRelationAttributeValue OccupancyGridAttribute::readAttributeValue(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::localization::attributes::OccupancyGridRelationAttributeValue(in, static_cast<::nds::localization::attributes::OccupancyGridRelationAttributeType>(getAttributeTypeCode()), allocator);
}

::nds::localization::attributes::OccupancyGridRelationAttributeValue OccupancyGridAttribute::readAttributeValue(OccupancyGridAttribute::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::localization::attributes::OccupancyGridRelationAttributeValue(context.getAttributeValue(), in, static_cast<::nds::localization::attributes::OccupancyGridRelationAttributeType>(getAttributeTypeCode()), allocator);
}

} // namespace instantiations
} // namespace localization
} // namespace nds
