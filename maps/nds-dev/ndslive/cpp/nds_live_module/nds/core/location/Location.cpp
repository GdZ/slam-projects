/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/core/location/RoadLocationPath.h>

namespace nds
{
namespace core
{
namespace location
{

RoadLocationPath::RoadLocationPath(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_pathGeometry_(allocator),
        m_locationPathSegments_(allocator)
{
}

RoadLocationPath::RoadLocationPath(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_pathGeometry_(readPathGeometry(in, allocator)),
        m_locationPathSegments_(readLocationPathSegments(in, allocator))
{
}

RoadLocationPath::RoadLocationPath(RoadLocationPath::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_pathGeometry_(readPathGeometry(context, in, allocator)),
        m_locationPathSegments_(readLocationPathSegments(context, in, allocator))
{
}

RoadLocationPath::RoadLocationPath(const RoadLocationPath& other) :
        m_pathGeometry_(other.m_pathGeometry_),
        m_locationPathSegments_(other.m_locationPathSegments_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

RoadLocationPath& RoadLocationPath::operator=(const RoadLocationPath& other)
{
    m_pathGeometry_ = other.m_pathGeometry_;
    m_locationPathSegments_ = other.m_locationPathSegments_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

RoadLocationPath::RoadLocationPath(RoadLocationPath&& other) :
        m_pathGeometry_(::std::move(other.m_pathGeometry_)),
        m_locationPathSegments_(::std::move(other.m_locationPathSegments_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

RoadLocationPath& RoadLocationPath::operator=(RoadLocationPath&& other)
{
    m_pathGeometry_ = ::std::move(other.m_pathGeometry_);
    m_locationPathSegments_ = ::std::move(other.m_locationPathSegments_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

RoadLocationPath::RoadLocationPath(::zserio::PropagateAllocatorT,
        const RoadLocationPath& other, const allocator_type& allocator) :
        m_pathGeometry_(::zserio::allocatorPropagatingCopy(other.m_pathGeometry_, allocator)),
        m_locationPathSegments_(::zserio::allocatorPropagatingCopy(other.m_locationPathSegments_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void RoadLocationPath::initializeChildren()
{
    m_pathGeometry_.initializeChildren();
    m_locationPathSegments_.initializeElements(*this);

    m_areChildrenInitialized = true;
}

::nds::core::location::LocationGeometry& RoadLocationPath::getPathGeometry()
{
    return m_pathGeometry_;
}

const ::nds::core::location::LocationGeometry& RoadLocationPath::getPathGeometry() const
{
    return m_pathGeometry_;
}

void RoadLocationPath::setPathGeometry(const ::nds::core::location::LocationGeometry& pathGeometry_)
{
    m_pathGeometry_ = pathGeometry_;
}

void RoadLocationPath::setPathGeometry(::nds::core::location::LocationGeometry&& pathGeometry_)
{
    m_pathGeometry_ = ::std::move(pathGeometry_);
}

::zserio::vector<::nds::core::location::LocationSegment>& RoadLocationPath::getLocationPathSegments()
{
    return m_locationPathSegments_.getRawArray();
}

const ::zserio::vector<::nds::core::location::LocationSegment>& RoadLocationPath::getLocationPathSegments() const
{
    return m_locationPathSegments_.getRawArray();
}

void RoadLocationPath::setLocationPathSegments(const ::zserio::vector<::nds::core::location::LocationSegment>& locationPathSegments_)
{
    m_locationPathSegments_ = ZserioArrayType_locationPathSegments(locationPathSegments_);
}

void RoadLocationPath::setLocationPathSegments(::zserio::vector<::nds::core::location::LocationSegment>&& locationPathSegments_)
{
    m_locationPathSegments_ = ZserioArrayType_locationPathSegments(std::move(locationPathSegments_));
}

void RoadLocationPath::initPackingContext(RoadLocationPath::ZserioPackingContext& context) const
{
    m_pathGeometry_.initPackingContext(context.getPathGeometry());
}

size_t RoadLocationPath::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_pathGeometry_.bitSizeOf(endBitPosition);
    endBitPosition += m_locationPathSegments_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoadLocationPath::bitSizeOf(RoadLocationPath::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_pathGeometry_.bitSizeOf(context.getPathGeometry(), endBitPosition);
    endBitPosition += m_locationPathSegments_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t RoadLocationPath::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_pathGeometry_.initializeOffsets(endBitPosition);
    endBitPosition = m_locationPathSegments_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t RoadLocationPath::initializeOffsets(RoadLocationPath::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_pathGeometry_.initializeOffsets(context.getPathGeometry(), endBitPosition);
    endBitPosition = m_locationPathSegments_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool RoadLocationPath::operator==(const RoadLocationPath& other) const
{
    if (this != &other)
    {
        return
                (m_pathGeometry_ == other.m_pathGeometry_) &&
                (m_locationPathSegments_ == other.m_locationPathSegments_);
    }

    return true;
}

uint32_t RoadLocationPath::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_pathGeometry_);
    result = ::zserio::calcHashCode(result, m_locationPathSegments_);

    return result;
}

void RoadLocationPath::write(::zserio::BitStreamWriter& out) const
{
    m_pathGeometry_.write(out);
    m_locationPathSegments_.writePacked(*this, out);
}

void RoadLocationPath::write(RoadLocationPath::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_pathGeometry_.write(context.getPathGeometry(), out);
    m_locationPathSegments_.writePacked(*this, out);
}

void RoadLocationPath::ZserioArrayExpressions_locationPathSegments::initializeElement(RoadLocationPath& owner,
        ::nds::core::location::LocationSegment& element, size_t)
{
    element.initialize(owner.getPathGeometry());
}

void RoadLocationPath::ZserioElementFactory_locationPathSegments::create(RoadLocationPath&         owner,
        ::zserio::vector<::nds::core::location::LocationSegment>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, owner.getPathGeometry(), array.get_allocator());
}

void RoadLocationPath::ZserioElementFactory_locationPathSegments::create(RoadLocationPath&         owner,
        ::zserio::vector<::nds::core::location::LocationSegment>& array,
        ::nds::core::location::LocationSegment::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, owner.getPathGeometry(), array.get_allocator());
}

::nds::core::location::LocationGeometry RoadLocationPath::readPathGeometry(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::location::LocationGeometry(in, allocator);
}

::nds::core::location::LocationGeometry RoadLocationPath::readPathGeometry(RoadLocationPath::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::location::LocationGeometry(context.getPathGeometry(), in, allocator);
}
RoadLocationPath::ZserioArrayType_locationPathSegments RoadLocationPath::readLocationPathSegments(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_locationPathSegments readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}

RoadLocationPath::ZserioArrayType_locationPathSegments RoadLocationPath::readLocationPathSegments(RoadLocationPath::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_locationPathSegments readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}

} // namespace location
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/core/location/LocationGeometry.h>

namespace nds
{
namespace core
{
namespace location
{

LocationGeometry::LocationGeometry(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_line_(allocator)
{
}

LocationGeometry::LocationGeometry(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_line_(readLine(in, allocator))
{
}

LocationGeometry::LocationGeometry(LocationGeometry::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_line_(readLine(context, in, allocator))
{
}

LocationGeometry::LocationGeometry(const LocationGeometry& other) :
        m_line_(other.m_line_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

LocationGeometry& LocationGeometry::operator=(const LocationGeometry& other)
{
    m_line_ = other.m_line_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

LocationGeometry::LocationGeometry(LocationGeometry&& other) :
        m_line_(::std::move(other.m_line_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

LocationGeometry& LocationGeometry::operator=(LocationGeometry&& other)
{
    m_line_ = ::std::move(other.m_line_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

LocationGeometry::LocationGeometry(::zserio::PropagateAllocatorT,
        const LocationGeometry& other, const allocator_type& allocator) :
        m_line_(::zserio::allocatorPropagatingCopy(other.m_line_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void LocationGeometry::initializeChildren()
{
    m_line_.initialize(static_cast<::nds::core::geometry::CoordShift>(0));

    m_areChildrenInitialized = true;
}

::nds::core::geometry::Line2D& LocationGeometry::getLine()
{
    return m_line_;
}

const ::nds::core::geometry::Line2D& LocationGeometry::getLine() const
{
    return m_line_;
}

void LocationGeometry::setLine(const ::nds::core::geometry::Line2D& line_)
{
    m_line_ = line_;
}

void LocationGeometry::setLine(::nds::core::geometry::Line2D&& line_)
{
    m_line_ = ::std::move(line_);
}

void LocationGeometry::initPackingContext(LocationGeometry::ZserioPackingContext& context) const
{
    m_line_.initPackingContext(context.getLine());
}

size_t LocationGeometry::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_line_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LocationGeometry::bitSizeOf(LocationGeometry::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_line_.bitSizeOf(context.getLine(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LocationGeometry::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_line_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t LocationGeometry::initializeOffsets(LocationGeometry::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_line_.initializeOffsets(context.getLine(), endBitPosition);

    return endBitPosition;
}

bool LocationGeometry::operator==(const LocationGeometry& other) const
{
    if (this != &other)
    {
        return
                (m_line_ == other.m_line_);
    }

    return true;
}

uint32_t LocationGeometry::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_line_);

    return result;
}

void LocationGeometry::write(::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_line_.getShift() != static_cast<::nds::core::geometry::CoordShift>(0))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field LocationGeometry.line: ") <<
                m_line_.getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(0) << "!";
    }
    m_line_.write(out);
}

void LocationGeometry::write(LocationGeometry::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_line_.getShift() != static_cast<::nds::core::geometry::CoordShift>(0))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field LocationGeometry.line: ") <<
                m_line_.getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(0) << "!";
    }
    m_line_.write(context.getLine(), out);
}

::nds::core::geometry::Line2D LocationGeometry::readLine(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::geometry::Line2D(in, static_cast<::nds::core::geometry::CoordShift>(0), allocator);
}

::nds::core::geometry::Line2D LocationGeometry::readLine(LocationGeometry::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::geometry::Line2D(context.getLine(), in, static_cast<::nds::core::geometry::CoordShift>(0), allocator);
}

} // namespace location
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/core/location/LocationSegment.h>

namespace nds
{
namespace core
{
namespace location
{

LocationSegment::LocationSegment(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_range_(allocator),
        m_absoluteBearingStart_(::nds::core::location::AbsoluteBearing()),
        m_absoluteBearingEnd_(::nds::core::location::AbsoluteBearing()),
        m_length_(::nds::core::types::LengthMeters()),
        m_frc_(::zserio::NullOpt),
        m_roadtypes_(::zserio::NullOpt),
        m_roadName_(::zserio::NullOpt),
        m_roadNumber_(::zserio::NullOpt)
{
}

LocationSegment::LocationSegment(::zserio::BitStreamReader& in,
        ::nds::core::location::LocationGeometry& pathGeometry_, const allocator_type& allocator) :
        m_pathGeometry_(&pathGeometry_),
        m_isInitialized(true),
        m_range_(readRange(in, allocator)),
        m_absoluteBearingStart_(readAbsoluteBearingStart(in)),
        m_absoluteBearingEnd_(readAbsoluteBearingEnd(in)),
        m_length_(readLength(in)),
        m_frc_(readFrc(in)),
        m_roadtypes_(readRoadtypes(in, allocator)),
        m_roadName_(readRoadName(in, allocator)),
        m_roadNumber_(readRoadNumber(in, allocator))
{
}

LocationSegment::LocationSegment(LocationSegment::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::location::LocationGeometry& pathGeometry_, const allocator_type& allocator) :
        m_pathGeometry_(&pathGeometry_),
        m_isInitialized(true),
        m_range_(readRange(context, in, allocator)),
        m_absoluteBearingStart_(readAbsoluteBearingStart(context, in)),
        m_absoluteBearingEnd_(readAbsoluteBearingEnd(context, in)),
        m_length_(readLength(context, in)),
        m_frc_(readFrc(context, in)),
        m_roadtypes_(readRoadtypes(context, in, allocator)),
        m_roadName_(readRoadName(in, allocator)),
        m_roadNumber_(readRoadNumber(in, allocator))
{
}

LocationSegment::LocationSegment(const LocationSegment& other) :
        m_range_(other.m_range_),
        m_absoluteBearingStart_(other.m_absoluteBearingStart_),
        m_absoluteBearingEnd_(other.m_absoluteBearingEnd_),
        m_length_(other.m_length_),
        m_frc_(other.m_frc_),
        m_roadtypes_(other.m_roadtypes_),
        m_roadName_(other.m_roadName_),
        m_roadNumber_(other.m_roadNumber_)
{
    if (other.m_isInitialized)
        initialize(*(other.m_pathGeometry_));
    else
        m_isInitialized = false;
}

LocationSegment& LocationSegment::operator=(const LocationSegment& other)
{
    m_range_ = other.m_range_;
    m_absoluteBearingStart_ = other.m_absoluteBearingStart_;
    m_absoluteBearingEnd_ = other.m_absoluteBearingEnd_;
    m_length_ = other.m_length_;
    m_frc_ = other.m_frc_;
    m_roadtypes_ = other.m_roadtypes_;
    m_roadName_ = other.m_roadName_;
    m_roadNumber_ = other.m_roadNumber_;
    if (other.m_isInitialized)
        initialize(*(other.m_pathGeometry_));
    else
        m_isInitialized = false;

    return *this;
}

LocationSegment::LocationSegment(LocationSegment&& other) :
        m_range_(::std::move(other.m_range_)),
        m_absoluteBearingStart_(::std::move(other.m_absoluteBearingStart_)),
        m_absoluteBearingEnd_(::std::move(other.m_absoluteBearingEnd_)),
        m_length_(::std::move(other.m_length_)),
        m_frc_(::std::move(other.m_frc_)),
        m_roadtypes_(::std::move(other.m_roadtypes_)),
        m_roadName_(::std::move(other.m_roadName_)),
        m_roadNumber_(::std::move(other.m_roadNumber_))
{
    if (other.m_isInitialized)
        initialize(*(other.m_pathGeometry_));
    else
        m_isInitialized = false;
}

LocationSegment& LocationSegment::operator=(LocationSegment&& other)
{
    m_range_ = ::std::move(other.m_range_);
    m_absoluteBearingStart_ = ::std::move(other.m_absoluteBearingStart_);
    m_absoluteBearingEnd_ = ::std::move(other.m_absoluteBearingEnd_);
    m_length_ = ::std::move(other.m_length_);
    m_frc_ = ::std::move(other.m_frc_);
    m_roadtypes_ = ::std::move(other.m_roadtypes_);
    m_roadName_ = ::std::move(other.m_roadName_);
    m_roadNumber_ = ::std::move(other.m_roadNumber_);
    if (other.m_isInitialized)
        initialize(*(other.m_pathGeometry_));
    else
        m_isInitialized = false;

    return *this;
}

LocationSegment::LocationSegment(::zserio::PropagateAllocatorT,
        const LocationSegment& other, const allocator_type& allocator) :
        m_range_(::zserio::allocatorPropagatingCopy(other.m_range_, allocator)),
        m_absoluteBearingStart_(::zserio::allocatorPropagatingCopy(other.m_absoluteBearingStart_, allocator)),
        m_absoluteBearingEnd_(::zserio::allocatorPropagatingCopy(other.m_absoluteBearingEnd_, allocator)),
        m_length_(::zserio::allocatorPropagatingCopy(other.m_length_, allocator)),
        m_frc_(::zserio::allocatorPropagatingCopy(other.m_frc_, allocator)),
        m_roadtypes_(::zserio::allocatorPropagatingCopy(other.m_roadtypes_, allocator)),
        m_roadName_(::zserio::allocatorPropagatingCopy(other.m_roadName_, allocator)),
        m_roadNumber_(::zserio::allocatorPropagatingCopy(other.m_roadNumber_, allocator))
{
    if (other.m_isInitialized)
        initialize(*(other.m_pathGeometry_));
    else
        m_isInitialized = false;
}

void LocationSegment::initialize(
        ::nds::core::location::LocationGeometry& pathGeometry_)
{
    m_pathGeometry_ = &pathGeometry_;
    m_isInitialized = true;

    initializeChildren();
}

bool LocationSegment::isInitialized() const
{
    return m_isInitialized;
}

void LocationSegment::initializeChildren()
{
    m_range_.initialize(getPathGeometry().getLine());
}

::nds::core::location::LocationGeometry& LocationSegment::getPathGeometry()
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'pathGeometry' of compound 'LocationSegment' is not initialized!");

    return *m_pathGeometry_;
}

const ::nds::core::location::LocationGeometry& LocationSegment::getPathGeometry() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'pathGeometry' of compound 'LocationSegment' is not initialized!");

    return *m_pathGeometry_;
}

::nds::core::location::LocationPathRange& LocationSegment::getRange()
{
    return m_range_;
}

const ::nds::core::location::LocationPathRange& LocationSegment::getRange() const
{
    return m_range_;
}

void LocationSegment::setRange(const ::nds::core::location::LocationPathRange& range_)
{
    m_range_ = range_;
}

void LocationSegment::setRange(::nds::core::location::LocationPathRange&& range_)
{
    m_range_ = ::std::move(range_);
}

::nds::core::location::AbsoluteBearing LocationSegment::getAbsoluteBearingStart() const
{
    return m_absoluteBearingStart_;
}

void LocationSegment::setAbsoluteBearingStart(::nds::core::location::AbsoluteBearing absoluteBearingStart_)
{
    m_absoluteBearingStart_ = absoluteBearingStart_;
}

::nds::core::location::AbsoluteBearing LocationSegment::getAbsoluteBearingEnd() const
{
    return m_absoluteBearingEnd_;
}

void LocationSegment::setAbsoluteBearingEnd(::nds::core::location::AbsoluteBearing absoluteBearingEnd_)
{
    m_absoluteBearingEnd_ = absoluteBearingEnd_;
}

::nds::core::types::LengthMeters LocationSegment::getLength() const
{
    return m_length_;
}

void LocationSegment::setLength(::nds::core::types::LengthMeters length_)
{
    m_length_ = length_;
}

::nds::core::types::FunctionalRoadClass LocationSegment::getFrc() const
{
    return m_frc_.value();
}

void LocationSegment::setFrc(::nds::core::types::FunctionalRoadClass frc_)
{
    m_frc_ = frc_;
}

bool LocationSegment::isFrcUsed() const
{
    return (isFrcSet());
}

bool LocationSegment::isFrcSet() const
{
    return m_frc_.hasValue();
}

void LocationSegment::resetFrc()
{
    m_frc_.reset();
}

::nds::core::types::RoadType& LocationSegment::getRoadtypes()
{
    return m_roadtypes_.value();
}

const ::nds::core::types::RoadType& LocationSegment::getRoadtypes() const
{
    return m_roadtypes_.value();
}

void LocationSegment::setRoadtypes(const ::nds::core::types::RoadType& roadtypes_)
{
    m_roadtypes_ = roadtypes_;
}

void LocationSegment::setRoadtypes(::nds::core::types::RoadType&& roadtypes_)
{
    m_roadtypes_ = ::std::move(roadtypes_);
}

bool LocationSegment::isRoadtypesUsed() const
{
    return (isRoadtypesSet());
}

bool LocationSegment::isRoadtypesSet() const
{
    return m_roadtypes_.hasValue();
}

void LocationSegment::resetRoadtypes()
{
    m_roadtypes_.reset();
}

::zserio::string<>& LocationSegment::getRoadName()
{
    return m_roadName_.value();
}

const ::zserio::string<>& LocationSegment::getRoadName() const
{
    return m_roadName_.value();
}

void LocationSegment::setRoadName(const ::zserio::string<>& roadName_)
{
    m_roadName_ = roadName_;
}

void LocationSegment::setRoadName(::zserio::string<>&& roadName_)
{
    m_roadName_ = ::std::move(roadName_);
}

bool LocationSegment::isRoadNameUsed() const
{
    return (isRoadNameSet());
}

bool LocationSegment::isRoadNameSet() const
{
    return m_roadName_.hasValue();
}

void LocationSegment::resetRoadName()
{
    m_roadName_.reset();
}

::zserio::string<>& LocationSegment::getRoadNumber()
{
    return m_roadNumber_.value();
}

const ::zserio::string<>& LocationSegment::getRoadNumber() const
{
    return m_roadNumber_.value();
}

void LocationSegment::setRoadNumber(const ::zserio::string<>& roadNumber_)
{
    m_roadNumber_ = roadNumber_;
}

void LocationSegment::setRoadNumber(::zserio::string<>&& roadNumber_)
{
    m_roadNumber_ = ::std::move(roadNumber_);
}

bool LocationSegment::isRoadNumberUsed() const
{
    return (isRoadNumberSet());
}

bool LocationSegment::isRoadNumberSet() const
{
    return m_roadNumber_.hasValue();
}

void LocationSegment::resetRoadNumber()
{
    m_roadNumber_.reset();
}

void LocationSegment::initPackingContext(LocationSegment::ZserioPackingContext& context) const
{
    m_range_.initPackingContext(context.getRange());
    context.getAbsoluteBearingStart().init<::zserio::StdIntArrayTraits<::nds::core::location::AbsoluteBearing>>(m_absoluteBearingStart_);
    context.getAbsoluteBearingEnd().init<::zserio::StdIntArrayTraits<::nds::core::location::AbsoluteBearing>>(m_absoluteBearingEnd_);
    context.getLength().init<::zserio::VarIntNNArrayTraits<::nds::core::types::LengthMeters>>(m_length_);
    if (isFrcSet())
    {
        context.getFrc().init<::zserio::BitFieldArrayTraits<::nds::core::types::FunctionalRoadClass, UINT8_C(3)>>(m_frc_.value());
    }
    if (isRoadtypesSet())
    {
        m_roadtypes_.value().initPackingContext(context.getRoadtypes());
    }
}

size_t LocationSegment::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_range_.bitSizeOf(endBitPosition);
    endBitPosition += UINT8_C(8);
    endBitPosition += UINT8_C(8);
    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_length_);
    endBitPosition += 1;
    if (isFrcSet())
    {
        endBitPosition += UINT8_C(3);
    }
    endBitPosition += 1;
    if (isRoadtypesSet())
    {
        endBitPosition += m_roadtypes_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition += 1;
    if (isRoadNameSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_roadName_.value());
    }
    endBitPosition += 1;
    if (isRoadNumberSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_roadNumber_.value());
    }

    return endBitPosition - bitPosition;
}

size_t LocationSegment::bitSizeOf(LocationSegment::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_range_.bitSizeOf(context.getRange(), endBitPosition);
    endBitPosition += context.getAbsoluteBearingStart().bitSizeOf<::zserio::StdIntArrayTraits<::nds::core::location::AbsoluteBearing>>(m_absoluteBearingStart_);
    endBitPosition += context.getAbsoluteBearingEnd().bitSizeOf<::zserio::StdIntArrayTraits<::nds::core::location::AbsoluteBearing>>(m_absoluteBearingEnd_);
    endBitPosition += context.getLength().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::types::LengthMeters>>(m_length_);
    endBitPosition += 1;
    if (isFrcSet())
    {
        endBitPosition += context.getFrc().bitSizeOf<::zserio::BitFieldArrayTraits<::nds::core::types::FunctionalRoadClass, UINT8_C(3)>>(m_frc_.value());
    }
    endBitPosition += 1;
    if (isRoadtypesSet())
    {
        endBitPosition += m_roadtypes_.value().bitSizeOf(context.getRoadtypes(), endBitPosition);
    }
    endBitPosition += 1;
    if (isRoadNameSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_roadName_.value());
    }
    endBitPosition += 1;
    if (isRoadNumberSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_roadNumber_.value());
    }

    return endBitPosition - bitPosition;
}

size_t LocationSegment::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_range_.initializeOffsets(endBitPosition);
    endBitPosition += UINT8_C(8);
    endBitPosition += UINT8_C(8);
    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_length_);
    endBitPosition += 1;
    if (isFrcSet())
    {
        endBitPosition += UINT8_C(3);
    }
    endBitPosition += 1;
    if (isRoadtypesSet())
    {
        endBitPosition = m_roadtypes_.value().initializeOffsets(endBitPosition);
    }
    endBitPosition += 1;
    if (isRoadNameSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_roadName_.value());
    }
    endBitPosition += 1;
    if (isRoadNumberSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_roadNumber_.value());
    }

    return endBitPosition;
}

size_t LocationSegment::initializeOffsets(LocationSegment::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_range_.initializeOffsets(context.getRange(), endBitPosition);
    endBitPosition += context.getAbsoluteBearingStart().bitSizeOf<::zserio::StdIntArrayTraits<::nds::core::location::AbsoluteBearing>>(m_absoluteBearingStart_);
    endBitPosition += context.getAbsoluteBearingEnd().bitSizeOf<::zserio::StdIntArrayTraits<::nds::core::location::AbsoluteBearing>>(m_absoluteBearingEnd_);
    endBitPosition += context.getLength().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::types::LengthMeters>>(m_length_);
    endBitPosition += 1;
    if (isFrcSet())
    {
        endBitPosition += context.getFrc().bitSizeOf<::zserio::BitFieldArrayTraits<::nds::core::types::FunctionalRoadClass, UINT8_C(3)>>(m_frc_.value());
    }
    endBitPosition += 1;
    if (isRoadtypesSet())
    {
        endBitPosition = m_roadtypes_.value().initializeOffsets(context.getRoadtypes(), endBitPosition);
    }
    endBitPosition += 1;
    if (isRoadNameSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_roadName_.value());
    }
    endBitPosition += 1;
    if (isRoadNumberSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_roadNumber_.value());
    }

    return endBitPosition;
}

bool LocationSegment::operator==(const LocationSegment& other) const
{
    if (this != &other)
    {
        return
                (getPathGeometry() == other.getPathGeometry()) &&
                (m_range_ == other.m_range_) &&
                (m_absoluteBearingStart_ == other.m_absoluteBearingStart_) &&
                (m_absoluteBearingEnd_ == other.m_absoluteBearingEnd_) &&
                (m_length_ == other.m_length_) &&
                (!isFrcUsed() ? !other.isFrcUsed() : (m_frc_ == other.m_frc_)) &&
                (!isRoadtypesUsed() ? !other.isRoadtypesUsed() : (m_roadtypes_ == other.m_roadtypes_)) &&
                (!isRoadNameUsed() ? !other.isRoadNameUsed() : (m_roadName_ == other.m_roadName_)) &&
                (!isRoadNumberUsed() ? !other.isRoadNumberUsed() : (m_roadNumber_ == other.m_roadNumber_));
    }

    return true;
}

uint32_t LocationSegment::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getPathGeometry());
    result = ::zserio::calcHashCode(result, m_range_);
    result = ::zserio::calcHashCode(result, m_absoluteBearingStart_);
    result = ::zserio::calcHashCode(result, m_absoluteBearingEnd_);
    result = ::zserio::calcHashCode(result, m_length_);
    if (isFrcUsed())
        result = ::zserio::calcHashCode(result, m_frc_);
    if (isRoadtypesUsed())
        result = ::zserio::calcHashCode(result, m_roadtypes_);
    if (isRoadNameUsed())
        result = ::zserio::calcHashCode(result, m_roadName_);
    if (isRoadNumberUsed())
        result = ::zserio::calcHashCode(result, m_roadNumber_);

    return result;
}

void LocationSegment::write(::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (&(m_range_.getLine()) != &(getPathGeometry().getLine()))
    {
        throw ::zserio::CppRuntimeException("Write: Inconsistent parameter line for field LocationSegment.range!");
    }
    m_range_.write(out);

    out.writeBits(m_absoluteBearingStart_, UINT8_C(8));

    out.writeBits(m_absoluteBearingEnd_, UINT8_C(8));

    out.writeVarUInt32(m_length_);

    if (isFrcSet())
    {
        out.writeBool(true);
        out.writeBits(m_frc_.value(), UINT8_C(3));
    }
    else
    {
        out.writeBool(false);
    }

    if (isRoadtypesSet())
    {
        out.writeBool(true);
        m_roadtypes_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isRoadNameSet())
    {
        out.writeBool(true);
        out.writeString(m_roadName_.value());
    }
    else
    {
        out.writeBool(false);
    }

    if (isRoadNumberSet())
    {
        out.writeBool(true);
        out.writeString(m_roadNumber_.value());
    }
    else
    {
        out.writeBool(false);
    }
}

void LocationSegment::write(LocationSegment::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (&(m_range_.getLine()) != &(getPathGeometry().getLine()))
    {
        throw ::zserio::CppRuntimeException("Write: Inconsistent parameter line for field LocationSegment.range!");
    }
    m_range_.write(context.getRange(), out);

    context.getAbsoluteBearingStart().write<::zserio::StdIntArrayTraits<::nds::core::location::AbsoluteBearing>>(out, m_absoluteBearingStart_);

    context.getAbsoluteBearingEnd().write<::zserio::StdIntArrayTraits<::nds::core::location::AbsoluteBearing>>(out, m_absoluteBearingEnd_);

    context.getLength().write<::zserio::VarIntNNArrayTraits<::nds::core::types::LengthMeters>>(out, m_length_);

    if (isFrcSet())
    {
        out.writeBool(true);
        context.getFrc().write<::zserio::BitFieldArrayTraits<::nds::core::types::FunctionalRoadClass, UINT8_C(3)>>(out, m_frc_.value());
    }
    else
    {
        out.writeBool(false);
    }

    if (isRoadtypesSet())
    {
        out.writeBool(true);
        m_roadtypes_.value().write(context.getRoadtypes(), out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isRoadNameSet())
    {
        out.writeBool(true);
        out.writeString(m_roadName_.value());
    }
    else
    {
        out.writeBool(false);
    }

    if (isRoadNumberSet())
    {
        out.writeBool(true);
        out.writeString(m_roadNumber_.value());
    }
    else
    {
        out.writeBool(false);
    }
}

::nds::core::location::LocationPathRange LocationSegment::readRange(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::location::LocationPathRange(in, getPathGeometry().getLine(), allocator);
}

::nds::core::location::LocationPathRange LocationSegment::readRange(LocationSegment::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::location::LocationPathRange(context.getRange(), in, getPathGeometry().getLine(), allocator);
}
::nds::core::location::AbsoluteBearing LocationSegment::readAbsoluteBearingStart(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::location::AbsoluteBearing>(in.readBits(UINT8_C(8)));
}

::nds::core::location::AbsoluteBearing LocationSegment::readAbsoluteBearingStart(LocationSegment::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getAbsoluteBearingStart().read<::zserio::StdIntArrayTraits<::nds::core::location::AbsoluteBearing>>(in);
}
::nds::core::location::AbsoluteBearing LocationSegment::readAbsoluteBearingEnd(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::location::AbsoluteBearing>(in.readBits(UINT8_C(8)));
}

::nds::core::location::AbsoluteBearing LocationSegment::readAbsoluteBearingEnd(LocationSegment::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getAbsoluteBearingEnd().read<::zserio::StdIntArrayTraits<::nds::core::location::AbsoluteBearing>>(in);
}
::nds::core::types::LengthMeters LocationSegment::readLength(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::types::LengthMeters>(in.readVarUInt32());
}

::nds::core::types::LengthMeters LocationSegment::readLength(LocationSegment::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getLength().read<::zserio::VarIntNNArrayTraits<::nds::core::types::LengthMeters>>(in);
}
::zserio::InplaceOptionalHolder<::nds::core::types::FunctionalRoadClass> LocationSegment::readFrc(::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::types::FunctionalRoadClass>(static_cast<::nds::core::types::FunctionalRoadClass>(in.readBits(UINT8_C(3))));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::types::FunctionalRoadClass>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::types::FunctionalRoadClass> LocationSegment::readFrc(LocationSegment::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::types::FunctionalRoadClass>(context.getFrc().read<::zserio::BitFieldArrayTraits<::nds::core::types::FunctionalRoadClass, UINT8_C(3)>>(in));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::types::FunctionalRoadClass>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::core::types::RoadType> LocationSegment::readRoadtypes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::types::RoadType>(::nds::core::types::RoadType(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::types::RoadType>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::types::RoadType> LocationSegment::readRoadtypes(LocationSegment::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::types::RoadType>(::nds::core::types::RoadType(context.getRoadtypes(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::types::RoadType>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::zserio::string<>> LocationSegment::readRoadName(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::zserio::string<>>(static_cast<::zserio::string<>>(in.readString(allocator)));
    }

    return ::zserio::InplaceOptionalHolder<::zserio::string<>>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::zserio::string<>> LocationSegment::readRoadNumber(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::zserio::string<>>(static_cast<::zserio::string<>>(in.readString(allocator)));
    }

    return ::zserio::InplaceOptionalHolder<::zserio::string<>>(::zserio::NullOpt);
}

} // namespace location
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/core/location/RoadLocationId.h>
#include <nds/core/location/NO_BRANCH.h>

namespace nds
{
namespace core
{
namespace location
{

RoadLocationId::RoadLocationId(const allocator_type& allocator) noexcept :
        m_value_(allocator),
        m_branchId_(static_cast<::nds::core::location::RoadLocationBranchId>(::nds::core::location::NO_BRANCH))
{
}

RoadLocationId::RoadLocationId(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_value_(readValue(in, allocator)),
        m_branchId_(readBranchId(in))
{
}

RoadLocationId::RoadLocationId(RoadLocationId::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_value_(readValue(context, in, allocator)),
        m_branchId_(readBranchId(context, in))
{
}

RoadLocationId::RoadLocationId(::zserio::PropagateAllocatorT,
        const RoadLocationId& other, const allocator_type& allocator) :
        m_value_(::zserio::allocatorPropagatingCopy(other.m_value_, allocator)),
        m_branchId_(::zserio::allocatorPropagatingCopy(other.m_branchId_, allocator))
{
}

::zserio::vector<uint8_t>& RoadLocationId::getValue()
{
    return m_value_.getRawArray();
}

const ::zserio::vector<uint8_t>& RoadLocationId::getValue() const
{
    return m_value_.getRawArray();
}

void RoadLocationId::setValue(const ::zserio::vector<uint8_t>& value_)
{
    m_value_ = ZserioArrayType_value(value_);
}

void RoadLocationId::setValue(::zserio::vector<uint8_t>&& value_)
{
    m_value_ = ZserioArrayType_value(std::move(value_));
}

::nds::core::location::RoadLocationBranchId RoadLocationId::getBranchId() const
{
    return m_branchId_;
}

void RoadLocationId::setBranchId(::nds::core::location::RoadLocationBranchId branchId_)
{
    m_branchId_ = branchId_;
}

void RoadLocationId::initPackingContext(RoadLocationId::ZserioPackingContext& context) const
{
    context.getBranchId().init<::zserio::StdIntArrayTraits<::nds::core::location::RoadLocationBranchId>>(m_branchId_);
}

size_t RoadLocationId::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_value_.bitSizeOf(endBitPosition);
    endBitPosition += UINT8_C(8);

    return endBitPosition - bitPosition;
}

size_t RoadLocationId::bitSizeOf(RoadLocationId::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_value_.bitSizeOfPacked(endBitPosition);
    endBitPosition += context.getBranchId().bitSizeOf<::zserio::StdIntArrayTraits<::nds::core::location::RoadLocationBranchId>>(m_branchId_);

    return endBitPosition - bitPosition;
}

size_t RoadLocationId::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_value_.initializeOffsets(endBitPosition);
    endBitPosition += UINT8_C(8);

    return endBitPosition;
}

size_t RoadLocationId::initializeOffsets(RoadLocationId::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_value_.initializeOffsetsPacked(endBitPosition);
    endBitPosition += context.getBranchId().bitSizeOf<::zserio::StdIntArrayTraits<::nds::core::location::RoadLocationBranchId>>(m_branchId_);

    return endBitPosition;
}

bool RoadLocationId::operator==(const RoadLocationId& other) const
{
    if (this != &other)
    {
        return
                (m_value_ == other.m_value_) &&
                (m_branchId_ == other.m_branchId_);
    }

    return true;
}

uint32_t RoadLocationId::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_value_);
    result = ::zserio::calcHashCode(result, m_branchId_);

    return result;
}

void RoadLocationId::write(::zserio::BitStreamWriter& out) const
{
    // check array length
    if (m_value_.getRawArray().size() != static_cast<size_t>(16))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoadLocationId.value: ") <<
                m_value_.getRawArray().size() << " != " <<
                static_cast<size_t>(16) << "!";
    }
    m_value_.write(out);

    out.writeBits(m_branchId_, UINT8_C(8));
}

void RoadLocationId::write(RoadLocationId::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    // check array length
    if (m_value_.getRawArray().size() != static_cast<size_t>(16))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field RoadLocationId.value: ") <<
                m_value_.getRawArray().size() << " != " <<
                static_cast<size_t>(16) << "!";
    }
    m_value_.writePacked(out);

    context.getBranchId().write<::zserio::StdIntArrayTraits<::nds::core::location::RoadLocationBranchId>>(out, m_branchId_);
}

RoadLocationId::ZserioArrayType_value RoadLocationId::readValue(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_value readField(allocator);
    readField.read(in, static_cast<size_t>(16));

    return readField;
}

RoadLocationId::ZserioArrayType_value RoadLocationId::readValue(RoadLocationId::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_value readField(allocator);
    readField.readPacked(in, static_cast<size_t>(16));

    return readField;
}
::nds::core::location::RoadLocationBranchId RoadLocationId::readBranchId(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::location::RoadLocationBranchId>(in.readBits(UINT8_C(8)));
}

::nds::core::location::RoadLocationBranchId RoadLocationId::readBranchId(RoadLocationId::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getBranchId().read<::zserio::StdIntArrayTraits<::nds::core::location::RoadLocationBranchId>>(in);
}

} // namespace location
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ConstraintException.h>

#include <nds/core/location/RoadLocationIdRange.h>

namespace nds
{
namespace core
{
namespace location
{

RoadLocationIdRange::RoadLocationIdRange(const allocator_type&) noexcept :
        m_startPosition_(::nds::core::types::LengthCentimeters()),
        m_endPosition_(::nds::core::types::LengthCentimeters())
{
}

RoadLocationIdRange::RoadLocationIdRange(::zserio::BitStreamReader& in, const allocator_type&) :
        m_startPosition_(readStartPosition(in)),
        m_endPosition_(readEndPosition(in))
{
}

RoadLocationIdRange::RoadLocationIdRange(RoadLocationIdRange::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type&) :
        m_startPosition_(readStartPosition(context, in)),
        m_endPosition_(readEndPosition(context, in))
{
}

RoadLocationIdRange::RoadLocationIdRange(::zserio::PropagateAllocatorT,
        const RoadLocationIdRange& other, const allocator_type& allocator) :
        m_startPosition_(::zserio::allocatorPropagatingCopy(other.m_startPosition_, allocator)),
        m_endPosition_(::zserio::allocatorPropagatingCopy(other.m_endPosition_, allocator))
{
}

::nds::core::types::LengthCentimeters RoadLocationIdRange::getStartPosition() const
{
    return m_startPosition_;
}

void RoadLocationIdRange::setStartPosition(::nds::core::types::LengthCentimeters startPosition_)
{
    m_startPosition_ = startPosition_;
}

::nds::core::types::LengthCentimeters RoadLocationIdRange::getEndPosition() const
{
    return m_endPosition_;
}

void RoadLocationIdRange::setEndPosition(::nds::core::types::LengthCentimeters endPosition_)
{
    m_endPosition_ = endPosition_;
}

void RoadLocationIdRange::initPackingContext(RoadLocationIdRange::ZserioPackingContext& context) const
{
    context.getStartPosition().init<::zserio::VarIntNNArrayTraits<::nds::core::types::LengthCentimeters>>(m_startPosition_);
    context.getEndPosition().init<::zserio::VarIntNNArrayTraits<::nds::core::types::LengthCentimeters>>(m_endPosition_);
}

size_t RoadLocationIdRange::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_startPosition_);
    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_endPosition_);

    return endBitPosition - bitPosition;
}

size_t RoadLocationIdRange::bitSizeOf(RoadLocationIdRange::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getStartPosition().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::types::LengthCentimeters>>(m_startPosition_);
    endBitPosition += context.getEndPosition().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::types::LengthCentimeters>>(m_endPosition_);

    return endBitPosition - bitPosition;
}

size_t RoadLocationIdRange::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_startPosition_);
    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_endPosition_);

    return endBitPosition;
}

size_t RoadLocationIdRange::initializeOffsets(RoadLocationIdRange::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getStartPosition().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::types::LengthCentimeters>>(m_startPosition_);
    endBitPosition += context.getEndPosition().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::types::LengthCentimeters>>(m_endPosition_);

    return endBitPosition;
}

bool RoadLocationIdRange::operator==(const RoadLocationIdRange& other) const
{
    if (this != &other)
    {
        return
                (m_startPosition_ == other.m_startPosition_) &&
                (m_endPosition_ == other.m_endPosition_);
    }

    return true;
}

uint32_t RoadLocationIdRange::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_startPosition_);
    result = ::zserio::calcHashCode(result, m_endPosition_);

    return result;
}

void RoadLocationIdRange::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt32(m_startPosition_);

    // check constraint
    if (!(getEndPosition() >= getStartPosition()))
        throw ::zserio::ConstraintException("Write: Constraint violated at RoadLocationIdRange.endPosition!");
    out.writeVarUInt32(m_endPosition_);
}

void RoadLocationIdRange::write(RoadLocationIdRange::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getStartPosition().write<::zserio::VarIntNNArrayTraits<::nds::core::types::LengthCentimeters>>(out, m_startPosition_);

    // check constraint
    if (!(getEndPosition() >= getStartPosition()))
        throw ::zserio::ConstraintException("Write: Constraint violated at RoadLocationIdRange.endPosition!");
    context.getEndPosition().write<::zserio::VarIntNNArrayTraits<::nds::core::types::LengthCentimeters>>(out, m_endPosition_);
}

::nds::core::types::LengthCentimeters RoadLocationIdRange::readStartPosition(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::types::LengthCentimeters>(in.readVarUInt32());
}

::nds::core::types::LengthCentimeters RoadLocationIdRange::readStartPosition(RoadLocationIdRange::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getStartPosition().read<::zserio::VarIntNNArrayTraits<::nds::core::types::LengthCentimeters>>(in);
}
::nds::core::types::LengthCentimeters RoadLocationIdRange::readEndPosition(::zserio::BitStreamReader& in)
{
    ::nds::core::types::LengthCentimeters readField = static_cast<::nds::core::types::LengthCentimeters>(in.readVarUInt32());
    // check constraint
    if (!(readField >= getStartPosition()))
        throw ::zserio::ConstraintException("Read: Constraint violated at RoadLocationIdRange.endPosition!");

    return readField;
}

::nds::core::types::LengthCentimeters RoadLocationIdRange::readEndPosition(RoadLocationIdRange::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    ::nds::core::types::LengthCentimeters readField = context.getEndPosition().read<::zserio::VarIntNNArrayTraits<::nds::core::types::LengthCentimeters>>(in);
    // check constraint
    if (!(readField >= getStartPosition()))
        throw ::zserio::ConstraintException("Read: Constraint violated at RoadLocationIdRange.endPosition!");

    return readField;
}

} // namespace location
} // namespace core
} // namespace nds
