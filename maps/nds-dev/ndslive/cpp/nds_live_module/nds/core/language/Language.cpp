/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/core/language/AvailableLanguages.h>

namespace nds
{
namespace core
{
namespace language
{

AvailableLanguages::AvailableLanguages(const allocator_type& allocator) noexcept :
        m_availableLanguages_(allocator)
{
}

AvailableLanguages::AvailableLanguages(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_availableLanguages_(readAvailableLanguages(in, allocator))
{
}

AvailableLanguages::AvailableLanguages(AvailableLanguages::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_availableLanguages_(readAvailableLanguages(context, in, allocator))
{
}

AvailableLanguages::AvailableLanguages(::zserio::PropagateAllocatorT,
        const AvailableLanguages& other, const allocator_type& allocator) :
        m_availableLanguages_(::zserio::allocatorPropagatingCopy(other.m_availableLanguages_, allocator))
{
}

::zserio::vector<::nds::core::language::LanguageMapping>& AvailableLanguages::getAvailableLanguages()
{
    return m_availableLanguages_.getRawArray();
}

const ::zserio::vector<::nds::core::language::LanguageMapping>& AvailableLanguages::getAvailableLanguages() const
{
    return m_availableLanguages_.getRawArray();
}

void AvailableLanguages::setAvailableLanguages(const ::zserio::vector<::nds::core::language::LanguageMapping>& availableLanguages_)
{
    m_availableLanguages_ = ZserioArrayType_availableLanguages(availableLanguages_);
}

void AvailableLanguages::setAvailableLanguages(::zserio::vector<::nds::core::language::LanguageMapping>&& availableLanguages_)
{
    m_availableLanguages_ = ZserioArrayType_availableLanguages(std::move(availableLanguages_));
}

void AvailableLanguages::initPackingContext(AvailableLanguages::ZserioPackingContext&) const
{
}

size_t AvailableLanguages::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_availableLanguages_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t AvailableLanguages::bitSizeOf(AvailableLanguages::ZserioPackingContext&, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_availableLanguages_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t AvailableLanguages::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_availableLanguages_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t AvailableLanguages::initializeOffsets(AvailableLanguages::ZserioPackingContext&, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_availableLanguages_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool AvailableLanguages::operator==(const AvailableLanguages& other) const
{
    if (this != &other)
    {
        return
                (m_availableLanguages_ == other.m_availableLanguages_);
    }

    return true;
}

uint32_t AvailableLanguages::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_availableLanguages_);

    return result;
}

void AvailableLanguages::write(::zserio::BitStreamWriter& out) const
{
    m_availableLanguages_.write(*this, out);
}

void AvailableLanguages::write(AvailableLanguages::ZserioPackingContext&, ::zserio::BitStreamWriter& out) const
{
    m_availableLanguages_.writePacked(*this, out);
}

void AvailableLanguages::ZserioElementFactory_availableLanguages::create(AvailableLanguages&        ,
        ::zserio::vector<::nds::core::language::LanguageMapping>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void AvailableLanguages::ZserioElementFactory_availableLanguages::create(AvailableLanguages&        ,
        ::zserio::vector<::nds::core::language::LanguageMapping>& array,
        ::nds::core::language::LanguageMapping::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

AvailableLanguages::ZserioArrayType_availableLanguages AvailableLanguages::readAvailableLanguages(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_availableLanguages readField(allocator);
    readField.read(*this, in);

    return readField;
}

AvailableLanguages::ZserioArrayType_availableLanguages AvailableLanguages::readAvailableLanguages(AvailableLanguages::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_availableLanguages readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}

} // namespace language
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/core/language/LanguageMapping.h>

namespace nds
{
namespace core
{
namespace language
{

LanguageMapping::LanguageMapping(const allocator_type& allocator) noexcept :
        m_languageCode_(::nds::core::types::LanguageCode()),
        m_isoCountryCode_(allocator),
        m_isoLanguageCode_(allocator),
        m_isoScriptCode_(allocator),
        m_isTransliterationOf_(::nds::core::types::LanguageCode()),
        m_isDiacriticTransliterationOf_(::nds::core::types::LanguageCode()),
        m_languageNames_(allocator)
{
}

LanguageMapping::LanguageMapping(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_languageCode_(readLanguageCode(in)),
        m_isoCountryCode_(readIsoCountryCode(in, allocator)),
        m_isoLanguageCode_(readIsoLanguageCode(in, allocator)),
        m_isoScriptCode_(readIsoScriptCode(in, allocator)),
        m_isTransliterationOf_(readIsTransliterationOf(in)),
        m_isDiacriticTransliterationOf_(readIsDiacriticTransliterationOf(in)),
        m_languageNames_(readLanguageNames(in, allocator))
{
}

LanguageMapping::LanguageMapping(LanguageMapping::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_languageCode_(readLanguageCode(context, in)),
        m_isoCountryCode_(readIsoCountryCode(in, allocator)),
        m_isoLanguageCode_(readIsoLanguageCode(in, allocator)),
        m_isoScriptCode_(readIsoScriptCode(in, allocator)),
        m_isTransliterationOf_(readIsTransliterationOf(context, in)),
        m_isDiacriticTransliterationOf_(readIsDiacriticTransliterationOf(context, in)),
        m_languageNames_(readLanguageNames(context, in, allocator))
{
}

LanguageMapping::LanguageMapping(::zserio::PropagateAllocatorT,
        const LanguageMapping& other, const allocator_type& allocator) :
        m_languageCode_(::zserio::allocatorPropagatingCopy(other.m_languageCode_, allocator)),
        m_isoCountryCode_(::zserio::allocatorPropagatingCopy(other.m_isoCountryCode_, allocator)),
        m_isoLanguageCode_(::zserio::allocatorPropagatingCopy(other.m_isoLanguageCode_, allocator)),
        m_isoScriptCode_(::zserio::allocatorPropagatingCopy(other.m_isoScriptCode_, allocator)),
        m_isTransliterationOf_(::zserio::allocatorPropagatingCopy(other.m_isTransliterationOf_, allocator)),
        m_isDiacriticTransliterationOf_(::zserio::allocatorPropagatingCopy(other.m_isDiacriticTransliterationOf_, allocator)),
        m_languageNames_(::zserio::allocatorPropagatingCopy(other.m_languageNames_, allocator))
{
}

::nds::core::types::LanguageCode LanguageMapping::getLanguageCode() const
{
    return m_languageCode_;
}

void LanguageMapping::setLanguageCode(::nds::core::types::LanguageCode languageCode_)
{
    m_languageCode_ = languageCode_;
}

::zserio::string<>& LanguageMapping::getIsoCountryCode()
{
    return m_isoCountryCode_;
}

const ::zserio::string<>& LanguageMapping::getIsoCountryCode() const
{
    return m_isoCountryCode_;
}

void LanguageMapping::setIsoCountryCode(const ::zserio::string<>& isoCountryCode_)
{
    m_isoCountryCode_ = isoCountryCode_;
}

void LanguageMapping::setIsoCountryCode(::zserio::string<>&& isoCountryCode_)
{
    m_isoCountryCode_ = ::std::move(isoCountryCode_);
}

::zserio::string<>& LanguageMapping::getIsoLanguageCode()
{
    return m_isoLanguageCode_;
}

const ::zserio::string<>& LanguageMapping::getIsoLanguageCode() const
{
    return m_isoLanguageCode_;
}

void LanguageMapping::setIsoLanguageCode(const ::zserio::string<>& isoLanguageCode_)
{
    m_isoLanguageCode_ = isoLanguageCode_;
}

void LanguageMapping::setIsoLanguageCode(::zserio::string<>&& isoLanguageCode_)
{
    m_isoLanguageCode_ = ::std::move(isoLanguageCode_);
}

::zserio::string<>& LanguageMapping::getIsoScriptCode()
{
    return m_isoScriptCode_;
}

const ::zserio::string<>& LanguageMapping::getIsoScriptCode() const
{
    return m_isoScriptCode_;
}

void LanguageMapping::setIsoScriptCode(const ::zserio::string<>& isoScriptCode_)
{
    m_isoScriptCode_ = isoScriptCode_;
}

void LanguageMapping::setIsoScriptCode(::zserio::string<>&& isoScriptCode_)
{
    m_isoScriptCode_ = ::std::move(isoScriptCode_);
}

::nds::core::types::LanguageCode LanguageMapping::getIsTransliterationOf() const
{
    return m_isTransliterationOf_;
}

void LanguageMapping::setIsTransliterationOf(::nds::core::types::LanguageCode isTransliterationOf_)
{
    m_isTransliterationOf_ = isTransliterationOf_;
}

::nds::core::types::LanguageCode LanguageMapping::getIsDiacriticTransliterationOf() const
{
    return m_isDiacriticTransliterationOf_;
}

void LanguageMapping::setIsDiacriticTransliterationOf(::nds::core::types::LanguageCode isDiacriticTransliterationOf_)
{
    m_isDiacriticTransliterationOf_ = isDiacriticTransliterationOf_;
}

::zserio::vector<::nds::core::language::LanguageName>& LanguageMapping::getLanguageNames()
{
    return m_languageNames_.getRawArray();
}

const ::zserio::vector<::nds::core::language::LanguageName>& LanguageMapping::getLanguageNames() const
{
    return m_languageNames_.getRawArray();
}

void LanguageMapping::setLanguageNames(const ::zserio::vector<::nds::core::language::LanguageName>& languageNames_)
{
    m_languageNames_ = ZserioArrayType_languageNames(languageNames_);
}

void LanguageMapping::setLanguageNames(::zserio::vector<::nds::core::language::LanguageName>&& languageNames_)
{
    m_languageNames_ = ZserioArrayType_languageNames(std::move(languageNames_));
}

void LanguageMapping::initPackingContext(LanguageMapping::ZserioPackingContext& context) const
{
    context.getLanguageCode().init<::zserio::VarIntNNArrayTraits<::nds::core::types::LanguageCode>>(m_languageCode_);
    context.getIsTransliterationOf().init<::zserio::VarIntNNArrayTraits<::nds::core::types::LanguageCode>>(m_isTransliterationOf_);
    context.getIsDiacriticTransliterationOf().init<::zserio::VarIntNNArrayTraits<::nds::core::types::LanguageCode>>(m_isDiacriticTransliterationOf_);
}

size_t LanguageMapping::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_languageCode_);
    endBitPosition += ::zserio::bitSizeOfString(m_isoCountryCode_);
    endBitPosition += ::zserio::bitSizeOfString(m_isoLanguageCode_);
    endBitPosition += ::zserio::bitSizeOfString(m_isoScriptCode_);
    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_isTransliterationOf_);
    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_isDiacriticTransliterationOf_);
    endBitPosition += m_languageNames_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LanguageMapping::bitSizeOf(LanguageMapping::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getLanguageCode().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::types::LanguageCode>>(m_languageCode_);
    endBitPosition += ::zserio::bitSizeOfString(m_isoCountryCode_);
    endBitPosition += ::zserio::bitSizeOfString(m_isoLanguageCode_);
    endBitPosition += ::zserio::bitSizeOfString(m_isoScriptCode_);
    endBitPosition += context.getIsTransliterationOf().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::types::LanguageCode>>(m_isTransliterationOf_);
    endBitPosition += context.getIsDiacriticTransliterationOf().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::types::LanguageCode>>(m_isDiacriticTransliterationOf_);
    endBitPosition += m_languageNames_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LanguageMapping::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_languageCode_);
    endBitPosition += ::zserio::bitSizeOfString(m_isoCountryCode_);
    endBitPosition += ::zserio::bitSizeOfString(m_isoLanguageCode_);
    endBitPosition += ::zserio::bitSizeOfString(m_isoScriptCode_);
    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_isTransliterationOf_);
    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_isDiacriticTransliterationOf_);
    endBitPosition = m_languageNames_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

size_t LanguageMapping::initializeOffsets(LanguageMapping::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getLanguageCode().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::types::LanguageCode>>(m_languageCode_);
    endBitPosition += ::zserio::bitSizeOfString(m_isoCountryCode_);
    endBitPosition += ::zserio::bitSizeOfString(m_isoLanguageCode_);
    endBitPosition += ::zserio::bitSizeOfString(m_isoScriptCode_);
    endBitPosition += context.getIsTransliterationOf().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::types::LanguageCode>>(m_isTransliterationOf_);
    endBitPosition += context.getIsDiacriticTransliterationOf().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::types::LanguageCode>>(m_isDiacriticTransliterationOf_);
    endBitPosition = m_languageNames_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool LanguageMapping::operator==(const LanguageMapping& other) const
{
    if (this != &other)
    {
        return
                (m_languageCode_ == other.m_languageCode_) &&
                (m_isoCountryCode_ == other.m_isoCountryCode_) &&
                (m_isoLanguageCode_ == other.m_isoLanguageCode_) &&
                (m_isoScriptCode_ == other.m_isoScriptCode_) &&
                (m_isTransliterationOf_ == other.m_isTransliterationOf_) &&
                (m_isDiacriticTransliterationOf_ == other.m_isDiacriticTransliterationOf_) &&
                (m_languageNames_ == other.m_languageNames_);
    }

    return true;
}

uint32_t LanguageMapping::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_languageCode_);
    result = ::zserio::calcHashCode(result, m_isoCountryCode_);
    result = ::zserio::calcHashCode(result, m_isoLanguageCode_);
    result = ::zserio::calcHashCode(result, m_isoScriptCode_);
    result = ::zserio::calcHashCode(result, m_isTransliterationOf_);
    result = ::zserio::calcHashCode(result, m_isDiacriticTransliterationOf_);
    result = ::zserio::calcHashCode(result, m_languageNames_);

    return result;
}

void LanguageMapping::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt16(m_languageCode_);
    out.writeString(m_isoCountryCode_);
    out.writeString(m_isoLanguageCode_);
    out.writeString(m_isoScriptCode_);
    out.writeVarUInt16(m_isTransliterationOf_);
    out.writeVarUInt16(m_isDiacriticTransliterationOf_);
    m_languageNames_.write(*this, out);
}

void LanguageMapping::write(LanguageMapping::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getLanguageCode().write<::zserio::VarIntNNArrayTraits<::nds::core::types::LanguageCode>>(out, m_languageCode_);
    out.writeString(m_isoCountryCode_);
    out.writeString(m_isoLanguageCode_);
    out.writeString(m_isoScriptCode_);
    context.getIsTransliterationOf().write<::zserio::VarIntNNArrayTraits<::nds::core::types::LanguageCode>>(out, m_isTransliterationOf_);
    context.getIsDiacriticTransliterationOf().write<::zserio::VarIntNNArrayTraits<::nds::core::types::LanguageCode>>(out, m_isDiacriticTransliterationOf_);
    m_languageNames_.writePacked(*this, out);
}

void LanguageMapping::ZserioElementFactory_languageNames::create(LanguageMapping&        ,
        ::zserio::vector<::nds::core::language::LanguageName>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void LanguageMapping::ZserioElementFactory_languageNames::create(LanguageMapping&        ,
        ::zserio::vector<::nds::core::language::LanguageName>& array,
        ::nds::core::language::LanguageName::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::core::types::LanguageCode LanguageMapping::readLanguageCode(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::types::LanguageCode>(in.readVarUInt16());
}

::nds::core::types::LanguageCode LanguageMapping::readLanguageCode(LanguageMapping::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getLanguageCode().read<::zserio::VarIntNNArrayTraits<::nds::core::types::LanguageCode>>(in);
}
::zserio::string<> LanguageMapping::readIsoCountryCode(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return static_cast<::zserio::string<>>(in.readString(allocator));
}
::zserio::string<> LanguageMapping::readIsoLanguageCode(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return static_cast<::zserio::string<>>(in.readString(allocator));
}
::zserio::string<> LanguageMapping::readIsoScriptCode(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return static_cast<::zserio::string<>>(in.readString(allocator));
}
::nds::core::types::LanguageCode LanguageMapping::readIsTransliterationOf(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::types::LanguageCode>(in.readVarUInt16());
}

::nds::core::types::LanguageCode LanguageMapping::readIsTransliterationOf(LanguageMapping::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getIsTransliterationOf().read<::zserio::VarIntNNArrayTraits<::nds::core::types::LanguageCode>>(in);
}
::nds::core::types::LanguageCode LanguageMapping::readIsDiacriticTransliterationOf(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::types::LanguageCode>(in.readVarUInt16());
}

::nds::core::types::LanguageCode LanguageMapping::readIsDiacriticTransliterationOf(LanguageMapping::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getIsDiacriticTransliterationOf().read<::zserio::VarIntNNArrayTraits<::nds::core::types::LanguageCode>>(in);
}
LanguageMapping::ZserioArrayType_languageNames LanguageMapping::readLanguageNames(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_languageNames readField(allocator);
    readField.read(*this, in);

    return readField;
}

LanguageMapping::ZserioArrayType_languageNames LanguageMapping::readLanguageNames(LanguageMapping::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_languageNames readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}

} // namespace language
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/core/language/LanguageName.h>

namespace nds
{
namespace core
{
namespace language
{

LanguageName::LanguageName(const allocator_type& allocator) noexcept :
        m_languageCode_(::nds::core::types::LanguageCode()),
        m_languageName_(allocator)
{
}

LanguageName::LanguageName(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_languageCode_(readLanguageCode(in)),
        m_languageName_(readLanguageName(in, allocator))
{
}

LanguageName::LanguageName(LanguageName::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_languageCode_(readLanguageCode(context, in)),
        m_languageName_(readLanguageName(in, allocator))
{
}

LanguageName::LanguageName(::zserio::PropagateAllocatorT,
        const LanguageName& other, const allocator_type& allocator) :
        m_languageCode_(::zserio::allocatorPropagatingCopy(other.m_languageCode_, allocator)),
        m_languageName_(::zserio::allocatorPropagatingCopy(other.m_languageName_, allocator))
{
}

::nds::core::types::LanguageCode LanguageName::getLanguageCode() const
{
    return m_languageCode_;
}

void LanguageName::setLanguageCode(::nds::core::types::LanguageCode languageCode_)
{
    m_languageCode_ = languageCode_;
}

::zserio::string<>& LanguageName::getLanguageName()
{
    return m_languageName_;
}

const ::zserio::string<>& LanguageName::getLanguageName() const
{
    return m_languageName_;
}

void LanguageName::setLanguageName(const ::zserio::string<>& languageName_)
{
    m_languageName_ = languageName_;
}

void LanguageName::setLanguageName(::zserio::string<>&& languageName_)
{
    m_languageName_ = ::std::move(languageName_);
}

void LanguageName::initPackingContext(LanguageName::ZserioPackingContext& context) const
{
    context.getLanguageCode().init<::zserio::VarIntNNArrayTraits<::nds::core::types::LanguageCode>>(m_languageCode_);
}

size_t LanguageName::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_languageCode_);
    endBitPosition += ::zserio::bitSizeOfString(m_languageName_);

    return endBitPosition - bitPosition;
}

size_t LanguageName::bitSizeOf(LanguageName::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getLanguageCode().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::types::LanguageCode>>(m_languageCode_);
    endBitPosition += ::zserio::bitSizeOfString(m_languageName_);

    return endBitPosition - bitPosition;
}

size_t LanguageName::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_languageCode_);
    endBitPosition += ::zserio::bitSizeOfString(m_languageName_);

    return endBitPosition;
}

size_t LanguageName::initializeOffsets(LanguageName::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getLanguageCode().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::types::LanguageCode>>(m_languageCode_);
    endBitPosition += ::zserio::bitSizeOfString(m_languageName_);

    return endBitPosition;
}

bool LanguageName::operator==(const LanguageName& other) const
{
    if (this != &other)
    {
        return
                (m_languageCode_ == other.m_languageCode_) &&
                (m_languageName_ == other.m_languageName_);
    }

    return true;
}

uint32_t LanguageName::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_languageCode_);
    result = ::zserio::calcHashCode(result, m_languageName_);

    return result;
}

void LanguageName::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt16(m_languageCode_);
    out.writeString(m_languageName_);
}

void LanguageName::write(LanguageName::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getLanguageCode().write<::zserio::VarIntNNArrayTraits<::nds::core::types::LanguageCode>>(out, m_languageCode_);
    out.writeString(m_languageName_);
}

::nds::core::types::LanguageCode LanguageName::readLanguageCode(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::types::LanguageCode>(in.readVarUInt16());
}

::nds::core::types::LanguageCode LanguageName::readLanguageCode(LanguageName::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getLanguageCode().read<::zserio::VarIntNNArrayTraits<::nds::core::types::LanguageCode>>(in);
}
::zserio::string<> LanguageName::readLanguageName(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return static_cast<::zserio::string<>>(in.readString(allocator));
}

} // namespace language
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/core/language/CharacterChartCodeColl.h>

namespace nds
{
namespace core
{
namespace language
{

CharacterChartCodeColl::CharacterChartCodeColl(const allocator_type& allocator) noexcept :
        m_characterChartCode_(allocator)
{
}

CharacterChartCodeColl::CharacterChartCodeColl(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_characterChartCode_(readCharacterChartCode(in, allocator))
{
}

CharacterChartCodeColl::CharacterChartCodeColl(CharacterChartCodeColl::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_characterChartCode_(readCharacterChartCode(context, in, allocator))
{
}

CharacterChartCodeColl::CharacterChartCodeColl(::zserio::PropagateAllocatorT,
        const CharacterChartCodeColl& other, const allocator_type& allocator) :
        m_characterChartCode_(::zserio::allocatorPropagatingCopy(other.m_characterChartCode_, allocator))
{
}

::zserio::vector<uint32_t>& CharacterChartCodeColl::getCharacterChartCode()
{
    return m_characterChartCode_.getRawArray();
}

const ::zserio::vector<uint32_t>& CharacterChartCodeColl::getCharacterChartCode() const
{
    return m_characterChartCode_.getRawArray();
}

void CharacterChartCodeColl::setCharacterChartCode(const ::zserio::vector<uint32_t>& characterChartCode_)
{
    m_characterChartCode_ = ZserioArrayType_characterChartCode(characterChartCode_);
}

void CharacterChartCodeColl::setCharacterChartCode(::zserio::vector<uint32_t>&& characterChartCode_)
{
    m_characterChartCode_ = ZserioArrayType_characterChartCode(std::move(characterChartCode_));
}

void CharacterChartCodeColl::initPackingContext(CharacterChartCodeColl::ZserioPackingContext&) const
{
}

size_t CharacterChartCodeColl::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_characterChartCode_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t CharacterChartCodeColl::bitSizeOf(CharacterChartCodeColl::ZserioPackingContext&, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_characterChartCode_.bitSizeOfPacked(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t CharacterChartCodeColl::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_characterChartCode_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t CharacterChartCodeColl::initializeOffsets(CharacterChartCodeColl::ZserioPackingContext&, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_characterChartCode_.initializeOffsetsPacked(endBitPosition);

    return endBitPosition;
}

bool CharacterChartCodeColl::operator==(const CharacterChartCodeColl& other) const
{
    if (this != &other)
    {
        return
                (m_characterChartCode_ == other.m_characterChartCode_);
    }

    return true;
}

uint32_t CharacterChartCodeColl::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_characterChartCode_);

    return result;
}

void CharacterChartCodeColl::write(::zserio::BitStreamWriter& out) const
{
    m_characterChartCode_.write(out);
}

void CharacterChartCodeColl::write(CharacterChartCodeColl::ZserioPackingContext&, ::zserio::BitStreamWriter& out) const
{
    m_characterChartCode_.writePacked(out);
}

CharacterChartCodeColl::ZserioArrayType_characterChartCode CharacterChartCodeColl::readCharacterChartCode(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_characterChartCode readField(allocator);
    readField.read(in);

    return readField;
}

CharacterChartCodeColl::ZserioArrayType_characterChartCode CharacterChartCodeColl::readCharacterChartCode(CharacterChartCodeColl::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_characterChartCode readField(allocator);
    readField.readPacked(in);

    return readField;
}

} // namespace language
} // namespace core
} // namespace nds
