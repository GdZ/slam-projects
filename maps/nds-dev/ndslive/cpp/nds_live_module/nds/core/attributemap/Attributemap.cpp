/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/core/attributemap/ConditionTypeCodeCollection.h>

namespace nds
{
namespace core
{
namespace attributemap
{

ConditionTypeCodeCollection::ConditionTypeCodeCollection(const allocator_type& allocator) noexcept :
        m_conditionTypeCode_(allocator)
{
}

ConditionTypeCodeCollection::ConditionTypeCodeCollection(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_conditionTypeCode_(readConditionTypeCode(in, allocator))
{
}

ConditionTypeCodeCollection::ConditionTypeCodeCollection(ConditionTypeCodeCollection::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_conditionTypeCode_(readConditionTypeCode(context, in, allocator))
{
}

ConditionTypeCodeCollection::ConditionTypeCodeCollection(::zserio::PropagateAllocatorT,
        const ConditionTypeCodeCollection& other, const allocator_type& allocator) :
        m_conditionTypeCode_(::zserio::allocatorPropagatingCopy(other.m_conditionTypeCode_, allocator))
{
}

::zserio::vector<::nds::core::conditions::ConditionTypeCode>& ConditionTypeCodeCollection::getConditionTypeCode()
{
    return m_conditionTypeCode_.getRawArray();
}

const ::zserio::vector<::nds::core::conditions::ConditionTypeCode>& ConditionTypeCodeCollection::getConditionTypeCode() const
{
    return m_conditionTypeCode_.getRawArray();
}

void ConditionTypeCodeCollection::setConditionTypeCode(const ::zserio::vector<::nds::core::conditions::ConditionTypeCode>& conditionTypeCode_)
{
    m_conditionTypeCode_ = ZserioArrayType_conditionTypeCode(conditionTypeCode_);
}

void ConditionTypeCodeCollection::setConditionTypeCode(::zserio::vector<::nds::core::conditions::ConditionTypeCode>&& conditionTypeCode_)
{
    m_conditionTypeCode_ = ZserioArrayType_conditionTypeCode(std::move(conditionTypeCode_));
}

void ConditionTypeCodeCollection::initPackingContext(ConditionTypeCodeCollection::ZserioPackingContext&) const
{
}

size_t ConditionTypeCodeCollection::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_conditionTypeCode_.bitSizeOfPacked(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ConditionTypeCodeCollection::bitSizeOf(ConditionTypeCodeCollection::ZserioPackingContext&, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_conditionTypeCode_.bitSizeOfPacked(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ConditionTypeCodeCollection::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_conditionTypeCode_.initializeOffsetsPacked(endBitPosition);

    return endBitPosition;
}

size_t ConditionTypeCodeCollection::initializeOffsets(ConditionTypeCodeCollection::ZserioPackingContext&, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_conditionTypeCode_.initializeOffsetsPacked(endBitPosition);

    return endBitPosition;
}

bool ConditionTypeCodeCollection::operator==(const ConditionTypeCodeCollection& other) const
{
    if (this != &other)
    {
        return
                (m_conditionTypeCode_ == other.m_conditionTypeCode_);
    }

    return true;
}

uint32_t ConditionTypeCodeCollection::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_conditionTypeCode_);

    return result;
}

void ConditionTypeCodeCollection::write(::zserio::BitStreamWriter& out) const
{
    m_conditionTypeCode_.writePacked(out);
}

void ConditionTypeCodeCollection::write(ConditionTypeCodeCollection::ZserioPackingContext&, ::zserio::BitStreamWriter& out) const
{
    m_conditionTypeCode_.writePacked(out);
}

ConditionTypeCodeCollection::ZserioArrayType_conditionTypeCode ConditionTypeCodeCollection::readConditionTypeCode(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_conditionTypeCode readField(allocator);
    readField.readPacked(in);

    return readField;
}

ConditionTypeCodeCollection::ZserioArrayType_conditionTypeCode ConditionTypeCodeCollection::readConditionTypeCode(ConditionTypeCodeCollection::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_conditionTypeCode readField(allocator);
    readField.readPacked(in);

    return readField;
}

} // namespace attributemap
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/core/attributemap/PropertyList_CorePropertyType_CorePropertyValue.h>

namespace nds
{
namespace core
{
namespace attributemap
{

PropertyList_CorePropertyType_CorePropertyValue::PropertyList_CorePropertyType_CorePropertyValue(const allocator_type&) noexcept :
        m_numProperties_(uint8_t()),
        m_property_(::zserio::NullOpt)
{
}

PropertyList_CorePropertyType_CorePropertyValue::PropertyList_CorePropertyType_CorePropertyValue(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numProperties_(readNumProperties(in)),
        m_property_(readProperty(in, allocator))
{
}

PropertyList_CorePropertyType_CorePropertyValue::PropertyList_CorePropertyType_CorePropertyValue(PropertyList_CorePropertyType_CorePropertyValue::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numProperties_(readNumProperties(context, in)),
        m_property_(readProperty(context, in, allocator))
{
}

PropertyList_CorePropertyType_CorePropertyValue::PropertyList_CorePropertyType_CorePropertyValue(::zserio::PropagateAllocatorT,
        const PropertyList_CorePropertyType_CorePropertyValue& other, const allocator_type& allocator) :
        m_numProperties_(::zserio::allocatorPropagatingCopy(other.m_numProperties_, allocator)),
        m_property_(::zserio::allocatorPropagatingCopy(other.m_property_, allocator))
{
}

void PropertyList_CorePropertyType_CorePropertyValue::initializeChildren()
{
    if (getNumProperties() > 0)
        m_property_.value().initializeElements(*this);
}

uint8_t PropertyList_CorePropertyType_CorePropertyValue::getNumProperties() const
{
    return m_numProperties_;
}

void PropertyList_CorePropertyType_CorePropertyValue::setNumProperties(uint8_t numProperties_)
{
    m_numProperties_ = numProperties_;
}

::zserio::vector<::nds::core::attributemap::Property_CorePropertyType_CorePropertyValue>& PropertyList_CorePropertyType_CorePropertyValue::getProperty()
{
    return m_property_.value().getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::Property_CorePropertyType_CorePropertyValue>& PropertyList_CorePropertyType_CorePropertyValue::getProperty() const
{
    return m_property_.value().getRawArray();
}

void PropertyList_CorePropertyType_CorePropertyValue::setProperty(const ::zserio::vector<::nds::core::attributemap::Property_CorePropertyType_CorePropertyValue>& property_)
{
    m_property_ = ZserioArrayType_property(property_);
}

void PropertyList_CorePropertyType_CorePropertyValue::setProperty(::zserio::vector<::nds::core::attributemap::Property_CorePropertyType_CorePropertyValue>&& property_)
{
    m_property_ = ZserioArrayType_property(std::move(property_));
}

bool PropertyList_CorePropertyType_CorePropertyValue::isPropertyUsed() const
{
    return (getNumProperties() > 0);
}

bool PropertyList_CorePropertyType_CorePropertyValue::isPropertySet() const
{
    return m_property_.hasValue();
}

void PropertyList_CorePropertyType_CorePropertyValue::resetProperty()
{
    m_property_.reset();
}

void PropertyList_CorePropertyType_CorePropertyValue::initPackingContext(PropertyList_CorePropertyType_CorePropertyValue::ZserioPackingContext& context) const
{
    context.getNumProperties().init<::zserio::StdIntArrayTraits<uint8_t>>(m_numProperties_);
}

size_t PropertyList_CorePropertyType_CorePropertyValue::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(8);
    if (getNumProperties() > 0)
    {
        endBitPosition += m_property_.value().bitSizeOfPacked(*this, endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t PropertyList_CorePropertyType_CorePropertyValue::bitSizeOf(PropertyList_CorePropertyType_CorePropertyValue::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumProperties().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_numProperties_);
    if (getNumProperties() > 0)
    {
        endBitPosition += m_property_.value().bitSizeOfPacked(*this, endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t PropertyList_CorePropertyType_CorePropertyValue::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(8);
    if (getNumProperties() > 0)
    {
        endBitPosition = m_property_.value().initializeOffsetsPacked(*this, endBitPosition);
    }

    return endBitPosition;
}

size_t PropertyList_CorePropertyType_CorePropertyValue::initializeOffsets(PropertyList_CorePropertyType_CorePropertyValue::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumProperties().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_numProperties_);
    if (getNumProperties() > 0)
    {
        endBitPosition = m_property_.value().initializeOffsetsPacked(*this, endBitPosition);
    }

    return endBitPosition;
}

bool PropertyList_CorePropertyType_CorePropertyValue::operator==(const PropertyList_CorePropertyType_CorePropertyValue& other) const
{
    if (this != &other)
    {
        return
                (m_numProperties_ == other.m_numProperties_) &&
                (!isPropertyUsed() ? !other.isPropertyUsed() : (m_property_ == other.m_property_));
    }

    return true;
}

uint32_t PropertyList_CorePropertyType_CorePropertyValue::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_numProperties_);
    if (isPropertyUsed())
        result = ::zserio::calcHashCode(result, m_property_);

    return result;
}

void PropertyList_CorePropertyType_CorePropertyValue::write(::zserio::BitStreamWriter& out) const
{
    out.writeBits(m_numProperties_, UINT8_C(8));

    if (getNumProperties() > 0)
    {
        // check array length
        if (m_property_.value().getRawArray().size() != static_cast<size_t>(getNumProperties()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field PropertyList_CorePropertyType_CorePropertyValue.property: ") <<
                    m_property_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumProperties()) << "!";
        }
        m_property_.value().writePacked(*this, out);
    }
}

void PropertyList_CorePropertyType_CorePropertyValue::write(PropertyList_CorePropertyType_CorePropertyValue::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumProperties().write<::zserio::StdIntArrayTraits<uint8_t>>(out, m_numProperties_);

    if (getNumProperties() > 0)
    {
        // check array length
        if (m_property_.value().getRawArray().size() != static_cast<size_t>(getNumProperties()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field PropertyList_CorePropertyType_CorePropertyValue.property: ") <<
                    m_property_.value().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumProperties()) << "!";
        }
        m_property_.value().writePacked(*this, out);
    }
}

void PropertyList_CorePropertyType_CorePropertyValue::ZserioArrayExpressions_property::initializeElement(PropertyList_CorePropertyType_CorePropertyValue&,
        ::nds::core::attributemap::Property_CorePropertyType_CorePropertyValue& element, size_t)
{
    element.initializeChildren();
}

void PropertyList_CorePropertyType_CorePropertyValue::ZserioElementFactory_property::create(PropertyList_CorePropertyType_CorePropertyValue&        ,
        ::zserio::vector<::nds::core::attributemap::Property_CorePropertyType_CorePropertyValue>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void PropertyList_CorePropertyType_CorePropertyValue::ZserioElementFactory_property::create(PropertyList_CorePropertyType_CorePropertyValue&        ,
        ::zserio::vector<::nds::core::attributemap::Property_CorePropertyType_CorePropertyValue>& array,
        ::nds::core::attributemap::Property_CorePropertyType_CorePropertyValue::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

uint8_t PropertyList_CorePropertyType_CorePropertyValue::readNumProperties(::zserio::BitStreamReader& in)
{
    return static_cast<uint8_t>(in.readBits(UINT8_C(8)));
}

uint8_t PropertyList_CorePropertyType_CorePropertyValue::readNumProperties(PropertyList_CorePropertyType_CorePropertyValue::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumProperties().read<::zserio::StdIntArrayTraits<uint8_t>>(in);
}
::zserio::InplaceOptionalHolder<PropertyList_CorePropertyType_CorePropertyValue::ZserioArrayType_property> PropertyList_CorePropertyType_CorePropertyValue::readProperty(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getNumProperties() > 0)
    {
        ZserioArrayType_property readField(allocator);
        readField.readPacked(*this, in, static_cast<size_t>(getNumProperties()));

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_property>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_property>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<PropertyList_CorePropertyType_CorePropertyValue::ZserioArrayType_property> PropertyList_CorePropertyType_CorePropertyValue::readProperty(PropertyList_CorePropertyType_CorePropertyValue::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getNumProperties() > 0)
    {
        ZserioArrayType_property readField(allocator);
        readField.readPacked(*this, in, static_cast<size_t>(getNumProperties()));

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_property>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_property>(::zserio::NullOpt);
}

} // namespace attributemap
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/core/attributemap/Property_CorePropertyType_CorePropertyValue.h>

namespace nds
{
namespace core
{
namespace attributemap
{

Property_CorePropertyType_CorePropertyValue::Property_CorePropertyType_CorePropertyValue(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_propertyTypeCode_(::nds::core::properties::CorePropertyType()),
        m_propertyValue_(allocator)
{
}

Property_CorePropertyType_CorePropertyValue::Property_CorePropertyType_CorePropertyValue(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_propertyTypeCode_(readPropertyTypeCode(in)),
        m_propertyValue_(readPropertyValue(in, allocator))
{
}

Property_CorePropertyType_CorePropertyValue::Property_CorePropertyType_CorePropertyValue(Property_CorePropertyType_CorePropertyValue::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_propertyTypeCode_(readPropertyTypeCode(context, in)),
        m_propertyValue_(readPropertyValue(context, in, allocator))
{
}

Property_CorePropertyType_CorePropertyValue::Property_CorePropertyType_CorePropertyValue(const Property_CorePropertyType_CorePropertyValue& other) :
        m_propertyTypeCode_(other.m_propertyTypeCode_),
        m_propertyValue_(other.m_propertyValue_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

Property_CorePropertyType_CorePropertyValue& Property_CorePropertyType_CorePropertyValue::operator=(const Property_CorePropertyType_CorePropertyValue& other)
{
    m_propertyTypeCode_ = other.m_propertyTypeCode_;
    m_propertyValue_ = other.m_propertyValue_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

Property_CorePropertyType_CorePropertyValue::Property_CorePropertyType_CorePropertyValue(Property_CorePropertyType_CorePropertyValue&& other) :
        m_propertyTypeCode_(::std::move(other.m_propertyTypeCode_)),
        m_propertyValue_(::std::move(other.m_propertyValue_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

Property_CorePropertyType_CorePropertyValue& Property_CorePropertyType_CorePropertyValue::operator=(Property_CorePropertyType_CorePropertyValue&& other)
{
    m_propertyTypeCode_ = ::std::move(other.m_propertyTypeCode_);
    m_propertyValue_ = ::std::move(other.m_propertyValue_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

Property_CorePropertyType_CorePropertyValue::Property_CorePropertyType_CorePropertyValue(::zserio::PropagateAllocatorT,
        const Property_CorePropertyType_CorePropertyValue& other, const allocator_type& allocator) :
        m_propertyTypeCode_(::zserio::allocatorPropagatingCopy(other.m_propertyTypeCode_, allocator)),
        m_propertyValue_(::zserio::allocatorPropagatingCopy(other.m_propertyValue_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void Property_CorePropertyType_CorePropertyValue::initializeChildren()
{
    m_propertyValue_.initialize(static_cast<::nds::core::properties::CorePropertyType>(getPropertyTypeCode()));

    m_areChildrenInitialized = true;
}

::nds::core::properties::CorePropertyType Property_CorePropertyType_CorePropertyValue::getPropertyTypeCode() const
{
    return m_propertyTypeCode_;
}

void Property_CorePropertyType_CorePropertyValue::setPropertyTypeCode(::nds::core::properties::CorePropertyType propertyTypeCode_)
{
    m_propertyTypeCode_ = propertyTypeCode_;
}

::nds::core::properties::CorePropertyValue& Property_CorePropertyType_CorePropertyValue::getPropertyValue()
{
    return m_propertyValue_;
}

const ::nds::core::properties::CorePropertyValue& Property_CorePropertyType_CorePropertyValue::getPropertyValue() const
{
    return m_propertyValue_;
}

void Property_CorePropertyType_CorePropertyValue::setPropertyValue(const ::nds::core::properties::CorePropertyValue& propertyValue_)
{
    m_propertyValue_ = propertyValue_;
}

void Property_CorePropertyType_CorePropertyValue::setPropertyValue(::nds::core::properties::CorePropertyValue&& propertyValue_)
{
    m_propertyValue_ = ::std::move(propertyValue_);
}

void Property_CorePropertyType_CorePropertyValue::initPackingContext(Property_CorePropertyType_CorePropertyValue::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getPropertyTypeCode(), m_propertyTypeCode_);
    m_propertyValue_.initPackingContext(context.getPropertyValue());
}

size_t Property_CorePropertyType_CorePropertyValue::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_propertyTypeCode_);
    endBitPosition += m_propertyValue_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t Property_CorePropertyType_CorePropertyValue::bitSizeOf(Property_CorePropertyType_CorePropertyValue::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getPropertyTypeCode(), m_propertyTypeCode_);
    endBitPosition += m_propertyValue_.bitSizeOf(context.getPropertyValue(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t Property_CorePropertyType_CorePropertyValue::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_propertyTypeCode_);
    endBitPosition = m_propertyValue_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t Property_CorePropertyType_CorePropertyValue::initializeOffsets(Property_CorePropertyType_CorePropertyValue::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getPropertyTypeCode(), endBitPosition,
        m_propertyTypeCode_);
    endBitPosition = m_propertyValue_.initializeOffsets(context.getPropertyValue(), endBitPosition);

    return endBitPosition;
}

bool Property_CorePropertyType_CorePropertyValue::operator==(const Property_CorePropertyType_CorePropertyValue& other) const
{
    if (this != &other)
    {
        return
                (m_propertyTypeCode_ == other.m_propertyTypeCode_) &&
                (m_propertyValue_ == other.m_propertyValue_);
    }

    return true;
}

uint32_t Property_CorePropertyType_CorePropertyValue::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_propertyTypeCode_);
    result = ::zserio::calcHashCode(result, m_propertyValue_);

    return result;
}

void Property_CorePropertyType_CorePropertyValue::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_propertyTypeCode_);

    // check parameters
    if (m_propertyValue_.getType() != static_cast<::nds::core::properties::CorePropertyType>(getPropertyTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field Property_CorePropertyType_CorePropertyValue.propertyValue: ") <<
                m_propertyValue_.getType() << " != " << static_cast<::nds::core::properties::CorePropertyType>(getPropertyTypeCode()) << "!";
    }
    m_propertyValue_.write(out);
}

void Property_CorePropertyType_CorePropertyValue::write(Property_CorePropertyType_CorePropertyValue::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getPropertyTypeCode(), out, m_propertyTypeCode_);

    // check parameters
    if (m_propertyValue_.getType() != static_cast<::nds::core::properties::CorePropertyType>(getPropertyTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field Property_CorePropertyType_CorePropertyValue.propertyValue: ") <<
                m_propertyValue_.getType() << " != " << static_cast<::nds::core::properties::CorePropertyType>(getPropertyTypeCode()) << "!";
    }
    m_propertyValue_.write(context.getPropertyValue(), out);
}

::nds::core::properties::CorePropertyType Property_CorePropertyType_CorePropertyValue::readPropertyTypeCode(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::core::properties::CorePropertyType>(in);
}

::nds::core::properties::CorePropertyType Property_CorePropertyType_CorePropertyValue::readPropertyTypeCode(Property_CorePropertyType_CorePropertyValue::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::core::properties::CorePropertyType>(context.getPropertyTypeCode(), in);
}
::nds::core::properties::CorePropertyValue Property_CorePropertyType_CorePropertyValue::readPropertyValue(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::properties::CorePropertyValue(in, static_cast<::nds::core::properties::CorePropertyType>(getPropertyTypeCode()), allocator);
}

::nds::core::properties::CorePropertyValue Property_CorePropertyType_CorePropertyValue::readPropertyValue(Property_CorePropertyType_CorePropertyValue::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::properties::CorePropertyValue(context.getPropertyValue(), in, static_cast<::nds::core::properties::CorePropertyType>(getPropertyTypeCode()), allocator);
}

} // namespace attributemap
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/core/attributemap/ConditionList.h>

namespace nds
{
namespace core
{
namespace attributemap
{

ConditionList::ConditionList(const allocator_type& allocator) noexcept :
        m_numConditions_(uint8_t()),
        m_conditionList_(allocator)
{
}

ConditionList::ConditionList(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numConditions_(readNumConditions(in)),
        m_conditionList_(readConditionList(in, allocator))
{
}

ConditionList::ConditionList(ConditionList::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numConditions_(readNumConditions(context, in)),
        m_conditionList_(readConditionList(context, in, allocator))
{
}

ConditionList::ConditionList(::zserio::PropagateAllocatorT,
        const ConditionList& other, const allocator_type& allocator) :
        m_numConditions_(::zserio::allocatorPropagatingCopy(other.m_numConditions_, allocator)),
        m_conditionList_(::zserio::allocatorPropagatingCopy(other.m_conditionList_, allocator))
{
}

void ConditionList::initializeChildren()
{
    m_conditionList_.initializeElements(*this);
}

uint8_t ConditionList::getNumConditions() const
{
    return m_numConditions_;
}

void ConditionList::setNumConditions(uint8_t numConditions_)
{
    m_numConditions_ = numConditions_;
}

::zserio::vector<::nds::core::attributemap::Condition>& ConditionList::getConditionList()
{
    return m_conditionList_.getRawArray();
}

const ::zserio::vector<::nds::core::attributemap::Condition>& ConditionList::getConditionList() const
{
    return m_conditionList_.getRawArray();
}

void ConditionList::setConditionList(const ::zserio::vector<::nds::core::attributemap::Condition>& conditionList_)
{
    m_conditionList_ = ZserioArrayType_conditionList(conditionList_);
}

void ConditionList::setConditionList(::zserio::vector<::nds::core::attributemap::Condition>&& conditionList_)
{
    m_conditionList_ = ZserioArrayType_conditionList(std::move(conditionList_));
}

void ConditionList::initPackingContext(ConditionList::ZserioPackingContext& context) const
{
    context.getNumConditions().init<::zserio::StdIntArrayTraits<uint8_t>>(m_numConditions_);
}

size_t ConditionList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(8);
    endBitPosition += m_conditionList_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ConditionList::bitSizeOf(ConditionList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumConditions().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_numConditions_);
    endBitPosition += m_conditionList_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ConditionList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(8);
    endBitPosition = m_conditionList_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t ConditionList::initializeOffsets(ConditionList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumConditions().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_numConditions_);
    endBitPosition = m_conditionList_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool ConditionList::operator==(const ConditionList& other) const
{
    if (this != &other)
    {
        return
                (m_numConditions_ == other.m_numConditions_) &&
                (m_conditionList_ == other.m_conditionList_);
    }

    return true;
}

uint32_t ConditionList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_numConditions_);
    result = ::zserio::calcHashCode(result, m_conditionList_);

    return result;
}

void ConditionList::write(::zserio::BitStreamWriter& out) const
{
    out.writeBits(m_numConditions_, UINT8_C(8));

    // check array length
    if (m_conditionList_.getRawArray().size() != static_cast<size_t>(getNumConditions()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ConditionList.conditionList: ") <<
                m_conditionList_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumConditions()) << "!";
    }
    m_conditionList_.writePacked(*this, out);
}

void ConditionList::write(ConditionList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumConditions().write<::zserio::StdIntArrayTraits<uint8_t>>(out, m_numConditions_);

    // check array length
    if (m_conditionList_.getRawArray().size() != static_cast<size_t>(getNumConditions()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ConditionList.conditionList: ") <<
                m_conditionList_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumConditions()) << "!";
    }
    m_conditionList_.writePacked(*this, out);
}

void ConditionList::ZserioArrayExpressions_conditionList::initializeElement(ConditionList&,
        ::nds::core::attributemap::Condition& element, size_t)
{
    element.initializeChildren();
}

void ConditionList::ZserioElementFactory_conditionList::create(ConditionList&        ,
        ::zserio::vector<::nds::core::attributemap::Condition>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void ConditionList::ZserioElementFactory_conditionList::create(ConditionList&        ,
        ::zserio::vector<::nds::core::attributemap::Condition>& array,
        ::nds::core::attributemap::Condition::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

uint8_t ConditionList::readNumConditions(::zserio::BitStreamReader& in)
{
    return static_cast<uint8_t>(in.readBits(UINT8_C(8)));
}

uint8_t ConditionList::readNumConditions(ConditionList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumConditions().read<::zserio::StdIntArrayTraits<uint8_t>>(in);
}
ConditionList::ZserioArrayType_conditionList ConditionList::readConditionList(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_conditionList readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumConditions()));

    return readField;
}

ConditionList::ZserioArrayType_conditionList ConditionList::readConditionList(ConditionList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_conditionList readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumConditions()));

    return readField;
}

} // namespace attributemap
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/core/attributemap/Condition.h>

namespace nds
{
namespace core
{
namespace attributemap
{

Condition::Condition(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_conditionTypeCode_(::nds::core::conditions::ConditionTypeCode()),
        m_conditionValue_(allocator)
{
}

Condition::Condition(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_conditionTypeCode_(readConditionTypeCode(in)),
        m_conditionValue_(readConditionValue(in, allocator))
{
}

Condition::Condition(Condition::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_conditionTypeCode_(readConditionTypeCode(context, in)),
        m_conditionValue_(readConditionValue(context, in, allocator))
{
}

Condition::Condition(const Condition& other) :
        m_conditionTypeCode_(other.m_conditionTypeCode_),
        m_conditionValue_(other.m_conditionValue_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

Condition& Condition::operator=(const Condition& other)
{
    m_conditionTypeCode_ = other.m_conditionTypeCode_;
    m_conditionValue_ = other.m_conditionValue_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

Condition::Condition(Condition&& other) :
        m_conditionTypeCode_(::std::move(other.m_conditionTypeCode_)),
        m_conditionValue_(::std::move(other.m_conditionValue_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

Condition& Condition::operator=(Condition&& other)
{
    m_conditionTypeCode_ = ::std::move(other.m_conditionTypeCode_);
    m_conditionValue_ = ::std::move(other.m_conditionValue_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

Condition::Condition(::zserio::PropagateAllocatorT,
        const Condition& other, const allocator_type& allocator) :
        m_conditionTypeCode_(::zserio::allocatorPropagatingCopy(other.m_conditionTypeCode_, allocator)),
        m_conditionValue_(::zserio::allocatorPropagatingCopy(other.m_conditionValue_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void Condition::initializeChildren()
{
    m_conditionValue_.initialize(static_cast<::nds::core::conditions::ConditionTypeCode>(getConditionTypeCode()));

    m_areChildrenInitialized = true;
}

::nds::core::conditions::ConditionTypeCode Condition::getConditionTypeCode() const
{
    return m_conditionTypeCode_;
}

void Condition::setConditionTypeCode(::nds::core::conditions::ConditionTypeCode conditionTypeCode_)
{
    m_conditionTypeCode_ = conditionTypeCode_;
}

::nds::core::conditions::ConditionValue& Condition::getConditionValue()
{
    return m_conditionValue_;
}

const ::nds::core::conditions::ConditionValue& Condition::getConditionValue() const
{
    return m_conditionValue_;
}

void Condition::setConditionValue(const ::nds::core::conditions::ConditionValue& conditionValue_)
{
    m_conditionValue_ = conditionValue_;
}

void Condition::setConditionValue(::nds::core::conditions::ConditionValue&& conditionValue_)
{
    m_conditionValue_ = ::std::move(conditionValue_);
}

void Condition::initPackingContext(Condition::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getConditionTypeCode(), m_conditionTypeCode_);
    m_conditionValue_.initPackingContext(context.getConditionValue());
}

size_t Condition::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_conditionTypeCode_);
    endBitPosition += m_conditionValue_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t Condition::bitSizeOf(Condition::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getConditionTypeCode(), m_conditionTypeCode_);
    endBitPosition += m_conditionValue_.bitSizeOf(context.getConditionValue(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t Condition::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_conditionTypeCode_);
    endBitPosition = m_conditionValue_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t Condition::initializeOffsets(Condition::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getConditionTypeCode(), endBitPosition,
        m_conditionTypeCode_);
    endBitPosition = m_conditionValue_.initializeOffsets(context.getConditionValue(), endBitPosition);

    return endBitPosition;
}

bool Condition::operator==(const Condition& other) const
{
    if (this != &other)
    {
        return
                (m_conditionTypeCode_ == other.m_conditionTypeCode_) &&
                (m_conditionValue_ == other.m_conditionValue_);
    }

    return true;
}

uint32_t Condition::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_conditionTypeCode_);
    result = ::zserio::calcHashCode(result, m_conditionValue_);

    return result;
}

void Condition::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_conditionTypeCode_);

    // check parameters
    if (m_conditionValue_.getCode() != static_cast<::nds::core::conditions::ConditionTypeCode>(getConditionTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter code for field Condition.conditionValue: ") <<
                m_conditionValue_.getCode() << " != " << static_cast<::nds::core::conditions::ConditionTypeCode>(getConditionTypeCode()) << "!";
    }
    m_conditionValue_.write(out);
}

void Condition::write(Condition::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getConditionTypeCode(), out, m_conditionTypeCode_);

    // check parameters
    if (m_conditionValue_.getCode() != static_cast<::nds::core::conditions::ConditionTypeCode>(getConditionTypeCode()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter code for field Condition.conditionValue: ") <<
                m_conditionValue_.getCode() << " != " << static_cast<::nds::core::conditions::ConditionTypeCode>(getConditionTypeCode()) << "!";
    }
    m_conditionValue_.write(context.getConditionValue(), out);
}

::nds::core::conditions::ConditionTypeCode Condition::readConditionTypeCode(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::core::conditions::ConditionTypeCode>(in);
}

::nds::core::conditions::ConditionTypeCode Condition::readConditionTypeCode(Condition::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::core::conditions::ConditionTypeCode>(context.getConditionTypeCode(), in);
}
::nds::core::conditions::ConditionValue Condition::readConditionValue(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::conditions::ConditionValue(in, static_cast<::nds::core::conditions::ConditionTypeCode>(getConditionTypeCode()), allocator);
}

::nds::core::conditions::ConditionValue Condition::readConditionValue(Condition::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::conditions::ConditionValue(context.getConditionValue(), in, static_cast<::nds::core::conditions::ConditionTypeCode>(getConditionTypeCode()), allocator);
}

} // namespace attributemap
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/core/attributemap/Validity.h>

namespace nds
{
namespace core
{
namespace attributemap
{

Validity::Validity(const allocator_type&) noexcept :
        m_isInitialized(false)
{
}

Validity::Validity(::zserio::BitStreamReader&,
        ::nds::core::geometry::CoordShift shift_, const allocator_type&) :
        m_shift_(shift_),
        m_isInitialized(true)
{
}

Validity::Validity(const Validity& other)
{
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;
}

Validity& Validity::operator=(const Validity& other)
{
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;

    return *this;
}

Validity::Validity(Validity&& other)
{
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;
}

Validity& Validity::operator=(Validity&& other)
{
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;

    return *this;
}

Validity::Validity(::zserio::PropagateAllocatorT,
        const Validity& other, const allocator_type&)
{
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;
}

void Validity::initialize(
        ::nds::core::geometry::CoordShift shift_)
{
    m_shift_ = shift_;
    m_isInitialized = true;
}

bool Validity::isInitialized() const
{
    return m_isInitialized;
}

::nds::core::geometry::CoordShift Validity::getShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'shift' of compound 'Validity' is not initialized!");

    return m_shift_;
}

size_t Validity::bitSizeOf(size_t) const
{
    return 0;
}

size_t Validity::initializeOffsets(size_t bitPosition)
{
    return bitPosition;
}

bool Validity::operator==(const Validity& other) const
{
    if (this != &other)
    {
        return
                (getShift() == other.getShift());
    }

    return true;
}

uint32_t Validity::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getShift());
    return result;
}

void Validity::write(::zserio::BitStreamWriter&) const
{
}

} // namespace attributemap
} // namespace core
} // namespace nds
