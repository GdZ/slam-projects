/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/core/color/ColorRgb.h>

namespace nds
{
namespace core
{
namespace color
{

ColorRgb::ColorRgb(const allocator_type&) noexcept :
        m_red_(uint8_t()),
        m_green_(uint8_t()),
        m_blue_(uint8_t())
{
}

ColorRgb::ColorRgb(::zserio::BitStreamReader& in, const allocator_type&) :
        m_red_(readRed(in)),
        m_green_(readGreen(in)),
        m_blue_(readBlue(in))
{
}

ColorRgb::ColorRgb(ColorRgb::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type&) :
        m_red_(readRed(context, in)),
        m_green_(readGreen(context, in)),
        m_blue_(readBlue(context, in))
{
}

ColorRgb::ColorRgb(::zserio::PropagateAllocatorT,
        const ColorRgb& other, const allocator_type& allocator) :
        m_red_(::zserio::allocatorPropagatingCopy(other.m_red_, allocator)),
        m_green_(::zserio::allocatorPropagatingCopy(other.m_green_, allocator)),
        m_blue_(::zserio::allocatorPropagatingCopy(other.m_blue_, allocator))
{
}

uint8_t ColorRgb::getRed() const
{
    return m_red_;
}

void ColorRgb::setRed(uint8_t red_)
{
    m_red_ = red_;
}

uint8_t ColorRgb::getGreen() const
{
    return m_green_;
}

void ColorRgb::setGreen(uint8_t green_)
{
    m_green_ = green_;
}

uint8_t ColorRgb::getBlue() const
{
    return m_blue_;
}

void ColorRgb::setBlue(uint8_t blue_)
{
    m_blue_ = blue_;
}

void ColorRgb::initPackingContext(ColorRgb::ZserioPackingContext& context) const
{
    context.getRed().init<::zserio::StdIntArrayTraits<uint8_t>>(m_red_);
    context.getGreen().init<::zserio::StdIntArrayTraits<uint8_t>>(m_green_);
    context.getBlue().init<::zserio::StdIntArrayTraits<uint8_t>>(m_blue_);
}

size_t ColorRgb::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(8);
    endBitPosition += UINT8_C(8);
    endBitPosition += UINT8_C(8);

    return endBitPosition - bitPosition;
}

size_t ColorRgb::bitSizeOf(ColorRgb::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getRed().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_red_);
    endBitPosition += context.getGreen().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_green_);
    endBitPosition += context.getBlue().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_blue_);

    return endBitPosition - bitPosition;
}

size_t ColorRgb::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(8);
    endBitPosition += UINT8_C(8);
    endBitPosition += UINT8_C(8);

    return endBitPosition;
}

size_t ColorRgb::initializeOffsets(ColorRgb::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getRed().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_red_);
    endBitPosition += context.getGreen().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_green_);
    endBitPosition += context.getBlue().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_blue_);

    return endBitPosition;
}

bool ColorRgb::operator==(const ColorRgb& other) const
{
    if (this != &other)
    {
        return
                (m_red_ == other.m_red_) &&
                (m_green_ == other.m_green_) &&
                (m_blue_ == other.m_blue_);
    }

    return true;
}

uint32_t ColorRgb::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_red_);
    result = ::zserio::calcHashCode(result, m_green_);
    result = ::zserio::calcHashCode(result, m_blue_);

    return result;
}

void ColorRgb::write(::zserio::BitStreamWriter& out) const
{
    out.writeBits(m_red_, UINT8_C(8));
    out.writeBits(m_green_, UINT8_C(8));
    out.writeBits(m_blue_, UINT8_C(8));
}

void ColorRgb::write(ColorRgb::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getRed().write<::zserio::StdIntArrayTraits<uint8_t>>(out, m_red_);
    context.getGreen().write<::zserio::StdIntArrayTraits<uint8_t>>(out, m_green_);
    context.getBlue().write<::zserio::StdIntArrayTraits<uint8_t>>(out, m_blue_);
}

uint8_t ColorRgb::readRed(::zserio::BitStreamReader& in)
{
    return static_cast<uint8_t>(in.readBits(UINT8_C(8)));
}

uint8_t ColorRgb::readRed(ColorRgb::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getRed().read<::zserio::StdIntArrayTraits<uint8_t>>(in);
}
uint8_t ColorRgb::readGreen(::zserio::BitStreamReader& in)
{
    return static_cast<uint8_t>(in.readBits(UINT8_C(8)));
}

uint8_t ColorRgb::readGreen(ColorRgb::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getGreen().read<::zserio::StdIntArrayTraits<uint8_t>>(in);
}
uint8_t ColorRgb::readBlue(::zserio::BitStreamReader& in)
{
    return static_cast<uint8_t>(in.readBits(UINT8_C(8)));
}

uint8_t ColorRgb::readBlue(ColorRgb::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getBlue().read<::zserio::StdIntArrayTraits<uint8_t>>(in);
}

} // namespace color
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/core/color/ColorRgba.h>

namespace nds
{
namespace core
{
namespace color
{

ColorRgba::ColorRgba(const allocator_type&) noexcept :
        m_red_(uint8_t()),
        m_green_(uint8_t()),
        m_blue_(uint8_t()),
        m_alpha_(uint8_t())
{
}

ColorRgba::ColorRgba(::zserio::BitStreamReader& in, const allocator_type&) :
        m_red_(readRed(in)),
        m_green_(readGreen(in)),
        m_blue_(readBlue(in)),
        m_alpha_(readAlpha(in))
{
}

ColorRgba::ColorRgba(ColorRgba::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type&) :
        m_red_(readRed(context, in)),
        m_green_(readGreen(context, in)),
        m_blue_(readBlue(context, in)),
        m_alpha_(readAlpha(context, in))
{
}

ColorRgba::ColorRgba(::zserio::PropagateAllocatorT,
        const ColorRgba& other, const allocator_type& allocator) :
        m_red_(::zserio::allocatorPropagatingCopy(other.m_red_, allocator)),
        m_green_(::zserio::allocatorPropagatingCopy(other.m_green_, allocator)),
        m_blue_(::zserio::allocatorPropagatingCopy(other.m_blue_, allocator)),
        m_alpha_(::zserio::allocatorPropagatingCopy(other.m_alpha_, allocator))
{
}

uint8_t ColorRgba::getRed() const
{
    return m_red_;
}

void ColorRgba::setRed(uint8_t red_)
{
    m_red_ = red_;
}

uint8_t ColorRgba::getGreen() const
{
    return m_green_;
}

void ColorRgba::setGreen(uint8_t green_)
{
    m_green_ = green_;
}

uint8_t ColorRgba::getBlue() const
{
    return m_blue_;
}

void ColorRgba::setBlue(uint8_t blue_)
{
    m_blue_ = blue_;
}

uint8_t ColorRgba::getAlpha() const
{
    return m_alpha_;
}

void ColorRgba::setAlpha(uint8_t alpha_)
{
    m_alpha_ = alpha_;
}

void ColorRgba::initPackingContext(ColorRgba::ZserioPackingContext& context) const
{
    context.getRed().init<::zserio::StdIntArrayTraits<uint8_t>>(m_red_);
    context.getGreen().init<::zserio::StdIntArrayTraits<uint8_t>>(m_green_);
    context.getBlue().init<::zserio::StdIntArrayTraits<uint8_t>>(m_blue_);
    context.getAlpha().init<::zserio::StdIntArrayTraits<uint8_t>>(m_alpha_);
}

size_t ColorRgba::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(8);
    endBitPosition += UINT8_C(8);
    endBitPosition += UINT8_C(8);
    endBitPosition += UINT8_C(8);

    return endBitPosition - bitPosition;
}

size_t ColorRgba::bitSizeOf(ColorRgba::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getRed().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_red_);
    endBitPosition += context.getGreen().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_green_);
    endBitPosition += context.getBlue().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_blue_);
    endBitPosition += context.getAlpha().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_alpha_);

    return endBitPosition - bitPosition;
}

size_t ColorRgba::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(8);
    endBitPosition += UINT8_C(8);
    endBitPosition += UINT8_C(8);
    endBitPosition += UINT8_C(8);

    return endBitPosition;
}

size_t ColorRgba::initializeOffsets(ColorRgba::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getRed().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_red_);
    endBitPosition += context.getGreen().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_green_);
    endBitPosition += context.getBlue().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_blue_);
    endBitPosition += context.getAlpha().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_alpha_);

    return endBitPosition;
}

bool ColorRgba::operator==(const ColorRgba& other) const
{
    if (this != &other)
    {
        return
                (m_red_ == other.m_red_) &&
                (m_green_ == other.m_green_) &&
                (m_blue_ == other.m_blue_) &&
                (m_alpha_ == other.m_alpha_);
    }

    return true;
}

uint32_t ColorRgba::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_red_);
    result = ::zserio::calcHashCode(result, m_green_);
    result = ::zserio::calcHashCode(result, m_blue_);
    result = ::zserio::calcHashCode(result, m_alpha_);

    return result;
}

void ColorRgba::write(::zserio::BitStreamWriter& out) const
{
    out.writeBits(m_red_, UINT8_C(8));
    out.writeBits(m_green_, UINT8_C(8));
    out.writeBits(m_blue_, UINT8_C(8));
    out.writeBits(m_alpha_, UINT8_C(8));
}

void ColorRgba::write(ColorRgba::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getRed().write<::zserio::StdIntArrayTraits<uint8_t>>(out, m_red_);
    context.getGreen().write<::zserio::StdIntArrayTraits<uint8_t>>(out, m_green_);
    context.getBlue().write<::zserio::StdIntArrayTraits<uint8_t>>(out, m_blue_);
    context.getAlpha().write<::zserio::StdIntArrayTraits<uint8_t>>(out, m_alpha_);
}

uint8_t ColorRgba::readRed(::zserio::BitStreamReader& in)
{
    return static_cast<uint8_t>(in.readBits(UINT8_C(8)));
}

uint8_t ColorRgba::readRed(ColorRgba::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getRed().read<::zserio::StdIntArrayTraits<uint8_t>>(in);
}
uint8_t ColorRgba::readGreen(::zserio::BitStreamReader& in)
{
    return static_cast<uint8_t>(in.readBits(UINT8_C(8)));
}

uint8_t ColorRgba::readGreen(ColorRgba::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getGreen().read<::zserio::StdIntArrayTraits<uint8_t>>(in);
}
uint8_t ColorRgba::readBlue(::zserio::BitStreamReader& in)
{
    return static_cast<uint8_t>(in.readBits(UINT8_C(8)));
}

uint8_t ColorRgba::readBlue(ColorRgba::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getBlue().read<::zserio::StdIntArrayTraits<uint8_t>>(in);
}
uint8_t ColorRgba::readAlpha(::zserio::BitStreamReader& in)
{
    return static_cast<uint8_t>(in.readBits(UINT8_C(8)));
}

uint8_t ColorRgba::readAlpha(ColorRgba::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getAlpha().read<::zserio::StdIntArrayTraits<uint8_t>>(in);
}

} // namespace color
} // namespace core
} // namespace nds
