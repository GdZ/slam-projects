/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/core/speech/PhoneticTranscriptionFormat.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for PhoneticTranscriptionFormat enumeration.
constexpr ::std::array<const char*, 9> EnumTraits<::nds::core::speech::PhoneticTranscriptionFormat>::names;
constexpr ::std::array<::nds::core::speech::PhoneticTranscriptionFormat, 9> EnumTraits<::nds::core::speech::PhoneticTranscriptionFormat>::values;
constexpr const char* EnumTraits<::nds::core::speech::PhoneticTranscriptionFormat>::enumName;

template <>
size_t enumToOrdinal(::nds::core::speech::PhoneticTranscriptionFormat value)
{
    switch (value)
    {
    case ::nds::core::speech::PhoneticTranscriptionFormat::IPA:
        return 0;
    case ::nds::core::speech::PhoneticTranscriptionFormat::STARREC_SAMPA:
        return 1;
    case ::nds::core::speech::PhoneticTranscriptionFormat::X_SAMPA:
        return 2;
    case ::nds::core::speech::PhoneticTranscriptionFormat::LH_PLUS:
        return 3;
    case ::nds::core::speech::PhoneticTranscriptionFormat::NT_SAMPA:
        return 4;
    case ::nds::core::speech::PhoneticTranscriptionFormat::SVOX_PA:
        return 5;
    case ::nds::core::speech::PhoneticTranscriptionFormat::LH_PLUS_V24:
        return 6;
    case ::nds::core::speech::PhoneticTranscriptionFormat::I_FLYTEC:
        return 7;
    case ::nds::core::speech::PhoneticTranscriptionFormat::JEITA:
        return 8;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration PhoneticTranscriptionFormat: ") <<
                static_cast<typename ::std::underlying_type<::nds::core::speech::PhoneticTranscriptionFormat>::type>(value) << "!";
    }
}

template <>
::nds::core::speech::PhoneticTranscriptionFormat valueToEnum(
        typename ::std::underlying_type<::nds::core::speech::PhoneticTranscriptionFormat>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
    case UINT8_C(3):
    case UINT8_C(4):
    case UINT8_C(5):
    case UINT8_C(6):
    case UINT8_C(7):
    case UINT8_C(8):
        return static_cast<::nds::core::speech::PhoneticTranscriptionFormat>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration PhoneticTranscriptionFormat: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::core::speech::PhoneticTranscriptionFormat>(::nds::core::speech::PhoneticTranscriptionFormat value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::core::speech::PhoneticTranscriptionFormat value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::core::speech::PhoneticTranscriptionFormat>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::core::speech::PhoneticTranscriptionFormat)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::core::speech::PhoneticTranscriptionFormat value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::core::speech::PhoneticTranscriptionFormat>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::core::speech::PhoneticTranscriptionFormat value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::core::speech::PhoneticTranscriptionFormat value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::core::speech::PhoneticTranscriptionFormat read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::core::speech::PhoneticTranscriptionFormat>(
            static_cast<typename ::std::underlying_type<::nds::core::speech::PhoneticTranscriptionFormat>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::core::speech::PhoneticTranscriptionFormat read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::core::speech::PhoneticTranscriptionFormat>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::core::speech::PhoneticTranscriptionFormat>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::core::speech::PhoneticTranscriptionFormat value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::core::speech::PhoneticTranscriptionFormat value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::core::speech::PhoneticTranscriptionFormat>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/core/speech/GrammaticalCase.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for GrammaticalCase enumeration.
constexpr ::std::array<const char*, 41> EnumTraits<::nds::core::speech::GrammaticalCase>::names;
constexpr ::std::array<::nds::core::speech::GrammaticalCase, 41> EnumTraits<::nds::core::speech::GrammaticalCase>::values;
constexpr const char* EnumTraits<::nds::core::speech::GrammaticalCase>::enumName;

template <>
size_t enumToOrdinal(::nds::core::speech::GrammaticalCase value)
{
    switch (value)
    {
    case ::nds::core::speech::GrammaticalCase::NO_GRAMMATICAL_CASE:
        return 0;
    case ::nds::core::speech::GrammaticalCase::ABESSIVE_CASE:
        return 1;
    case ::nds::core::speech::GrammaticalCase::ABLATIVE_CASE:
        return 2;
    case ::nds::core::speech::GrammaticalCase::ABSOLUTIVE_CASE:
        return 3;
    case ::nds::core::speech::GrammaticalCase::ADESSIVE_CASE:
        return 4;
    case ::nds::core::speech::GrammaticalCase::ACCUSATIVE_CASE:
        return 5;
    case ::nds::core::speech::GrammaticalCase::ALLATIVE_CASE:
        return 6;
    case ::nds::core::speech::GrammaticalCase::CAUSAL_CASE:
        return 7;
    case ::nds::core::speech::GrammaticalCase::COMITATIVE_CASE:
        return 8;
    case ::nds::core::speech::GrammaticalCase::DATIVE_CASE:
        return 9;
    case ::nds::core::speech::GrammaticalCase::DELATIVE_CASE:
        return 10;
    case ::nds::core::speech::GrammaticalCase::DELIMITATIVE_CASE:
        return 11;
    case ::nds::core::speech::GrammaticalCase::DIRECTIONAL_CASE:
        return 12;
    case ::nds::core::speech::GrammaticalCase::DISTRIBUTIVE_TEMPORAL_CASE:
        return 13;
    case ::nds::core::speech::GrammaticalCase::ELATIVE_CASE:
        return 14;
    case ::nds::core::speech::GrammaticalCase::EQUATIVE_CASE:
        return 15;
    case ::nds::core::speech::GrammaticalCase::ERGATIVE_CASE:
        return 16;
    case ::nds::core::speech::GrammaticalCase::ESSIVE_CASE:
        return 17;
    case ::nds::core::speech::GrammaticalCase::FINAL_CASE:
        return 18;
    case ::nds::core::speech::GrammaticalCase::GENITIVE_CASE:
        return 19;
    case ::nds::core::speech::GrammaticalCase::ILLATIVE_CASE:
        return 20;
    case ::nds::core::speech::GrammaticalCase::INESSIVE_CASE:
        return 21;
    case ::nds::core::speech::GrammaticalCase::INSTRUCTIVE_CASE:
        return 22;
    case ::nds::core::speech::GrammaticalCase::INSTRUMENTAL_CASE:
        return 23;
    case ::nds::core::speech::GrammaticalCase::LOCATIVE_CASE:
        return 24;
    case ::nds::core::speech::GrammaticalCase::MODAL_CASE:
        return 25;
    case ::nds::core::speech::GrammaticalCase::MULTIPLICATIVE_CASE:
        return 26;
    case ::nds::core::speech::GrammaticalCase::NOMINATIVE_CASE:
        return 27;
    case ::nds::core::speech::GrammaticalCase::OBLIQUE_CASE:
        return 28;
    case ::nds::core::speech::GrammaticalCase::PARTITIVE_CASE:
        return 29;
    case ::nds::core::speech::GrammaticalCase::PERLATIVE_CASE:
        return 30;
    case ::nds::core::speech::GrammaticalCase::POSSESSIVE_CASE:
        return 31;
    case ::nds::core::speech::GrammaticalCase::POSTPOSITIONAL_CASE:
        return 32;
    case ::nds::core::speech::GrammaticalCase::PREPOSITIONAL_CASE:
        return 33;
    case ::nds::core::speech::GrammaticalCase::PROLATIVE_CASE:
        return 34;
    case ::nds::core::speech::GrammaticalCase::SUBLATIVE_CASE:
        return 35;
    case ::nds::core::speech::GrammaticalCase::SUPERESSIVE_CASE:
        return 36;
    case ::nds::core::speech::GrammaticalCase::TEMPORAL_CASE:
        return 37;
    case ::nds::core::speech::GrammaticalCase::TERMINATIVE_CASE:
        return 38;
    case ::nds::core::speech::GrammaticalCase::TRANSLATIVE_CASE:
        return 39;
    case ::nds::core::speech::GrammaticalCase::VOCATIVE_CASE:
        return 40;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration GrammaticalCase: ") <<
                static_cast<typename ::std::underlying_type<::nds::core::speech::GrammaticalCase>::type>(value) << "!";
    }
}

template <>
::nds::core::speech::GrammaticalCase valueToEnum(
        typename ::std::underlying_type<::nds::core::speech::GrammaticalCase>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
    case UINT8_C(3):
    case UINT8_C(4):
    case UINT8_C(5):
    case UINT8_C(6):
    case UINT8_C(7):
    case UINT8_C(8):
    case UINT8_C(9):
    case UINT8_C(10):
    case UINT8_C(11):
    case UINT8_C(12):
    case UINT8_C(13):
    case UINT8_C(14):
    case UINT8_C(15):
    case UINT8_C(16):
    case UINT8_C(17):
    case UINT8_C(18):
    case UINT8_C(19):
    case UINT8_C(20):
    case UINT8_C(21):
    case UINT8_C(22):
    case UINT8_C(23):
    case UINT8_C(24):
    case UINT8_C(25):
    case UINT8_C(26):
    case UINT8_C(27):
    case UINT8_C(28):
    case UINT8_C(29):
    case UINT8_C(30):
    case UINT8_C(31):
    case UINT8_C(32):
    case UINT8_C(33):
    case UINT8_C(34):
    case UINT8_C(35):
    case UINT8_C(36):
    case UINT8_C(37):
    case UINT8_C(38):
    case UINT8_C(39):
    case UINT8_C(40):
        return static_cast<::nds::core::speech::GrammaticalCase>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration GrammaticalCase: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::core::speech::GrammaticalCase>(::nds::core::speech::GrammaticalCase value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::core::speech::GrammaticalCase value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::core::speech::GrammaticalCase>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::core::speech::GrammaticalCase)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::core::speech::GrammaticalCase value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::core::speech::GrammaticalCase>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::core::speech::GrammaticalCase value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::core::speech::GrammaticalCase value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::core::speech::GrammaticalCase read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::core::speech::GrammaticalCase>(
            static_cast<typename ::std::underlying_type<::nds::core::speech::GrammaticalCase>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::core::speech::GrammaticalCase read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::core::speech::GrammaticalCase>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::core::speech::GrammaticalCase>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::core::speech::GrammaticalCase value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::core::speech::GrammaticalCase value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::core::speech::GrammaticalCase>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/core/speech/PhoneticPrefixUsageType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for PhoneticPrefixUsageType enumeration.
constexpr ::std::array<const char*, 2> EnumTraits<::nds::core::speech::PhoneticPrefixUsageType>::names;
constexpr ::std::array<::nds::core::speech::PhoneticPrefixUsageType, 2> EnumTraits<::nds::core::speech::PhoneticPrefixUsageType>::values;
constexpr const char* EnumTraits<::nds::core::speech::PhoneticPrefixUsageType>::enumName;

template <>
size_t enumToOrdinal(::nds::core::speech::PhoneticPrefixUsageType value)
{
    switch (value)
    {
    case ::nds::core::speech::PhoneticPrefixUsageType::INTO:
        return 0;
    case ::nds::core::speech::PhoneticPrefixUsageType::FOLLOW:
        return 1;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration PhoneticPrefixUsageType: ") <<
                static_cast<typename ::std::underlying_type<::nds::core::speech::PhoneticPrefixUsageType>::type>(value) << "!";
    }
}

template <>
::nds::core::speech::PhoneticPrefixUsageType valueToEnum(
        typename ::std::underlying_type<::nds::core::speech::PhoneticPrefixUsageType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
        return static_cast<::nds::core::speech::PhoneticPrefixUsageType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration PhoneticPrefixUsageType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::core::speech::PhoneticPrefixUsageType>(::nds::core::speech::PhoneticPrefixUsageType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::core::speech::PhoneticPrefixUsageType value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::core::speech::PhoneticPrefixUsageType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::core::speech::PhoneticPrefixUsageType)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::core::speech::PhoneticPrefixUsageType value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::core::speech::PhoneticPrefixUsageType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::core::speech::PhoneticPrefixUsageType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::core::speech::PhoneticPrefixUsageType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::core::speech::PhoneticPrefixUsageType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::core::speech::PhoneticPrefixUsageType>(
            static_cast<typename ::std::underlying_type<::nds::core::speech::PhoneticPrefixUsageType>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::core::speech::PhoneticPrefixUsageType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::core::speech::PhoneticPrefixUsageType>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::core::speech::PhoneticPrefixUsageType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::core::speech::PhoneticPrefixUsageType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::core::speech::PhoneticPrefixUsageType value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::core::speech::PhoneticPrefixUsageType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/core/speech/SpeechType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for SpeechType enumeration.
constexpr ::std::array<const char*, 7> EnumTraits<::nds::core::speech::SpeechType>::names;
constexpr ::std::array<::nds::core::speech::SpeechType, 7> EnumTraits<::nds::core::speech::SpeechType>::values;
constexpr const char* EnumTraits<::nds::core::speech::SpeechType>::enumName;

template <>
size_t enumToOrdinal(::nds::core::speech::SpeechType value)
{
    switch (value)
    {
    case ::nds::core::speech::SpeechType::NOT_AVAILABLE:
        return 0;
    case ::nds::core::speech::SpeechType::FIRST_APPROPRIATE:
        return 1;
    case ::nds::core::speech::SpeechType::STANDARD:
        return 2;
    case ::nds::core::speech::SpeechType::FLUENT:
        return 3;
    case ::nds::core::speech::SpeechType::FOREIGN:
        return 4;
    case ::nds::core::speech::SpeechType::LOCAL:
        return 5;
    case ::nds::core::speech::SpeechType::LITERAL:
        return 6;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration SpeechType: ") <<
                static_cast<typename ::std::underlying_type<::nds::core::speech::SpeechType>::type>(value) << "!";
    }
}

template <>
::nds::core::speech::SpeechType valueToEnum(
        typename ::std::underlying_type<::nds::core::speech::SpeechType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
    case UINT8_C(3):
    case UINT8_C(4):
    case UINT8_C(5):
    case UINT8_C(6):
        return static_cast<::nds::core::speech::SpeechType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration SpeechType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::core::speech::SpeechType>(::nds::core::speech::SpeechType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::core::speech::SpeechType value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::core::speech::SpeechType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::core::speech::SpeechType)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::core::speech::SpeechType value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::core::speech::SpeechType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::core::speech::SpeechType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::core::speech::SpeechType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::core::speech::SpeechType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::core::speech::SpeechType>(
            static_cast<typename ::std::underlying_type<::nds::core::speech::SpeechType>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::core::speech::SpeechType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::core::speech::SpeechType>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::core::speech::SpeechType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::core::speech::SpeechType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::core::speech::SpeechType value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::core::speech::SpeechType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/core/speech/PhoneticTranscriptionList.h>

namespace nds
{
namespace core
{
namespace speech
{

PhoneticTranscriptionList::PhoneticTranscriptionList(const allocator_type& allocator) noexcept :
        m_format_(::nds::core::speech::PhoneticTranscriptionFormat()),
        m_transcriptions_(allocator)
{
}

PhoneticTranscriptionList::PhoneticTranscriptionList(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_format_(readFormat(in)),
        m_transcriptions_(readTranscriptions(in, allocator))
{
}

PhoneticTranscriptionList::PhoneticTranscriptionList(PhoneticTranscriptionList::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_format_(readFormat(context, in)),
        m_transcriptions_(readTranscriptions(context, in, allocator))
{
}

PhoneticTranscriptionList::PhoneticTranscriptionList(::zserio::PropagateAllocatorT,
        const PhoneticTranscriptionList& other, const allocator_type& allocator) :
        m_format_(::zserio::allocatorPropagatingCopy(other.m_format_, allocator)),
        m_transcriptions_(::zserio::allocatorPropagatingCopy(other.m_transcriptions_, allocator))
{
}

::nds::core::speech::PhoneticTranscriptionFormat PhoneticTranscriptionList::getFormat() const
{
    return m_format_;
}

void PhoneticTranscriptionList::setFormat(::nds::core::speech::PhoneticTranscriptionFormat format_)
{
    m_format_ = format_;
}

::zserio::vector<::nds::core::speech::PhoneticTranscription>& PhoneticTranscriptionList::getTranscriptions()
{
    return m_transcriptions_.getRawArray();
}

const ::zserio::vector<::nds::core::speech::PhoneticTranscription>& PhoneticTranscriptionList::getTranscriptions() const
{
    return m_transcriptions_.getRawArray();
}

void PhoneticTranscriptionList::setTranscriptions(const ::zserio::vector<::nds::core::speech::PhoneticTranscription>& transcriptions_)
{
    m_transcriptions_ = ZserioArrayType_transcriptions(transcriptions_);
}

void PhoneticTranscriptionList::setTranscriptions(::zserio::vector<::nds::core::speech::PhoneticTranscription>&& transcriptions_)
{
    m_transcriptions_ = ZserioArrayType_transcriptions(std::move(transcriptions_));
}

void PhoneticTranscriptionList::initPackingContext(PhoneticTranscriptionList::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getFormat(), m_format_);
}

size_t PhoneticTranscriptionList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_format_);
    endBitPosition += m_transcriptions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t PhoneticTranscriptionList::bitSizeOf(PhoneticTranscriptionList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getFormat(), m_format_);
    endBitPosition += m_transcriptions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t PhoneticTranscriptionList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_format_);
    endBitPosition = m_transcriptions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t PhoneticTranscriptionList::initializeOffsets(PhoneticTranscriptionList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getFormat(), endBitPosition,
        m_format_);
    endBitPosition = m_transcriptions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool PhoneticTranscriptionList::operator==(const PhoneticTranscriptionList& other) const
{
    if (this != &other)
    {
        return
                (m_format_ == other.m_format_) &&
                (m_transcriptions_ == other.m_transcriptions_);
    }

    return true;
}

uint32_t PhoneticTranscriptionList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_format_);
    result = ::zserio::calcHashCode(result, m_transcriptions_);

    return result;
}

void PhoneticTranscriptionList::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_format_);
    m_transcriptions_.writePacked(*this, out);
}

void PhoneticTranscriptionList::write(PhoneticTranscriptionList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getFormat(), out, m_format_);
    m_transcriptions_.writePacked(*this, out);
}

void PhoneticTranscriptionList::ZserioElementFactory_transcriptions::create(PhoneticTranscriptionList&        ,
        ::zserio::vector<::nds::core::speech::PhoneticTranscription>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void PhoneticTranscriptionList::ZserioElementFactory_transcriptions::create(PhoneticTranscriptionList&        ,
        ::zserio::vector<::nds::core::speech::PhoneticTranscription>& array,
        ::nds::core::speech::PhoneticTranscription::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::core::speech::PhoneticTranscriptionFormat PhoneticTranscriptionList::readFormat(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::core::speech::PhoneticTranscriptionFormat>(in);
}

::nds::core::speech::PhoneticTranscriptionFormat PhoneticTranscriptionList::readFormat(PhoneticTranscriptionList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::core::speech::PhoneticTranscriptionFormat>(context.getFormat(), in);
}
PhoneticTranscriptionList::ZserioArrayType_transcriptions PhoneticTranscriptionList::readTranscriptions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_transcriptions readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}

PhoneticTranscriptionList::ZserioArrayType_transcriptions PhoneticTranscriptionList::readTranscriptions(PhoneticTranscriptionList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_transcriptions readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}

} // namespace speech
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/core/speech/PhoneticTranscription.h>

namespace nds
{
namespace core
{
namespace speech
{

PhoneticTranscription::PhoneticTranscription(const allocator_type& allocator) noexcept :
        m_grammaticalCase_(::zserio::NullOpt),
        m_phoneticTranscriptionString_(allocator),
        m_prefix_(::zserio::NullOpt)
{
}

PhoneticTranscription::PhoneticTranscription(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_grammaticalCase_(readGrammaticalCase(in, allocator)),
        m_phoneticTranscriptionString_(readPhoneticTranscriptionString(in, allocator)),
        m_prefix_(readPrefix(in, allocator))
{
}

PhoneticTranscription::PhoneticTranscription(PhoneticTranscription::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_grammaticalCase_(readGrammaticalCase(context, in, allocator)),
        m_phoneticTranscriptionString_(readPhoneticTranscriptionString(in, allocator)),
        m_prefix_(readPrefix(context, in, allocator))
{
}

PhoneticTranscription::PhoneticTranscription(::zserio::PropagateAllocatorT,
        const PhoneticTranscription& other, const allocator_type& allocator) :
        m_grammaticalCase_(::zserio::allocatorPropagatingCopy(other.m_grammaticalCase_, allocator)),
        m_phoneticTranscriptionString_(::zserio::allocatorPropagatingCopy(other.m_phoneticTranscriptionString_, allocator)),
        m_prefix_(::zserio::allocatorPropagatingCopy(other.m_prefix_, allocator))
{
}

::zserio::vector<::nds::core::speech::GrammaticalCase>& PhoneticTranscription::getGrammaticalCase()
{
    return m_grammaticalCase_.value().getRawArray();
}

const ::zserio::vector<::nds::core::speech::GrammaticalCase>& PhoneticTranscription::getGrammaticalCase() const
{
    return m_grammaticalCase_.value().getRawArray();
}

void PhoneticTranscription::setGrammaticalCase(const ::zserio::vector<::nds::core::speech::GrammaticalCase>& grammaticalCase_)
{
    m_grammaticalCase_ = ZserioArrayType_grammaticalCase(grammaticalCase_);
}

void PhoneticTranscription::setGrammaticalCase(::zserio::vector<::nds::core::speech::GrammaticalCase>&& grammaticalCase_)
{
    m_grammaticalCase_ = ZserioArrayType_grammaticalCase(std::move(grammaticalCase_));
}

bool PhoneticTranscription::isGrammaticalCaseUsed() const
{
    return (isGrammaticalCaseSet());
}

bool PhoneticTranscription::isGrammaticalCaseSet() const
{
    return m_grammaticalCase_.hasValue();
}

void PhoneticTranscription::resetGrammaticalCase()
{
    m_grammaticalCase_.reset();
}

::zserio::string<>& PhoneticTranscription::getPhoneticTranscriptionString()
{
    return m_phoneticTranscriptionString_;
}

const ::zserio::string<>& PhoneticTranscription::getPhoneticTranscriptionString() const
{
    return m_phoneticTranscriptionString_;
}

void PhoneticTranscription::setPhoneticTranscriptionString(const ::zserio::string<>& phoneticTranscriptionString_)
{
    m_phoneticTranscriptionString_ = phoneticTranscriptionString_;
}

void PhoneticTranscription::setPhoneticTranscriptionString(::zserio::string<>&& phoneticTranscriptionString_)
{
    m_phoneticTranscriptionString_ = ::std::move(phoneticTranscriptionString_);
}

::nds::core::speech::PhoneticPrefix& PhoneticTranscription::getPrefix()
{
    return m_prefix_.value();
}

const ::nds::core::speech::PhoneticPrefix& PhoneticTranscription::getPrefix() const
{
    return m_prefix_.value();
}

void PhoneticTranscription::setPrefix(const ::nds::core::speech::PhoneticPrefix& prefix_)
{
    m_prefix_ = prefix_;
}

void PhoneticTranscription::setPrefix(::nds::core::speech::PhoneticPrefix&& prefix_)
{
    m_prefix_ = ::std::move(prefix_);
}

bool PhoneticTranscription::isPrefixUsed() const
{
    return (isPrefixSet());
}

bool PhoneticTranscription::isPrefixSet() const
{
    return m_prefix_.hasValue();
}

void PhoneticTranscription::resetPrefix()
{
    m_prefix_.reset();
}

void PhoneticTranscription::initPackingContext(PhoneticTranscription::ZserioPackingContext& context) const
{
    if (isPrefixSet())
    {
        m_prefix_.value().initPackingContext(context.getPrefix());
    }
}

size_t PhoneticTranscription::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += 1;
    if (isGrammaticalCaseSet())
    {
        endBitPosition += m_grammaticalCase_.value().bitSizeOfPacked(endBitPosition);
    }
    endBitPosition += ::zserio::bitSizeOfString(m_phoneticTranscriptionString_);
    endBitPosition += 1;
    if (isPrefixSet())
    {
        endBitPosition += m_prefix_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t PhoneticTranscription::bitSizeOf(PhoneticTranscription::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += 1;
    if (isGrammaticalCaseSet())
    {
        endBitPosition += m_grammaticalCase_.value().bitSizeOfPacked(endBitPosition);
    }
    endBitPosition += ::zserio::bitSizeOfString(m_phoneticTranscriptionString_);
    endBitPosition += 1;
    if (isPrefixSet())
    {
        endBitPosition += m_prefix_.value().bitSizeOf(context.getPrefix(), endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t PhoneticTranscription::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += 1;
    if (isGrammaticalCaseSet())
    {
        endBitPosition = m_grammaticalCase_.value().initializeOffsetsPacked(endBitPosition);
    }
    endBitPosition += ::zserio::bitSizeOfString(m_phoneticTranscriptionString_);
    endBitPosition += 1;
    if (isPrefixSet())
    {
        endBitPosition = m_prefix_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

size_t PhoneticTranscription::initializeOffsets(PhoneticTranscription::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += 1;
    if (isGrammaticalCaseSet())
    {
        endBitPosition = m_grammaticalCase_.value().initializeOffsetsPacked(endBitPosition);
    }
    endBitPosition += ::zserio::bitSizeOfString(m_phoneticTranscriptionString_);
    endBitPosition += 1;
    if (isPrefixSet())
    {
        endBitPosition = m_prefix_.value().initializeOffsets(context.getPrefix(), endBitPosition);
    }

    return endBitPosition;
}

bool PhoneticTranscription::operator==(const PhoneticTranscription& other) const
{
    if (this != &other)
    {
        return
                (!isGrammaticalCaseUsed() ? !other.isGrammaticalCaseUsed() : (m_grammaticalCase_ == other.m_grammaticalCase_)) &&
                (m_phoneticTranscriptionString_ == other.m_phoneticTranscriptionString_) &&
                (!isPrefixUsed() ? !other.isPrefixUsed() : (m_prefix_ == other.m_prefix_));
    }

    return true;
}

uint32_t PhoneticTranscription::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    if (isGrammaticalCaseUsed())
        result = ::zserio::calcHashCode(result, m_grammaticalCase_);
    result = ::zserio::calcHashCode(result, m_phoneticTranscriptionString_);
    if (isPrefixUsed())
        result = ::zserio::calcHashCode(result, m_prefix_);

    return result;
}

void PhoneticTranscription::write(::zserio::BitStreamWriter& out) const
{
    if (isGrammaticalCaseSet())
    {
        out.writeBool(true);
        m_grammaticalCase_.value().writePacked(out);
    }
    else
    {
        out.writeBool(false);
    }
    out.writeString(m_phoneticTranscriptionString_);
    if (isPrefixSet())
    {
        out.writeBool(true);
        m_prefix_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
}

void PhoneticTranscription::write(PhoneticTranscription::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    if (isGrammaticalCaseSet())
    {
        out.writeBool(true);
        m_grammaticalCase_.value().writePacked(out);
    }
    else
    {
        out.writeBool(false);
    }
    out.writeString(m_phoneticTranscriptionString_);
    if (isPrefixSet())
    {
        out.writeBool(true);
        m_prefix_.value().write(context.getPrefix(), out);
    }
    else
    {
        out.writeBool(false);
    }
}

::zserio::InplaceOptionalHolder<PhoneticTranscription::ZserioArrayType_grammaticalCase> PhoneticTranscription::readGrammaticalCase(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        ZserioArrayType_grammaticalCase readField(allocator);
        readField.readPacked(in);

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_grammaticalCase>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_grammaticalCase>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<PhoneticTranscription::ZserioArrayType_grammaticalCase> PhoneticTranscription::readGrammaticalCase(PhoneticTranscription::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        ZserioArrayType_grammaticalCase readField(allocator);
        readField.readPacked(in);

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_grammaticalCase>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_grammaticalCase>(::zserio::NullOpt);
}
::zserio::string<> PhoneticTranscription::readPhoneticTranscriptionString(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return static_cast<::zserio::string<>>(in.readString(allocator));
}
::zserio::InplaceOptionalHolder<::nds::core::speech::PhoneticPrefix> PhoneticTranscription::readPrefix(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::speech::PhoneticPrefix>(::nds::core::speech::PhoneticPrefix(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::speech::PhoneticPrefix>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::speech::PhoneticPrefix> PhoneticTranscription::readPrefix(PhoneticTranscription::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::speech::PhoneticPrefix>(::nds::core::speech::PhoneticPrefix(context.getPrefix(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::speech::PhoneticPrefix>(::zserio::NullOpt);
}

} // namespace speech
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/core/speech/PhoneticPrefix.h>

namespace nds
{
namespace core
{
namespace speech
{

PhoneticPrefix::PhoneticPrefix(const allocator_type& allocator) noexcept :
        m_usageType_(::nds::core::speech::PhoneticPrefixUsageType()),
        m_prefixString_(allocator)
{
}

PhoneticPrefix::PhoneticPrefix(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_usageType_(readUsageType(in)),
        m_prefixString_(readPrefixString(in, allocator))
{
}

PhoneticPrefix::PhoneticPrefix(PhoneticPrefix::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_usageType_(readUsageType(context, in)),
        m_prefixString_(readPrefixString(in, allocator))
{
}

PhoneticPrefix::PhoneticPrefix(::zserio::PropagateAllocatorT,
        const PhoneticPrefix& other, const allocator_type& allocator) :
        m_usageType_(::zserio::allocatorPropagatingCopy(other.m_usageType_, allocator)),
        m_prefixString_(::zserio::allocatorPropagatingCopy(other.m_prefixString_, allocator))
{
}

::nds::core::speech::PhoneticPrefixUsageType PhoneticPrefix::getUsageType() const
{
    return m_usageType_;
}

void PhoneticPrefix::setUsageType(::nds::core::speech::PhoneticPrefixUsageType usageType_)
{
    m_usageType_ = usageType_;
}

::zserio::string<>& PhoneticPrefix::getPrefixString()
{
    return m_prefixString_;
}

const ::zserio::string<>& PhoneticPrefix::getPrefixString() const
{
    return m_prefixString_;
}

void PhoneticPrefix::setPrefixString(const ::zserio::string<>& prefixString_)
{
    m_prefixString_ = prefixString_;
}

void PhoneticPrefix::setPrefixString(::zserio::string<>&& prefixString_)
{
    m_prefixString_ = ::std::move(prefixString_);
}

void PhoneticPrefix::initPackingContext(PhoneticPrefix::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getUsageType(), m_usageType_);
}

size_t PhoneticPrefix::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_usageType_);
    endBitPosition += ::zserio::bitSizeOfString(m_prefixString_);

    return endBitPosition - bitPosition;
}

size_t PhoneticPrefix::bitSizeOf(PhoneticPrefix::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getUsageType(), m_usageType_);
    endBitPosition += ::zserio::bitSizeOfString(m_prefixString_);

    return endBitPosition - bitPosition;
}

size_t PhoneticPrefix::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_usageType_);
    endBitPosition += ::zserio::bitSizeOfString(m_prefixString_);

    return endBitPosition;
}

size_t PhoneticPrefix::initializeOffsets(PhoneticPrefix::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getUsageType(), endBitPosition,
        m_usageType_);
    endBitPosition += ::zserio::bitSizeOfString(m_prefixString_);

    return endBitPosition;
}

bool PhoneticPrefix::operator==(const PhoneticPrefix& other) const
{
    if (this != &other)
    {
        return
                (m_usageType_ == other.m_usageType_) &&
                (m_prefixString_ == other.m_prefixString_);
    }

    return true;
}

uint32_t PhoneticPrefix::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_usageType_);
    result = ::zserio::calcHashCode(result, m_prefixString_);

    return result;
}

void PhoneticPrefix::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_usageType_);
    out.writeString(m_prefixString_);
}

void PhoneticPrefix::write(PhoneticPrefix::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getUsageType(), out, m_usageType_);
    out.writeString(m_prefixString_);
}

::nds::core::speech::PhoneticPrefixUsageType PhoneticPrefix::readUsageType(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::core::speech::PhoneticPrefixUsageType>(in);
}

::nds::core::speech::PhoneticPrefixUsageType PhoneticPrefix::readUsageType(PhoneticPrefix::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::core::speech::PhoneticPrefixUsageType>(context.getUsageType(), in);
}
::zserio::string<> PhoneticPrefix::readPrefixString(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return static_cast<::zserio::string<>>(in.readString(allocator));
}

} // namespace speech
} // namespace core
} // namespace nds
