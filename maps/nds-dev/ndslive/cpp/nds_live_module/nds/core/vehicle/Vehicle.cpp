/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/core/vehicle/AdrTunnelRestriction.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for AdrTunnelRestriction enumeration.
constexpr ::std::array<const char*, 5> EnumTraits<::nds::core::vehicle::AdrTunnelRestriction>::names;
constexpr ::std::array<::nds::core::vehicle::AdrTunnelRestriction, 5> EnumTraits<::nds::core::vehicle::AdrTunnelRestriction>::values;
constexpr const char* EnumTraits<::nds::core::vehicle::AdrTunnelRestriction>::enumName;

template <>
size_t enumToOrdinal(::nds::core::vehicle::AdrTunnelRestriction value)
{
    switch (value)
    {
    case ::nds::core::vehicle::AdrTunnelRestriction::NONE:
        return 0;
    case ::nds::core::vehicle::AdrTunnelRestriction::B:
        return 1;
    case ::nds::core::vehicle::AdrTunnelRestriction::C:
        return 2;
    case ::nds::core::vehicle::AdrTunnelRestriction::D:
        return 3;
    case ::nds::core::vehicle::AdrTunnelRestriction::E:
        return 4;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration AdrTunnelRestriction: ") <<
                static_cast<typename ::std::underlying_type<::nds::core::vehicle::AdrTunnelRestriction>::type>(value) << "!";
    }
}

template <>
::nds::core::vehicle::AdrTunnelRestriction valueToEnum(
        typename ::std::underlying_type<::nds::core::vehicle::AdrTunnelRestriction>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
    case UINT8_C(3):
    case UINT8_C(4):
        return static_cast<::nds::core::vehicle::AdrTunnelRestriction>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration AdrTunnelRestriction: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::core::vehicle::AdrTunnelRestriction>(::nds::core::vehicle::AdrTunnelRestriction value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::core::vehicle::AdrTunnelRestriction value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::core::vehicle::AdrTunnelRestriction>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::core::vehicle::AdrTunnelRestriction)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::core::vehicle::AdrTunnelRestriction value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::core::vehicle::AdrTunnelRestriction>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::core::vehicle::AdrTunnelRestriction value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::core::vehicle::AdrTunnelRestriction value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::core::vehicle::AdrTunnelRestriction read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::core::vehicle::AdrTunnelRestriction>(
            static_cast<typename ::std::underlying_type<::nds::core::vehicle::AdrTunnelRestriction>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::core::vehicle::AdrTunnelRestriction read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::core::vehicle::AdrTunnelRestriction>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::core::vehicle::AdrTunnelRestriction>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::core::vehicle::AdrTunnelRestriction value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::core::vehicle::AdrTunnelRestriction value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::core::vehicle::AdrTunnelRestriction>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/HashCodeUtil.h>
#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/core/vehicle/FrequentlyUsedVehicleTypes.h>

namespace nds
{
namespace core
{
namespace vehicle
{

FrequentlyUsedVehicleTypes::FrequentlyUsedVehicleTypes(::zserio::BitStreamReader& in) :
        m_value(readValue(in))
{}

FrequentlyUsedVehicleTypes::FrequentlyUsedVehicleTypes(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in) :
        m_value(readValue(context, in))
{}

FrequentlyUsedVehicleTypes::FrequentlyUsedVehicleTypes(underlying_type value) :
        m_value(value)
{
    if (m_value > UINT32_C(536870911))
        throw ::zserio::CppRuntimeException("Value for bitmask 'FrequentlyUsedVehicleTypes' out of bounds: ") << value << "!";
}

void FrequentlyUsedVehicleTypes::initPackingContext(::zserio::DeltaContext& context) const
{
    context.init<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::FrequentlyUsedVehicleTypes::underlying_type>>(m_value);
}

size_t FrequentlyUsedVehicleTypes::bitSizeOf(size_t) const
{
    return ::zserio::bitSizeOfVarUInt32(m_value);
}

size_t FrequentlyUsedVehicleTypes::bitSizeOf(::zserio::DeltaContext& context, size_t) const
{
    return context.bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::FrequentlyUsedVehicleTypes::underlying_type>>(m_value);
}

size_t FrequentlyUsedVehicleTypes::initializeOffsets(size_t bitPosition) const
{
    return bitPosition + bitSizeOf(bitPosition);
}

size_t FrequentlyUsedVehicleTypes::initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition) const
{
    return bitPosition + bitSizeOf(context, bitPosition);
}

uint32_t FrequentlyUsedVehicleTypes::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, m_value);
    return result;
}

void FrequentlyUsedVehicleTypes::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt32(m_value);
}

void FrequentlyUsedVehicleTypes::write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out) const
{
    context.write<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::FrequentlyUsedVehicleTypes::underlying_type>>(out, m_value);
}

::zserio::string<> FrequentlyUsedVehicleTypes::toString(const ::zserio::string<>::allocator_type& allocator) const
{
    ::zserio::string<> result(allocator);
    if ((*this & FrequentlyUsedVehicleTypes::Values::MOTORIZED_VEHICLE) == FrequentlyUsedVehicleTypes::Values::MOTORIZED_VEHICLE)
        result += result.empty() ? "MOTORIZED_VEHICLE" : " | MOTORIZED_VEHICLE";
    if ((*this & FrequentlyUsedVehicleTypes::Values::PERSONAL_CAR) == FrequentlyUsedVehicleTypes::Values::PERSONAL_CAR)
        result += result.empty() ? "PERSONAL_CAR" : " | PERSONAL_CAR";
    if ((*this & FrequentlyUsedVehicleTypes::Values::TRUCK) == FrequentlyUsedVehicleTypes::Values::TRUCK)
        result += result.empty() ? "TRUCK" : " | TRUCK";
    if ((*this & FrequentlyUsedVehicleTypes::Values::MOTORCYCLE) == FrequentlyUsedVehicleTypes::Values::MOTORCYCLE)
        result += result.empty() ? "MOTORCYCLE" : " | MOTORCYCLE";
    if ((*this & FrequentlyUsedVehicleTypes::Values::BUS) == FrequentlyUsedVehicleTypes::Values::BUS)
        result += result.empty() ? "BUS" : " | BUS";
    if ((*this & FrequentlyUsedVehicleTypes::Values::NOT_LIGHT_MOTORIZED_VEHICLE) == FrequentlyUsedVehicleTypes::Values::NOT_LIGHT_MOTORIZED_VEHICLE)
        result += result.empty() ? "NOT_LIGHT_MOTORIZED_VEHICLE" : " | NOT_LIGHT_MOTORIZED_VEHICLE";
    if ((*this & FrequentlyUsedVehicleTypes::Values::COMMERCIAL_VEHICLE) == FrequentlyUsedVehicleTypes::Values::COMMERCIAL_VEHICLE)
        result += result.empty() ? "COMMERCIAL_VEHICLE" : " | COMMERCIAL_VEHICLE";

    return ::zserio::toString<::zserio::string<>::allocator_type>(m_value, allocator) + "[" + result + "]";
}

FrequentlyUsedVehicleTypes::underlying_type FrequentlyUsedVehicleTypes::readValue(::zserio::BitStreamReader& in)
{
    return static_cast<underlying_type>(in.readVarUInt32());
}

FrequentlyUsedVehicleTypes::underlying_type FrequentlyUsedVehicleTypes::readValue(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return context.read<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::FrequentlyUsedVehicleTypes::underlying_type>>(
            in);
}

} // namespace vehicle
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/HashCodeUtil.h>
#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/core/vehicle/BigVehicleTypes.h>

namespace nds
{
namespace core
{
namespace vehicle
{

BigVehicleTypes::BigVehicleTypes(::zserio::BitStreamReader& in) :
        m_value(readValue(in))
{}

BigVehicleTypes::BigVehicleTypes(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in) :
        m_value(readValue(context, in))
{}

BigVehicleTypes::BigVehicleTypes(underlying_type value) :
        m_value(value)
{
    if (m_value > UINT32_C(536870911))
        throw ::zserio::CppRuntimeException("Value for bitmask 'BigVehicleTypes' out of bounds: ") << value << "!";
}

void BigVehicleTypes::initPackingContext(::zserio::DeltaContext& context) const
{
    context.init<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::BigVehicleTypes::underlying_type>>(m_value);
}

size_t BigVehicleTypes::bitSizeOf(size_t) const
{
    return ::zserio::bitSizeOfVarUInt32(m_value);
}

size_t BigVehicleTypes::bitSizeOf(::zserio::DeltaContext& context, size_t) const
{
    return context.bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::BigVehicleTypes::underlying_type>>(m_value);
}

size_t BigVehicleTypes::initializeOffsets(size_t bitPosition) const
{
    return bitPosition + bitSizeOf(bitPosition);
}

size_t BigVehicleTypes::initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition) const
{
    return bitPosition + bitSizeOf(context, bitPosition);
}

uint32_t BigVehicleTypes::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, m_value);
    return result;
}

void BigVehicleTypes::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt32(m_value);
}

void BigVehicleTypes::write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out) const
{
    context.write<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::BigVehicleTypes::underlying_type>>(out, m_value);
}

::zserio::string<> BigVehicleTypes::toString(const ::zserio::string<>::allocator_type& allocator) const
{
    ::zserio::string<> result(allocator);
    if ((*this & BigVehicleTypes::Values::MINIVAN) == BigVehicleTypes::Values::MINIVAN)
        result += result.empty() ? "MINIVAN" : " | MINIVAN";
    if ((*this & BigVehicleTypes::Values::ONE_BOX_TYPE_VEHICLE) == BigVehicleTypes::Values::ONE_BOX_TYPE_VEHICLE)
        result += result.empty() ? "ONE_BOX_TYPE_VEHICLE" : " | ONE_BOX_TYPE_VEHICLE";
    if ((*this & BigVehicleTypes::Values::LIGHT_TRUCK) == BigVehicleTypes::Values::LIGHT_TRUCK)
        result += result.empty() ? "LIGHT_TRUCK" : " | LIGHT_TRUCK";
    if ((*this & BigVehicleTypes::Values::NORMAL_TRUCK) == BigVehicleTypes::Values::NORMAL_TRUCK)
        result += result.empty() ? "NORMAL_TRUCK" : " | NORMAL_TRUCK";
    if ((*this & BigVehicleTypes::Values::TANK_TRUCK) == BigVehicleTypes::Values::TANK_TRUCK)
        result += result.empty() ? "TANK_TRUCK" : " | TANK_TRUCK";
    if ((*this & BigVehicleTypes::Values::RECREATION_VEHICLE) == BigVehicleTypes::Values::RECREATION_VEHICLE)
        result += result.empty() ? "RECREATION_VEHICLE" : " | RECREATION_VEHICLE";

    return ::zserio::toString<::zserio::string<>::allocator_type>(m_value, allocator) + "[" + result + "]";
}

BigVehicleTypes::underlying_type BigVehicleTypes::readValue(::zserio::BitStreamReader& in)
{
    return static_cast<underlying_type>(in.readVarUInt32());
}

BigVehicleTypes::underlying_type BigVehicleTypes::readValue(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return context.read<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::BigVehicleTypes::underlying_type>>(
            in);
}

} // namespace vehicle
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/HashCodeUtil.h>
#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/core/vehicle/PublicServiceVehicleTypes.h>

namespace nds
{
namespace core
{
namespace vehicle
{

PublicServiceVehicleTypes::PublicServiceVehicleTypes(::zserio::BitStreamReader& in) :
        m_value(readValue(in))
{}

PublicServiceVehicleTypes::PublicServiceVehicleTypes(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in) :
        m_value(readValue(context, in))
{}

PublicServiceVehicleTypes::PublicServiceVehicleTypes(underlying_type value) :
        m_value(value)
{
    if (m_value > UINT32_C(536870911))
        throw ::zserio::CppRuntimeException("Value for bitmask 'PublicServiceVehicleTypes' out of bounds: ") << value << "!";
}

void PublicServiceVehicleTypes::initPackingContext(::zserio::DeltaContext& context) const
{
    context.init<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::PublicServiceVehicleTypes::underlying_type>>(m_value);
}

size_t PublicServiceVehicleTypes::bitSizeOf(size_t) const
{
    return ::zserio::bitSizeOfVarUInt32(m_value);
}

size_t PublicServiceVehicleTypes::bitSizeOf(::zserio::DeltaContext& context, size_t) const
{
    return context.bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::PublicServiceVehicleTypes::underlying_type>>(m_value);
}

size_t PublicServiceVehicleTypes::initializeOffsets(size_t bitPosition) const
{
    return bitPosition + bitSizeOf(bitPosition);
}

size_t PublicServiceVehicleTypes::initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition) const
{
    return bitPosition + bitSizeOf(context, bitPosition);
}

uint32_t PublicServiceVehicleTypes::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, m_value);
    return result;
}

void PublicServiceVehicleTypes::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt32(m_value);
}

void PublicServiceVehicleTypes::write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out) const
{
    context.write<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::PublicServiceVehicleTypes::underlying_type>>(out, m_value);
}

::zserio::string<> PublicServiceVehicleTypes::toString(const ::zserio::string<>::allocator_type& allocator) const
{
    ::zserio::string<> result(allocator);
    if ((*this & PublicServiceVehicleTypes::Values::PUBLIC_BUS) == PublicServiceVehicleTypes::Values::PUBLIC_BUS)
        result += result.empty() ? "PUBLIC_BUS" : " | PUBLIC_BUS";
    if ((*this & PublicServiceVehicleTypes::Values::SCHOOL_BUS) == PublicServiceVehicleTypes::Values::SCHOOL_BUS)
        result += result.empty() ? "SCHOOL_BUS" : " | SCHOOL_BUS";
    if ((*this & PublicServiceVehicleTypes::Values::TROLLEY) == PublicServiceVehicleTypes::Values::TROLLEY)
        result += result.empty() ? "TROLLEY" : " | TROLLEY";
    if ((*this & PublicServiceVehicleTypes::Values::TRAM) == PublicServiceVehicleTypes::Values::TRAM)
        result += result.empty() ? "TRAM" : " | TRAM";
    if ((*this & PublicServiceVehicleTypes::Values::TAXI) == PublicServiceVehicleTypes::Values::TAXI)
        result += result.empty() ? "TAXI" : " | TAXI";
    if ((*this & PublicServiceVehicleTypes::Values::EMERGENCY) == PublicServiceVehicleTypes::Values::EMERGENCY)
        result += result.empty() ? "EMERGENCY" : " | EMERGENCY";
    if ((*this & PublicServiceVehicleTypes::Values::MAIL) == PublicServiceVehicleTypes::Values::MAIL)
        result += result.empty() ? "MAIL" : " | MAIL";

    return ::zserio::toString<::zserio::string<>::allocator_type>(m_value, allocator) + "[" + result + "]";
}

PublicServiceVehicleTypes::underlying_type PublicServiceVehicleTypes::readValue(::zserio::BitStreamReader& in)
{
    return static_cast<underlying_type>(in.readVarUInt32());
}

PublicServiceVehicleTypes::underlying_type PublicServiceVehicleTypes::readValue(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return context.read<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::PublicServiceVehicleTypes::underlying_type>>(
            in);
}

} // namespace vehicle
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/HashCodeUtil.h>
#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/core/vehicle/PublicBusType.h>

namespace nds
{
namespace core
{
namespace vehicle
{

PublicBusType::PublicBusType(::zserio::BitStreamReader& in) :
        m_value(readValue(in))
{}

PublicBusType::PublicBusType(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in) :
        m_value(readValue(context, in))
{}

PublicBusType::PublicBusType(underlying_type value) :
        m_value(value)
{
    if (m_value > UINT32_C(536870911))
        throw ::zserio::CppRuntimeException("Value for bitmask 'PublicBusType' out of bounds: ") << value << "!";
}

void PublicBusType::initPackingContext(::zserio::DeltaContext& context) const
{
    context.init<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::PublicBusType::underlying_type>>(m_value);
}

size_t PublicBusType::bitSizeOf(size_t) const
{
    return ::zserio::bitSizeOfVarUInt32(m_value);
}

size_t PublicBusType::bitSizeOf(::zserio::DeltaContext& context, size_t) const
{
    return context.bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::PublicBusType::underlying_type>>(m_value);
}

size_t PublicBusType::initializeOffsets(size_t bitPosition) const
{
    return bitPosition + bitSizeOf(bitPosition);
}

size_t PublicBusType::initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition) const
{
    return bitPosition + bitSizeOf(context, bitPosition);
}

uint32_t PublicBusType::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, m_value);
    return result;
}

void PublicBusType::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt32(m_value);
}

void PublicBusType::write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out) const
{
    context.write<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::PublicBusType::underlying_type>>(out, m_value);
}

::zserio::string<> PublicBusType::toString(const ::zserio::string<>::allocator_type& allocator) const
{
    ::zserio::string<> result(allocator);
    if ((*this & PublicBusType::Values::ARTICULATED_BUS) == PublicBusType::Values::ARTICULATED_BUS)
        result += result.empty() ? "ARTICULATED_BUS" : " | ARTICULATED_BUS";
    if ((*this & PublicBusType::Values::BUS_WITH_STANDING_PASSENGERS) == PublicBusType::Values::BUS_WITH_STANDING_PASSENGERS)
        result += result.empty() ? "BUS_WITH_STANDING_PASSENGERS" : " | BUS_WITH_STANDING_PASSENGERS";
    if ((*this & PublicBusType::Values::HIGHSPEED_BUS) == PublicBusType::Values::HIGHSPEED_BUS)
        result += result.empty() ? "HIGHSPEED_BUS" : " | HIGHSPEED_BUS";

    return ::zserio::toString<::zserio::string<>::allocator_type>(m_value, allocator) + "[" + result + "]";
}

PublicBusType::underlying_type PublicBusType::readValue(::zserio::BitStreamReader& in)
{
    return static_cast<underlying_type>(in.readVarUInt32());
}

PublicBusType::underlying_type PublicBusType::readValue(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return context.read<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::PublicBusType::underlying_type>>(
            in);
}

} // namespace vehicle
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/HashCodeUtil.h>
#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/core/vehicle/SlowRoadUserTypes.h>

namespace nds
{
namespace core
{
namespace vehicle
{

SlowRoadUserTypes::SlowRoadUserTypes(::zserio::BitStreamReader& in) :
        m_value(readValue(in))
{}

SlowRoadUserTypes::SlowRoadUserTypes(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in) :
        m_value(readValue(context, in))
{}

SlowRoadUserTypes::SlowRoadUserTypes(underlying_type value) :
        m_value(value)
{
    if (m_value > UINT32_C(536870911))
        throw ::zserio::CppRuntimeException("Value for bitmask 'SlowRoadUserTypes' out of bounds: ") << value << "!";
}

void SlowRoadUserTypes::initPackingContext(::zserio::DeltaContext& context) const
{
    context.init<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::SlowRoadUserTypes::underlying_type>>(m_value);
}

size_t SlowRoadUserTypes::bitSizeOf(size_t) const
{
    return ::zserio::bitSizeOfVarUInt32(m_value);
}

size_t SlowRoadUserTypes::bitSizeOf(::zserio::DeltaContext& context, size_t) const
{
    return context.bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::SlowRoadUserTypes::underlying_type>>(m_value);
}

size_t SlowRoadUserTypes::initializeOffsets(size_t bitPosition) const
{
    return bitPosition + bitSizeOf(bitPosition);
}

size_t SlowRoadUserTypes::initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition) const
{
    return bitPosition + bitSizeOf(context, bitPosition);
}

uint32_t SlowRoadUserTypes::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, m_value);
    return result;
}

void SlowRoadUserTypes::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt32(m_value);
}

void SlowRoadUserTypes::write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out) const
{
    context.write<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::SlowRoadUserTypes::underlying_type>>(out, m_value);
}

::zserio::string<> SlowRoadUserTypes::toString(const ::zserio::string<>::allocator_type& allocator) const
{
    ::zserio::string<> result(allocator);
    if ((*this & SlowRoadUserTypes::Values::PEDESTRIAN) == SlowRoadUserTypes::Values::PEDESTRIAN)
        result += result.empty() ? "PEDESTRIAN" : " | PEDESTRIAN";
    if ((*this & SlowRoadUserTypes::Values::PEDESTRIAN_WITH_HANDCART) == SlowRoadUserTypes::Values::PEDESTRIAN_WITH_HANDCART)
        result += result.empty() ? "PEDESTRIAN_WITH_HANDCART" : " | PEDESTRIAN_WITH_HANDCART";
    if ((*this & SlowRoadUserTypes::Values::HORSE_DRIVEN_CARRIAGE) == SlowRoadUserTypes::Values::HORSE_DRIVEN_CARRIAGE)
        result += result.empty() ? "HORSE_DRIVEN_CARRIAGE" : " | HORSE_DRIVEN_CARRIAGE";
    if ((*this & SlowRoadUserTypes::Values::BICYCLE) == SlowRoadUserTypes::Values::BICYCLE)
        result += result.empty() ? "BICYCLE" : " | BICYCLE";
    if ((*this & SlowRoadUserTypes::Values::SCOOTER) == SlowRoadUserTypes::Values::SCOOTER)
        result += result.empty() ? "SCOOTER" : " | SCOOTER";
    if ((*this & SlowRoadUserTypes::Values::MOTORIZED_RICKSHAW) == SlowRoadUserTypes::Values::MOTORIZED_RICKSHAW)
        result += result.empty() ? "MOTORIZED_RICKSHAW" : " | MOTORIZED_RICKSHAW";
    if ((*this & SlowRoadUserTypes::Values::MOPED) == SlowRoadUserTypes::Values::MOPED)
        result += result.empty() ? "MOPED" : " | MOPED";
    if ((*this & SlowRoadUserTypes::Values::RIDER) == SlowRoadUserTypes::Values::RIDER)
        result += result.empty() ? "RIDER" : " | RIDER";
    if ((*this & SlowRoadUserTypes::Values::TRACTOR) == SlowRoadUserTypes::Values::TRACTOR)
        result += result.empty() ? "TRACTOR" : " | TRACTOR";

    return ::zserio::toString<::zserio::string<>::allocator_type>(m_value, allocator) + "[" + result + "]";
}

SlowRoadUserTypes::underlying_type SlowRoadUserTypes::readValue(::zserio::BitStreamReader& in)
{
    return static_cast<underlying_type>(in.readVarUInt32());
}

SlowRoadUserTypes::underlying_type SlowRoadUserTypes::readValue(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return context.read<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::SlowRoadUserTypes::underlying_type>>(
            in);
}

} // namespace vehicle
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/HashCodeUtil.h>
#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/core/vehicle/EmergencyMilitaryDetailTypes.h>

namespace nds
{
namespace core
{
namespace vehicle
{

EmergencyMilitaryDetailTypes::EmergencyMilitaryDetailTypes(::zserio::BitStreamReader& in) :
        m_value(readValue(in))
{}

EmergencyMilitaryDetailTypes::EmergencyMilitaryDetailTypes(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in) :
        m_value(readValue(context, in))
{}

EmergencyMilitaryDetailTypes::EmergencyMilitaryDetailTypes(underlying_type value) :
        m_value(value)
{
    if (m_value > UINT32_C(536870911))
        throw ::zserio::CppRuntimeException("Value for bitmask 'EmergencyMilitaryDetailTypes' out of bounds: ") << value << "!";
}

void EmergencyMilitaryDetailTypes::initPackingContext(::zserio::DeltaContext& context) const
{
    context.init<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::EmergencyMilitaryDetailTypes::underlying_type>>(m_value);
}

size_t EmergencyMilitaryDetailTypes::bitSizeOf(size_t) const
{
    return ::zserio::bitSizeOfVarUInt32(m_value);
}

size_t EmergencyMilitaryDetailTypes::bitSizeOf(::zserio::DeltaContext& context, size_t) const
{
    return context.bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::EmergencyMilitaryDetailTypes::underlying_type>>(m_value);
}

size_t EmergencyMilitaryDetailTypes::initializeOffsets(size_t bitPosition) const
{
    return bitPosition + bitSizeOf(bitPosition);
}

size_t EmergencyMilitaryDetailTypes::initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition) const
{
    return bitPosition + bitSizeOf(context, bitPosition);
}

uint32_t EmergencyMilitaryDetailTypes::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, m_value);
    return result;
}

void EmergencyMilitaryDetailTypes::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt32(m_value);
}

void EmergencyMilitaryDetailTypes::write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out) const
{
    context.write<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::EmergencyMilitaryDetailTypes::underlying_type>>(out, m_value);
}

::zserio::string<> EmergencyMilitaryDetailTypes::toString(const ::zserio::string<>::allocator_type& allocator) const
{
    ::zserio::string<> result(allocator);
    if ((*this & EmergencyMilitaryDetailTypes::Values::POLICE) == EmergencyMilitaryDetailTypes::Values::POLICE)
        result += result.empty() ? "POLICE" : " | POLICE";
    if ((*this & EmergencyMilitaryDetailTypes::Values::FIRE_DEPARTMENT) == EmergencyMilitaryDetailTypes::Values::FIRE_DEPARTMENT)
        result += result.empty() ? "FIRE_DEPARTMENT" : " | FIRE_DEPARTMENT";
    if ((*this & EmergencyMilitaryDetailTypes::Values::AMBULANCE) == EmergencyMilitaryDetailTypes::Values::AMBULANCE)
        result += result.empty() ? "AMBULANCE" : " | AMBULANCE";
    if ((*this & EmergencyMilitaryDetailTypes::Values::MILITARY_PERSONAL_CAR) == EmergencyMilitaryDetailTypes::Values::MILITARY_PERSONAL_CAR)
        result += result.empty() ? "MILITARY_PERSONAL_CAR" : " | MILITARY_PERSONAL_CAR";
    if ((*this & EmergencyMilitaryDetailTypes::Values::MILITARY_TRUCK) == EmergencyMilitaryDetailTypes::Values::MILITARY_TRUCK)
        result += result.empty() ? "MILITARY_TRUCK" : " | MILITARY_TRUCK";
    if ((*this & EmergencyMilitaryDetailTypes::Values::MILITARY_TANK) == EmergencyMilitaryDetailTypes::Values::MILITARY_TANK)
        result += result.empty() ? "MILITARY_TANK" : " | MILITARY_TANK";

    return ::zserio::toString<::zserio::string<>::allocator_type>(m_value, allocator) + "[" + result + "]";
}

EmergencyMilitaryDetailTypes::underlying_type EmergencyMilitaryDetailTypes::readValue(::zserio::BitStreamReader& in)
{
    return static_cast<underlying_type>(in.readVarUInt32());
}

EmergencyMilitaryDetailTypes::underlying_type EmergencyMilitaryDetailTypes::readValue(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return context.read<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::EmergencyMilitaryDetailTypes::underlying_type>>(
            in);
}

} // namespace vehicle
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/HashCodeUtil.h>
#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/core/vehicle/Authorization.h>

namespace nds
{
namespace core
{
namespace vehicle
{

Authorization::Authorization(::zserio::BitStreamReader& in) :
        m_value(readValue(in))
{}

Authorization::Authorization(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in) :
        m_value(readValue(context, in))
{}

Authorization::Authorization(underlying_type value) :
        m_value(value)
{
    if (m_value > UINT32_C(536870911))
        throw ::zserio::CppRuntimeException("Value for bitmask 'Authorization' out of bounds: ") << value << "!";
}

void Authorization::initPackingContext(::zserio::DeltaContext& context) const
{
    context.init<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::Authorization::underlying_type>>(m_value);
}

size_t Authorization::bitSizeOf(size_t) const
{
    return ::zserio::bitSizeOfVarUInt32(m_value);
}

size_t Authorization::bitSizeOf(::zserio::DeltaContext& context, size_t) const
{
    return context.bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::Authorization::underlying_type>>(m_value);
}

size_t Authorization::initializeOffsets(size_t bitPosition) const
{
    return bitPosition + bitSizeOf(bitPosition);
}

size_t Authorization::initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition) const
{
    return bitPosition + bitSizeOf(context, bitPosition);
}

uint32_t Authorization::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, m_value);
    return result;
}

void Authorization::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt32(m_value);
}

void Authorization::write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out) const
{
    context.write<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::Authorization::underlying_type>>(out, m_value);
}

::zserio::string<> Authorization::toString(const ::zserio::string<>::allocator_type& allocator) const
{
    ::zserio::string<> result(allocator);
    if ((*this & Authorization::Values::RESIDENTIAL) == Authorization::Values::RESIDENTIAL)
        result += result.empty() ? "RESIDENTIAL" : " | RESIDENTIAL";
    if ((*this & Authorization::Values::AGRICULTURAL) == Authorization::Values::AGRICULTURAL)
        result += result.empty() ? "AGRICULTURAL" : " | AGRICULTURAL";
    if ((*this & Authorization::Values::FORESTRY) == Authorization::Values::FORESTRY)
        result += result.empty() ? "FORESTRY" : " | FORESTRY";
    if ((*this & Authorization::Values::MILITARY) == Authorization::Values::MILITARY)
        result += result.empty() ? "MILITARY" : " | MILITARY";
    if ((*this & Authorization::Values::FACILITY) == Authorization::Values::FACILITY)
        result += result.empty() ? "FACILITY" : " | FACILITY";
    if ((*this & Authorization::Values::EMPLOYEES) == Authorization::Values::EMPLOYEES)
        result += result.empty() ? "EMPLOYEES" : " | EMPLOYEES";
    if ((*this & Authorization::Values::DELIVERY) == Authorization::Values::DELIVERY)
        result += result.empty() ? "DELIVERY" : " | DELIVERY";
    if ((*this & Authorization::Values::DISABLED_PERSONS) == Authorization::Values::DISABLED_PERSONS)
        result += result.empty() ? "DISABLED_PERSONS" : " | DISABLED_PERSONS";
    if ((*this & Authorization::Values::SPECIAL_AUTHORIZATION) == Authorization::Values::SPECIAL_AUTHORIZATION)
        result += result.empty() ? "SPECIAL_AUTHORIZATION" : " | SPECIAL_AUTHORIZATION";
    if ((*this & Authorization::Values::FOREIGN_VEHICLE) == Authorization::Values::FOREIGN_VEHICLE)
        result += result.empty() ? "FOREIGN_VEHICLE" : " | FOREIGN_VEHICLE";
    if ((*this & Authorization::Values::LOCAL_VEHICLE) == Authorization::Values::LOCAL_VEHICLE)
        result += result.empty() ? "LOCAL_VEHICLE" : " | LOCAL_VEHICLE";
    if ((*this & Authorization::Values::FEE_PAID) == Authorization::Values::FEE_PAID)
        result += result.empty() ? "FEE_PAID" : " | FEE_PAID";
    if ((*this & Authorization::Values::REGISTERED_LICENSE_PLATE) == Authorization::Values::REGISTERED_LICENSE_PLATE)
        result += result.empty() ? "REGISTERED_LICENSE_PLATE" : " | REGISTERED_LICENSE_PLATE";

    return ::zserio::toString<::zserio::string<>::allocator_type>(m_value, allocator) + "[" + result + "]";
}

Authorization::underlying_type Authorization::readValue(::zserio::BitStreamReader& in)
{
    return static_cast<underlying_type>(in.readVarUInt32());
}

Authorization::underlying_type Authorization::readValue(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return context.read<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::Authorization::underlying_type>>(
            in);
}

} // namespace vehicle
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/HashCodeUtil.h>
#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/core/vehicle/EnergyType.h>

namespace nds
{
namespace core
{
namespace vehicle
{

EnergyType::EnergyType(::zserio::BitStreamReader& in) :
        m_value(readValue(in))
{}

EnergyType::EnergyType(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in) :
        m_value(readValue(context, in))
{}

EnergyType::EnergyType(underlying_type value) :
        m_value(value)
{
    if (m_value > UINT32_C(536870911))
        throw ::zserio::CppRuntimeException("Value for bitmask 'EnergyType' out of bounds: ") << value << "!";
}

void EnergyType::initPackingContext(::zserio::DeltaContext& context) const
{
    context.init<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::EnergyType::underlying_type>>(m_value);
}

size_t EnergyType::bitSizeOf(size_t) const
{
    return ::zserio::bitSizeOfVarUInt32(m_value);
}

size_t EnergyType::bitSizeOf(::zserio::DeltaContext& context, size_t) const
{
    return context.bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::EnergyType::underlying_type>>(m_value);
}

size_t EnergyType::initializeOffsets(size_t bitPosition) const
{
    return bitPosition + bitSizeOf(bitPosition);
}

size_t EnergyType::initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition) const
{
    return bitPosition + bitSizeOf(context, bitPosition);
}

uint32_t EnergyType::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, m_value);
    return result;
}

void EnergyType::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt32(m_value);
}

void EnergyType::write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out) const
{
    context.write<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::EnergyType::underlying_type>>(out, m_value);
}

::zserio::string<> EnergyType::toString(const ::zserio::string<>::allocator_type& allocator) const
{
    ::zserio::string<> result(allocator);
    if ((*this & EnergyType::Values::BIO_DIESEL) == EnergyType::Values::BIO_DIESEL)
        result += result.empty() ? "BIO_DIESEL" : " | BIO_DIESEL";
    if ((*this & EnergyType::Values::CNG) == EnergyType::Values::CNG)
        result += result.empty() ? "CNG" : " | CNG";
    if ((*this & EnergyType::Values::DIESEL) == EnergyType::Values::DIESEL)
        result += result.empty() ? "DIESEL" : " | DIESEL";
    if ((*this & EnergyType::Values::DIESEL_COMMERCIAL) == EnergyType::Values::DIESEL_COMMERCIAL)
        result += result.empty() ? "DIESEL_COMMERCIAL" : " | DIESEL_COMMERCIAL";
    if ((*this & EnergyType::Values::E85) == EnergyType::Values::E85)
        result += result.empty() ? "E85" : " | E85";
    if ((*this & EnergyType::Values::ETHANOL) == EnergyType::Values::ETHANOL)
        result += result.empty() ? "ETHANOL" : " | ETHANOL";
    if ((*this & EnergyType::Values::GASOLINE) == EnergyType::Values::GASOLINE)
        result += result.empty() ? "GASOLINE" : " | GASOLINE";
    if ((*this & EnergyType::Values::HYDROGEN) == EnergyType::Values::HYDROGEN)
        result += result.empty() ? "HYDROGEN" : " | HYDROGEN";
    if ((*this & EnergyType::Values::LPG) == EnergyType::Values::LPG)
        result += result.empty() ? "LPG" : " | LPG";
    if ((*this & EnergyType::Values::ELECTRICITY) == EnergyType::Values::ELECTRICITY)
        result += result.empty() ? "ELECTRICITY" : " | ELECTRICITY";

    return ::zserio::toString<::zserio::string<>::allocator_type>(m_value, allocator) + "[" + result + "]";
}

EnergyType::underlying_type EnergyType::readValue(::zserio::BitStreamReader& in)
{
    return static_cast<underlying_type>(in.readVarUInt32());
}

EnergyType::underlying_type EnergyType::readValue(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return context.read<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::EnergyType::underlying_type>>(
            in);
}

} // namespace vehicle
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/HashCodeUtil.h>
#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/core/vehicle/VehicleEuroEmissionClass.h>

namespace nds
{
namespace core
{
namespace vehicle
{

VehicleEuroEmissionClass::VehicleEuroEmissionClass(::zserio::BitStreamReader& in) :
        m_value(readValue(in))
{}

VehicleEuroEmissionClass::VehicleEuroEmissionClass(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in) :
        m_value(readValue(context, in))
{}

VehicleEuroEmissionClass::VehicleEuroEmissionClass(underlying_type value) :
        m_value(value)
{
    if (m_value > UINT32_C(536870911))
        throw ::zserio::CppRuntimeException("Value for bitmask 'VehicleEuroEmissionClass' out of bounds: ") << value << "!";
}

void VehicleEuroEmissionClass::initPackingContext(::zserio::DeltaContext& context) const
{
    context.init<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::VehicleEuroEmissionClass::underlying_type>>(m_value);
}

size_t VehicleEuroEmissionClass::bitSizeOf(size_t) const
{
    return ::zserio::bitSizeOfVarUInt32(m_value);
}

size_t VehicleEuroEmissionClass::bitSizeOf(::zserio::DeltaContext& context, size_t) const
{
    return context.bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::VehicleEuroEmissionClass::underlying_type>>(m_value);
}

size_t VehicleEuroEmissionClass::initializeOffsets(size_t bitPosition) const
{
    return bitPosition + bitSizeOf(bitPosition);
}

size_t VehicleEuroEmissionClass::initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition) const
{
    return bitPosition + bitSizeOf(context, bitPosition);
}

uint32_t VehicleEuroEmissionClass::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, m_value);
    return result;
}

void VehicleEuroEmissionClass::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt32(m_value);
}

void VehicleEuroEmissionClass::write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out) const
{
    context.write<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::VehicleEuroEmissionClass::underlying_type>>(out, m_value);
}

::zserio::string<> VehicleEuroEmissionClass::toString(const ::zserio::string<>::allocator_type& allocator) const
{
    ::zserio::string<> result(allocator);
    if ((*this & VehicleEuroEmissionClass::Values::EURO_1) == VehicleEuroEmissionClass::Values::EURO_1)
        result += result.empty() ? "EURO_1" : " | EURO_1";
    if ((*this & VehicleEuroEmissionClass::Values::EURO_2) == VehicleEuroEmissionClass::Values::EURO_2)
        result += result.empty() ? "EURO_2" : " | EURO_2";
    if ((*this & VehicleEuroEmissionClass::Values::EURO_3) == VehicleEuroEmissionClass::Values::EURO_3)
        result += result.empty() ? "EURO_3" : " | EURO_3";
    if ((*this & VehicleEuroEmissionClass::Values::EURO_4) == VehicleEuroEmissionClass::Values::EURO_4)
        result += result.empty() ? "EURO_4" : " | EURO_4";
    if ((*this & VehicleEuroEmissionClass::Values::EURO_5) == VehicleEuroEmissionClass::Values::EURO_5)
        result += result.empty() ? "EURO_5" : " | EURO_5";
    if ((*this & VehicleEuroEmissionClass::Values::EURO_5A) == VehicleEuroEmissionClass::Values::EURO_5A)
        result += result.empty() ? "EURO_5A" : " | EURO_5A";
    if ((*this & VehicleEuroEmissionClass::Values::EURO_5B) == VehicleEuroEmissionClass::Values::EURO_5B)
        result += result.empty() ? "EURO_5B" : " | EURO_5B";
    if ((*this & VehicleEuroEmissionClass::Values::EURO_6B) == VehicleEuroEmissionClass::Values::EURO_6B)
        result += result.empty() ? "EURO_6B" : " | EURO_6B";
    if ((*this & VehicleEuroEmissionClass::Values::EURO_6C) == VehicleEuroEmissionClass::Values::EURO_6C)
        result += result.empty() ? "EURO_6C" : " | EURO_6C";
    if ((*this & VehicleEuroEmissionClass::Values::EURO_6D_TEMP) == VehicleEuroEmissionClass::Values::EURO_6D_TEMP)
        result += result.empty() ? "EURO_6D_TEMP" : " | EURO_6D_TEMP";
    if ((*this & VehicleEuroEmissionClass::Values::EURO_6D) == VehicleEuroEmissionClass::Values::EURO_6D)
        result += result.empty() ? "EURO_6D" : " | EURO_6D";
    if ((*this & VehicleEuroEmissionClass::Values::EURO_7) == VehicleEuroEmissionClass::Values::EURO_7)
        result += result.empty() ? "EURO_7" : " | EURO_7";
    if ((*this & VehicleEuroEmissionClass::Values::EURO_0) == VehicleEuroEmissionClass::Values::EURO_0)
        result += result.empty() ? "EURO_0" : " | EURO_0";
    if ((*this & VehicleEuroEmissionClass::Values::EURO_I) == VehicleEuroEmissionClass::Values::EURO_I)
        result += result.empty() ? "EURO_I" : " | EURO_I";
    if ((*this & VehicleEuroEmissionClass::Values::EURO_II) == VehicleEuroEmissionClass::Values::EURO_II)
        result += result.empty() ? "EURO_II" : " | EURO_II";
    if ((*this & VehicleEuroEmissionClass::Values::EURO_III) == VehicleEuroEmissionClass::Values::EURO_III)
        result += result.empty() ? "EURO_III" : " | EURO_III";
    if ((*this & VehicleEuroEmissionClass::Values::EURO_IV) == VehicleEuroEmissionClass::Values::EURO_IV)
        result += result.empty() ? "EURO_IV" : " | EURO_IV";
    if ((*this & VehicleEuroEmissionClass::Values::EURO_V) == VehicleEuroEmissionClass::Values::EURO_V)
        result += result.empty() ? "EURO_V" : " | EURO_V";
    if ((*this & VehicleEuroEmissionClass::Values::EURO_VI) == VehicleEuroEmissionClass::Values::EURO_VI)
        result += result.empty() ? "EURO_VI" : " | EURO_VI";

    return ::zserio::toString<::zserio::string<>::allocator_type>(m_value, allocator) + "[" + result + "]";
}

VehicleEuroEmissionClass::underlying_type VehicleEuroEmissionClass::readValue(::zserio::BitStreamReader& in)
{
    return static_cast<underlying_type>(in.readVarUInt32());
}

VehicleEuroEmissionClass::underlying_type VehicleEuroEmissionClass::readValue(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return context.read<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::VehicleEuroEmissionClass::underlying_type>>(
            in);
}

} // namespace vehicle
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/HashCodeUtil.h>
#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/core/vehicle/Equipment.h>

namespace nds
{
namespace core
{
namespace vehicle
{

Equipment::Equipment(::zserio::BitStreamReader& in) :
        m_value(readValue(in))
{}

Equipment::Equipment(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in) :
        m_value(readValue(context, in))
{}

Equipment::Equipment(underlying_type value) :
        m_value(value)
{
    if (m_value > UINT32_C(536870911))
        throw ::zserio::CppRuntimeException("Value for bitmask 'Equipment' out of bounds: ") << value << "!";
}

void Equipment::initPackingContext(::zserio::DeltaContext& context) const
{
    context.init<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::Equipment::underlying_type>>(m_value);
}

size_t Equipment::bitSizeOf(size_t) const
{
    return ::zserio::bitSizeOfVarUInt32(m_value);
}

size_t Equipment::bitSizeOf(::zserio::DeltaContext& context, size_t) const
{
    return context.bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::Equipment::underlying_type>>(m_value);
}

size_t Equipment::initializeOffsets(size_t bitPosition) const
{
    return bitPosition + bitSizeOf(bitPosition);
}

size_t Equipment::initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition) const
{
    return bitPosition + bitSizeOf(context, bitPosition);
}

uint32_t Equipment::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, m_value);
    return result;
}

void Equipment::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt32(m_value);
}

void Equipment::write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out) const
{
    context.write<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::Equipment::underlying_type>>(out, m_value);
}

::zserio::string<> Equipment::toString(const ::zserio::string<>::allocator_type& allocator) const
{
    ::zserio::string<> result(allocator);
    if ((*this & Equipment::Values::TRAILER) == Equipment::Values::TRAILER)
        result += result.empty() ? "TRAILER" : " | TRAILER";
    if ((*this & Equipment::Values::CARAVAN) == Equipment::Values::CARAVAN)
        result += result.empty() ? "CARAVAN" : " | CARAVAN";
    if ((*this & Equipment::Values::SEMI_TRAILER) == Equipment::Values::SEMI_TRAILER)
        result += result.empty() ? "SEMI_TRAILER" : " | SEMI_TRAILER";
    if ((*this & Equipment::Values::SNOW_CHAINS) == Equipment::Values::SNOW_CHAINS)
        result += result.empty() ? "SNOW_CHAINS" : " | SNOW_CHAINS";
    if ((*this & Equipment::Values::FOUR_WHEEL_DRIVE) == Equipment::Values::FOUR_WHEEL_DRIVE)
        result += result.empty() ? "FOUR_WHEEL_DRIVE" : " | FOUR_WHEEL_DRIVE";
    if ((*this & Equipment::Values::PARTICULATE_FILTER) == Equipment::Values::PARTICULATE_FILTER)
        result += result.empty() ? "PARTICULATE_FILTER" : " | PARTICULATE_FILTER";

    return ::zserio::toString<::zserio::string<>::allocator_type>(m_value, allocator) + "[" + result + "]";
}

Equipment::underlying_type Equipment::readValue(::zserio::BitStreamReader& in)
{
    return static_cast<underlying_type>(in.readVarUInt32());
}

Equipment::underlying_type Equipment::readValue(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return context.read<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::Equipment::underlying_type>>(
            in);
}

} // namespace vehicle
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/HashCodeUtil.h>
#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/core/vehicle/LoadType.h>

namespace nds
{
namespace core
{
namespace vehicle
{

LoadType::LoadType(::zserio::BitStreamReader& in) :
        m_value(readValue(in))
{}

LoadType::LoadType(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in) :
        m_value(readValue(context, in))
{}

LoadType::LoadType(underlying_type value) :
        m_value(value)
{
    if (m_value > UINT32_C(536870911))
        throw ::zserio::CppRuntimeException("Value for bitmask 'LoadType' out of bounds: ") << value << "!";
}

void LoadType::initPackingContext(::zserio::DeltaContext& context) const
{
    context.init<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::LoadType::underlying_type>>(m_value);
}

size_t LoadType::bitSizeOf(size_t) const
{
    return ::zserio::bitSizeOfVarUInt32(m_value);
}

size_t LoadType::bitSizeOf(::zserio::DeltaContext& context, size_t) const
{
    return context.bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::LoadType::underlying_type>>(m_value);
}

size_t LoadType::initializeOffsets(size_t bitPosition) const
{
    return bitPosition + bitSizeOf(bitPosition);
}

size_t LoadType::initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition) const
{
    return bitPosition + bitSizeOf(context, bitPosition);
}

uint32_t LoadType::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, m_value);
    return result;
}

void LoadType::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt32(m_value);
}

void LoadType::write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out) const
{
    context.write<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::LoadType::underlying_type>>(out, m_value);
}

::zserio::string<> LoadType::toString(const ::zserio::string<>::allocator_type& allocator) const
{
    ::zserio::string<> result(allocator);
    if ((*this & LoadType::Values::WATER_POLLUTING) == LoadType::Values::WATER_POLLUTING)
        result += result.empty() ? "WATER_POLLUTING" : " | WATER_POLLUTING";
    if ((*this & LoadType::Values::EXPLOSIVE) == LoadType::Values::EXPLOSIVE)
        result += result.empty() ? "EXPLOSIVE" : " | EXPLOSIVE";
    if ((*this & LoadType::Values::OTHER_DANGEROUS_GOODS) == LoadType::Values::OTHER_DANGEROUS_GOODS)
        result += result.empty() ? "OTHER_DANGEROUS_GOODS" : " | OTHER_DANGEROUS_GOODS";
    if ((*this & LoadType::Values::NO_LOAD) == LoadType::Values::NO_LOAD)
        result += result.empty() ? "NO_LOAD" : " | NO_LOAD";
    if ((*this & LoadType::Values::SPECIAL_LOAD) == LoadType::Values::SPECIAL_LOAD)
        result += result.empty() ? "SPECIAL_LOAD" : " | SPECIAL_LOAD";
    if ((*this & LoadType::Values::GAS) == LoadType::Values::GAS)
        result += result.empty() ? "GAS" : " | GAS";
    if ((*this & LoadType::Values::FLAMMABLE_LIQUIDS) == LoadType::Values::FLAMMABLE_LIQUIDS)
        result += result.empty() ? "FLAMMABLE_LIQUIDS" : " | FLAMMABLE_LIQUIDS";
    if ((*this & LoadType::Values::FLAMMABLE_SOLIDS) == LoadType::Values::FLAMMABLE_SOLIDS)
        result += result.empty() ? "FLAMMABLE_SOLIDS" : " | FLAMMABLE_SOLIDS";
    if ((*this & LoadType::Values::OXIDIZERS_AND_ORGANIC_PEROXIDES) == LoadType::Values::OXIDIZERS_AND_ORGANIC_PEROXIDES)
        result += result.empty() ? "OXIDIZERS_AND_ORGANIC_PEROXIDES" : " | OXIDIZERS_AND_ORGANIC_PEROXIDES";
    if ((*this & LoadType::Values::TOXIC_AND_INFECTIOUS_SUBSTANCES) == LoadType::Values::TOXIC_AND_INFECTIOUS_SUBSTANCES)
        result += result.empty() ? "TOXIC_AND_INFECTIOUS_SUBSTANCES" : " | TOXIC_AND_INFECTIOUS_SUBSTANCES";
    if ((*this & LoadType::Values::RADIOACTIVE_SUBSTANCES) == LoadType::Values::RADIOACTIVE_SUBSTANCES)
        result += result.empty() ? "RADIOACTIVE_SUBSTANCES" : " | RADIOACTIVE_SUBSTANCES";
    if ((*this & LoadType::Values::CORROSIVE_SUBSTANCES) == LoadType::Values::CORROSIVE_SUBSTANCES)
        result += result.empty() ? "CORROSIVE_SUBSTANCES" : " | CORROSIVE_SUBSTANCES";

    return ::zserio::toString<::zserio::string<>::allocator_type>(m_value, allocator) + "[" + result + "]";
}

LoadType::underlying_type LoadType::readValue(::zserio::BitStreamReader& in)
{
    return static_cast<underlying_type>(in.readVarUInt32());
}

LoadType::underlying_type LoadType::readValue(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return context.read<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::LoadType::underlying_type>>(
            in);
}

} // namespace vehicle
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/HashCodeUtil.h>
#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/core/vehicle/DriverAssistFunctions.h>

namespace nds
{
namespace core
{
namespace vehicle
{

DriverAssistFunctions::DriverAssistFunctions(::zserio::BitStreamReader& in) :
        m_value(readValue(in))
{}

DriverAssistFunctions::DriverAssistFunctions(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in) :
        m_value(readValue(context, in))
{}

DriverAssistFunctions::DriverAssistFunctions(underlying_type value) :
        m_value(value)
{
    if (m_value > UINT32_C(536870911))
        throw ::zserio::CppRuntimeException("Value for bitmask 'DriverAssistFunctions' out of bounds: ") << value << "!";
}

void DriverAssistFunctions::initPackingContext(::zserio::DeltaContext& context) const
{
    context.init<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::DriverAssistFunctions::underlying_type>>(m_value);
}

size_t DriverAssistFunctions::bitSizeOf(size_t) const
{
    return ::zserio::bitSizeOfVarUInt32(m_value);
}

size_t DriverAssistFunctions::bitSizeOf(::zserio::DeltaContext& context, size_t) const
{
    return context.bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::DriverAssistFunctions::underlying_type>>(m_value);
}

size_t DriverAssistFunctions::initializeOffsets(size_t bitPosition) const
{
    return bitPosition + bitSizeOf(bitPosition);
}

size_t DriverAssistFunctions::initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition) const
{
    return bitPosition + bitSizeOf(context, bitPosition);
}

uint32_t DriverAssistFunctions::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, m_value);
    return result;
}

void DriverAssistFunctions::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt32(m_value);
}

void DriverAssistFunctions::write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out) const
{
    context.write<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::DriverAssistFunctions::underlying_type>>(out, m_value);
}

::zserio::string<> DriverAssistFunctions::toString(const ::zserio::string<>::allocator_type& allocator) const
{
    ::zserio::string<> result(allocator);
    if ((*this & DriverAssistFunctions::Values::AUTONOMOUS_DRIVING_LEVEL_0) == DriverAssistFunctions::Values::AUTONOMOUS_DRIVING_LEVEL_0)
        result += result.empty() ? "AUTONOMOUS_DRIVING_LEVEL_0" : " | AUTONOMOUS_DRIVING_LEVEL_0";
    if ((*this & DriverAssistFunctions::Values::AUTONOMOUS_DRIVING_LEVEL_1) == DriverAssistFunctions::Values::AUTONOMOUS_DRIVING_LEVEL_1)
        result += result.empty() ? "AUTONOMOUS_DRIVING_LEVEL_1" : " | AUTONOMOUS_DRIVING_LEVEL_1";
    if ((*this & DriverAssistFunctions::Values::AUTONOMOUS_DRIVING_LEVEL_2) == DriverAssistFunctions::Values::AUTONOMOUS_DRIVING_LEVEL_2)
        result += result.empty() ? "AUTONOMOUS_DRIVING_LEVEL_2" : " | AUTONOMOUS_DRIVING_LEVEL_2";
    if ((*this & DriverAssistFunctions::Values::AUTONOMOUS_DRIVING_LEVEL_3) == DriverAssistFunctions::Values::AUTONOMOUS_DRIVING_LEVEL_3)
        result += result.empty() ? "AUTONOMOUS_DRIVING_LEVEL_3" : " | AUTONOMOUS_DRIVING_LEVEL_3";
    if ((*this & DriverAssistFunctions::Values::AUTONOMOUS_DRIVING_LEVEL_4) == DriverAssistFunctions::Values::AUTONOMOUS_DRIVING_LEVEL_4)
        result += result.empty() ? "AUTONOMOUS_DRIVING_LEVEL_4" : " | AUTONOMOUS_DRIVING_LEVEL_4";
    if ((*this & DriverAssistFunctions::Values::AUTONOMOUS_DRIVING_LEVEL_5) == DriverAssistFunctions::Values::AUTONOMOUS_DRIVING_LEVEL_5)
        result += result.empty() ? "AUTONOMOUS_DRIVING_LEVEL_5" : " | AUTONOMOUS_DRIVING_LEVEL_5";

    return ::zserio::toString<::zserio::string<>::allocator_type>(m_value, allocator) + "[" + result + "]";
}

DriverAssistFunctions::underlying_type DriverAssistFunctions::readValue(::zserio::BitStreamReader& in)
{
    return static_cast<underlying_type>(in.readVarUInt32());
}

DriverAssistFunctions::underlying_type DriverAssistFunctions::readValue(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return context.read<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::DriverAssistFunctions::underlying_type>>(
            in);
}

} // namespace vehicle
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/core/vehicle/VehicleDimensions.h>

namespace nds
{
namespace core
{
namespace vehicle
{

VehicleDimensions::VehicleDimensions(const allocator_type&) noexcept :
        m_length_(::nds::core::vehicle::VehicleLength()),
        m_width_(::nds::core::vehicle::VehicleWidth()),
        m_height_(::nds::core::vehicle::VehicleHeight()),
        m_weight_(::nds::core::vehicle::VehicleWeight())
{
}

VehicleDimensions::VehicleDimensions(::zserio::BitStreamReader& in, const allocator_type&) :
        m_length_(readLength(in)),
        m_width_(readWidth(in)),
        m_height_(readHeight(in)),
        m_weight_(readWeight(in))
{
}

VehicleDimensions::VehicleDimensions(VehicleDimensions::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type&) :
        m_length_(readLength(context, in)),
        m_width_(readWidth(context, in)),
        m_height_(readHeight(context, in)),
        m_weight_(readWeight(context, in))
{
}

VehicleDimensions::VehicleDimensions(::zserio::PropagateAllocatorT,
        const VehicleDimensions& other, const allocator_type& allocator) :
        m_length_(::zserio::allocatorPropagatingCopy(other.m_length_, allocator)),
        m_width_(::zserio::allocatorPropagatingCopy(other.m_width_, allocator)),
        m_height_(::zserio::allocatorPropagatingCopy(other.m_height_, allocator)),
        m_weight_(::zserio::allocatorPropagatingCopy(other.m_weight_, allocator))
{
}

::nds::core::vehicle::VehicleLength VehicleDimensions::getLength() const
{
    return m_length_;
}

void VehicleDimensions::setLength(::nds::core::vehicle::VehicleLength length_)
{
    m_length_ = length_;
}

::nds::core::vehicle::VehicleWidth VehicleDimensions::getWidth() const
{
    return m_width_;
}

void VehicleDimensions::setWidth(::nds::core::vehicle::VehicleWidth width_)
{
    m_width_ = width_;
}

::nds::core::vehicle::VehicleHeight VehicleDimensions::getHeight() const
{
    return m_height_;
}

void VehicleDimensions::setHeight(::nds::core::vehicle::VehicleHeight height_)
{
    m_height_ = height_;
}

::nds::core::vehicle::VehicleWeight VehicleDimensions::getWeight() const
{
    return m_weight_;
}

void VehicleDimensions::setWeight(::nds::core::vehicle::VehicleWeight weight_)
{
    m_weight_ = weight_;
}

void VehicleDimensions::initPackingContext(VehicleDimensions::ZserioPackingContext& context) const
{
    context.getLength().init<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::VehicleLength>>(m_length_);
    context.getWidth().init<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::VehicleWidth>>(m_width_);
    context.getHeight().init<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::VehicleHeight>>(m_height_);
    context.getWeight().init<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::VehicleWeight>>(m_weight_);
}

size_t VehicleDimensions::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_length_);
    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_width_);
    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_height_);
    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_weight_);

    return endBitPosition - bitPosition;
}

size_t VehicleDimensions::bitSizeOf(VehicleDimensions::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getLength().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::VehicleLength>>(m_length_);
    endBitPosition += context.getWidth().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::VehicleWidth>>(m_width_);
    endBitPosition += context.getHeight().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::VehicleHeight>>(m_height_);
    endBitPosition += context.getWeight().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::VehicleWeight>>(m_weight_);

    return endBitPosition - bitPosition;
}

size_t VehicleDimensions::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_length_);
    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_width_);
    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_height_);
    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_weight_);

    return endBitPosition;
}

size_t VehicleDimensions::initializeOffsets(VehicleDimensions::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getLength().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::VehicleLength>>(m_length_);
    endBitPosition += context.getWidth().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::VehicleWidth>>(m_width_);
    endBitPosition += context.getHeight().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::VehicleHeight>>(m_height_);
    endBitPosition += context.getWeight().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::VehicleWeight>>(m_weight_);

    return endBitPosition;
}

bool VehicleDimensions::operator==(const VehicleDimensions& other) const
{
    if (this != &other)
    {
        return
                (m_length_ == other.m_length_) &&
                (m_width_ == other.m_width_) &&
                (m_height_ == other.m_height_) &&
                (m_weight_ == other.m_weight_);
    }

    return true;
}

uint32_t VehicleDimensions::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_length_);
    result = ::zserio::calcHashCode(result, m_width_);
    result = ::zserio::calcHashCode(result, m_height_);
    result = ::zserio::calcHashCode(result, m_weight_);

    return result;
}

void VehicleDimensions::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt32(m_length_);
    out.writeVarUInt32(m_width_);
    out.writeVarUInt32(m_height_);
    out.writeVarUInt32(m_weight_);
}

void VehicleDimensions::write(VehicleDimensions::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getLength().write<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::VehicleLength>>(out, m_length_);
    context.getWidth().write<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::VehicleWidth>>(out, m_width_);
    context.getHeight().write<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::VehicleHeight>>(out, m_height_);
    context.getWeight().write<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::VehicleWeight>>(out, m_weight_);
}

::nds::core::vehicle::VehicleLength VehicleDimensions::readLength(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::vehicle::VehicleLength>(in.readVarUInt32());
}

::nds::core::vehicle::VehicleLength VehicleDimensions::readLength(VehicleDimensions::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getLength().read<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::VehicleLength>>(in);
}
::nds::core::vehicle::VehicleWidth VehicleDimensions::readWidth(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::vehicle::VehicleWidth>(in.readVarUInt32());
}

::nds::core::vehicle::VehicleWidth VehicleDimensions::readWidth(VehicleDimensions::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getWidth().read<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::VehicleWidth>>(in);
}
::nds::core::vehicle::VehicleHeight VehicleDimensions::readHeight(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::vehicle::VehicleHeight>(in.readVarUInt32());
}

::nds::core::vehicle::VehicleHeight VehicleDimensions::readHeight(VehicleDimensions::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getHeight().read<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::VehicleHeight>>(in);
}
::nds::core::vehicle::VehicleWeight VehicleDimensions::readWeight(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::vehicle::VehicleWeight>(in.readVarUInt32());
}

::nds::core::vehicle::VehicleWeight VehicleDimensions::readWeight(VehicleDimensions::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getWeight().read<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::VehicleWeight>>(in);
}

} // namespace vehicle
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/core/vehicle/PoseRaw.h>

namespace nds
{
namespace core
{
namespace vehicle
{

PoseRaw::PoseRaw(const allocator_type&) noexcept :
        m_longitude_(::nds::core::geometry::Longitude()),
        m_latitude_(::nds::core::geometry::Latitude()),
        m_elevation_(::zserio::NullOpt),
        m_heading_(::zserio::NullOpt),
        m_pitch_(::zserio::NullOpt),
        m_speed_(::zserio::NullOpt)
{
}

PoseRaw::PoseRaw(::zserio::BitStreamReader& in, const allocator_type&) :
        m_longitude_(readLongitude(in)),
        m_latitude_(readLatitude(in)),
        m_elevation_(readElevation(in)),
        m_heading_(readHeading(in)),
        m_pitch_(readPitch(in)),
        m_speed_(readSpeed(in))
{
}

PoseRaw::PoseRaw(PoseRaw::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type&) :
        m_longitude_(readLongitude(context, in)),
        m_latitude_(readLatitude(context, in)),
        m_elevation_(readElevation(context, in)),
        m_heading_(readHeading(context, in)),
        m_pitch_(readPitch(context, in)),
        m_speed_(readSpeed(context, in))
{
}

PoseRaw::PoseRaw(::zserio::PropagateAllocatorT,
        const PoseRaw& other, const allocator_type& allocator) :
        m_longitude_(::zserio::allocatorPropagatingCopy(other.m_longitude_, allocator)),
        m_latitude_(::zserio::allocatorPropagatingCopy(other.m_latitude_, allocator)),
        m_elevation_(::zserio::allocatorPropagatingCopy(other.m_elevation_, allocator)),
        m_heading_(::zserio::allocatorPropagatingCopy(other.m_heading_, allocator)),
        m_pitch_(::zserio::allocatorPropagatingCopy(other.m_pitch_, allocator)),
        m_speed_(::zserio::allocatorPropagatingCopy(other.m_speed_, allocator))
{
}

::nds::core::geometry::Longitude PoseRaw::getLongitude() const
{
    return m_longitude_;
}

void PoseRaw::setLongitude(::nds::core::geometry::Longitude longitude_)
{
    m_longitude_ = longitude_;
}

::nds::core::geometry::Latitude PoseRaw::getLatitude() const
{
    return m_latitude_;
}

void PoseRaw::setLatitude(::nds::core::geometry::Latitude latitude_)
{
    m_latitude_ = latitude_;
}

::nds::core::geometry::Elevation PoseRaw::getElevation() const
{
    return m_elevation_.value();
}

void PoseRaw::setElevation(::nds::core::geometry::Elevation elevation_)
{
    m_elevation_ = elevation_;
}

bool PoseRaw::isElevationUsed() const
{
    return (isElevationSet());
}

bool PoseRaw::isElevationSet() const
{
    return m_elevation_.hasValue();
}

void PoseRaw::resetElevation()
{
    m_elevation_.reset();
}

::nds::core::vehicle::Heading PoseRaw::getHeading() const
{
    return m_heading_.value();
}

void PoseRaw::setHeading(::nds::core::vehicle::Heading heading_)
{
    m_heading_ = heading_;
}

bool PoseRaw::isHeadingUsed() const
{
    return (isHeadingSet());
}

bool PoseRaw::isHeadingSet() const
{
    return m_heading_.hasValue();
}

void PoseRaw::resetHeading()
{
    m_heading_.reset();
}

::nds::core::vehicle::Pitch PoseRaw::getPitch() const
{
    return m_pitch_.value();
}

void PoseRaw::setPitch(::nds::core::vehicle::Pitch pitch_)
{
    m_pitch_ = pitch_;
}

bool PoseRaw::isPitchUsed() const
{
    return (isPitchSet());
}

bool PoseRaw::isPitchSet() const
{
    return m_pitch_.hasValue();
}

void PoseRaw::resetPitch()
{
    m_pitch_.reset();
}

::nds::core::types::SpeedKmh PoseRaw::getSpeed() const
{
    return m_speed_.value();
}

void PoseRaw::setSpeed(::nds::core::types::SpeedKmh speed_)
{
    m_speed_ = speed_;
}

bool PoseRaw::isSpeedUsed() const
{
    return (isSpeedSet());
}

bool PoseRaw::isSpeedSet() const
{
    return m_speed_.hasValue();
}

void PoseRaw::resetSpeed()
{
    m_speed_.reset();
}

void PoseRaw::initPackingContext(PoseRaw::ZserioPackingContext& context) const
{
    context.getLongitude().init<::zserio::StdIntArrayTraits<::nds::core::geometry::Longitude>>(m_longitude_);
    context.getLatitude().init<::zserio::StdIntArrayTraits<::nds::core::geometry::Latitude>>(m_latitude_);
    if (isElevationSet())
    {
        context.getElevation().init<::zserio::VarIntNNArrayTraits<::nds::core::geometry::Elevation>>(m_elevation_.value());
    }
    if (isHeadingSet())
    {
        context.getHeading().init<::zserio::StdIntArrayTraits<::nds::core::vehicle::Heading>>(m_heading_.value());
    }
    if (isPitchSet())
    {
        context.getPitch().init<::zserio::StdIntArrayTraits<::nds::core::vehicle::Pitch>>(m_pitch_.value());
    }
    if (isSpeedSet())
    {
        context.getSpeed().init<::zserio::StdIntArrayTraits<::nds::core::types::SpeedKmh>>(m_speed_.value());
    }
}

size_t PoseRaw::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(32);
    endBitPosition += UINT8_C(32);
    endBitPosition += 1;
    if (isElevationSet())
    {
        endBitPosition += ::zserio::bitSizeOfVarInt32(m_elevation_.value());
    }
    endBitPosition += 1;
    if (isHeadingSet())
    {
        endBitPosition += UINT8_C(8);
    }
    endBitPosition += 1;
    if (isPitchSet())
    {
        endBitPosition += UINT8_C(8);
    }
    endBitPosition += 1;
    if (isSpeedSet())
    {
        endBitPosition += UINT8_C(8);
    }

    return endBitPosition - bitPosition;
}

size_t PoseRaw::bitSizeOf(PoseRaw::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getLongitude().bitSizeOf<::zserio::StdIntArrayTraits<::nds::core::geometry::Longitude>>(m_longitude_);
    endBitPosition += context.getLatitude().bitSizeOf<::zserio::StdIntArrayTraits<::nds::core::geometry::Latitude>>(m_latitude_);
    endBitPosition += 1;
    if (isElevationSet())
    {
        endBitPosition += context.getElevation().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::geometry::Elevation>>(m_elevation_.value());
    }
    endBitPosition += 1;
    if (isHeadingSet())
    {
        endBitPosition += context.getHeading().bitSizeOf<::zserio::StdIntArrayTraits<::nds::core::vehicle::Heading>>(m_heading_.value());
    }
    endBitPosition += 1;
    if (isPitchSet())
    {
        endBitPosition += context.getPitch().bitSizeOf<::zserio::StdIntArrayTraits<::nds::core::vehicle::Pitch>>(m_pitch_.value());
    }
    endBitPosition += 1;
    if (isSpeedSet())
    {
        endBitPosition += context.getSpeed().bitSizeOf<::zserio::StdIntArrayTraits<::nds::core::types::SpeedKmh>>(m_speed_.value());
    }

    return endBitPosition - bitPosition;
}

size_t PoseRaw::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(32);
    endBitPosition += UINT8_C(32);
    endBitPosition += 1;
    if (isElevationSet())
    {
        endBitPosition += ::zserio::bitSizeOfVarInt32(m_elevation_.value());
    }
    endBitPosition += 1;
    if (isHeadingSet())
    {
        endBitPosition += UINT8_C(8);
    }
    endBitPosition += 1;
    if (isPitchSet())
    {
        endBitPosition += UINT8_C(8);
    }
    endBitPosition += 1;
    if (isSpeedSet())
    {
        endBitPosition += UINT8_C(8);
    }

    return endBitPosition;
}

size_t PoseRaw::initializeOffsets(PoseRaw::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getLongitude().bitSizeOf<::zserio::StdIntArrayTraits<::nds::core::geometry::Longitude>>(m_longitude_);
    endBitPosition += context.getLatitude().bitSizeOf<::zserio::StdIntArrayTraits<::nds::core::geometry::Latitude>>(m_latitude_);
    endBitPosition += 1;
    if (isElevationSet())
    {
        endBitPosition += context.getElevation().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::geometry::Elevation>>(m_elevation_.value());
    }
    endBitPosition += 1;
    if (isHeadingSet())
    {
        endBitPosition += context.getHeading().bitSizeOf<::zserio::StdIntArrayTraits<::nds::core::vehicle::Heading>>(m_heading_.value());
    }
    endBitPosition += 1;
    if (isPitchSet())
    {
        endBitPosition += context.getPitch().bitSizeOf<::zserio::StdIntArrayTraits<::nds::core::vehicle::Pitch>>(m_pitch_.value());
    }
    endBitPosition += 1;
    if (isSpeedSet())
    {
        endBitPosition += context.getSpeed().bitSizeOf<::zserio::StdIntArrayTraits<::nds::core::types::SpeedKmh>>(m_speed_.value());
    }

    return endBitPosition;
}

bool PoseRaw::operator==(const PoseRaw& other) const
{
    if (this != &other)
    {
        return
                (m_longitude_ == other.m_longitude_) &&
                (m_latitude_ == other.m_latitude_) &&
                (!isElevationUsed() ? !other.isElevationUsed() : (m_elevation_ == other.m_elevation_)) &&
                (!isHeadingUsed() ? !other.isHeadingUsed() : (m_heading_ == other.m_heading_)) &&
                (!isPitchUsed() ? !other.isPitchUsed() : (m_pitch_ == other.m_pitch_)) &&
                (!isSpeedUsed() ? !other.isSpeedUsed() : (m_speed_ == other.m_speed_));
    }

    return true;
}

uint32_t PoseRaw::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_longitude_);
    result = ::zserio::calcHashCode(result, m_latitude_);
    if (isElevationUsed())
        result = ::zserio::calcHashCode(result, m_elevation_);
    if (isHeadingUsed())
        result = ::zserio::calcHashCode(result, m_heading_);
    if (isPitchUsed())
        result = ::zserio::calcHashCode(result, m_pitch_);
    if (isSpeedUsed())
        result = ::zserio::calcHashCode(result, m_speed_);

    return result;
}

void PoseRaw::write(::zserio::BitStreamWriter& out) const
{
    out.writeSignedBits(m_longitude_, UINT8_C(32));
    out.writeSignedBits(m_latitude_, UINT8_C(32));
    if (isElevationSet())
    {
        out.writeBool(true);
        out.writeVarInt32(m_elevation_.value());
    }
    else
    {
        out.writeBool(false);
    }
    if (isHeadingSet())
    {
        out.writeBool(true);
        out.writeBits(m_heading_.value(), UINT8_C(8));
    }
    else
    {
        out.writeBool(false);
    }
    if (isPitchSet())
    {
        out.writeBool(true);
        out.writeSignedBits(m_pitch_.value(), UINT8_C(8));
    }
    else
    {
        out.writeBool(false);
    }
    if (isSpeedSet())
    {
        out.writeBool(true);
        out.writeBits(m_speed_.value(), UINT8_C(8));
    }
    else
    {
        out.writeBool(false);
    }
}

void PoseRaw::write(PoseRaw::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getLongitude().write<::zserio::StdIntArrayTraits<::nds::core::geometry::Longitude>>(out, m_longitude_);
    context.getLatitude().write<::zserio::StdIntArrayTraits<::nds::core::geometry::Latitude>>(out, m_latitude_);
    if (isElevationSet())
    {
        out.writeBool(true);
        context.getElevation().write<::zserio::VarIntNNArrayTraits<::nds::core::geometry::Elevation>>(out, m_elevation_.value());
    }
    else
    {
        out.writeBool(false);
    }
    if (isHeadingSet())
    {
        out.writeBool(true);
        context.getHeading().write<::zserio::StdIntArrayTraits<::nds::core::vehicle::Heading>>(out, m_heading_.value());
    }
    else
    {
        out.writeBool(false);
    }
    if (isPitchSet())
    {
        out.writeBool(true);
        context.getPitch().write<::zserio::StdIntArrayTraits<::nds::core::vehicle::Pitch>>(out, m_pitch_.value());
    }
    else
    {
        out.writeBool(false);
    }
    if (isSpeedSet())
    {
        out.writeBool(true);
        context.getSpeed().write<::zserio::StdIntArrayTraits<::nds::core::types::SpeedKmh>>(out, m_speed_.value());
    }
    else
    {
        out.writeBool(false);
    }
}

::nds::core::geometry::Longitude PoseRaw::readLongitude(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::geometry::Longitude>(in.readSignedBits(UINT8_C(32)));
}

::nds::core::geometry::Longitude PoseRaw::readLongitude(PoseRaw::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getLongitude().read<::zserio::StdIntArrayTraits<::nds::core::geometry::Longitude>>(in);
}
::nds::core::geometry::Latitude PoseRaw::readLatitude(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::geometry::Latitude>(in.readSignedBits(UINT8_C(32)));
}

::nds::core::geometry::Latitude PoseRaw::readLatitude(PoseRaw::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getLatitude().read<::zserio::StdIntArrayTraits<::nds::core::geometry::Latitude>>(in);
}
::zserio::InplaceOptionalHolder<::nds::core::geometry::Elevation> PoseRaw::readElevation(::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::geometry::Elevation>(static_cast<::nds::core::geometry::Elevation>(in.readVarInt32()));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::geometry::Elevation>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::geometry::Elevation> PoseRaw::readElevation(PoseRaw::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::geometry::Elevation>(context.getElevation().read<::zserio::VarIntNNArrayTraits<::nds::core::geometry::Elevation>>(in));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::geometry::Elevation>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::core::vehicle::Heading> PoseRaw::readHeading(::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::Heading>(static_cast<::nds::core::vehicle::Heading>(in.readBits(UINT8_C(8))));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::Heading>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::vehicle::Heading> PoseRaw::readHeading(PoseRaw::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::Heading>(context.getHeading().read<::zserio::StdIntArrayTraits<::nds::core::vehicle::Heading>>(in));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::Heading>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::core::vehicle::Pitch> PoseRaw::readPitch(::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::Pitch>(static_cast<::nds::core::vehicle::Pitch>(in.readSignedBits(UINT8_C(8))));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::Pitch>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::vehicle::Pitch> PoseRaw::readPitch(PoseRaw::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::Pitch>(context.getPitch().read<::zserio::StdIntArrayTraits<::nds::core::vehicle::Pitch>>(in));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::Pitch>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::core::types::SpeedKmh> PoseRaw::readSpeed(::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::types::SpeedKmh>(static_cast<::nds::core::types::SpeedKmh>(in.readBits(UINT8_C(8))));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::types::SpeedKmh>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::types::SpeedKmh> PoseRaw::readSpeed(PoseRaw::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::types::SpeedKmh>(context.getSpeed().read<::zserio::StdIntArrayTraits<::nds::core::types::SpeedKmh>>(in));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::types::SpeedKmh>(::zserio::NullOpt);
}

} // namespace vehicle
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/core/vehicle/TimedRawPose.h>

namespace nds
{
namespace core
{
namespace vehicle
{

TimedRawPose::TimedRawPose(const allocator_type& allocator) noexcept :
        m_age_(::nds::core::types::Milliseconds()),
        m_pose_(allocator)
{
}

TimedRawPose::TimedRawPose(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_age_(readAge(in)),
        m_pose_(readPose(in, allocator))
{
}

TimedRawPose::TimedRawPose(TimedRawPose::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_age_(readAge(context, in)),
        m_pose_(readPose(context, in, allocator))
{
}

TimedRawPose::TimedRawPose(::zserio::PropagateAllocatorT,
        const TimedRawPose& other, const allocator_type& allocator) :
        m_age_(::zserio::allocatorPropagatingCopy(other.m_age_, allocator)),
        m_pose_(::zserio::allocatorPropagatingCopy(other.m_pose_, allocator))
{
}

::nds::core::types::Milliseconds TimedRawPose::getAge() const
{
    return m_age_;
}

void TimedRawPose::setAge(::nds::core::types::Milliseconds age_)
{
    m_age_ = age_;
}

::nds::core::vehicle::PoseRaw& TimedRawPose::getPose()
{
    return m_pose_;
}

const ::nds::core::vehicle::PoseRaw& TimedRawPose::getPose() const
{
    return m_pose_;
}

void TimedRawPose::setPose(const ::nds::core::vehicle::PoseRaw& pose_)
{
    m_pose_ = pose_;
}

void TimedRawPose::setPose(::nds::core::vehicle::PoseRaw&& pose_)
{
    m_pose_ = ::std::move(pose_);
}

void TimedRawPose::initPackingContext(TimedRawPose::ZserioPackingContext& context) const
{
    context.getAge().init<::zserio::VarIntNNArrayTraits<::nds::core::types::Milliseconds>>(m_age_);
    m_pose_.initPackingContext(context.getPose());
}

size_t TimedRawPose::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_age_);
    endBitPosition += m_pose_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TimedRawPose::bitSizeOf(TimedRawPose::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getAge().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::types::Milliseconds>>(m_age_);
    endBitPosition += m_pose_.bitSizeOf(context.getPose(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TimedRawPose::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_age_);
    endBitPosition = m_pose_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t TimedRawPose::initializeOffsets(TimedRawPose::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getAge().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::types::Milliseconds>>(m_age_);
    endBitPosition = m_pose_.initializeOffsets(context.getPose(), endBitPosition);

    return endBitPosition;
}

bool TimedRawPose::operator==(const TimedRawPose& other) const
{
    if (this != &other)
    {
        return
                (m_age_ == other.m_age_) &&
                (m_pose_ == other.m_pose_);
    }

    return true;
}

uint32_t TimedRawPose::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_age_);
    result = ::zserio::calcHashCode(result, m_pose_);

    return result;
}

void TimedRawPose::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt32(m_age_);
    m_pose_.write(out);
}

void TimedRawPose::write(TimedRawPose::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getAge().write<::zserio::VarIntNNArrayTraits<::nds::core::types::Milliseconds>>(out, m_age_);
    m_pose_.write(context.getPose(), out);
}

::nds::core::types::Milliseconds TimedRawPose::readAge(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::types::Milliseconds>(in.readVarUInt32());
}

::nds::core::types::Milliseconds TimedRawPose::readAge(TimedRawPose::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getAge().read<::zserio::VarIntNNArrayTraits<::nds::core::types::Milliseconds>>(in);
}
::nds::core::vehicle::PoseRaw TimedRawPose::readPose(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::vehicle::PoseRaw(in, allocator);
}

::nds::core::vehicle::PoseRaw TimedRawPose::readPose(TimedRawPose::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::vehicle::PoseRaw(context.getPose(), in, allocator);
}

} // namespace vehicle
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/core/vehicle/PoseGeoMatched.h>

namespace nds
{
namespace core
{
namespace vehicle
{

PoseGeoMatched::PoseGeoMatched(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_coordinate_(allocator),
        m_elevation_(::zserio::NullOpt),
        m_zLevel_(::zserio::NullOpt),
        m_frc_(::zserio::NullOpt),
        m_heading_(::zserio::NullOpt),
        m_speed_(::zserio::NullOpt),
        m_probability_(::zserio::NullOpt)
{
}

PoseGeoMatched::PoseGeoMatched(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_coordinate_(readCoordinate(in, allocator)),
        m_elevation_(readElevation(in)),
        m_zLevel_(readZLevel(in)),
        m_frc_(readFrc(in)),
        m_heading_(readHeading(in)),
        m_speed_(readSpeed(in)),
        m_probability_(readProbability(in, allocator))
{
}

PoseGeoMatched::PoseGeoMatched(PoseGeoMatched::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_coordinate_(readCoordinate(context, in, allocator)),
        m_elevation_(readElevation(context, in)),
        m_zLevel_(readZLevel(context, in)),
        m_frc_(readFrc(context, in)),
        m_heading_(readHeading(context, in)),
        m_speed_(readSpeed(context, in)),
        m_probability_(readProbability(context, in, allocator))
{
}

PoseGeoMatched::PoseGeoMatched(const PoseGeoMatched& other) :
        m_coordinate_(other.m_coordinate_),
        m_elevation_(other.m_elevation_),
        m_zLevel_(other.m_zLevel_),
        m_frc_(other.m_frc_),
        m_heading_(other.m_heading_),
        m_speed_(other.m_speed_),
        m_probability_(other.m_probability_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

PoseGeoMatched& PoseGeoMatched::operator=(const PoseGeoMatched& other)
{
    m_coordinate_ = other.m_coordinate_;
    m_elevation_ = other.m_elevation_;
    m_zLevel_ = other.m_zLevel_;
    m_frc_ = other.m_frc_;
    m_heading_ = other.m_heading_;
    m_speed_ = other.m_speed_;
    m_probability_ = other.m_probability_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

PoseGeoMatched::PoseGeoMatched(PoseGeoMatched&& other) :
        m_coordinate_(::std::move(other.m_coordinate_)),
        m_elevation_(::std::move(other.m_elevation_)),
        m_zLevel_(::std::move(other.m_zLevel_)),
        m_frc_(::std::move(other.m_frc_)),
        m_heading_(::std::move(other.m_heading_)),
        m_speed_(::std::move(other.m_speed_)),
        m_probability_(::std::move(other.m_probability_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

PoseGeoMatched& PoseGeoMatched::operator=(PoseGeoMatched&& other)
{
    m_coordinate_ = ::std::move(other.m_coordinate_);
    m_elevation_ = ::std::move(other.m_elevation_);
    m_zLevel_ = ::std::move(other.m_zLevel_);
    m_frc_ = ::std::move(other.m_frc_);
    m_heading_ = ::std::move(other.m_heading_);
    m_speed_ = ::std::move(other.m_speed_);
    m_probability_ = ::std::move(other.m_probability_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

PoseGeoMatched::PoseGeoMatched(::zserio::PropagateAllocatorT,
        const PoseGeoMatched& other, const allocator_type& allocator) :
        m_coordinate_(::zserio::allocatorPropagatingCopy(other.m_coordinate_, allocator)),
        m_elevation_(::zserio::allocatorPropagatingCopy(other.m_elevation_, allocator)),
        m_zLevel_(::zserio::allocatorPropagatingCopy(other.m_zLevel_, allocator)),
        m_frc_(::zserio::allocatorPropagatingCopy(other.m_frc_, allocator)),
        m_heading_(::zserio::allocatorPropagatingCopy(other.m_heading_, allocator)),
        m_speed_(::zserio::allocatorPropagatingCopy(other.m_speed_, allocator)),
        m_probability_(::zserio::allocatorPropagatingCopy(other.m_probability_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void PoseGeoMatched::initializeChildren()
{
    m_coordinate_.initialize(static_cast<::nds::core::geometry::CoordShift>(0));

    m_areChildrenInitialized = true;
}

::nds::core::geometry::Position2D& PoseGeoMatched::getCoordinate()
{
    return m_coordinate_;
}

const ::nds::core::geometry::Position2D& PoseGeoMatched::getCoordinate() const
{
    return m_coordinate_;
}

void PoseGeoMatched::setCoordinate(const ::nds::core::geometry::Position2D& coordinate_)
{
    m_coordinate_ = coordinate_;
}

void PoseGeoMatched::setCoordinate(::nds::core::geometry::Position2D&& coordinate_)
{
    m_coordinate_ = ::std::move(coordinate_);
}

::nds::core::geometry::Elevation PoseGeoMatched::getElevation() const
{
    return m_elevation_.value();
}

void PoseGeoMatched::setElevation(::nds::core::geometry::Elevation elevation_)
{
    m_elevation_ = elevation_;
}

bool PoseGeoMatched::isElevationUsed() const
{
    return (isElevationSet());
}

bool PoseGeoMatched::isElevationSet() const
{
    return m_elevation_.hasValue();
}

void PoseGeoMatched::resetElevation()
{
    m_elevation_.reset();
}

int8_t PoseGeoMatched::getZLevel() const
{
    return m_zLevel_.value();
}

void PoseGeoMatched::setZLevel(int8_t zLevel_)
{
    m_zLevel_ = zLevel_;
}

bool PoseGeoMatched::isZLevelUsed() const
{
    return (isZLevelSet());
}

bool PoseGeoMatched::isZLevelSet() const
{
    return m_zLevel_.hasValue();
}

void PoseGeoMatched::resetZLevel()
{
    m_zLevel_.reset();
}

::nds::core::types::FunctionalRoadClass PoseGeoMatched::getFrc() const
{
    return m_frc_.value();
}

void PoseGeoMatched::setFrc(::nds::core::types::FunctionalRoadClass frc_)
{
    m_frc_ = frc_;
}

bool PoseGeoMatched::isFrcUsed() const
{
    return (isFrcSet());
}

bool PoseGeoMatched::isFrcSet() const
{
    return m_frc_.hasValue();
}

void PoseGeoMatched::resetFrc()
{
    m_frc_.reset();
}

::nds::core::vehicle::Heading PoseGeoMatched::getHeading() const
{
    return m_heading_.value();
}

void PoseGeoMatched::setHeading(::nds::core::vehicle::Heading heading_)
{
    m_heading_ = heading_;
}

bool PoseGeoMatched::isHeadingUsed() const
{
    return (isHeadingSet());
}

bool PoseGeoMatched::isHeadingSet() const
{
    return m_heading_.hasValue();
}

void PoseGeoMatched::resetHeading()
{
    m_heading_.reset();
}

::nds::core::types::SpeedKmh PoseGeoMatched::getSpeed() const
{
    return m_speed_.value();
}

void PoseGeoMatched::setSpeed(::nds::core::types::SpeedKmh speed_)
{
    m_speed_ = speed_;
}

bool PoseGeoMatched::isSpeedUsed() const
{
    return (isSpeedSet());
}

bool PoseGeoMatched::isSpeedSet() const
{
    return m_speed_.hasValue();
}

void PoseGeoMatched::resetSpeed()
{
    m_speed_.reset();
}

::nds::core::vehicle::MatchProbability& PoseGeoMatched::getProbability()
{
    return m_probability_.value();
}

const ::nds::core::vehicle::MatchProbability& PoseGeoMatched::getProbability() const
{
    return m_probability_.value();
}

void PoseGeoMatched::setProbability(const ::nds::core::vehicle::MatchProbability& probability_)
{
    m_probability_ = probability_;
}

void PoseGeoMatched::setProbability(::nds::core::vehicle::MatchProbability&& probability_)
{
    m_probability_ = ::std::move(probability_);
}

bool PoseGeoMatched::isProbabilityUsed() const
{
    return (isProbabilitySet());
}

bool PoseGeoMatched::isProbabilitySet() const
{
    return m_probability_.hasValue();
}

void PoseGeoMatched::resetProbability()
{
    m_probability_.reset();
}

void PoseGeoMatched::initPackingContext(PoseGeoMatched::ZserioPackingContext& context) const
{
    m_coordinate_.initPackingContext(context.getCoordinate());
    if (isElevationSet())
    {
        context.getElevation().init<::zserio::VarIntNNArrayTraits<::nds::core::geometry::Elevation>>(m_elevation_.value());
    }
    if (isZLevelSet())
    {
        context.getZLevel().init<::zserio::StdIntArrayTraits<int8_t>>(m_zLevel_.value());
    }
    if (isFrcSet())
    {
        context.getFrc().init<::zserio::BitFieldArrayTraits<::nds::core::types::FunctionalRoadClass, UINT8_C(3)>>(m_frc_.value());
    }
    if (isHeadingSet())
    {
        context.getHeading().init<::zserio::StdIntArrayTraits<::nds::core::vehicle::Heading>>(m_heading_.value());
    }
    if (isSpeedSet())
    {
        context.getSpeed().init<::zserio::StdIntArrayTraits<::nds::core::types::SpeedKmh>>(m_speed_.value());
    }
    if (isProbabilitySet())
    {
        m_probability_.value().initPackingContext(context.getProbability());
    }
}

size_t PoseGeoMatched::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_coordinate_.bitSizeOf(endBitPosition);
    endBitPosition += 1;
    if (isElevationSet())
    {
        endBitPosition += ::zserio::bitSizeOfVarInt32(m_elevation_.value());
    }
    endBitPosition += 1;
    if (isZLevelSet())
    {
        endBitPosition += UINT8_C(8);
    }
    endBitPosition += 1;
    if (isFrcSet())
    {
        endBitPosition += UINT8_C(3);
    }
    endBitPosition += 1;
    if (isHeadingSet())
    {
        endBitPosition += UINT8_C(8);
    }
    endBitPosition += 1;
    if (isSpeedSet())
    {
        endBitPosition += UINT8_C(8);
    }
    endBitPosition += 1;
    if (isProbabilitySet())
    {
        endBitPosition += m_probability_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t PoseGeoMatched::bitSizeOf(PoseGeoMatched::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_coordinate_.bitSizeOf(context.getCoordinate(), endBitPosition);
    endBitPosition += 1;
    if (isElevationSet())
    {
        endBitPosition += context.getElevation().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::geometry::Elevation>>(m_elevation_.value());
    }
    endBitPosition += 1;
    if (isZLevelSet())
    {
        endBitPosition += context.getZLevel().bitSizeOf<::zserio::StdIntArrayTraits<int8_t>>(m_zLevel_.value());
    }
    endBitPosition += 1;
    if (isFrcSet())
    {
        endBitPosition += context.getFrc().bitSizeOf<::zserio::BitFieldArrayTraits<::nds::core::types::FunctionalRoadClass, UINT8_C(3)>>(m_frc_.value());
    }
    endBitPosition += 1;
    if (isHeadingSet())
    {
        endBitPosition += context.getHeading().bitSizeOf<::zserio::StdIntArrayTraits<::nds::core::vehicle::Heading>>(m_heading_.value());
    }
    endBitPosition += 1;
    if (isSpeedSet())
    {
        endBitPosition += context.getSpeed().bitSizeOf<::zserio::StdIntArrayTraits<::nds::core::types::SpeedKmh>>(m_speed_.value());
    }
    endBitPosition += 1;
    if (isProbabilitySet())
    {
        endBitPosition += m_probability_.value().bitSizeOf(context.getProbability(), endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t PoseGeoMatched::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_coordinate_.initializeOffsets(endBitPosition);
    endBitPosition += 1;
    if (isElevationSet())
    {
        endBitPosition += ::zserio::bitSizeOfVarInt32(m_elevation_.value());
    }
    endBitPosition += 1;
    if (isZLevelSet())
    {
        endBitPosition += UINT8_C(8);
    }
    endBitPosition += 1;
    if (isFrcSet())
    {
        endBitPosition += UINT8_C(3);
    }
    endBitPosition += 1;
    if (isHeadingSet())
    {
        endBitPosition += UINT8_C(8);
    }
    endBitPosition += 1;
    if (isSpeedSet())
    {
        endBitPosition += UINT8_C(8);
    }
    endBitPosition += 1;
    if (isProbabilitySet())
    {
        endBitPosition = m_probability_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

size_t PoseGeoMatched::initializeOffsets(PoseGeoMatched::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_coordinate_.initializeOffsets(context.getCoordinate(), endBitPosition);
    endBitPosition += 1;
    if (isElevationSet())
    {
        endBitPosition += context.getElevation().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::geometry::Elevation>>(m_elevation_.value());
    }
    endBitPosition += 1;
    if (isZLevelSet())
    {
        endBitPosition += context.getZLevel().bitSizeOf<::zserio::StdIntArrayTraits<int8_t>>(m_zLevel_.value());
    }
    endBitPosition += 1;
    if (isFrcSet())
    {
        endBitPosition += context.getFrc().bitSizeOf<::zserio::BitFieldArrayTraits<::nds::core::types::FunctionalRoadClass, UINT8_C(3)>>(m_frc_.value());
    }
    endBitPosition += 1;
    if (isHeadingSet())
    {
        endBitPosition += context.getHeading().bitSizeOf<::zserio::StdIntArrayTraits<::nds::core::vehicle::Heading>>(m_heading_.value());
    }
    endBitPosition += 1;
    if (isSpeedSet())
    {
        endBitPosition += context.getSpeed().bitSizeOf<::zserio::StdIntArrayTraits<::nds::core::types::SpeedKmh>>(m_speed_.value());
    }
    endBitPosition += 1;
    if (isProbabilitySet())
    {
        endBitPosition = m_probability_.value().initializeOffsets(context.getProbability(), endBitPosition);
    }

    return endBitPosition;
}

bool PoseGeoMatched::operator==(const PoseGeoMatched& other) const
{
    if (this != &other)
    {
        return
                (m_coordinate_ == other.m_coordinate_) &&
                (!isElevationUsed() ? !other.isElevationUsed() : (m_elevation_ == other.m_elevation_)) &&
                (!isZLevelUsed() ? !other.isZLevelUsed() : (m_zLevel_ == other.m_zLevel_)) &&
                (!isFrcUsed() ? !other.isFrcUsed() : (m_frc_ == other.m_frc_)) &&
                (!isHeadingUsed() ? !other.isHeadingUsed() : (m_heading_ == other.m_heading_)) &&
                (!isSpeedUsed() ? !other.isSpeedUsed() : (m_speed_ == other.m_speed_)) &&
                (!isProbabilityUsed() ? !other.isProbabilityUsed() : (m_probability_ == other.m_probability_));
    }

    return true;
}

uint32_t PoseGeoMatched::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_coordinate_);
    if (isElevationUsed())
        result = ::zserio::calcHashCode(result, m_elevation_);
    if (isZLevelUsed())
        result = ::zserio::calcHashCode(result, m_zLevel_);
    if (isFrcUsed())
        result = ::zserio::calcHashCode(result, m_frc_);
    if (isHeadingUsed())
        result = ::zserio::calcHashCode(result, m_heading_);
    if (isSpeedUsed())
        result = ::zserio::calcHashCode(result, m_speed_);
    if (isProbabilityUsed())
        result = ::zserio::calcHashCode(result, m_probability_);

    return result;
}

void PoseGeoMatched::write(::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_coordinate_.getShift() != static_cast<::nds::core::geometry::CoordShift>(0))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field PoseGeoMatched.coordinate: ") <<
                m_coordinate_.getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(0) << "!";
    }
    m_coordinate_.write(out);

    if (isElevationSet())
    {
        out.writeBool(true);
        out.writeVarInt32(m_elevation_.value());
    }
    else
    {
        out.writeBool(false);
    }

    if (isZLevelSet())
    {
        out.writeBool(true);
        out.writeSignedBits(m_zLevel_.value(), UINT8_C(8));
    }
    else
    {
        out.writeBool(false);
    }

    if (isFrcSet())
    {
        out.writeBool(true);
        out.writeBits(m_frc_.value(), UINT8_C(3));
    }
    else
    {
        out.writeBool(false);
    }

    if (isHeadingSet())
    {
        out.writeBool(true);
        out.writeBits(m_heading_.value(), UINT8_C(8));
    }
    else
    {
        out.writeBool(false);
    }

    if (isSpeedSet())
    {
        out.writeBool(true);
        out.writeBits(m_speed_.value(), UINT8_C(8));
    }
    else
    {
        out.writeBool(false);
    }

    if (isProbabilitySet())
    {
        out.writeBool(true);
        m_probability_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
}

void PoseGeoMatched::write(PoseGeoMatched::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_coordinate_.getShift() != static_cast<::nds::core::geometry::CoordShift>(0))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field PoseGeoMatched.coordinate: ") <<
                m_coordinate_.getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(0) << "!";
    }
    m_coordinate_.write(context.getCoordinate(), out);

    if (isElevationSet())
    {
        out.writeBool(true);
        context.getElevation().write<::zserio::VarIntNNArrayTraits<::nds::core::geometry::Elevation>>(out, m_elevation_.value());
    }
    else
    {
        out.writeBool(false);
    }

    if (isZLevelSet())
    {
        out.writeBool(true);
        context.getZLevel().write<::zserio::StdIntArrayTraits<int8_t>>(out, m_zLevel_.value());
    }
    else
    {
        out.writeBool(false);
    }

    if (isFrcSet())
    {
        out.writeBool(true);
        context.getFrc().write<::zserio::BitFieldArrayTraits<::nds::core::types::FunctionalRoadClass, UINT8_C(3)>>(out, m_frc_.value());
    }
    else
    {
        out.writeBool(false);
    }

    if (isHeadingSet())
    {
        out.writeBool(true);
        context.getHeading().write<::zserio::StdIntArrayTraits<::nds::core::vehicle::Heading>>(out, m_heading_.value());
    }
    else
    {
        out.writeBool(false);
    }

    if (isSpeedSet())
    {
        out.writeBool(true);
        context.getSpeed().write<::zserio::StdIntArrayTraits<::nds::core::types::SpeedKmh>>(out, m_speed_.value());
    }
    else
    {
        out.writeBool(false);
    }

    if (isProbabilitySet())
    {
        out.writeBool(true);
        m_probability_.value().write(context.getProbability(), out);
    }
    else
    {
        out.writeBool(false);
    }
}

::nds::core::geometry::Position2D PoseGeoMatched::readCoordinate(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::geometry::Position2D(in, static_cast<::nds::core::geometry::CoordShift>(0), allocator);
}

::nds::core::geometry::Position2D PoseGeoMatched::readCoordinate(PoseGeoMatched::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::geometry::Position2D(context.getCoordinate(), in, static_cast<::nds::core::geometry::CoordShift>(0), allocator);
}
::zserio::InplaceOptionalHolder<::nds::core::geometry::Elevation> PoseGeoMatched::readElevation(::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::geometry::Elevation>(static_cast<::nds::core::geometry::Elevation>(in.readVarInt32()));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::geometry::Elevation>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::geometry::Elevation> PoseGeoMatched::readElevation(PoseGeoMatched::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::geometry::Elevation>(context.getElevation().read<::zserio::VarIntNNArrayTraits<::nds::core::geometry::Elevation>>(in));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::geometry::Elevation>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<int8_t> PoseGeoMatched::readZLevel(::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<int8_t>(static_cast<int8_t>(in.readSignedBits(UINT8_C(8))));
    }

    return ::zserio::InplaceOptionalHolder<int8_t>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<int8_t> PoseGeoMatched::readZLevel(PoseGeoMatched::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<int8_t>(context.getZLevel().read<::zserio::StdIntArrayTraits<int8_t>>(in));
    }

    return ::zserio::InplaceOptionalHolder<int8_t>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::core::types::FunctionalRoadClass> PoseGeoMatched::readFrc(::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::types::FunctionalRoadClass>(static_cast<::nds::core::types::FunctionalRoadClass>(in.readBits(UINT8_C(3))));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::types::FunctionalRoadClass>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::types::FunctionalRoadClass> PoseGeoMatched::readFrc(PoseGeoMatched::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::types::FunctionalRoadClass>(context.getFrc().read<::zserio::BitFieldArrayTraits<::nds::core::types::FunctionalRoadClass, UINT8_C(3)>>(in));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::types::FunctionalRoadClass>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::core::vehicle::Heading> PoseGeoMatched::readHeading(::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::Heading>(static_cast<::nds::core::vehicle::Heading>(in.readBits(UINT8_C(8))));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::Heading>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::vehicle::Heading> PoseGeoMatched::readHeading(PoseGeoMatched::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::Heading>(context.getHeading().read<::zserio::StdIntArrayTraits<::nds::core::vehicle::Heading>>(in));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::Heading>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::core::types::SpeedKmh> PoseGeoMatched::readSpeed(::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::types::SpeedKmh>(static_cast<::nds::core::types::SpeedKmh>(in.readBits(UINT8_C(8))));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::types::SpeedKmh>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::types::SpeedKmh> PoseGeoMatched::readSpeed(PoseGeoMatched::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::types::SpeedKmh>(context.getSpeed().read<::zserio::StdIntArrayTraits<::nds::core::types::SpeedKmh>>(in));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::types::SpeedKmh>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::core::vehicle::MatchProbability> PoseGeoMatched::readProbability(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::MatchProbability>(::nds::core::vehicle::MatchProbability(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::MatchProbability>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::vehicle::MatchProbability> PoseGeoMatched::readProbability(PoseGeoMatched::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::MatchProbability>(::nds::core::vehicle::MatchProbability(context.getProbability(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::MatchProbability>(::zserio::NullOpt);
}

} // namespace vehicle
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ConstraintException.h>

#include <nds/core/vehicle/MatchProbability.h>

namespace nds
{
namespace core
{
namespace vehicle
{

MatchProbability::MatchProbability(const allocator_type&) noexcept :
        m_percent_(uint8_t()),
        m_deviation_(uint32_t())
{
}

MatchProbability::MatchProbability(::zserio::BitStreamReader& in, const allocator_type&) :
        m_percent_(readPercent(in)),
        m_deviation_(readDeviation(in))
{
}

MatchProbability::MatchProbability(MatchProbability::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type&) :
        m_percent_(readPercent(context, in)),
        m_deviation_(readDeviation(context, in))
{
}

MatchProbability::MatchProbability(::zserio::PropagateAllocatorT,
        const MatchProbability& other, const allocator_type& allocator) :
        m_percent_(::zserio::allocatorPropagatingCopy(other.m_percent_, allocator)),
        m_deviation_(::zserio::allocatorPropagatingCopy(other.m_deviation_, allocator))
{
}

uint8_t MatchProbability::getPercent() const
{
    return m_percent_;
}

void MatchProbability::setPercent(uint8_t percent_)
{
    m_percent_ = percent_;
}

uint32_t MatchProbability::getDeviation() const
{
    return m_deviation_;
}

void MatchProbability::setDeviation(uint32_t deviation_)
{
    m_deviation_ = deviation_;
}

void MatchProbability::initPackingContext(MatchProbability::ZserioPackingContext& context) const
{
    context.getPercent().init<::zserio::StdIntArrayTraits<uint8_t>>(m_percent_);
    context.getDeviation().init<::zserio::VarIntNNArrayTraits<uint32_t>>(m_deviation_);
}

size_t MatchProbability::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(8);
    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_deviation_);

    return endBitPosition - bitPosition;
}

size_t MatchProbability::bitSizeOf(MatchProbability::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getPercent().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_percent_);
    endBitPosition += context.getDeviation().bitSizeOf<::zserio::VarIntNNArrayTraits<uint32_t>>(m_deviation_);

    return endBitPosition - bitPosition;
}

size_t MatchProbability::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(8);
    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_deviation_);

    return endBitPosition;
}

size_t MatchProbability::initializeOffsets(MatchProbability::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getPercent().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_percent_);
    endBitPosition += context.getDeviation().bitSizeOf<::zserio::VarIntNNArrayTraits<uint32_t>>(m_deviation_);

    return endBitPosition;
}

bool MatchProbability::operator==(const MatchProbability& other) const
{
    if (this != &other)
    {
        return
                (m_percent_ == other.m_percent_) &&
                (m_deviation_ == other.m_deviation_);
    }

    return true;
}

uint32_t MatchProbability::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_percent_);
    result = ::zserio::calcHashCode(result, m_deviation_);

    return result;
}

void MatchProbability::write(::zserio::BitStreamWriter& out) const
{
    // check constraint
    if (!(getPercent() <= 200))
        throw ::zserio::ConstraintException("Write: Constraint violated at MatchProbability.percent!");
    out.writeBits(m_percent_, UINT8_C(8));

    out.writeVarUInt32(m_deviation_);
}

void MatchProbability::write(MatchProbability::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    // check constraint
    if (!(getPercent() <= 200))
        throw ::zserio::ConstraintException("Write: Constraint violated at MatchProbability.percent!");
    context.getPercent().write<::zserio::StdIntArrayTraits<uint8_t>>(out, m_percent_);

    context.getDeviation().write<::zserio::VarIntNNArrayTraits<uint32_t>>(out, m_deviation_);
}

uint8_t MatchProbability::readPercent(::zserio::BitStreamReader& in)
{
    uint8_t readField = static_cast<uint8_t>(in.readBits(UINT8_C(8)));
    // check constraint
    if (!(readField <= 200))
        throw ::zserio::ConstraintException("Read: Constraint violated at MatchProbability.percent!");

    return readField;
}

uint8_t MatchProbability::readPercent(MatchProbability::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    uint8_t readField = context.getPercent().read<::zserio::StdIntArrayTraits<uint8_t>>(in);
    // check constraint
    if (!(readField <= 200))
        throw ::zserio::ConstraintException("Read: Constraint violated at MatchProbability.percent!");

    return readField;
}
uint32_t MatchProbability::readDeviation(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarUInt32());
}

uint32_t MatchProbability::readDeviation(MatchProbability::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getDeviation().read<::zserio::VarIntNNArrayTraits<uint32_t>>(in);
}

} // namespace vehicle
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/core/vehicle/VehicleTypeInformation.h>

namespace nds
{
namespace core
{
namespace vehicle
{

VehicleTypeInformation::VehicleTypeInformation(const allocator_type&) noexcept :
        m_frequentlyUsedVehicles_(::nds::core::vehicle::FrequentlyUsedVehicleTypes()),
        m_bigVehicles_(::nds::core::vehicle::BigVehicleTypes()),
        m_publicServiceVehicles_(::nds::core::vehicle::PublicServiceVehicleTypes()),
        m_slowRoadUsers_(::nds::core::vehicle::SlowRoadUserTypes()),
        m_emergencyMilitaryDetails_(::nds::core::vehicle::EmergencyMilitaryDetailTypes())
{
}

VehicleTypeInformation::VehicleTypeInformation(::zserio::BitStreamReader& in, const allocator_type&) :
        m_frequentlyUsedVehicles_(readFrequentlyUsedVehicles(in)),
        m_bigVehicles_(readBigVehicles(in)),
        m_publicServiceVehicles_(readPublicServiceVehicles(in)),
        m_slowRoadUsers_(readSlowRoadUsers(in)),
        m_emergencyMilitaryDetails_(readEmergencyMilitaryDetails(in))
{
}

VehicleTypeInformation::VehicleTypeInformation(VehicleTypeInformation::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type&) :
        m_frequentlyUsedVehicles_(readFrequentlyUsedVehicles(context, in)),
        m_bigVehicles_(readBigVehicles(context, in)),
        m_publicServiceVehicles_(readPublicServiceVehicles(context, in)),
        m_slowRoadUsers_(readSlowRoadUsers(context, in)),
        m_emergencyMilitaryDetails_(readEmergencyMilitaryDetails(context, in))
{
}

VehicleTypeInformation::VehicleTypeInformation(::zserio::PropagateAllocatorT,
        const VehicleTypeInformation& other, const allocator_type& allocator) :
        m_frequentlyUsedVehicles_(::zserio::allocatorPropagatingCopy(other.m_frequentlyUsedVehicles_, allocator)),
        m_bigVehicles_(::zserio::allocatorPropagatingCopy(other.m_bigVehicles_, allocator)),
        m_publicServiceVehicles_(::zserio::allocatorPropagatingCopy(other.m_publicServiceVehicles_, allocator)),
        m_slowRoadUsers_(::zserio::allocatorPropagatingCopy(other.m_slowRoadUsers_, allocator)),
        m_emergencyMilitaryDetails_(::zserio::allocatorPropagatingCopy(other.m_emergencyMilitaryDetails_, allocator))
{
}

::nds::core::vehicle::FrequentlyUsedVehicleTypes VehicleTypeInformation::getFrequentlyUsedVehicles() const
{
    return m_frequentlyUsedVehicles_;
}

void VehicleTypeInformation::setFrequentlyUsedVehicles(::nds::core::vehicle::FrequentlyUsedVehicleTypes frequentlyUsedVehicles_)
{
    m_frequentlyUsedVehicles_ = frequentlyUsedVehicles_;
}

::nds::core::vehicle::BigVehicleTypes VehicleTypeInformation::getBigVehicles() const
{
    return m_bigVehicles_;
}

void VehicleTypeInformation::setBigVehicles(::nds::core::vehicle::BigVehicleTypes bigVehicles_)
{
    m_bigVehicles_ = bigVehicles_;
}

::nds::core::vehicle::PublicServiceVehicleTypes VehicleTypeInformation::getPublicServiceVehicles() const
{
    return m_publicServiceVehicles_;
}

void VehicleTypeInformation::setPublicServiceVehicles(::nds::core::vehicle::PublicServiceVehicleTypes publicServiceVehicles_)
{
    m_publicServiceVehicles_ = publicServiceVehicles_;
}

::nds::core::vehicle::SlowRoadUserTypes VehicleTypeInformation::getSlowRoadUsers() const
{
    return m_slowRoadUsers_;
}

void VehicleTypeInformation::setSlowRoadUsers(::nds::core::vehicle::SlowRoadUserTypes slowRoadUsers_)
{
    m_slowRoadUsers_ = slowRoadUsers_;
}

::nds::core::vehicle::EmergencyMilitaryDetailTypes VehicleTypeInformation::getEmergencyMilitaryDetails() const
{
    return m_emergencyMilitaryDetails_;
}

void VehicleTypeInformation::setEmergencyMilitaryDetails(::nds::core::vehicle::EmergencyMilitaryDetailTypes emergencyMilitaryDetails_)
{
    m_emergencyMilitaryDetails_ = emergencyMilitaryDetails_;
}

void VehicleTypeInformation::initPackingContext(VehicleTypeInformation::ZserioPackingContext& context) const
{
    m_frequentlyUsedVehicles_.initPackingContext(context.getFrequentlyUsedVehicles());
    m_bigVehicles_.initPackingContext(context.getBigVehicles());
    m_publicServiceVehicles_.initPackingContext(context.getPublicServiceVehicles());
    m_slowRoadUsers_.initPackingContext(context.getSlowRoadUsers());
    m_emergencyMilitaryDetails_.initPackingContext(context.getEmergencyMilitaryDetails());
}

size_t VehicleTypeInformation::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_frequentlyUsedVehicles_.bitSizeOf(endBitPosition);
    endBitPosition += m_bigVehicles_.bitSizeOf(endBitPosition);
    endBitPosition += m_publicServiceVehicles_.bitSizeOf(endBitPosition);
    endBitPosition += m_slowRoadUsers_.bitSizeOf(endBitPosition);
    endBitPosition += m_emergencyMilitaryDetails_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t VehicleTypeInformation::bitSizeOf(VehicleTypeInformation::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_frequentlyUsedVehicles_.bitSizeOf(context.getFrequentlyUsedVehicles(), endBitPosition);
    endBitPosition += m_bigVehicles_.bitSizeOf(context.getBigVehicles(), endBitPosition);
    endBitPosition += m_publicServiceVehicles_.bitSizeOf(context.getPublicServiceVehicles(), endBitPosition);
    endBitPosition += m_slowRoadUsers_.bitSizeOf(context.getSlowRoadUsers(), endBitPosition);
    endBitPosition += m_emergencyMilitaryDetails_.bitSizeOf(context.getEmergencyMilitaryDetails(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t VehicleTypeInformation::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_frequentlyUsedVehicles_.initializeOffsets(endBitPosition);
    endBitPosition = m_bigVehicles_.initializeOffsets(endBitPosition);
    endBitPosition = m_publicServiceVehicles_.initializeOffsets(endBitPosition);
    endBitPosition = m_slowRoadUsers_.initializeOffsets(endBitPosition);
    endBitPosition = m_emergencyMilitaryDetails_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t VehicleTypeInformation::initializeOffsets(VehicleTypeInformation::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_frequentlyUsedVehicles_.initializeOffsets(context.getFrequentlyUsedVehicles(), endBitPosition);
    endBitPosition = m_bigVehicles_.initializeOffsets(context.getBigVehicles(), endBitPosition);
    endBitPosition = m_publicServiceVehicles_.initializeOffsets(context.getPublicServiceVehicles(), endBitPosition);
    endBitPosition = m_slowRoadUsers_.initializeOffsets(context.getSlowRoadUsers(), endBitPosition);
    endBitPosition = m_emergencyMilitaryDetails_.initializeOffsets(context.getEmergencyMilitaryDetails(), endBitPosition);

    return endBitPosition;
}

bool VehicleTypeInformation::operator==(const VehicleTypeInformation& other) const
{
    if (this != &other)
    {
        return
                (m_frequentlyUsedVehicles_ == other.m_frequentlyUsedVehicles_) &&
                (m_bigVehicles_ == other.m_bigVehicles_) &&
                (m_publicServiceVehicles_ == other.m_publicServiceVehicles_) &&
                (m_slowRoadUsers_ == other.m_slowRoadUsers_) &&
                (m_emergencyMilitaryDetails_ == other.m_emergencyMilitaryDetails_);
    }

    return true;
}

uint32_t VehicleTypeInformation::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_frequentlyUsedVehicles_);
    result = ::zserio::calcHashCode(result, m_bigVehicles_);
    result = ::zserio::calcHashCode(result, m_publicServiceVehicles_);
    result = ::zserio::calcHashCode(result, m_slowRoadUsers_);
    result = ::zserio::calcHashCode(result, m_emergencyMilitaryDetails_);

    return result;
}

void VehicleTypeInformation::write(::zserio::BitStreamWriter& out) const
{
    m_frequentlyUsedVehicles_.write(out);
    m_bigVehicles_.write(out);
    m_publicServiceVehicles_.write(out);
    m_slowRoadUsers_.write(out);
    m_emergencyMilitaryDetails_.write(out);
}

void VehicleTypeInformation::write(VehicleTypeInformation::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_frequentlyUsedVehicles_.write(context.getFrequentlyUsedVehicles(), out);
    m_bigVehicles_.write(context.getBigVehicles(), out);
    m_publicServiceVehicles_.write(context.getPublicServiceVehicles(), out);
    m_slowRoadUsers_.write(context.getSlowRoadUsers(), out);
    m_emergencyMilitaryDetails_.write(context.getEmergencyMilitaryDetails(), out);
}

::nds::core::vehicle::FrequentlyUsedVehicleTypes VehicleTypeInformation::readFrequentlyUsedVehicles(::zserio::BitStreamReader& in)
{
    return ::nds::core::vehicle::FrequentlyUsedVehicleTypes(in);
}

::nds::core::vehicle::FrequentlyUsedVehicleTypes VehicleTypeInformation::readFrequentlyUsedVehicles(VehicleTypeInformation::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::nds::core::vehicle::FrequentlyUsedVehicleTypes(context.getFrequentlyUsedVehicles(), in);
}
::nds::core::vehicle::BigVehicleTypes VehicleTypeInformation::readBigVehicles(::zserio::BitStreamReader& in)
{
    return ::nds::core::vehicle::BigVehicleTypes(in);
}

::nds::core::vehicle::BigVehicleTypes VehicleTypeInformation::readBigVehicles(VehicleTypeInformation::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::nds::core::vehicle::BigVehicleTypes(context.getBigVehicles(), in);
}
::nds::core::vehicle::PublicServiceVehicleTypes VehicleTypeInformation::readPublicServiceVehicles(::zserio::BitStreamReader& in)
{
    return ::nds::core::vehicle::PublicServiceVehicleTypes(in);
}

::nds::core::vehicle::PublicServiceVehicleTypes VehicleTypeInformation::readPublicServiceVehicles(VehicleTypeInformation::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::nds::core::vehicle::PublicServiceVehicleTypes(context.getPublicServiceVehicles(), in);
}
::nds::core::vehicle::SlowRoadUserTypes VehicleTypeInformation::readSlowRoadUsers(::zserio::BitStreamReader& in)
{
    return ::nds::core::vehicle::SlowRoadUserTypes(in);
}

::nds::core::vehicle::SlowRoadUserTypes VehicleTypeInformation::readSlowRoadUsers(VehicleTypeInformation::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::nds::core::vehicle::SlowRoadUserTypes(context.getSlowRoadUsers(), in);
}
::nds::core::vehicle::EmergencyMilitaryDetailTypes VehicleTypeInformation::readEmergencyMilitaryDetails(::zserio::BitStreamReader& in)
{
    return ::nds::core::vehicle::EmergencyMilitaryDetailTypes(in);
}

::nds::core::vehicle::EmergencyMilitaryDetailTypes VehicleTypeInformation::readEmergencyMilitaryDetails(VehicleTypeInformation::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::nds::core::vehicle::EmergencyMilitaryDetailTypes(context.getEmergencyMilitaryDetails(), in);
}

} // namespace vehicle
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/core/vehicle/VehicleClassSpecification.h>

namespace nds
{
namespace core
{
namespace vehicle
{

VehicleClassSpecification::VehicleClassSpecification(const allocator_type& allocator) noexcept :
        m_engine_(allocator),
        m_equipment_(::nds::core::vehicle::Equipment()),
        m_maxDimensions_(allocator),
        m_minDimensions_(allocator),
        m_load_(::nds::core::vehicle::LoadType()),
        m_axles_(allocator),
        m_assistFunctions_(::nds::core::vehicle::DriverAssistFunctions())
{
}

VehicleClassSpecification::VehicleClassSpecification(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_engine_(readEngine(in, allocator)),
        m_equipment_(readEquipment(in)),
        m_maxDimensions_(readMaxDimensions(in, allocator)),
        m_minDimensions_(readMinDimensions(in, allocator)),
        m_load_(readLoad(in)),
        m_axles_(readAxles(in, allocator)),
        m_assistFunctions_(readAssistFunctions(in))
{
}

VehicleClassSpecification::VehicleClassSpecification(VehicleClassSpecification::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_engine_(readEngine(context, in, allocator)),
        m_equipment_(readEquipment(context, in)),
        m_maxDimensions_(readMaxDimensions(context, in, allocator)),
        m_minDimensions_(readMinDimensions(context, in, allocator)),
        m_load_(readLoad(context, in)),
        m_axles_(readAxles(context, in, allocator)),
        m_assistFunctions_(readAssistFunctions(context, in))
{
}

VehicleClassSpecification::VehicleClassSpecification(::zserio::PropagateAllocatorT,
        const VehicleClassSpecification& other, const allocator_type& allocator) :
        m_engine_(::zserio::allocatorPropagatingCopy(other.m_engine_, allocator)),
        m_equipment_(::zserio::allocatorPropagatingCopy(other.m_equipment_, allocator)),
        m_maxDimensions_(::zserio::allocatorPropagatingCopy(other.m_maxDimensions_, allocator)),
        m_minDimensions_(::zserio::allocatorPropagatingCopy(other.m_minDimensions_, allocator)),
        m_load_(::zserio::allocatorPropagatingCopy(other.m_load_, allocator)),
        m_axles_(::zserio::allocatorPropagatingCopy(other.m_axles_, allocator)),
        m_assistFunctions_(::zserio::allocatorPropagatingCopy(other.m_assistFunctions_, allocator))
{
}

::nds::core::vehicle::Engine& VehicleClassSpecification::getEngine()
{
    return m_engine_;
}

const ::nds::core::vehicle::Engine& VehicleClassSpecification::getEngine() const
{
    return m_engine_;
}

void VehicleClassSpecification::setEngine(const ::nds::core::vehicle::Engine& engine_)
{
    m_engine_ = engine_;
}

void VehicleClassSpecification::setEngine(::nds::core::vehicle::Engine&& engine_)
{
    m_engine_ = ::std::move(engine_);
}

::nds::core::vehicle::Equipment VehicleClassSpecification::getEquipment() const
{
    return m_equipment_;
}

void VehicleClassSpecification::setEquipment(::nds::core::vehicle::Equipment equipment_)
{
    m_equipment_ = equipment_;
}

::nds::core::vehicle::VehicleDimensions& VehicleClassSpecification::getMaxDimensions()
{
    return m_maxDimensions_;
}

const ::nds::core::vehicle::VehicleDimensions& VehicleClassSpecification::getMaxDimensions() const
{
    return m_maxDimensions_;
}

void VehicleClassSpecification::setMaxDimensions(const ::nds::core::vehicle::VehicleDimensions& maxDimensions_)
{
    m_maxDimensions_ = maxDimensions_;
}

void VehicleClassSpecification::setMaxDimensions(::nds::core::vehicle::VehicleDimensions&& maxDimensions_)
{
    m_maxDimensions_ = ::std::move(maxDimensions_);
}

::nds::core::vehicle::VehicleDimensions& VehicleClassSpecification::getMinDimensions()
{
    return m_minDimensions_;
}

const ::nds::core::vehicle::VehicleDimensions& VehicleClassSpecification::getMinDimensions() const
{
    return m_minDimensions_;
}

void VehicleClassSpecification::setMinDimensions(const ::nds::core::vehicle::VehicleDimensions& minDimensions_)
{
    m_minDimensions_ = minDimensions_;
}

void VehicleClassSpecification::setMinDimensions(::nds::core::vehicle::VehicleDimensions&& minDimensions_)
{
    m_minDimensions_ = ::std::move(minDimensions_);
}

::nds::core::vehicle::LoadType VehicleClassSpecification::getLoad() const
{
    return m_load_;
}

void VehicleClassSpecification::setLoad(::nds::core::vehicle::LoadType load_)
{
    m_load_ = load_;
}

::nds::core::vehicle::AxleDetails& VehicleClassSpecification::getAxles()
{
    return m_axles_;
}

const ::nds::core::vehicle::AxleDetails& VehicleClassSpecification::getAxles() const
{
    return m_axles_;
}

void VehicleClassSpecification::setAxles(const ::nds::core::vehicle::AxleDetails& axles_)
{
    m_axles_ = axles_;
}

void VehicleClassSpecification::setAxles(::nds::core::vehicle::AxleDetails&& axles_)
{
    m_axles_ = ::std::move(axles_);
}

::nds::core::vehicle::DriverAssistFunctions VehicleClassSpecification::getAssistFunctions() const
{
    return m_assistFunctions_;
}

void VehicleClassSpecification::setAssistFunctions(::nds::core::vehicle::DriverAssistFunctions assistFunctions_)
{
    m_assistFunctions_ = assistFunctions_;
}

void VehicleClassSpecification::initPackingContext(VehicleClassSpecification::ZserioPackingContext& context) const
{
    m_engine_.initPackingContext(context.getEngine());
    m_equipment_.initPackingContext(context.getEquipment());
    m_maxDimensions_.initPackingContext(context.getMaxDimensions());
    m_minDimensions_.initPackingContext(context.getMinDimensions());
    m_load_.initPackingContext(context.getLoad());
    m_axles_.initPackingContext(context.getAxles());
    m_assistFunctions_.initPackingContext(context.getAssistFunctions());
}

size_t VehicleClassSpecification::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_engine_.bitSizeOf(endBitPosition);
    endBitPosition += m_equipment_.bitSizeOf(endBitPosition);
    endBitPosition += m_maxDimensions_.bitSizeOf(endBitPosition);
    endBitPosition += m_minDimensions_.bitSizeOf(endBitPosition);
    endBitPosition += m_load_.bitSizeOf(endBitPosition);
    endBitPosition += m_axles_.bitSizeOf(endBitPosition);
    endBitPosition += m_assistFunctions_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t VehicleClassSpecification::bitSizeOf(VehicleClassSpecification::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_engine_.bitSizeOf(context.getEngine(), endBitPosition);
    endBitPosition += m_equipment_.bitSizeOf(context.getEquipment(), endBitPosition);
    endBitPosition += m_maxDimensions_.bitSizeOf(context.getMaxDimensions(), endBitPosition);
    endBitPosition += m_minDimensions_.bitSizeOf(context.getMinDimensions(), endBitPosition);
    endBitPosition += m_load_.bitSizeOf(context.getLoad(), endBitPosition);
    endBitPosition += m_axles_.bitSizeOf(context.getAxles(), endBitPosition);
    endBitPosition += m_assistFunctions_.bitSizeOf(context.getAssistFunctions(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t VehicleClassSpecification::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_engine_.initializeOffsets(endBitPosition);
    endBitPosition = m_equipment_.initializeOffsets(endBitPosition);
    endBitPosition = m_maxDimensions_.initializeOffsets(endBitPosition);
    endBitPosition = m_minDimensions_.initializeOffsets(endBitPosition);
    endBitPosition = m_load_.initializeOffsets(endBitPosition);
    endBitPosition = m_axles_.initializeOffsets(endBitPosition);
    endBitPosition = m_assistFunctions_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t VehicleClassSpecification::initializeOffsets(VehicleClassSpecification::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_engine_.initializeOffsets(context.getEngine(), endBitPosition);
    endBitPosition = m_equipment_.initializeOffsets(context.getEquipment(), endBitPosition);
    endBitPosition = m_maxDimensions_.initializeOffsets(context.getMaxDimensions(), endBitPosition);
    endBitPosition = m_minDimensions_.initializeOffsets(context.getMinDimensions(), endBitPosition);
    endBitPosition = m_load_.initializeOffsets(context.getLoad(), endBitPosition);
    endBitPosition = m_axles_.initializeOffsets(context.getAxles(), endBitPosition);
    endBitPosition = m_assistFunctions_.initializeOffsets(context.getAssistFunctions(), endBitPosition);

    return endBitPosition;
}

bool VehicleClassSpecification::operator==(const VehicleClassSpecification& other) const
{
    if (this != &other)
    {
        return
                (m_engine_ == other.m_engine_) &&
                (m_equipment_ == other.m_equipment_) &&
                (m_maxDimensions_ == other.m_maxDimensions_) &&
                (m_minDimensions_ == other.m_minDimensions_) &&
                (m_load_ == other.m_load_) &&
                (m_axles_ == other.m_axles_) &&
                (m_assistFunctions_ == other.m_assistFunctions_);
    }

    return true;
}

uint32_t VehicleClassSpecification::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_engine_);
    result = ::zserio::calcHashCode(result, m_equipment_);
    result = ::zserio::calcHashCode(result, m_maxDimensions_);
    result = ::zserio::calcHashCode(result, m_minDimensions_);
    result = ::zserio::calcHashCode(result, m_load_);
    result = ::zserio::calcHashCode(result, m_axles_);
    result = ::zserio::calcHashCode(result, m_assistFunctions_);

    return result;
}

void VehicleClassSpecification::write(::zserio::BitStreamWriter& out) const
{
    m_engine_.write(out);
    m_equipment_.write(out);
    m_maxDimensions_.write(out);
    m_minDimensions_.write(out);
    m_load_.write(out);
    m_axles_.write(out);
    m_assistFunctions_.write(out);
}

void VehicleClassSpecification::write(VehicleClassSpecification::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_engine_.write(context.getEngine(), out);
    m_equipment_.write(context.getEquipment(), out);
    m_maxDimensions_.write(context.getMaxDimensions(), out);
    m_minDimensions_.write(context.getMinDimensions(), out);
    m_load_.write(context.getLoad(), out);
    m_axles_.write(context.getAxles(), out);
    m_assistFunctions_.write(context.getAssistFunctions(), out);
}

::nds::core::vehicle::Engine VehicleClassSpecification::readEngine(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::vehicle::Engine(in, allocator);
}

::nds::core::vehicle::Engine VehicleClassSpecification::readEngine(VehicleClassSpecification::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::vehicle::Engine(context.getEngine(), in, allocator);
}
::nds::core::vehicle::Equipment VehicleClassSpecification::readEquipment(::zserio::BitStreamReader& in)
{
    return ::nds::core::vehicle::Equipment(in);
}

::nds::core::vehicle::Equipment VehicleClassSpecification::readEquipment(VehicleClassSpecification::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::nds::core::vehicle::Equipment(context.getEquipment(), in);
}
::nds::core::vehicle::VehicleDimensions VehicleClassSpecification::readMaxDimensions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::vehicle::VehicleDimensions(in, allocator);
}

::nds::core::vehicle::VehicleDimensions VehicleClassSpecification::readMaxDimensions(VehicleClassSpecification::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::vehicle::VehicleDimensions(context.getMaxDimensions(), in, allocator);
}
::nds::core::vehicle::VehicleDimensions VehicleClassSpecification::readMinDimensions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::vehicle::VehicleDimensions(in, allocator);
}

::nds::core::vehicle::VehicleDimensions VehicleClassSpecification::readMinDimensions(VehicleClassSpecification::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::vehicle::VehicleDimensions(context.getMinDimensions(), in, allocator);
}
::nds::core::vehicle::LoadType VehicleClassSpecification::readLoad(::zserio::BitStreamReader& in)
{
    return ::nds::core::vehicle::LoadType(in);
}

::nds::core::vehicle::LoadType VehicleClassSpecification::readLoad(VehicleClassSpecification::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::nds::core::vehicle::LoadType(context.getLoad(), in);
}
::nds::core::vehicle::AxleDetails VehicleClassSpecification::readAxles(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::vehicle::AxleDetails(in, allocator);
}

::nds::core::vehicle::AxleDetails VehicleClassSpecification::readAxles(VehicleClassSpecification::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::vehicle::AxleDetails(context.getAxles(), in, allocator);
}
::nds::core::vehicle::DriverAssistFunctions VehicleClassSpecification::readAssistFunctions(::zserio::BitStreamReader& in)
{
    return ::nds::core::vehicle::DriverAssistFunctions(in);
}

::nds::core::vehicle::DriverAssistFunctions VehicleClassSpecification::readAssistFunctions(VehicleClassSpecification::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::nds::core::vehicle::DriverAssistFunctions(context.getAssistFunctions(), in);
}

} // namespace vehicle
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/core/vehicle/Engine.h>

namespace nds
{
namespace core
{
namespace vehicle
{

Engine::Engine(const allocator_type&) noexcept :
        m_energyType_(::nds::core::vehicle::EnergyType()),
        m_euroEmissionClass_(::nds::core::vehicle::VehicleEuroEmissionClass())
{
}

Engine::Engine(::zserio::BitStreamReader& in, const allocator_type&) :
        m_energyType_(readEnergyType(in)),
        m_euroEmissionClass_(readEuroEmissionClass(in))
{
}

Engine::Engine(Engine::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type&) :
        m_energyType_(readEnergyType(context, in)),
        m_euroEmissionClass_(readEuroEmissionClass(context, in))
{
}

Engine::Engine(::zserio::PropagateAllocatorT,
        const Engine& other, const allocator_type& allocator) :
        m_energyType_(::zserio::allocatorPropagatingCopy(other.m_energyType_, allocator)),
        m_euroEmissionClass_(::zserio::allocatorPropagatingCopy(other.m_euroEmissionClass_, allocator))
{
}

::nds::core::vehicle::EnergyType Engine::getEnergyType() const
{
    return m_energyType_;
}

void Engine::setEnergyType(::nds::core::vehicle::EnergyType energyType_)
{
    m_energyType_ = energyType_;
}

::nds::core::vehicle::VehicleEuroEmissionClass Engine::getEuroEmissionClass() const
{
    return m_euroEmissionClass_;
}

void Engine::setEuroEmissionClass(::nds::core::vehicle::VehicleEuroEmissionClass euroEmissionClass_)
{
    m_euroEmissionClass_ = euroEmissionClass_;
}

void Engine::initPackingContext(Engine::ZserioPackingContext& context) const
{
    m_energyType_.initPackingContext(context.getEnergyType());
    m_euroEmissionClass_.initPackingContext(context.getEuroEmissionClass());
}

size_t Engine::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_energyType_.bitSizeOf(endBitPosition);
    endBitPosition += m_euroEmissionClass_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t Engine::bitSizeOf(Engine::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_energyType_.bitSizeOf(context.getEnergyType(), endBitPosition);
    endBitPosition += m_euroEmissionClass_.bitSizeOf(context.getEuroEmissionClass(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t Engine::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_energyType_.initializeOffsets(endBitPosition);
    endBitPosition = m_euroEmissionClass_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t Engine::initializeOffsets(Engine::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_energyType_.initializeOffsets(context.getEnergyType(), endBitPosition);
    endBitPosition = m_euroEmissionClass_.initializeOffsets(context.getEuroEmissionClass(), endBitPosition);

    return endBitPosition;
}

bool Engine::operator==(const Engine& other) const
{
    if (this != &other)
    {
        return
                (m_energyType_ == other.m_energyType_) &&
                (m_euroEmissionClass_ == other.m_euroEmissionClass_);
    }

    return true;
}

uint32_t Engine::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_energyType_);
    result = ::zserio::calcHashCode(result, m_euroEmissionClass_);

    return result;
}

void Engine::write(::zserio::BitStreamWriter& out) const
{
    m_energyType_.write(out);
    m_euroEmissionClass_.write(out);
}

void Engine::write(Engine::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_energyType_.write(context.getEnergyType(), out);
    m_euroEmissionClass_.write(context.getEuroEmissionClass(), out);
}

::nds::core::vehicle::EnergyType Engine::readEnergyType(::zserio::BitStreamReader& in)
{
    return ::nds::core::vehicle::EnergyType(in);
}

::nds::core::vehicle::EnergyType Engine::readEnergyType(Engine::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::nds::core::vehicle::EnergyType(context.getEnergyType(), in);
}
::nds::core::vehicle::VehicleEuroEmissionClass Engine::readEuroEmissionClass(::zserio::BitStreamReader& in)
{
    return ::nds::core::vehicle::VehicleEuroEmissionClass(in);
}

::nds::core::vehicle::VehicleEuroEmissionClass Engine::readEuroEmissionClass(Engine::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::nds::core::vehicle::VehicleEuroEmissionClass(context.getEuroEmissionClass(), in);
}

} // namespace vehicle
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/core/vehicle/AxleDetails.h>

namespace nds
{
namespace core
{
namespace vehicle
{

AxleDetails::AxleDetails(const allocator_type&) noexcept :
        m_numAxles_(::nds::core::vehicle::NumAxles()),
        m_maxTandemAxleWeight_(::nds::core::vehicle::AxleWeight()),
        m_maxTridemAxleWeight_(::nds::core::vehicle::AxleWeight()),
        m_maxSteeringAxleWeight_(::nds::core::vehicle::AxleWeight())
{
}

AxleDetails::AxleDetails(::zserio::BitStreamReader& in, const allocator_type&) :
        m_numAxles_(readNumAxles(in)),
        m_maxTandemAxleWeight_(readMaxTandemAxleWeight(in)),
        m_maxTridemAxleWeight_(readMaxTridemAxleWeight(in)),
        m_maxSteeringAxleWeight_(readMaxSteeringAxleWeight(in))
{
}

AxleDetails::AxleDetails(AxleDetails::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type&) :
        m_numAxles_(readNumAxles(context, in)),
        m_maxTandemAxleWeight_(readMaxTandemAxleWeight(context, in)),
        m_maxTridemAxleWeight_(readMaxTridemAxleWeight(context, in)),
        m_maxSteeringAxleWeight_(readMaxSteeringAxleWeight(context, in))
{
}

AxleDetails::AxleDetails(::zserio::PropagateAllocatorT,
        const AxleDetails& other, const allocator_type& allocator) :
        m_numAxles_(::zserio::allocatorPropagatingCopy(other.m_numAxles_, allocator)),
        m_maxTandemAxleWeight_(::zserio::allocatorPropagatingCopy(other.m_maxTandemAxleWeight_, allocator)),
        m_maxTridemAxleWeight_(::zserio::allocatorPropagatingCopy(other.m_maxTridemAxleWeight_, allocator)),
        m_maxSteeringAxleWeight_(::zserio::allocatorPropagatingCopy(other.m_maxSteeringAxleWeight_, allocator))
{
}

::nds::core::vehicle::NumAxles AxleDetails::getNumAxles() const
{
    return m_numAxles_;
}

void AxleDetails::setNumAxles(::nds::core::vehicle::NumAxles numAxles_)
{
    m_numAxles_ = numAxles_;
}

::nds::core::vehicle::AxleWeight AxleDetails::getMaxTandemAxleWeight() const
{
    return m_maxTandemAxleWeight_;
}

void AxleDetails::setMaxTandemAxleWeight(::nds::core::vehicle::AxleWeight maxTandemAxleWeight_)
{
    m_maxTandemAxleWeight_ = maxTandemAxleWeight_;
}

::nds::core::vehicle::AxleWeight AxleDetails::getMaxTridemAxleWeight() const
{
    return m_maxTridemAxleWeight_;
}

void AxleDetails::setMaxTridemAxleWeight(::nds::core::vehicle::AxleWeight maxTridemAxleWeight_)
{
    m_maxTridemAxleWeight_ = maxTridemAxleWeight_;
}

::nds::core::vehicle::AxleWeight AxleDetails::getMaxSteeringAxleWeight() const
{
    return m_maxSteeringAxleWeight_;
}

void AxleDetails::setMaxSteeringAxleWeight(::nds::core::vehicle::AxleWeight maxSteeringAxleWeight_)
{
    m_maxSteeringAxleWeight_ = maxSteeringAxleWeight_;
}

void AxleDetails::initPackingContext(AxleDetails::ZserioPackingContext& context) const
{
    context.getNumAxles().init<::zserio::StdIntArrayTraits<::nds::core::vehicle::NumAxles>>(m_numAxles_);
    context.getMaxTandemAxleWeight().init<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::AxleWeight>>(m_maxTandemAxleWeight_);
    context.getMaxTridemAxleWeight().init<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::AxleWeight>>(m_maxTridemAxleWeight_);
    context.getMaxSteeringAxleWeight().init<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::AxleWeight>>(m_maxSteeringAxleWeight_);
}

size_t AxleDetails::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(8);
    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_maxTandemAxleWeight_);
    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_maxTridemAxleWeight_);
    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_maxSteeringAxleWeight_);

    return endBitPosition - bitPosition;
}

size_t AxleDetails::bitSizeOf(AxleDetails::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumAxles().bitSizeOf<::zserio::StdIntArrayTraits<::nds::core::vehicle::NumAxles>>(m_numAxles_);
    endBitPosition += context.getMaxTandemAxleWeight().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::AxleWeight>>(m_maxTandemAxleWeight_);
    endBitPosition += context.getMaxTridemAxleWeight().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::AxleWeight>>(m_maxTridemAxleWeight_);
    endBitPosition += context.getMaxSteeringAxleWeight().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::AxleWeight>>(m_maxSteeringAxleWeight_);

    return endBitPosition - bitPosition;
}

size_t AxleDetails::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(8);
    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_maxTandemAxleWeight_);
    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_maxTridemAxleWeight_);
    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_maxSteeringAxleWeight_);

    return endBitPosition;
}

size_t AxleDetails::initializeOffsets(AxleDetails::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumAxles().bitSizeOf<::zserio::StdIntArrayTraits<::nds::core::vehicle::NumAxles>>(m_numAxles_);
    endBitPosition += context.getMaxTandemAxleWeight().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::AxleWeight>>(m_maxTandemAxleWeight_);
    endBitPosition += context.getMaxTridemAxleWeight().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::AxleWeight>>(m_maxTridemAxleWeight_);
    endBitPosition += context.getMaxSteeringAxleWeight().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::AxleWeight>>(m_maxSteeringAxleWeight_);

    return endBitPosition;
}

bool AxleDetails::operator==(const AxleDetails& other) const
{
    if (this != &other)
    {
        return
                (m_numAxles_ == other.m_numAxles_) &&
                (m_maxTandemAxleWeight_ == other.m_maxTandemAxleWeight_) &&
                (m_maxTridemAxleWeight_ == other.m_maxTridemAxleWeight_) &&
                (m_maxSteeringAxleWeight_ == other.m_maxSteeringAxleWeight_);
    }

    return true;
}

uint32_t AxleDetails::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_numAxles_);
    result = ::zserio::calcHashCode(result, m_maxTandemAxleWeight_);
    result = ::zserio::calcHashCode(result, m_maxTridemAxleWeight_);
    result = ::zserio::calcHashCode(result, m_maxSteeringAxleWeight_);

    return result;
}

void AxleDetails::write(::zserio::BitStreamWriter& out) const
{
    out.writeBits(m_numAxles_, UINT8_C(8));
    out.writeVarUInt32(m_maxTandemAxleWeight_);
    out.writeVarUInt32(m_maxTridemAxleWeight_);
    out.writeVarUInt32(m_maxSteeringAxleWeight_);
}

void AxleDetails::write(AxleDetails::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumAxles().write<::zserio::StdIntArrayTraits<::nds::core::vehicle::NumAxles>>(out, m_numAxles_);
    context.getMaxTandemAxleWeight().write<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::AxleWeight>>(out, m_maxTandemAxleWeight_);
    context.getMaxTridemAxleWeight().write<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::AxleWeight>>(out, m_maxTridemAxleWeight_);
    context.getMaxSteeringAxleWeight().write<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::AxleWeight>>(out, m_maxSteeringAxleWeight_);
}

::nds::core::vehicle::NumAxles AxleDetails::readNumAxles(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::vehicle::NumAxles>(in.readBits(UINT8_C(8)));
}

::nds::core::vehicle::NumAxles AxleDetails::readNumAxles(AxleDetails::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumAxles().read<::zserio::StdIntArrayTraits<::nds::core::vehicle::NumAxles>>(in);
}
::nds::core::vehicle::AxleWeight AxleDetails::readMaxTandemAxleWeight(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::vehicle::AxleWeight>(in.readVarUInt32());
}

::nds::core::vehicle::AxleWeight AxleDetails::readMaxTandemAxleWeight(AxleDetails::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getMaxTandemAxleWeight().read<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::AxleWeight>>(in);
}
::nds::core::vehicle::AxleWeight AxleDetails::readMaxTridemAxleWeight(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::vehicle::AxleWeight>(in.readVarUInt32());
}

::nds::core::vehicle::AxleWeight AxleDetails::readMaxTridemAxleWeight(AxleDetails::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getMaxTridemAxleWeight().read<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::AxleWeight>>(in);
}
::nds::core::vehicle::AxleWeight AxleDetails::readMaxSteeringAxleWeight(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::vehicle::AxleWeight>(in.readVarUInt32());
}

::nds::core::vehicle::AxleWeight AxleDetails::readMaxSteeringAxleWeight(AxleDetails::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getMaxSteeringAxleWeight().read<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::AxleWeight>>(in);
}

} // namespace vehicle
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/core/vehicle/VehicleDetails.h>

namespace nds
{
namespace core
{
namespace vehicle
{

VehicleDetails::VehicleDetails(const allocator_type& allocator) noexcept :
        m_vehicleType_(allocator),
        m_vehicleClassSpecification_(allocator),
        m_tunnelRestriction_(::nds::core::vehicle::AdrTunnelRestriction()),
        m_maxSpeed_(::nds::core::types::SpeedKmh()),
        m_combustionConsumption_(::zserio::NullOpt),
        m_electricConsumption_(::zserio::NullOpt),
        m_engineManufacturingYear_(::zserio::NullOpt),
        m_licensePlate_(::zserio::NullOpt),
        m_registrationCountry_(::zserio::NullOpt),
        m_currentOccupancy_(::zserio::NullOpt)
{
}

VehicleDetails::VehicleDetails(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_vehicleType_(readVehicleType(in, allocator)),
        m_vehicleClassSpecification_(readVehicleClassSpecification(in, allocator)),
        m_tunnelRestriction_(readTunnelRestriction(in)),
        m_maxSpeed_(readMaxSpeed(in)),
        m_combustionConsumption_(readCombustionConsumption(in, allocator)),
        m_electricConsumption_(readElectricConsumption(in, allocator)),
        m_engineManufacturingYear_(readEngineManufacturingYear(in)),
        m_licensePlate_(readLicensePlate(in, allocator)),
        m_registrationCountry_(readRegistrationCountry(in, allocator)),
        m_currentOccupancy_(readCurrentOccupancy(in))
{
}

VehicleDetails::VehicleDetails(VehicleDetails::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_vehicleType_(readVehicleType(context, in, allocator)),
        m_vehicleClassSpecification_(readVehicleClassSpecification(context, in, allocator)),
        m_tunnelRestriction_(readTunnelRestriction(context, in)),
        m_maxSpeed_(readMaxSpeed(context, in)),
        m_combustionConsumption_(readCombustionConsumption(context, in, allocator)),
        m_electricConsumption_(readElectricConsumption(context, in, allocator)),
        m_engineManufacturingYear_(readEngineManufacturingYear(context, in)),
        m_licensePlate_(readLicensePlate(in, allocator)),
        m_registrationCountry_(readRegistrationCountry(in, allocator)),
        m_currentOccupancy_(readCurrentOccupancy(context, in))
{
}

VehicleDetails::VehicleDetails(::zserio::PropagateAllocatorT,
        const VehicleDetails& other, const allocator_type& allocator) :
        m_vehicleType_(::zserio::allocatorPropagatingCopy(other.m_vehicleType_, allocator)),
        m_vehicleClassSpecification_(::zserio::allocatorPropagatingCopy(other.m_vehicleClassSpecification_, allocator)),
        m_tunnelRestriction_(::zserio::allocatorPropagatingCopy(other.m_tunnelRestriction_, allocator)),
        m_maxSpeed_(::zserio::allocatorPropagatingCopy(other.m_maxSpeed_, allocator)),
        m_combustionConsumption_(::zserio::allocatorPropagatingCopy(other.m_combustionConsumption_, allocator)),
        m_electricConsumption_(::zserio::allocatorPropagatingCopy(other.m_electricConsumption_, allocator)),
        m_engineManufacturingYear_(::zserio::allocatorPropagatingCopy(other.m_engineManufacturingYear_, allocator)),
        m_licensePlate_(::zserio::allocatorPropagatingCopy(other.m_licensePlate_, allocator)),
        m_registrationCountry_(::zserio::allocatorPropagatingCopy(other.m_registrationCountry_, allocator)),
        m_currentOccupancy_(::zserio::allocatorPropagatingCopy(other.m_currentOccupancy_, allocator))
{
}

::nds::core::vehicle::VehicleTypeInformation& VehicleDetails::getVehicleType()
{
    return m_vehicleType_;
}

const ::nds::core::vehicle::VehicleTypeInformation& VehicleDetails::getVehicleType() const
{
    return m_vehicleType_;
}

void VehicleDetails::setVehicleType(const ::nds::core::vehicle::VehicleTypeInformation& vehicleType_)
{
    m_vehicleType_ = vehicleType_;
}

void VehicleDetails::setVehicleType(::nds::core::vehicle::VehicleTypeInformation&& vehicleType_)
{
    m_vehicleType_ = ::std::move(vehicleType_);
}

::nds::core::vehicle::VehicleClassSpecification& VehicleDetails::getVehicleClassSpecification()
{
    return m_vehicleClassSpecification_;
}

const ::nds::core::vehicle::VehicleClassSpecification& VehicleDetails::getVehicleClassSpecification() const
{
    return m_vehicleClassSpecification_;
}

void VehicleDetails::setVehicleClassSpecification(const ::nds::core::vehicle::VehicleClassSpecification& vehicleClassSpecification_)
{
    m_vehicleClassSpecification_ = vehicleClassSpecification_;
}

void VehicleDetails::setVehicleClassSpecification(::nds::core::vehicle::VehicleClassSpecification&& vehicleClassSpecification_)
{
    m_vehicleClassSpecification_ = ::std::move(vehicleClassSpecification_);
}

::nds::core::vehicle::AdrTunnelRestriction VehicleDetails::getTunnelRestriction() const
{
    return m_tunnelRestriction_;
}

void VehicleDetails::setTunnelRestriction(::nds::core::vehicle::AdrTunnelRestriction tunnelRestriction_)
{
    m_tunnelRestriction_ = tunnelRestriction_;
}

::nds::core::types::SpeedKmh VehicleDetails::getMaxSpeed() const
{
    return m_maxSpeed_;
}

void VehicleDetails::setMaxSpeed(::nds::core::types::SpeedKmh maxSpeed_)
{
    m_maxSpeed_ = maxSpeed_;
}

::nds::core::vehicle::CombustionConsumption& VehicleDetails::getCombustionConsumption()
{
    return m_combustionConsumption_.value();
}

const ::nds::core::vehicle::CombustionConsumption& VehicleDetails::getCombustionConsumption() const
{
    return m_combustionConsumption_.value();
}

void VehicleDetails::setCombustionConsumption(const ::nds::core::vehicle::CombustionConsumption& combustionConsumption_)
{
    m_combustionConsumption_ = combustionConsumption_;
}

void VehicleDetails::setCombustionConsumption(::nds::core::vehicle::CombustionConsumption&& combustionConsumption_)
{
    m_combustionConsumption_ = ::std::move(combustionConsumption_);
}

bool VehicleDetails::isCombustionConsumptionUsed() const
{
    return (isCombustionConsumptionSet());
}

bool VehicleDetails::isCombustionConsumptionSet() const
{
    return m_combustionConsumption_.hasValue();
}

void VehicleDetails::resetCombustionConsumption()
{
    m_combustionConsumption_.reset();
}

::nds::core::vehicle::ElectricConsumption& VehicleDetails::getElectricConsumption()
{
    return m_electricConsumption_.value();
}

const ::nds::core::vehicle::ElectricConsumption& VehicleDetails::getElectricConsumption() const
{
    return m_electricConsumption_.value();
}

void VehicleDetails::setElectricConsumption(const ::nds::core::vehicle::ElectricConsumption& electricConsumption_)
{
    m_electricConsumption_ = electricConsumption_;
}

void VehicleDetails::setElectricConsumption(::nds::core::vehicle::ElectricConsumption&& electricConsumption_)
{
    m_electricConsumption_ = ::std::move(electricConsumption_);
}

bool VehicleDetails::isElectricConsumptionUsed() const
{
    return (isElectricConsumptionSet());
}

bool VehicleDetails::isElectricConsumptionSet() const
{
    return m_electricConsumption_.hasValue();
}

void VehicleDetails::resetElectricConsumption()
{
    m_electricConsumption_.reset();
}

::nds::core::types::Year VehicleDetails::getEngineManufacturingYear() const
{
    return m_engineManufacturingYear_.value();
}

void VehicleDetails::setEngineManufacturingYear(::nds::core::types::Year engineManufacturingYear_)
{
    m_engineManufacturingYear_ = engineManufacturingYear_;
}

bool VehicleDetails::isEngineManufacturingYearUsed() const
{
    return (isEngineManufacturingYearSet());
}

bool VehicleDetails::isEngineManufacturingYearSet() const
{
    return m_engineManufacturingYear_.hasValue();
}

void VehicleDetails::resetEngineManufacturingYear()
{
    m_engineManufacturingYear_.reset();
}

::zserio::string<>& VehicleDetails::getLicensePlate()
{
    return m_licensePlate_.value();
}

const ::zserio::string<>& VehicleDetails::getLicensePlate() const
{
    return m_licensePlate_.value();
}

void VehicleDetails::setLicensePlate(const ::zserio::string<>& licensePlate_)
{
    m_licensePlate_ = licensePlate_;
}

void VehicleDetails::setLicensePlate(::zserio::string<>&& licensePlate_)
{
    m_licensePlate_ = ::std::move(licensePlate_);
}

bool VehicleDetails::isLicensePlateUsed() const
{
    return (isLicensePlateSet());
}

bool VehicleDetails::isLicensePlateSet() const
{
    return m_licensePlate_.hasValue();
}

void VehicleDetails::resetLicensePlate()
{
    m_licensePlate_.reset();
}

::nds::core::types::IsoCountryCode& VehicleDetails::getRegistrationCountry()
{
    return m_registrationCountry_.value();
}

const ::nds::core::types::IsoCountryCode& VehicleDetails::getRegistrationCountry() const
{
    return m_registrationCountry_.value();
}

void VehicleDetails::setRegistrationCountry(const ::nds::core::types::IsoCountryCode& registrationCountry_)
{
    m_registrationCountry_ = registrationCountry_;
}

void VehicleDetails::setRegistrationCountry(::nds::core::types::IsoCountryCode&& registrationCountry_)
{
    m_registrationCountry_ = ::std::move(registrationCountry_);
}

bool VehicleDetails::isRegistrationCountryUsed() const
{
    return (isRegistrationCountrySet());
}

bool VehicleDetails::isRegistrationCountrySet() const
{
    return m_registrationCountry_.hasValue();
}

void VehicleDetails::resetRegistrationCountry()
{
    m_registrationCountry_.reset();
}

uint16_t VehicleDetails::getCurrentOccupancy() const
{
    return m_currentOccupancy_.value();
}

void VehicleDetails::setCurrentOccupancy(uint16_t currentOccupancy_)
{
    m_currentOccupancy_ = currentOccupancy_;
}

bool VehicleDetails::isCurrentOccupancyUsed() const
{
    return (isCurrentOccupancySet());
}

bool VehicleDetails::isCurrentOccupancySet() const
{
    return m_currentOccupancy_.hasValue();
}

void VehicleDetails::resetCurrentOccupancy()
{
    m_currentOccupancy_.reset();
}

void VehicleDetails::initPackingContext(VehicleDetails::ZserioPackingContext& context) const
{
    m_vehicleType_.initPackingContext(context.getVehicleType());
    m_vehicleClassSpecification_.initPackingContext(context.getVehicleClassSpecification());
    ::zserio::initPackingContext(context.getTunnelRestriction(), m_tunnelRestriction_);
    context.getMaxSpeed().init<::zserio::StdIntArrayTraits<::nds::core::types::SpeedKmh>>(m_maxSpeed_);
    if (isCombustionConsumptionSet())
    {
        m_combustionConsumption_.value().initPackingContext(context.getCombustionConsumption());
    }
    if (isElectricConsumptionSet())
    {
        m_electricConsumption_.value().initPackingContext(context.getElectricConsumption());
    }
    if (isEngineManufacturingYearSet())
    {
        context.getEngineManufacturingYear().init<::zserio::StdIntArrayTraits<::nds::core::types::Year>>(m_engineManufacturingYear_.value());
    }
    if (isCurrentOccupancySet())
    {
        context.getCurrentOccupancy().init<::zserio::VarIntNNArrayTraits<uint16_t>>(m_currentOccupancy_.value());
    }
}

size_t VehicleDetails::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_vehicleType_.bitSizeOf(endBitPosition);
    endBitPosition += m_vehicleClassSpecification_.bitSizeOf(endBitPosition);
    endBitPosition += ::zserio::bitSizeOf(m_tunnelRestriction_);
    endBitPosition += UINT8_C(8);
    endBitPosition += 1;
    if (isCombustionConsumptionSet())
    {
        endBitPosition += m_combustionConsumption_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition += 1;
    if (isElectricConsumptionSet())
    {
        endBitPosition += m_electricConsumption_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition += 1;
    if (isEngineManufacturingYearSet())
    {
        endBitPosition += UINT8_C(16);
    }
    endBitPosition += 1;
    if (isLicensePlateSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_licensePlate_.value());
    }
    endBitPosition += 1;
    if (isRegistrationCountrySet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_registrationCountry_.value());
    }
    endBitPosition += 1;
    if (isCurrentOccupancySet())
    {
        endBitPosition += ::zserio::bitSizeOfVarUInt16(m_currentOccupancy_.value());
    }

    return endBitPosition - bitPosition;
}

size_t VehicleDetails::bitSizeOf(VehicleDetails::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_vehicleType_.bitSizeOf(context.getVehicleType(), endBitPosition);
    endBitPosition += m_vehicleClassSpecification_.bitSizeOf(context.getVehicleClassSpecification(), endBitPosition);
    endBitPosition += ::zserio::bitSizeOf(context.getTunnelRestriction(), m_tunnelRestriction_);
    endBitPosition += context.getMaxSpeed().bitSizeOf<::zserio::StdIntArrayTraits<::nds::core::types::SpeedKmh>>(m_maxSpeed_);
    endBitPosition += 1;
    if (isCombustionConsumptionSet())
    {
        endBitPosition += m_combustionConsumption_.value().bitSizeOf(context.getCombustionConsumption(), endBitPosition);
    }
    endBitPosition += 1;
    if (isElectricConsumptionSet())
    {
        endBitPosition += m_electricConsumption_.value().bitSizeOf(context.getElectricConsumption(), endBitPosition);
    }
    endBitPosition += 1;
    if (isEngineManufacturingYearSet())
    {
        endBitPosition += context.getEngineManufacturingYear().bitSizeOf<::zserio::StdIntArrayTraits<::nds::core::types::Year>>(m_engineManufacturingYear_.value());
    }
    endBitPosition += 1;
    if (isLicensePlateSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_licensePlate_.value());
    }
    endBitPosition += 1;
    if (isRegistrationCountrySet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_registrationCountry_.value());
    }
    endBitPosition += 1;
    if (isCurrentOccupancySet())
    {
        endBitPosition += context.getCurrentOccupancy().bitSizeOf<::zserio::VarIntNNArrayTraits<uint16_t>>(m_currentOccupancy_.value());
    }

    return endBitPosition - bitPosition;
}

size_t VehicleDetails::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_vehicleType_.initializeOffsets(endBitPosition);
    endBitPosition = m_vehicleClassSpecification_.initializeOffsets(endBitPosition);
    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_tunnelRestriction_);
    endBitPosition += UINT8_C(8);
    endBitPosition += 1;
    if (isCombustionConsumptionSet())
    {
        endBitPosition = m_combustionConsumption_.value().initializeOffsets(endBitPosition);
    }
    endBitPosition += 1;
    if (isElectricConsumptionSet())
    {
        endBitPosition = m_electricConsumption_.value().initializeOffsets(endBitPosition);
    }
    endBitPosition += 1;
    if (isEngineManufacturingYearSet())
    {
        endBitPosition += UINT8_C(16);
    }
    endBitPosition += 1;
    if (isLicensePlateSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_licensePlate_.value());
    }
    endBitPosition += 1;
    if (isRegistrationCountrySet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_registrationCountry_.value());
    }
    endBitPosition += 1;
    if (isCurrentOccupancySet())
    {
        endBitPosition += ::zserio::bitSizeOfVarUInt16(m_currentOccupancy_.value());
    }

    return endBitPosition;
}

size_t VehicleDetails::initializeOffsets(VehicleDetails::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_vehicleType_.initializeOffsets(context.getVehicleType(), endBitPosition);
    endBitPosition = m_vehicleClassSpecification_.initializeOffsets(context.getVehicleClassSpecification(), endBitPosition);
    endBitPosition = ::zserio::initializeOffsets(context.getTunnelRestriction(), endBitPosition,
        m_tunnelRestriction_);
    endBitPosition += context.getMaxSpeed().bitSizeOf<::zserio::StdIntArrayTraits<::nds::core::types::SpeedKmh>>(m_maxSpeed_);
    endBitPosition += 1;
    if (isCombustionConsumptionSet())
    {
        endBitPosition = m_combustionConsumption_.value().initializeOffsets(context.getCombustionConsumption(), endBitPosition);
    }
    endBitPosition += 1;
    if (isElectricConsumptionSet())
    {
        endBitPosition = m_electricConsumption_.value().initializeOffsets(context.getElectricConsumption(), endBitPosition);
    }
    endBitPosition += 1;
    if (isEngineManufacturingYearSet())
    {
        endBitPosition += context.getEngineManufacturingYear().bitSizeOf<::zserio::StdIntArrayTraits<::nds::core::types::Year>>(m_engineManufacturingYear_.value());
    }
    endBitPosition += 1;
    if (isLicensePlateSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_licensePlate_.value());
    }
    endBitPosition += 1;
    if (isRegistrationCountrySet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_registrationCountry_.value());
    }
    endBitPosition += 1;
    if (isCurrentOccupancySet())
    {
        endBitPosition += context.getCurrentOccupancy().bitSizeOf<::zserio::VarIntNNArrayTraits<uint16_t>>(m_currentOccupancy_.value());
    }

    return endBitPosition;
}

bool VehicleDetails::operator==(const VehicleDetails& other) const
{
    if (this != &other)
    {
        return
                (m_vehicleType_ == other.m_vehicleType_) &&
                (m_vehicleClassSpecification_ == other.m_vehicleClassSpecification_) &&
                (m_tunnelRestriction_ == other.m_tunnelRestriction_) &&
                (m_maxSpeed_ == other.m_maxSpeed_) &&
                (!isCombustionConsumptionUsed() ? !other.isCombustionConsumptionUsed() : (m_combustionConsumption_ == other.m_combustionConsumption_)) &&
                (!isElectricConsumptionUsed() ? !other.isElectricConsumptionUsed() : (m_electricConsumption_ == other.m_electricConsumption_)) &&
                (!isEngineManufacturingYearUsed() ? !other.isEngineManufacturingYearUsed() : (m_engineManufacturingYear_ == other.m_engineManufacturingYear_)) &&
                (!isLicensePlateUsed() ? !other.isLicensePlateUsed() : (m_licensePlate_ == other.m_licensePlate_)) &&
                (!isRegistrationCountryUsed() ? !other.isRegistrationCountryUsed() : (m_registrationCountry_ == other.m_registrationCountry_)) &&
                (!isCurrentOccupancyUsed() ? !other.isCurrentOccupancyUsed() : (m_currentOccupancy_ == other.m_currentOccupancy_));
    }

    return true;
}

uint32_t VehicleDetails::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_vehicleType_);
    result = ::zserio::calcHashCode(result, m_vehicleClassSpecification_);
    result = ::zserio::calcHashCode(result, m_tunnelRestriction_);
    result = ::zserio::calcHashCode(result, m_maxSpeed_);
    if (isCombustionConsumptionUsed())
        result = ::zserio::calcHashCode(result, m_combustionConsumption_);
    if (isElectricConsumptionUsed())
        result = ::zserio::calcHashCode(result, m_electricConsumption_);
    if (isEngineManufacturingYearUsed())
        result = ::zserio::calcHashCode(result, m_engineManufacturingYear_);
    if (isLicensePlateUsed())
        result = ::zserio::calcHashCode(result, m_licensePlate_);
    if (isRegistrationCountryUsed())
        result = ::zserio::calcHashCode(result, m_registrationCountry_);
    if (isCurrentOccupancyUsed())
        result = ::zserio::calcHashCode(result, m_currentOccupancy_);

    return result;
}

void VehicleDetails::write(::zserio::BitStreamWriter& out) const
{
    m_vehicleType_.write(out);
    m_vehicleClassSpecification_.write(out);
    ::zserio::write(out, m_tunnelRestriction_);
    out.writeBits(m_maxSpeed_, UINT8_C(8));
    if (isCombustionConsumptionSet())
    {
        out.writeBool(true);
        m_combustionConsumption_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
    if (isElectricConsumptionSet())
    {
        out.writeBool(true);
        m_electricConsumption_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
    if (isEngineManufacturingYearSet())
    {
        out.writeBool(true);
        out.writeSignedBits(m_engineManufacturingYear_.value(), UINT8_C(16));
    }
    else
    {
        out.writeBool(false);
    }
    if (isLicensePlateSet())
    {
        out.writeBool(true);
        out.writeString(m_licensePlate_.value());
    }
    else
    {
        out.writeBool(false);
    }
    if (isRegistrationCountrySet())
    {
        out.writeBool(true);
        out.writeString(m_registrationCountry_.value());
    }
    else
    {
        out.writeBool(false);
    }
    if (isCurrentOccupancySet())
    {
        out.writeBool(true);
        out.writeVarUInt16(m_currentOccupancy_.value());
    }
    else
    {
        out.writeBool(false);
    }
}

void VehicleDetails::write(VehicleDetails::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_vehicleType_.write(context.getVehicleType(), out);
    m_vehicleClassSpecification_.write(context.getVehicleClassSpecification(), out);
    ::zserio::write(context.getTunnelRestriction(), out, m_tunnelRestriction_);
    context.getMaxSpeed().write<::zserio::StdIntArrayTraits<::nds::core::types::SpeedKmh>>(out, m_maxSpeed_);
    if (isCombustionConsumptionSet())
    {
        out.writeBool(true);
        m_combustionConsumption_.value().write(context.getCombustionConsumption(), out);
    }
    else
    {
        out.writeBool(false);
    }
    if (isElectricConsumptionSet())
    {
        out.writeBool(true);
        m_electricConsumption_.value().write(context.getElectricConsumption(), out);
    }
    else
    {
        out.writeBool(false);
    }
    if (isEngineManufacturingYearSet())
    {
        out.writeBool(true);
        context.getEngineManufacturingYear().write<::zserio::StdIntArrayTraits<::nds::core::types::Year>>(out, m_engineManufacturingYear_.value());
    }
    else
    {
        out.writeBool(false);
    }
    if (isLicensePlateSet())
    {
        out.writeBool(true);
        out.writeString(m_licensePlate_.value());
    }
    else
    {
        out.writeBool(false);
    }
    if (isRegistrationCountrySet())
    {
        out.writeBool(true);
        out.writeString(m_registrationCountry_.value());
    }
    else
    {
        out.writeBool(false);
    }
    if (isCurrentOccupancySet())
    {
        out.writeBool(true);
        context.getCurrentOccupancy().write<::zserio::VarIntNNArrayTraits<uint16_t>>(out, m_currentOccupancy_.value());
    }
    else
    {
        out.writeBool(false);
    }
}

::nds::core::vehicle::VehicleTypeInformation VehicleDetails::readVehicleType(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::vehicle::VehicleTypeInformation(in, allocator);
}

::nds::core::vehicle::VehicleTypeInformation VehicleDetails::readVehicleType(VehicleDetails::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::vehicle::VehicleTypeInformation(context.getVehicleType(), in, allocator);
}
::nds::core::vehicle::VehicleClassSpecification VehicleDetails::readVehicleClassSpecification(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::vehicle::VehicleClassSpecification(in, allocator);
}

::nds::core::vehicle::VehicleClassSpecification VehicleDetails::readVehicleClassSpecification(VehicleDetails::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::vehicle::VehicleClassSpecification(context.getVehicleClassSpecification(), in, allocator);
}
::nds::core::vehicle::AdrTunnelRestriction VehicleDetails::readTunnelRestriction(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::core::vehicle::AdrTunnelRestriction>(in);
}

::nds::core::vehicle::AdrTunnelRestriction VehicleDetails::readTunnelRestriction(VehicleDetails::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::core::vehicle::AdrTunnelRestriction>(context.getTunnelRestriction(), in);
}
::nds::core::types::SpeedKmh VehicleDetails::readMaxSpeed(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::types::SpeedKmh>(in.readBits(UINT8_C(8)));
}

::nds::core::types::SpeedKmh VehicleDetails::readMaxSpeed(VehicleDetails::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getMaxSpeed().read<::zserio::StdIntArrayTraits<::nds::core::types::SpeedKmh>>(in);
}
::zserio::InplaceOptionalHolder<::nds::core::vehicle::CombustionConsumption> VehicleDetails::readCombustionConsumption(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::CombustionConsumption>(::nds::core::vehicle::CombustionConsumption(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::CombustionConsumption>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::vehicle::CombustionConsumption> VehicleDetails::readCombustionConsumption(VehicleDetails::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::CombustionConsumption>(::nds::core::vehicle::CombustionConsumption(context.getCombustionConsumption(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::CombustionConsumption>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::core::vehicle::ElectricConsumption> VehicleDetails::readElectricConsumption(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::ElectricConsumption>(::nds::core::vehicle::ElectricConsumption(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::ElectricConsumption>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::vehicle::ElectricConsumption> VehicleDetails::readElectricConsumption(VehicleDetails::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::ElectricConsumption>(::nds::core::vehicle::ElectricConsumption(context.getElectricConsumption(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::ElectricConsumption>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::core::types::Year> VehicleDetails::readEngineManufacturingYear(::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::types::Year>(static_cast<::nds::core::types::Year>(in.readSignedBits(UINT8_C(16))));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::types::Year>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::types::Year> VehicleDetails::readEngineManufacturingYear(VehicleDetails::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::types::Year>(context.getEngineManufacturingYear().read<::zserio::StdIntArrayTraits<::nds::core::types::Year>>(in));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::types::Year>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::zserio::string<>> VehicleDetails::readLicensePlate(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::zserio::string<>>(static_cast<::zserio::string<>>(in.readString(allocator)));
    }

    return ::zserio::InplaceOptionalHolder<::zserio::string<>>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::core::types::IsoCountryCode> VehicleDetails::readRegistrationCountry(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::types::IsoCountryCode>(static_cast<::nds::core::types::IsoCountryCode>(in.readString(allocator)));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::types::IsoCountryCode>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<uint16_t> VehicleDetails::readCurrentOccupancy(::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<uint16_t>(static_cast<uint16_t>(in.readVarUInt16()));
    }

    return ::zserio::InplaceOptionalHolder<uint16_t>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<uint16_t> VehicleDetails::readCurrentOccupancy(VehicleDetails::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<uint16_t>(context.getCurrentOccupancy().read<::zserio::VarIntNNArrayTraits<uint16_t>>(in));
    }

    return ::zserio::InplaceOptionalHolder<uint16_t>(::zserio::NullOpt);
}

} // namespace vehicle
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/core/vehicle/CombustionConsumption.h>

namespace nds
{
namespace core
{
namespace vehicle
{

CombustionConsumption::CombustionConsumption(const allocator_type& allocator) noexcept :
        m_currentFuelSupply_(::nds::core::vehicle::FuelLiters()),
        m_auxConsumption_(::zserio::NullOpt),
        m_normalConsumption_(allocator),
        m_trafficConsumption_(::zserio::NullOpt),
        m_efficiency_(::zserio::NullOpt)
{
}

CombustionConsumption::CombustionConsumption(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_currentFuelSupply_(readCurrentFuelSupply(in)),
        m_auxConsumption_(readAuxConsumption(in)),
        m_normalConsumption_(readNormalConsumption(in, allocator)),
        m_trafficConsumption_(readTrafficConsumption(in, allocator)),
        m_efficiency_(readEfficiency(in, allocator))
{
}

CombustionConsumption::CombustionConsumption(CombustionConsumption::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_currentFuelSupply_(readCurrentFuelSupply(in)),
        m_auxConsumption_(readAuxConsumption(in)),
        m_normalConsumption_(readNormalConsumption(context, in, allocator)),
        m_trafficConsumption_(readTrafficConsumption(context, in, allocator)),
        m_efficiency_(readEfficiency(context, in, allocator))
{
}

CombustionConsumption::CombustionConsumption(::zserio::PropagateAllocatorT,
        const CombustionConsumption& other, const allocator_type& allocator) :
        m_currentFuelSupply_(::zserio::allocatorPropagatingCopy(other.m_currentFuelSupply_, allocator)),
        m_auxConsumption_(::zserio::allocatorPropagatingCopy(other.m_auxConsumption_, allocator)),
        m_normalConsumption_(::zserio::allocatorPropagatingCopy(other.m_normalConsumption_, allocator)),
        m_trafficConsumption_(::zserio::allocatorPropagatingCopy(other.m_trafficConsumption_, allocator)),
        m_efficiency_(::zserio::allocatorPropagatingCopy(other.m_efficiency_, allocator))
{
}

::nds::core::vehicle::FuelLiters CombustionConsumption::getCurrentFuelSupply() const
{
    return m_currentFuelSupply_;
}

void CombustionConsumption::setCurrentFuelSupply(::nds::core::vehicle::FuelLiters currentFuelSupply_)
{
    m_currentFuelSupply_ = currentFuelSupply_;
}

::nds::core::vehicle::LitersPerHour CombustionConsumption::getAuxConsumption() const
{
    return m_auxConsumption_.value();
}

void CombustionConsumption::setAuxConsumption(::nds::core::vehicle::LitersPerHour auxConsumption_)
{
    m_auxConsumption_ = auxConsumption_;
}

bool CombustionConsumption::isAuxConsumptionUsed() const
{
    return (isAuxConsumptionSet());
}

bool CombustionConsumption::isAuxConsumptionSet() const
{
    return m_auxConsumption_.hasValue();
}

void CombustionConsumption::resetAuxConsumption()
{
    m_auxConsumption_.reset();
}

::nds::core::vehicle::CombustionConsumptionCurve& CombustionConsumption::getNormalConsumption()
{
    return m_normalConsumption_;
}

const ::nds::core::vehicle::CombustionConsumptionCurve& CombustionConsumption::getNormalConsumption() const
{
    return m_normalConsumption_;
}

void CombustionConsumption::setNormalConsumption(const ::nds::core::vehicle::CombustionConsumptionCurve& normalConsumption_)
{
    m_normalConsumption_ = normalConsumption_;
}

void CombustionConsumption::setNormalConsumption(::nds::core::vehicle::CombustionConsumptionCurve&& normalConsumption_)
{
    m_normalConsumption_ = ::std::move(normalConsumption_);
}

::nds::core::vehicle::CombustionConsumptionCurve& CombustionConsumption::getTrafficConsumption()
{
    return m_trafficConsumption_.value();
}

const ::nds::core::vehicle::CombustionConsumptionCurve& CombustionConsumption::getTrafficConsumption() const
{
    return m_trafficConsumption_.value();
}

void CombustionConsumption::setTrafficConsumption(const ::nds::core::vehicle::CombustionConsumptionCurve& trafficConsumption_)
{
    m_trafficConsumption_ = trafficConsumption_;
}

void CombustionConsumption::setTrafficConsumption(::nds::core::vehicle::CombustionConsumptionCurve&& trafficConsumption_)
{
    m_trafficConsumption_ = ::std::move(trafficConsumption_);
}

bool CombustionConsumption::isTrafficConsumptionUsed() const
{
    return (isTrafficConsumptionSet());
}

bool CombustionConsumption::isTrafficConsumptionSet() const
{
    return m_trafficConsumption_.hasValue();
}

void CombustionConsumption::resetTrafficConsumption()
{
    m_trafficConsumption_.reset();
}

::nds::core::vehicle::ConsumptionEfficiency& CombustionConsumption::getEfficiency()
{
    return m_efficiency_.value();
}

const ::nds::core::vehicle::ConsumptionEfficiency& CombustionConsumption::getEfficiency() const
{
    return m_efficiency_.value();
}

void CombustionConsumption::setEfficiency(const ::nds::core::vehicle::ConsumptionEfficiency& efficiency_)
{
    m_efficiency_ = efficiency_;
}

void CombustionConsumption::setEfficiency(::nds::core::vehicle::ConsumptionEfficiency&& efficiency_)
{
    m_efficiency_ = ::std::move(efficiency_);
}

bool CombustionConsumption::isEfficiencyUsed() const
{
    return (isEfficiencySet());
}

bool CombustionConsumption::isEfficiencySet() const
{
    return m_efficiency_.hasValue();
}

void CombustionConsumption::resetEfficiency()
{
    m_efficiency_.reset();
}

void CombustionConsumption::initPackingContext(CombustionConsumption::ZserioPackingContext& context) const
{
    m_normalConsumption_.initPackingContext(context.getNormalConsumption());
    if (isTrafficConsumptionSet())
    {
        m_trafficConsumption_.value().initPackingContext(context.getTrafficConsumption());
    }
    if (isEfficiencySet())
    {
        m_efficiency_.value().initPackingContext(context.getEfficiency());
    }
}

size_t CombustionConsumption::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(16);
    endBitPosition += 1;
    if (isAuxConsumptionSet())
    {
        endBitPosition += UINT8_C(16);
    }
    endBitPosition += m_normalConsumption_.bitSizeOf(endBitPosition);
    endBitPosition += 1;
    if (isTrafficConsumptionSet())
    {
        endBitPosition += m_trafficConsumption_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition += 1;
    if (isEfficiencySet())
    {
        endBitPosition += m_efficiency_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t CombustionConsumption::bitSizeOf(CombustionConsumption::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(16);
    endBitPosition += 1;
    if (isAuxConsumptionSet())
    {
        endBitPosition += UINT8_C(16);
    }
    endBitPosition += m_normalConsumption_.bitSizeOf(context.getNormalConsumption(), endBitPosition);
    endBitPosition += 1;
    if (isTrafficConsumptionSet())
    {
        endBitPosition += m_trafficConsumption_.value().bitSizeOf(context.getTrafficConsumption(), endBitPosition);
    }
    endBitPosition += 1;
    if (isEfficiencySet())
    {
        endBitPosition += m_efficiency_.value().bitSizeOf(context.getEfficiency(), endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t CombustionConsumption::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(16);
    endBitPosition += 1;
    if (isAuxConsumptionSet())
    {
        endBitPosition += UINT8_C(16);
    }
    endBitPosition = m_normalConsumption_.initializeOffsets(endBitPosition);
    endBitPosition += 1;
    if (isTrafficConsumptionSet())
    {
        endBitPosition = m_trafficConsumption_.value().initializeOffsets(endBitPosition);
    }
    endBitPosition += 1;
    if (isEfficiencySet())
    {
        endBitPosition = m_efficiency_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

size_t CombustionConsumption::initializeOffsets(CombustionConsumption::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(16);
    endBitPosition += 1;
    if (isAuxConsumptionSet())
    {
        endBitPosition += UINT8_C(16);
    }
    endBitPosition = m_normalConsumption_.initializeOffsets(context.getNormalConsumption(), endBitPosition);
    endBitPosition += 1;
    if (isTrafficConsumptionSet())
    {
        endBitPosition = m_trafficConsumption_.value().initializeOffsets(context.getTrafficConsumption(), endBitPosition);
    }
    endBitPosition += 1;
    if (isEfficiencySet())
    {
        endBitPosition = m_efficiency_.value().initializeOffsets(context.getEfficiency(), endBitPosition);
    }

    return endBitPosition;
}

bool CombustionConsumption::operator==(const CombustionConsumption& other) const
{
    if (this != &other)
    {
        return
                (m_currentFuelSupply_ == other.m_currentFuelSupply_) &&
                (!isAuxConsumptionUsed() ? !other.isAuxConsumptionUsed() : (m_auxConsumption_ == other.m_auxConsumption_)) &&
                (m_normalConsumption_ == other.m_normalConsumption_) &&
                (!isTrafficConsumptionUsed() ? !other.isTrafficConsumptionUsed() : (m_trafficConsumption_ == other.m_trafficConsumption_)) &&
                (!isEfficiencyUsed() ? !other.isEfficiencyUsed() : (m_efficiency_ == other.m_efficiency_));
    }

    return true;
}

uint32_t CombustionConsumption::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_currentFuelSupply_);
    if (isAuxConsumptionUsed())
        result = ::zserio::calcHashCode(result, m_auxConsumption_);
    result = ::zserio::calcHashCode(result, m_normalConsumption_);
    if (isTrafficConsumptionUsed())
        result = ::zserio::calcHashCode(result, m_trafficConsumption_);
    if (isEfficiencyUsed())
        result = ::zserio::calcHashCode(result, m_efficiency_);

    return result;
}

void CombustionConsumption::write(::zserio::BitStreamWriter& out) const
{
    out.writeFloat16(m_currentFuelSupply_);
    if (isAuxConsumptionSet())
    {
        out.writeBool(true);
        out.writeFloat16(m_auxConsumption_.value());
    }
    else
    {
        out.writeBool(false);
    }
    m_normalConsumption_.write(out);
    if (isTrafficConsumptionSet())
    {
        out.writeBool(true);
        m_trafficConsumption_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
    if (isEfficiencySet())
    {
        out.writeBool(true);
        m_efficiency_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
}

void CombustionConsumption::write(CombustionConsumption::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    out.writeFloat16(m_currentFuelSupply_);
    if (isAuxConsumptionSet())
    {
        out.writeBool(true);
        out.writeFloat16(m_auxConsumption_.value());
    }
    else
    {
        out.writeBool(false);
    }
    m_normalConsumption_.write(context.getNormalConsumption(), out);
    if (isTrafficConsumptionSet())
    {
        out.writeBool(true);
        m_trafficConsumption_.value().write(context.getTrafficConsumption(), out);
    }
    else
    {
        out.writeBool(false);
    }
    if (isEfficiencySet())
    {
        out.writeBool(true);
        m_efficiency_.value().write(context.getEfficiency(), out);
    }
    else
    {
        out.writeBool(false);
    }
}

::nds::core::vehicle::FuelLiters CombustionConsumption::readCurrentFuelSupply(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::vehicle::FuelLiters>(in.readFloat16());
}
::zserio::InplaceOptionalHolder<::nds::core::vehicle::LitersPerHour> CombustionConsumption::readAuxConsumption(::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::LitersPerHour>(static_cast<::nds::core::vehicle::LitersPerHour>(in.readFloat16()));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::LitersPerHour>(::zserio::NullOpt);
}
::nds::core::vehicle::CombustionConsumptionCurve CombustionConsumption::readNormalConsumption(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::vehicle::CombustionConsumptionCurve(in, allocator);
}

::nds::core::vehicle::CombustionConsumptionCurve CombustionConsumption::readNormalConsumption(CombustionConsumption::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::vehicle::CombustionConsumptionCurve(context.getNormalConsumption(), in, allocator);
}
::zserio::InplaceOptionalHolder<::nds::core::vehicle::CombustionConsumptionCurve> CombustionConsumption::readTrafficConsumption(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::CombustionConsumptionCurve>(::nds::core::vehicle::CombustionConsumptionCurve(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::CombustionConsumptionCurve>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::vehicle::CombustionConsumptionCurve> CombustionConsumption::readTrafficConsumption(CombustionConsumption::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::CombustionConsumptionCurve>(::nds::core::vehicle::CombustionConsumptionCurve(context.getTrafficConsumption(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::CombustionConsumptionCurve>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::core::vehicle::ConsumptionEfficiency> CombustionConsumption::readEfficiency(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::ConsumptionEfficiency>(::nds::core::vehicle::ConsumptionEfficiency(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::ConsumptionEfficiency>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::vehicle::ConsumptionEfficiency> CombustionConsumption::readEfficiency(CombustionConsumption::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::ConsumptionEfficiency>(::nds::core::vehicle::ConsumptionEfficiency(context.getEfficiency(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::ConsumptionEfficiency>(::zserio::NullOpt);
}

} // namespace vehicle
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ConstraintException.h>

#include <nds/core/vehicle/ElectricConsumption.h>

namespace nds
{
namespace core
{
namespace vehicle
{

ElectricConsumption::ElectricConsumption(const allocator_type& allocator) noexcept :
        m_maxCharge_(::nds::core::vehicle::WattHrs()),
        m_currentCharge_(::nds::core::vehicle::WattHrs()),
        m_auxConsumption_(::zserio::NullOpt),
        m_normalConsumption_(allocator),
        m_trafficConsumption_(::zserio::NullOpt),
        m_efficiency_(::zserio::NullOpt),
        m_consumptionElevationGain_(::zserio::NullOpt),
        m_recuperationElevationLoss_(::zserio::NullOpt)
{
}

ElectricConsumption::ElectricConsumption(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_maxCharge_(readMaxCharge(in)),
        m_currentCharge_(readCurrentCharge(in)),
        m_auxConsumption_(readAuxConsumption(in)),
        m_normalConsumption_(readNormalConsumption(in, allocator)),
        m_trafficConsumption_(readTrafficConsumption(in, allocator)),
        m_efficiency_(readEfficiency(in, allocator)),
        m_consumptionElevationGain_(readConsumptionElevationGain(in)),
        m_recuperationElevationLoss_(readRecuperationElevationLoss(in))
{
}

ElectricConsumption::ElectricConsumption(ElectricConsumption::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_maxCharge_(readMaxCharge(context, in)),
        m_currentCharge_(readCurrentCharge(context, in)),
        m_auxConsumption_(readAuxConsumption(context, in)),
        m_normalConsumption_(readNormalConsumption(context, in, allocator)),
        m_trafficConsumption_(readTrafficConsumption(context, in, allocator)),
        m_efficiency_(readEfficiency(context, in, allocator)),
        m_consumptionElevationGain_(readConsumptionElevationGain(context, in)),
        m_recuperationElevationLoss_(readRecuperationElevationLoss(context, in))
{
}

ElectricConsumption::ElectricConsumption(::zserio::PropagateAllocatorT,
        const ElectricConsumption& other, const allocator_type& allocator) :
        m_maxCharge_(::zserio::allocatorPropagatingCopy(other.m_maxCharge_, allocator)),
        m_currentCharge_(::zserio::allocatorPropagatingCopy(other.m_currentCharge_, allocator)),
        m_auxConsumption_(::zserio::allocatorPropagatingCopy(other.m_auxConsumption_, allocator)),
        m_normalConsumption_(::zserio::allocatorPropagatingCopy(other.m_normalConsumption_, allocator)),
        m_trafficConsumption_(::zserio::allocatorPropagatingCopy(other.m_trafficConsumption_, allocator)),
        m_efficiency_(::zserio::allocatorPropagatingCopy(other.m_efficiency_, allocator)),
        m_consumptionElevationGain_(::zserio::allocatorPropagatingCopy(other.m_consumptionElevationGain_, allocator)),
        m_recuperationElevationLoss_(::zserio::allocatorPropagatingCopy(other.m_recuperationElevationLoss_, allocator))
{
}

::nds::core::vehicle::WattHrs ElectricConsumption::getMaxCharge() const
{
    return m_maxCharge_;
}

void ElectricConsumption::setMaxCharge(::nds::core::vehicle::WattHrs maxCharge_)
{
    m_maxCharge_ = maxCharge_;
}

::nds::core::vehicle::WattHrs ElectricConsumption::getCurrentCharge() const
{
    return m_currentCharge_;
}

void ElectricConsumption::setCurrentCharge(::nds::core::vehicle::WattHrs currentCharge_)
{
    m_currentCharge_ = currentCharge_;
}

::nds::core::vehicle::Watt ElectricConsumption::getAuxConsumption() const
{
    return m_auxConsumption_.value();
}

void ElectricConsumption::setAuxConsumption(::nds::core::vehicle::Watt auxConsumption_)
{
    m_auxConsumption_ = auxConsumption_;
}

bool ElectricConsumption::isAuxConsumptionUsed() const
{
    return (isAuxConsumptionSet());
}

bool ElectricConsumption::isAuxConsumptionSet() const
{
    return m_auxConsumption_.hasValue();
}

void ElectricConsumption::resetAuxConsumption()
{
    m_auxConsumption_.reset();
}

::nds::core::vehicle::ElectricConsumptionCurve& ElectricConsumption::getNormalConsumption()
{
    return m_normalConsumption_;
}

const ::nds::core::vehicle::ElectricConsumptionCurve& ElectricConsumption::getNormalConsumption() const
{
    return m_normalConsumption_;
}

void ElectricConsumption::setNormalConsumption(const ::nds::core::vehicle::ElectricConsumptionCurve& normalConsumption_)
{
    m_normalConsumption_ = normalConsumption_;
}

void ElectricConsumption::setNormalConsumption(::nds::core::vehicle::ElectricConsumptionCurve&& normalConsumption_)
{
    m_normalConsumption_ = ::std::move(normalConsumption_);
}

::nds::core::vehicle::ElectricConsumptionCurve& ElectricConsumption::getTrafficConsumption()
{
    return m_trafficConsumption_.value();
}

const ::nds::core::vehicle::ElectricConsumptionCurve& ElectricConsumption::getTrafficConsumption() const
{
    return m_trafficConsumption_.value();
}

void ElectricConsumption::setTrafficConsumption(const ::nds::core::vehicle::ElectricConsumptionCurve& trafficConsumption_)
{
    m_trafficConsumption_ = trafficConsumption_;
}

void ElectricConsumption::setTrafficConsumption(::nds::core::vehicle::ElectricConsumptionCurve&& trafficConsumption_)
{
    m_trafficConsumption_ = ::std::move(trafficConsumption_);
}

bool ElectricConsumption::isTrafficConsumptionUsed() const
{
    return (isTrafficConsumptionSet());
}

bool ElectricConsumption::isTrafficConsumptionSet() const
{
    return m_trafficConsumption_.hasValue();
}

void ElectricConsumption::resetTrafficConsumption()
{
    m_trafficConsumption_.reset();
}

::nds::core::vehicle::ConsumptionEfficiency& ElectricConsumption::getEfficiency()
{
    return m_efficiency_.value();
}

const ::nds::core::vehicle::ConsumptionEfficiency& ElectricConsumption::getEfficiency() const
{
    return m_efficiency_.value();
}

void ElectricConsumption::setEfficiency(const ::nds::core::vehicle::ConsumptionEfficiency& efficiency_)
{
    m_efficiency_ = efficiency_;
}

void ElectricConsumption::setEfficiency(::nds::core::vehicle::ConsumptionEfficiency&& efficiency_)
{
    m_efficiency_ = ::std::move(efficiency_);
}

bool ElectricConsumption::isEfficiencyUsed() const
{
    return (isEfficiencySet());
}

bool ElectricConsumption::isEfficiencySet() const
{
    return m_efficiency_.hasValue();
}

void ElectricConsumption::resetEfficiency()
{
    m_efficiency_.reset();
}

::nds::core::vehicle::WattHrsPerKm ElectricConsumption::getConsumptionElevationGain() const
{
    return m_consumptionElevationGain_.value();
}

void ElectricConsumption::setConsumptionElevationGain(::nds::core::vehicle::WattHrsPerKm consumptionElevationGain_)
{
    m_consumptionElevationGain_ = consumptionElevationGain_;
}

bool ElectricConsumption::isConsumptionElevationGainUsed() const
{
    return (isConsumptionElevationGainSet());
}

bool ElectricConsumption::isConsumptionElevationGainSet() const
{
    return m_consumptionElevationGain_.hasValue();
}

void ElectricConsumption::resetConsumptionElevationGain()
{
    m_consumptionElevationGain_.reset();
}

::nds::core::vehicle::WattHrsPerKm ElectricConsumption::getRecuperationElevationLoss() const
{
    return m_recuperationElevationLoss_.value();
}

void ElectricConsumption::setRecuperationElevationLoss(::nds::core::vehicle::WattHrsPerKm recuperationElevationLoss_)
{
    m_recuperationElevationLoss_ = recuperationElevationLoss_;
}

bool ElectricConsumption::isRecuperationElevationLossUsed() const
{
    return (isRecuperationElevationLossSet());
}

bool ElectricConsumption::isRecuperationElevationLossSet() const
{
    return m_recuperationElevationLoss_.hasValue();
}

void ElectricConsumption::resetRecuperationElevationLoss()
{
    m_recuperationElevationLoss_.reset();
}

void ElectricConsumption::initPackingContext(ElectricConsumption::ZserioPackingContext& context) const
{
    context.getMaxCharge().init<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::WattHrs>>(m_maxCharge_);
    context.getCurrentCharge().init<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::WattHrs>>(m_currentCharge_);
    if (isAuxConsumptionSet())
    {
        context.getAuxConsumption().init<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::Watt>>(m_auxConsumption_.value());
    }
    m_normalConsumption_.initPackingContext(context.getNormalConsumption());
    if (isTrafficConsumptionSet())
    {
        m_trafficConsumption_.value().initPackingContext(context.getTrafficConsumption());
    }
    if (isEfficiencySet())
    {
        m_efficiency_.value().initPackingContext(context.getEfficiency());
    }
    if (isConsumptionElevationGainSet())
    {
        context.getConsumptionElevationGain().init<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::WattHrsPerKm>>(m_consumptionElevationGain_.value());
    }
    if (isRecuperationElevationLossSet())
    {
        context.getRecuperationElevationLoss().init<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::WattHrsPerKm>>(m_recuperationElevationLoss_.value());
    }
}

size_t ElectricConsumption::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_maxCharge_);
    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_currentCharge_);
    endBitPosition += 1;
    if (isAuxConsumptionSet())
    {
        endBitPosition += ::zserio::bitSizeOfVarUInt32(m_auxConsumption_.value());
    }
    endBitPosition += m_normalConsumption_.bitSizeOf(endBitPosition);
    endBitPosition += 1;
    if (isTrafficConsumptionSet())
    {
        endBitPosition += m_trafficConsumption_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition += 1;
    if (isEfficiencySet())
    {
        endBitPosition += m_efficiency_.value().bitSizeOf(endBitPosition);
    }
    endBitPosition += 1;
    if (isConsumptionElevationGainSet())
    {
        endBitPosition += ::zserio::bitSizeOfVarUInt32(m_consumptionElevationGain_.value());
    }
    endBitPosition += 1;
    if (isRecuperationElevationLossSet())
    {
        endBitPosition += ::zserio::bitSizeOfVarUInt32(m_recuperationElevationLoss_.value());
    }

    return endBitPosition - bitPosition;
}

size_t ElectricConsumption::bitSizeOf(ElectricConsumption::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getMaxCharge().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::WattHrs>>(m_maxCharge_);
    endBitPosition += context.getCurrentCharge().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::WattHrs>>(m_currentCharge_);
    endBitPosition += 1;
    if (isAuxConsumptionSet())
    {
        endBitPosition += context.getAuxConsumption().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::Watt>>(m_auxConsumption_.value());
    }
    endBitPosition += m_normalConsumption_.bitSizeOf(context.getNormalConsumption(), endBitPosition);
    endBitPosition += 1;
    if (isTrafficConsumptionSet())
    {
        endBitPosition += m_trafficConsumption_.value().bitSizeOf(context.getTrafficConsumption(), endBitPosition);
    }
    endBitPosition += 1;
    if (isEfficiencySet())
    {
        endBitPosition += m_efficiency_.value().bitSizeOf(context.getEfficiency(), endBitPosition);
    }
    endBitPosition += 1;
    if (isConsumptionElevationGainSet())
    {
        endBitPosition += context.getConsumptionElevationGain().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::WattHrsPerKm>>(m_consumptionElevationGain_.value());
    }
    endBitPosition += 1;
    if (isRecuperationElevationLossSet())
    {
        endBitPosition += context.getRecuperationElevationLoss().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::WattHrsPerKm>>(m_recuperationElevationLoss_.value());
    }

    return endBitPosition - bitPosition;
}

size_t ElectricConsumption::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_maxCharge_);
    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_currentCharge_);
    endBitPosition += 1;
    if (isAuxConsumptionSet())
    {
        endBitPosition += ::zserio::bitSizeOfVarUInt32(m_auxConsumption_.value());
    }
    endBitPosition = m_normalConsumption_.initializeOffsets(endBitPosition);
    endBitPosition += 1;
    if (isTrafficConsumptionSet())
    {
        endBitPosition = m_trafficConsumption_.value().initializeOffsets(endBitPosition);
    }
    endBitPosition += 1;
    if (isEfficiencySet())
    {
        endBitPosition = m_efficiency_.value().initializeOffsets(endBitPosition);
    }
    endBitPosition += 1;
    if (isConsumptionElevationGainSet())
    {
        endBitPosition += ::zserio::bitSizeOfVarUInt32(m_consumptionElevationGain_.value());
    }
    endBitPosition += 1;
    if (isRecuperationElevationLossSet())
    {
        endBitPosition += ::zserio::bitSizeOfVarUInt32(m_recuperationElevationLoss_.value());
    }

    return endBitPosition;
}

size_t ElectricConsumption::initializeOffsets(ElectricConsumption::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getMaxCharge().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::WattHrs>>(m_maxCharge_);
    endBitPosition += context.getCurrentCharge().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::WattHrs>>(m_currentCharge_);
    endBitPosition += 1;
    if (isAuxConsumptionSet())
    {
        endBitPosition += context.getAuxConsumption().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::Watt>>(m_auxConsumption_.value());
    }
    endBitPosition = m_normalConsumption_.initializeOffsets(context.getNormalConsumption(), endBitPosition);
    endBitPosition += 1;
    if (isTrafficConsumptionSet())
    {
        endBitPosition = m_trafficConsumption_.value().initializeOffsets(context.getTrafficConsumption(), endBitPosition);
    }
    endBitPosition += 1;
    if (isEfficiencySet())
    {
        endBitPosition = m_efficiency_.value().initializeOffsets(context.getEfficiency(), endBitPosition);
    }
    endBitPosition += 1;
    if (isConsumptionElevationGainSet())
    {
        endBitPosition += context.getConsumptionElevationGain().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::WattHrsPerKm>>(m_consumptionElevationGain_.value());
    }
    endBitPosition += 1;
    if (isRecuperationElevationLossSet())
    {
        endBitPosition += context.getRecuperationElevationLoss().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::WattHrsPerKm>>(m_recuperationElevationLoss_.value());
    }

    return endBitPosition;
}

bool ElectricConsumption::operator==(const ElectricConsumption& other) const
{
    if (this != &other)
    {
        return
                (m_maxCharge_ == other.m_maxCharge_) &&
                (m_currentCharge_ == other.m_currentCharge_) &&
                (!isAuxConsumptionUsed() ? !other.isAuxConsumptionUsed() : (m_auxConsumption_ == other.m_auxConsumption_)) &&
                (m_normalConsumption_ == other.m_normalConsumption_) &&
                (!isTrafficConsumptionUsed() ? !other.isTrafficConsumptionUsed() : (m_trafficConsumption_ == other.m_trafficConsumption_)) &&
                (!isEfficiencyUsed() ? !other.isEfficiencyUsed() : (m_efficiency_ == other.m_efficiency_)) &&
                (!isConsumptionElevationGainUsed() ? !other.isConsumptionElevationGainUsed() : (m_consumptionElevationGain_ == other.m_consumptionElevationGain_)) &&
                (!isRecuperationElevationLossUsed() ? !other.isRecuperationElevationLossUsed() : (m_recuperationElevationLoss_ == other.m_recuperationElevationLoss_));
    }

    return true;
}

uint32_t ElectricConsumption::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_maxCharge_);
    result = ::zserio::calcHashCode(result, m_currentCharge_);
    if (isAuxConsumptionUsed())
        result = ::zserio::calcHashCode(result, m_auxConsumption_);
    result = ::zserio::calcHashCode(result, m_normalConsumption_);
    if (isTrafficConsumptionUsed())
        result = ::zserio::calcHashCode(result, m_trafficConsumption_);
    if (isEfficiencyUsed())
        result = ::zserio::calcHashCode(result, m_efficiency_);
    if (isConsumptionElevationGainUsed())
        result = ::zserio::calcHashCode(result, m_consumptionElevationGain_);
    if (isRecuperationElevationLossUsed())
        result = ::zserio::calcHashCode(result, m_recuperationElevationLoss_);

    return result;
}

void ElectricConsumption::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt32(m_maxCharge_);

    // check constraint
    if (!(getCurrentCharge() <= getMaxCharge()))
        throw ::zserio::ConstraintException("Write: Constraint violated at ElectricConsumption.currentCharge!");
    out.writeVarUInt32(m_currentCharge_);

    if (isAuxConsumptionSet())
    {
        out.writeBool(true);
        out.writeVarUInt32(m_auxConsumption_.value());
    }
    else
    {
        out.writeBool(false);
    }

    m_normalConsumption_.write(out);

    if (isTrafficConsumptionSet())
    {
        out.writeBool(true);
        m_trafficConsumption_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isEfficiencySet())
    {
        out.writeBool(true);
        m_efficiency_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isConsumptionElevationGainSet())
    {
        out.writeBool(true);
        out.writeVarUInt32(m_consumptionElevationGain_.value());
    }
    else
    {
        out.writeBool(false);
    }

    if (isRecuperationElevationLossSet())
    {
        out.writeBool(true);
        out.writeVarUInt32(m_recuperationElevationLoss_.value());
    }
    else
    {
        out.writeBool(false);
    }
}

void ElectricConsumption::write(ElectricConsumption::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getMaxCharge().write<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::WattHrs>>(out, m_maxCharge_);

    // check constraint
    if (!(getCurrentCharge() <= getMaxCharge()))
        throw ::zserio::ConstraintException("Write: Constraint violated at ElectricConsumption.currentCharge!");
    context.getCurrentCharge().write<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::WattHrs>>(out, m_currentCharge_);

    if (isAuxConsumptionSet())
    {
        out.writeBool(true);
        context.getAuxConsumption().write<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::Watt>>(out, m_auxConsumption_.value());
    }
    else
    {
        out.writeBool(false);
    }

    m_normalConsumption_.write(context.getNormalConsumption(), out);

    if (isTrafficConsumptionSet())
    {
        out.writeBool(true);
        m_trafficConsumption_.value().write(context.getTrafficConsumption(), out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isEfficiencySet())
    {
        out.writeBool(true);
        m_efficiency_.value().write(context.getEfficiency(), out);
    }
    else
    {
        out.writeBool(false);
    }

    if (isConsumptionElevationGainSet())
    {
        out.writeBool(true);
        context.getConsumptionElevationGain().write<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::WattHrsPerKm>>(out, m_consumptionElevationGain_.value());
    }
    else
    {
        out.writeBool(false);
    }

    if (isRecuperationElevationLossSet())
    {
        out.writeBool(true);
        context.getRecuperationElevationLoss().write<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::WattHrsPerKm>>(out, m_recuperationElevationLoss_.value());
    }
    else
    {
        out.writeBool(false);
    }
}

::nds::core::vehicle::WattHrs ElectricConsumption::readMaxCharge(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::vehicle::WattHrs>(in.readVarUInt32());
}

::nds::core::vehicle::WattHrs ElectricConsumption::readMaxCharge(ElectricConsumption::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getMaxCharge().read<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::WattHrs>>(in);
}
::nds::core::vehicle::WattHrs ElectricConsumption::readCurrentCharge(::zserio::BitStreamReader& in)
{
    ::nds::core::vehicle::WattHrs readField = static_cast<::nds::core::vehicle::WattHrs>(in.readVarUInt32());
    // check constraint
    if (!(readField <= getMaxCharge()))
        throw ::zserio::ConstraintException("Read: Constraint violated at ElectricConsumption.currentCharge!");

    return readField;
}

::nds::core::vehicle::WattHrs ElectricConsumption::readCurrentCharge(ElectricConsumption::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    ::nds::core::vehicle::WattHrs readField = context.getCurrentCharge().read<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::WattHrs>>(in);
    // check constraint
    if (!(readField <= getMaxCharge()))
        throw ::zserio::ConstraintException("Read: Constraint violated at ElectricConsumption.currentCharge!");

    return readField;
}
::zserio::InplaceOptionalHolder<::nds::core::vehicle::Watt> ElectricConsumption::readAuxConsumption(::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::Watt>(static_cast<::nds::core::vehicle::Watt>(in.readVarUInt32()));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::Watt>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::vehicle::Watt> ElectricConsumption::readAuxConsumption(ElectricConsumption::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::Watt>(context.getAuxConsumption().read<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::Watt>>(in));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::Watt>(::zserio::NullOpt);
}
::nds::core::vehicle::ElectricConsumptionCurve ElectricConsumption::readNormalConsumption(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::vehicle::ElectricConsumptionCurve(in, allocator);
}

::nds::core::vehicle::ElectricConsumptionCurve ElectricConsumption::readNormalConsumption(ElectricConsumption::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::vehicle::ElectricConsumptionCurve(context.getNormalConsumption(), in, allocator);
}
::zserio::InplaceOptionalHolder<::nds::core::vehicle::ElectricConsumptionCurve> ElectricConsumption::readTrafficConsumption(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::ElectricConsumptionCurve>(::nds::core::vehicle::ElectricConsumptionCurve(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::ElectricConsumptionCurve>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::vehicle::ElectricConsumptionCurve> ElectricConsumption::readTrafficConsumption(ElectricConsumption::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::ElectricConsumptionCurve>(::nds::core::vehicle::ElectricConsumptionCurve(context.getTrafficConsumption(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::ElectricConsumptionCurve>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::core::vehicle::ConsumptionEfficiency> ElectricConsumption::readEfficiency(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::ConsumptionEfficiency>(::nds::core::vehicle::ConsumptionEfficiency(in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::ConsumptionEfficiency>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::vehicle::ConsumptionEfficiency> ElectricConsumption::readEfficiency(ElectricConsumption::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::ConsumptionEfficiency>(::nds::core::vehicle::ConsumptionEfficiency(context.getEfficiency(), in, allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::ConsumptionEfficiency>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::core::vehicle::WattHrsPerKm> ElectricConsumption::readConsumptionElevationGain(::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::WattHrsPerKm>(static_cast<::nds::core::vehicle::WattHrsPerKm>(in.readVarUInt32()));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::WattHrsPerKm>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::vehicle::WattHrsPerKm> ElectricConsumption::readConsumptionElevationGain(ElectricConsumption::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::WattHrsPerKm>(context.getConsumptionElevationGain().read<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::WattHrsPerKm>>(in));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::WattHrsPerKm>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::core::vehicle::WattHrsPerKm> ElectricConsumption::readRecuperationElevationLoss(::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::WattHrsPerKm>(static_cast<::nds::core::vehicle::WattHrsPerKm>(in.readVarUInt32()));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::WattHrsPerKm>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::vehicle::WattHrsPerKm> ElectricConsumption::readRecuperationElevationLoss(ElectricConsumption::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::WattHrsPerKm>(context.getRecuperationElevationLoss().read<::zserio::VarIntNNArrayTraits<::nds::core::vehicle::WattHrsPerKm>>(in));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::vehicle::WattHrsPerKm>(::zserio::NullOpt);
}

} // namespace vehicle
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/core/vehicle/CombustionConsumptionCurve.h>

namespace nds
{
namespace core
{
namespace vehicle
{

CombustionConsumptionCurve::CombustionConsumptionCurve(const allocator_type& allocator) noexcept :
        m_numEntries_(uint8_t()),
        m_speed_(allocator),
        m_consumption_(allocator)
{
}

CombustionConsumptionCurve::CombustionConsumptionCurve(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numEntries_(readNumEntries(in)),
        m_speed_(readSpeed(in, allocator)),
        m_consumption_(readConsumption(in, allocator))
{
}

CombustionConsumptionCurve::CombustionConsumptionCurve(CombustionConsumptionCurve::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numEntries_(readNumEntries(context, in)),
        m_speed_(readSpeed(context, in, allocator)),
        m_consumption_(readConsumption(in, allocator))
{
}

CombustionConsumptionCurve::CombustionConsumptionCurve(::zserio::PropagateAllocatorT,
        const CombustionConsumptionCurve& other, const allocator_type& allocator) :
        m_numEntries_(::zserio::allocatorPropagatingCopy(other.m_numEntries_, allocator)),
        m_speed_(::zserio::allocatorPropagatingCopy(other.m_speed_, allocator)),
        m_consumption_(::zserio::allocatorPropagatingCopy(other.m_consumption_, allocator))
{
}

uint8_t CombustionConsumptionCurve::getNumEntries() const
{
    return m_numEntries_;
}

void CombustionConsumptionCurve::setNumEntries(uint8_t numEntries_)
{
    m_numEntries_ = numEntries_;
}

::zserio::vector<::nds::core::types::SpeedKmh>& CombustionConsumptionCurve::getSpeed()
{
    return m_speed_.getRawArray();
}

const ::zserio::vector<::nds::core::types::SpeedKmh>& CombustionConsumptionCurve::getSpeed() const
{
    return m_speed_.getRawArray();
}

void CombustionConsumptionCurve::setSpeed(const ::zserio::vector<::nds::core::types::SpeedKmh>& speed_)
{
    m_speed_ = ZserioArrayType_speed(speed_);
}

void CombustionConsumptionCurve::setSpeed(::zserio::vector<::nds::core::types::SpeedKmh>&& speed_)
{
    m_speed_ = ZserioArrayType_speed(std::move(speed_));
}

::zserio::vector<::nds::core::vehicle::LitersPer100km>& CombustionConsumptionCurve::getConsumption()
{
    return m_consumption_.getRawArray();
}

const ::zserio::vector<::nds::core::vehicle::LitersPer100km>& CombustionConsumptionCurve::getConsumption() const
{
    return m_consumption_.getRawArray();
}

void CombustionConsumptionCurve::setConsumption(const ::zserio::vector<::nds::core::vehicle::LitersPer100km>& consumption_)
{
    m_consumption_ = ZserioArrayType_consumption(consumption_);
}

void CombustionConsumptionCurve::setConsumption(::zserio::vector<::nds::core::vehicle::LitersPer100km>&& consumption_)
{
    m_consumption_ = ZserioArrayType_consumption(std::move(consumption_));
}

void CombustionConsumptionCurve::initPackingContext(CombustionConsumptionCurve::ZserioPackingContext& context) const
{
    context.getNumEntries().init<::zserio::StdIntArrayTraits<uint8_t>>(m_numEntries_);
}

size_t CombustionConsumptionCurve::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(8);
    endBitPosition += m_speed_.bitSizeOf(endBitPosition);
    endBitPosition += m_consumption_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t CombustionConsumptionCurve::bitSizeOf(CombustionConsumptionCurve::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumEntries().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_numEntries_);
    endBitPosition += m_speed_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_consumption_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t CombustionConsumptionCurve::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(8);
    endBitPosition = m_speed_.initializeOffsets(endBitPosition);
    endBitPosition = m_consumption_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t CombustionConsumptionCurve::initializeOffsets(CombustionConsumptionCurve::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumEntries().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_numEntries_);
    endBitPosition = m_speed_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_consumption_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

bool CombustionConsumptionCurve::operator==(const CombustionConsumptionCurve& other) const
{
    if (this != &other)
    {
        return
                (m_numEntries_ == other.m_numEntries_) &&
                (m_speed_ == other.m_speed_) &&
                (m_consumption_ == other.m_consumption_);
    }

    return true;
}

uint32_t CombustionConsumptionCurve::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_numEntries_);
    result = ::zserio::calcHashCode(result, m_speed_);
    result = ::zserio::calcHashCode(result, m_consumption_);

    return result;
}

void CombustionConsumptionCurve::write(::zserio::BitStreamWriter& out) const
{
    out.writeBits(m_numEntries_, UINT8_C(8));

    // check array length
    if (m_speed_.getRawArray().size() != static_cast<size_t>(getNumEntries()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field CombustionConsumptionCurve.speed: ") <<
                m_speed_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumEntries()) << "!";
    }
    m_speed_.write(out);

    // check array length
    if (m_consumption_.getRawArray().size() != static_cast<size_t>(getNumEntries()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field CombustionConsumptionCurve.consumption: ") <<
                m_consumption_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumEntries()) << "!";
    }
    m_consumption_.write(out);
}

void CombustionConsumptionCurve::write(CombustionConsumptionCurve::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumEntries().write<::zserio::StdIntArrayTraits<uint8_t>>(out, m_numEntries_);

    // check array length
    if (m_speed_.getRawArray().size() != static_cast<size_t>(getNumEntries()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field CombustionConsumptionCurve.speed: ") <<
                m_speed_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumEntries()) << "!";
    }
    m_speed_.writePacked(out);

    // check array length
    if (m_consumption_.getRawArray().size() != static_cast<size_t>(getNumEntries()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field CombustionConsumptionCurve.consumption: ") <<
                m_consumption_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumEntries()) << "!";
    }
    m_consumption_.write(out);
}

uint8_t CombustionConsumptionCurve::readNumEntries(::zserio::BitStreamReader& in)
{
    return static_cast<uint8_t>(in.readBits(UINT8_C(8)));
}

uint8_t CombustionConsumptionCurve::readNumEntries(CombustionConsumptionCurve::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumEntries().read<::zserio::StdIntArrayTraits<uint8_t>>(in);
}
CombustionConsumptionCurve::ZserioArrayType_speed CombustionConsumptionCurve::readSpeed(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_speed readField(allocator);
    readField.read(in, static_cast<size_t>(getNumEntries()));

    return readField;
}

CombustionConsumptionCurve::ZserioArrayType_speed CombustionConsumptionCurve::readSpeed(CombustionConsumptionCurve::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_speed readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumEntries()));

    return readField;
}
CombustionConsumptionCurve::ZserioArrayType_consumption CombustionConsumptionCurve::readConsumption(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_consumption readField(allocator);
    readField.read(in, static_cast<size_t>(getNumEntries()));

    return readField;
}

} // namespace vehicle
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/core/vehicle/ElectricConsumptionCurve.h>

namespace nds
{
namespace core
{
namespace vehicle
{

ElectricConsumptionCurve::ElectricConsumptionCurve(const allocator_type& allocator) noexcept :
        m_numEntries_(uint8_t()),
        m_speed_(allocator),
        m_consumption_(allocator)
{
}

ElectricConsumptionCurve::ElectricConsumptionCurve(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numEntries_(readNumEntries(in)),
        m_speed_(readSpeed(in, allocator)),
        m_consumption_(readConsumption(in, allocator))
{
}

ElectricConsumptionCurve::ElectricConsumptionCurve(ElectricConsumptionCurve::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numEntries_(readNumEntries(context, in)),
        m_speed_(readSpeed(context, in, allocator)),
        m_consumption_(readConsumption(context, in, allocator))
{
}

ElectricConsumptionCurve::ElectricConsumptionCurve(::zserio::PropagateAllocatorT,
        const ElectricConsumptionCurve& other, const allocator_type& allocator) :
        m_numEntries_(::zserio::allocatorPropagatingCopy(other.m_numEntries_, allocator)),
        m_speed_(::zserio::allocatorPropagatingCopy(other.m_speed_, allocator)),
        m_consumption_(::zserio::allocatorPropagatingCopy(other.m_consumption_, allocator))
{
}

uint8_t ElectricConsumptionCurve::getNumEntries() const
{
    return m_numEntries_;
}

void ElectricConsumptionCurve::setNumEntries(uint8_t numEntries_)
{
    m_numEntries_ = numEntries_;
}

::zserio::vector<::nds::core::types::SpeedKmh>& ElectricConsumptionCurve::getSpeed()
{
    return m_speed_.getRawArray();
}

const ::zserio::vector<::nds::core::types::SpeedKmh>& ElectricConsumptionCurve::getSpeed() const
{
    return m_speed_.getRawArray();
}

void ElectricConsumptionCurve::setSpeed(const ::zserio::vector<::nds::core::types::SpeedKmh>& speed_)
{
    m_speed_ = ZserioArrayType_speed(speed_);
}

void ElectricConsumptionCurve::setSpeed(::zserio::vector<::nds::core::types::SpeedKmh>&& speed_)
{
    m_speed_ = ZserioArrayType_speed(std::move(speed_));
}

::zserio::vector<::nds::core::vehicle::WattHrsPer100km>& ElectricConsumptionCurve::getConsumption()
{
    return m_consumption_.getRawArray();
}

const ::zserio::vector<::nds::core::vehicle::WattHrsPer100km>& ElectricConsumptionCurve::getConsumption() const
{
    return m_consumption_.getRawArray();
}

void ElectricConsumptionCurve::setConsumption(const ::zserio::vector<::nds::core::vehicle::WattHrsPer100km>& consumption_)
{
    m_consumption_ = ZserioArrayType_consumption(consumption_);
}

void ElectricConsumptionCurve::setConsumption(::zserio::vector<::nds::core::vehicle::WattHrsPer100km>&& consumption_)
{
    m_consumption_ = ZserioArrayType_consumption(std::move(consumption_));
}

void ElectricConsumptionCurve::initPackingContext(ElectricConsumptionCurve::ZserioPackingContext& context) const
{
    context.getNumEntries().init<::zserio::StdIntArrayTraits<uint8_t>>(m_numEntries_);
}

size_t ElectricConsumptionCurve::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(8);
    endBitPosition += m_speed_.bitSizeOf(endBitPosition);
    endBitPosition += m_consumption_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ElectricConsumptionCurve::bitSizeOf(ElectricConsumptionCurve::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumEntries().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_numEntries_);
    endBitPosition += m_speed_.bitSizeOfPacked(endBitPosition);
    endBitPosition += m_consumption_.bitSizeOfPacked(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ElectricConsumptionCurve::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(8);
    endBitPosition = m_speed_.initializeOffsets(endBitPosition);
    endBitPosition = m_consumption_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t ElectricConsumptionCurve::initializeOffsets(ElectricConsumptionCurve::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumEntries().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_numEntries_);
    endBitPosition = m_speed_.initializeOffsetsPacked(endBitPosition);
    endBitPosition = m_consumption_.initializeOffsetsPacked(endBitPosition);

    return endBitPosition;
}

bool ElectricConsumptionCurve::operator==(const ElectricConsumptionCurve& other) const
{
    if (this != &other)
    {
        return
                (m_numEntries_ == other.m_numEntries_) &&
                (m_speed_ == other.m_speed_) &&
                (m_consumption_ == other.m_consumption_);
    }

    return true;
}

uint32_t ElectricConsumptionCurve::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_numEntries_);
    result = ::zserio::calcHashCode(result, m_speed_);
    result = ::zserio::calcHashCode(result, m_consumption_);

    return result;
}

void ElectricConsumptionCurve::write(::zserio::BitStreamWriter& out) const
{
    out.writeBits(m_numEntries_, UINT8_C(8));

    // check array length
    if (m_speed_.getRawArray().size() != static_cast<size_t>(getNumEntries()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ElectricConsumptionCurve.speed: ") <<
                m_speed_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumEntries()) << "!";
    }
    m_speed_.write(out);

    // check array length
    if (m_consumption_.getRawArray().size() != static_cast<size_t>(getNumEntries()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ElectricConsumptionCurve.consumption: ") <<
                m_consumption_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumEntries()) << "!";
    }
    m_consumption_.write(out);
}

void ElectricConsumptionCurve::write(ElectricConsumptionCurve::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumEntries().write<::zserio::StdIntArrayTraits<uint8_t>>(out, m_numEntries_);

    // check array length
    if (m_speed_.getRawArray().size() != static_cast<size_t>(getNumEntries()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ElectricConsumptionCurve.speed: ") <<
                m_speed_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumEntries()) << "!";
    }
    m_speed_.writePacked(out);

    // check array length
    if (m_consumption_.getRawArray().size() != static_cast<size_t>(getNumEntries()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ElectricConsumptionCurve.consumption: ") <<
                m_consumption_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumEntries()) << "!";
    }
    m_consumption_.writePacked(out);
}

uint8_t ElectricConsumptionCurve::readNumEntries(::zserio::BitStreamReader& in)
{
    return static_cast<uint8_t>(in.readBits(UINT8_C(8)));
}

uint8_t ElectricConsumptionCurve::readNumEntries(ElectricConsumptionCurve::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumEntries().read<::zserio::StdIntArrayTraits<uint8_t>>(in);
}
ElectricConsumptionCurve::ZserioArrayType_speed ElectricConsumptionCurve::readSpeed(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_speed readField(allocator);
    readField.read(in, static_cast<size_t>(getNumEntries()));

    return readField;
}

ElectricConsumptionCurve::ZserioArrayType_speed ElectricConsumptionCurve::readSpeed(ElectricConsumptionCurve::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_speed readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumEntries()));

    return readField;
}
ElectricConsumptionCurve::ZserioArrayType_consumption ElectricConsumptionCurve::readConsumption(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_consumption readField(allocator);
    readField.read(in, static_cast<size_t>(getNumEntries()));

    return readField;
}

ElectricConsumptionCurve::ZserioArrayType_consumption ElectricConsumptionCurve::readConsumption(ElectricConsumptionCurve::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_consumption readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumEntries()));

    return readField;
}

} // namespace vehicle
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/core/vehicle/ConsumptionEfficiency.h>

namespace nds
{
namespace core
{
namespace vehicle
{

ConsumptionEfficiency::ConsumptionEfficiency(const allocator_type&) noexcept :
        m_grossWeight_(::nds::core::types::Weight10Kilogram()),
        m_accelerationEfficiency_(float()),
        m_decelerationEfficiency_(float()),
        m_uphillEfficiency_(float()),
        m_downhillEfficiency_(float())
{
}

ConsumptionEfficiency::ConsumptionEfficiency(::zserio::BitStreamReader& in, const allocator_type&) :
        m_grossWeight_(readGrossWeight(in)),
        m_accelerationEfficiency_(readAccelerationEfficiency(in)),
        m_decelerationEfficiency_(readDecelerationEfficiency(in)),
        m_uphillEfficiency_(readUphillEfficiency(in)),
        m_downhillEfficiency_(readDownhillEfficiency(in))
{
}

ConsumptionEfficiency::ConsumptionEfficiency(ConsumptionEfficiency::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type&) :
        m_grossWeight_(readGrossWeight(context, in)),
        m_accelerationEfficiency_(readAccelerationEfficiency(in)),
        m_decelerationEfficiency_(readDecelerationEfficiency(in)),
        m_uphillEfficiency_(readUphillEfficiency(in)),
        m_downhillEfficiency_(readDownhillEfficiency(in))
{
}

ConsumptionEfficiency::ConsumptionEfficiency(::zserio::PropagateAllocatorT,
        const ConsumptionEfficiency& other, const allocator_type& allocator) :
        m_grossWeight_(::zserio::allocatorPropagatingCopy(other.m_grossWeight_, allocator)),
        m_accelerationEfficiency_(::zserio::allocatorPropagatingCopy(other.m_accelerationEfficiency_, allocator)),
        m_decelerationEfficiency_(::zserio::allocatorPropagatingCopy(other.m_decelerationEfficiency_, allocator)),
        m_uphillEfficiency_(::zserio::allocatorPropagatingCopy(other.m_uphillEfficiency_, allocator)),
        m_downhillEfficiency_(::zserio::allocatorPropagatingCopy(other.m_downhillEfficiency_, allocator))
{
}

::nds::core::types::Weight10Kilogram ConsumptionEfficiency::getGrossWeight() const
{
    return m_grossWeight_;
}

void ConsumptionEfficiency::setGrossWeight(::nds::core::types::Weight10Kilogram grossWeight_)
{
    m_grossWeight_ = grossWeight_;
}

float ConsumptionEfficiency::getAccelerationEfficiency() const
{
    return m_accelerationEfficiency_;
}

void ConsumptionEfficiency::setAccelerationEfficiency(float accelerationEfficiency_)
{
    m_accelerationEfficiency_ = accelerationEfficiency_;
}

float ConsumptionEfficiency::getDecelerationEfficiency() const
{
    return m_decelerationEfficiency_;
}

void ConsumptionEfficiency::setDecelerationEfficiency(float decelerationEfficiency_)
{
    m_decelerationEfficiency_ = decelerationEfficiency_;
}

float ConsumptionEfficiency::getUphillEfficiency() const
{
    return m_uphillEfficiency_;
}

void ConsumptionEfficiency::setUphillEfficiency(float uphillEfficiency_)
{
    m_uphillEfficiency_ = uphillEfficiency_;
}

float ConsumptionEfficiency::getDownhillEfficiency() const
{
    return m_downhillEfficiency_;
}

void ConsumptionEfficiency::setDownhillEfficiency(float downhillEfficiency_)
{
    m_downhillEfficiency_ = downhillEfficiency_;
}

void ConsumptionEfficiency::initPackingContext(ConsumptionEfficiency::ZserioPackingContext& context) const
{
    context.getGrossWeight().init<::zserio::VarIntNNArrayTraits<::nds::core::types::Weight10Kilogram>>(m_grossWeight_);
}

size_t ConsumptionEfficiency::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_grossWeight_);
    endBitPosition += UINT8_C(16);
    endBitPosition += UINT8_C(16);
    endBitPosition += UINT8_C(16);
    endBitPosition += UINT8_C(16);

    return endBitPosition - bitPosition;
}

size_t ConsumptionEfficiency::bitSizeOf(ConsumptionEfficiency::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getGrossWeight().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::types::Weight10Kilogram>>(m_grossWeight_);
    endBitPosition += UINT8_C(16);
    endBitPosition += UINT8_C(16);
    endBitPosition += UINT8_C(16);
    endBitPosition += UINT8_C(16);

    return endBitPosition - bitPosition;
}

size_t ConsumptionEfficiency::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_grossWeight_);
    endBitPosition += UINT8_C(16);
    endBitPosition += UINT8_C(16);
    endBitPosition += UINT8_C(16);
    endBitPosition += UINT8_C(16);

    return endBitPosition;
}

size_t ConsumptionEfficiency::initializeOffsets(ConsumptionEfficiency::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getGrossWeight().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::types::Weight10Kilogram>>(m_grossWeight_);
    endBitPosition += UINT8_C(16);
    endBitPosition += UINT8_C(16);
    endBitPosition += UINT8_C(16);
    endBitPosition += UINT8_C(16);

    return endBitPosition;
}

bool ConsumptionEfficiency::operator==(const ConsumptionEfficiency& other) const
{
    if (this != &other)
    {
        return
                (m_grossWeight_ == other.m_grossWeight_) &&
                (m_accelerationEfficiency_ == other.m_accelerationEfficiency_) &&
                (m_decelerationEfficiency_ == other.m_decelerationEfficiency_) &&
                (m_uphillEfficiency_ == other.m_uphillEfficiency_) &&
                (m_downhillEfficiency_ == other.m_downhillEfficiency_);
    }

    return true;
}

uint32_t ConsumptionEfficiency::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_grossWeight_);
    result = ::zserio::calcHashCode(result, m_accelerationEfficiency_);
    result = ::zserio::calcHashCode(result, m_decelerationEfficiency_);
    result = ::zserio::calcHashCode(result, m_uphillEfficiency_);
    result = ::zserio::calcHashCode(result, m_downhillEfficiency_);

    return result;
}

void ConsumptionEfficiency::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt32(m_grossWeight_);
    out.writeFloat16(m_accelerationEfficiency_);
    out.writeFloat16(m_decelerationEfficiency_);
    out.writeFloat16(m_uphillEfficiency_);
    out.writeFloat16(m_downhillEfficiency_);
}

void ConsumptionEfficiency::write(ConsumptionEfficiency::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getGrossWeight().write<::zserio::VarIntNNArrayTraits<::nds::core::types::Weight10Kilogram>>(out, m_grossWeight_);
    out.writeFloat16(m_accelerationEfficiency_);
    out.writeFloat16(m_decelerationEfficiency_);
    out.writeFloat16(m_uphillEfficiency_);
    out.writeFloat16(m_downhillEfficiency_);
}

::nds::core::types::Weight10Kilogram ConsumptionEfficiency::readGrossWeight(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::types::Weight10Kilogram>(in.readVarUInt32());
}

::nds::core::types::Weight10Kilogram ConsumptionEfficiency::readGrossWeight(ConsumptionEfficiency::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getGrossWeight().read<::zserio::VarIntNNArrayTraits<::nds::core::types::Weight10Kilogram>>(in);
}
float ConsumptionEfficiency::readAccelerationEfficiency(::zserio::BitStreamReader& in)
{
    return static_cast<float>(in.readFloat16());
}
float ConsumptionEfficiency::readDecelerationEfficiency(::zserio::BitStreamReader& in)
{
    return static_cast<float>(in.readFloat16());
}
float ConsumptionEfficiency::readUphillEfficiency(::zserio::BitStreamReader& in)
{
    return static_cast<float>(in.readFloat16());
}
float ConsumptionEfficiency::readDownhillEfficiency(::zserio::BitStreamReader& in)
{
    return static_cast<float>(in.readFloat16());
}

} // namespace vehicle
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/core/vehicle/VehiclePose.h>

namespace nds
{
namespace core
{
namespace vehicle
{

VehiclePose::VehiclePose(const allocator_type& allocator) noexcept :
        m_choiceTag(UNDEFINED_CHOICE),
        m_objectChoice(allocator)
{
}

VehiclePose::VehiclePose(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_choiceTag(readChoiceTag(in)),
        m_objectChoice(readObject(in, allocator))
{
}

VehiclePose::VehiclePose(VehiclePose::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_choiceTag(readChoiceTag(context, in)),
        m_objectChoice(readObject(context, in, allocator))
{
}

VehiclePose::VehiclePose(::zserio::PropagateAllocatorT,
        const VehiclePose& other, const allocator_type& allocator) :
        m_choiceTag(other.m_choiceTag),
        m_objectChoice(other.copyObject(allocator))
{
}

void VehiclePose::initializeChildren()
{
    switch (m_choiceTag)
    {
    case CHOICE_poseRaw:
        ;
        break;
    case CHOICE_poseGeoMatched:
        m_objectChoice.get<::nds::core::vehicle::PoseGeoMatched>().initializeChildren();
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in union VehiclePose!");
    }
}

::nds::core::vehicle::PoseRaw& VehiclePose::getPoseRaw()
{
    return m_objectChoice.get<::nds::core::vehicle::PoseRaw>();
}

const ::nds::core::vehicle::PoseRaw& VehiclePose::getPoseRaw() const
{
    return m_objectChoice.get<::nds::core::vehicle::PoseRaw>();
}

void VehiclePose::setPoseRaw(const ::nds::core::vehicle::PoseRaw& poseRaw_)
{
    m_choiceTag = CHOICE_poseRaw;
    m_objectChoice = poseRaw_;
}

void VehiclePose::setPoseRaw(::nds::core::vehicle::PoseRaw&& poseRaw_)
{
    m_choiceTag = CHOICE_poseRaw;
    m_objectChoice = ::std::move(poseRaw_);
}

::nds::core::vehicle::PoseGeoMatched& VehiclePose::getPoseGeoMatched()
{
    return m_objectChoice.get<::nds::core::vehicle::PoseGeoMatched>();
}

const ::nds::core::vehicle::PoseGeoMatched& VehiclePose::getPoseGeoMatched() const
{
    return m_objectChoice.get<::nds::core::vehicle::PoseGeoMatched>();
}

void VehiclePose::setPoseGeoMatched(const ::nds::core::vehicle::PoseGeoMatched& poseGeoMatched_)
{
    m_choiceTag = CHOICE_poseGeoMatched;
    m_objectChoice = poseGeoMatched_;
}

void VehiclePose::setPoseGeoMatched(::nds::core::vehicle::PoseGeoMatched&& poseGeoMatched_)
{
    m_choiceTag = CHOICE_poseGeoMatched;
    m_objectChoice = ::std::move(poseGeoMatched_);
}

VehiclePose::ChoiceTag VehiclePose::choiceTag() const
{
    return m_choiceTag;
}

void VehiclePose::initPackingContext(VehiclePose::ZserioPackingContext& context) const
{
    context.getChoiceTag().init<::zserio::VarSizeArrayTraits>(static_cast<uint32_t>(m_choiceTag));

    switch (m_choiceTag)
    {
    case CHOICE_poseRaw:
        m_objectChoice.get<::nds::core::vehicle::PoseRaw>().initPackingContext(context.getPoseRaw());
        break;
    case CHOICE_poseGeoMatched:
        m_objectChoice.get<::nds::core::vehicle::PoseGeoMatched>().initPackingContext(context.getPoseGeoMatched());
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in union VehiclePose!");
    }
}

size_t VehiclePose::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(static_cast<uint32_t>(m_choiceTag));

    switch (m_choiceTag)
    {
    case CHOICE_poseRaw:
        endBitPosition += m_objectChoice.get<::nds::core::vehicle::PoseRaw>().bitSizeOf(endBitPosition);
        break;
    case CHOICE_poseGeoMatched:
        endBitPosition += m_objectChoice.get<::nds::core::vehicle::PoseGeoMatched>().bitSizeOf(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in union VehiclePose!");
    }

    return endBitPosition - bitPosition;
}

size_t VehiclePose::bitSizeOf(VehiclePose::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getChoiceTag().bitSizeOf<::zserio::VarSizeArrayTraits>(static_cast<uint32_t>(m_choiceTag));

    switch (m_choiceTag)
    {
    case CHOICE_poseRaw:
        endBitPosition += m_objectChoice.get<::nds::core::vehicle::PoseRaw>().bitSizeOf(context.getPoseRaw(), endBitPosition);
        break;
    case CHOICE_poseGeoMatched:
        endBitPosition += m_objectChoice.get<::nds::core::vehicle::PoseGeoMatched>().bitSizeOf(context.getPoseGeoMatched(), endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in union VehiclePose!");
    }

    return endBitPosition - bitPosition;
}

size_t VehiclePose::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(static_cast<uint32_t>(m_choiceTag));

    switch (m_choiceTag)
    {
    case CHOICE_poseRaw:
        endBitPosition = m_objectChoice.get<::nds::core::vehicle::PoseRaw>().initializeOffsets(endBitPosition);
        break;
    case CHOICE_poseGeoMatched:
        endBitPosition = m_objectChoice.get<::nds::core::vehicle::PoseGeoMatched>().initializeOffsets(endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in union VehiclePose!");
    }

    return endBitPosition;
}

size_t VehiclePose::initializeOffsets(VehiclePose::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getChoiceTag().bitSizeOf<::zserio::VarSizeArrayTraits>(static_cast<uint32_t>(m_choiceTag));

    switch (m_choiceTag)
    {
    case CHOICE_poseRaw:
        endBitPosition = m_objectChoice.get<::nds::core::vehicle::PoseRaw>().initializeOffsets(context.getPoseRaw(), endBitPosition);
        break;
    case CHOICE_poseGeoMatched:
        endBitPosition = m_objectChoice.get<::nds::core::vehicle::PoseGeoMatched>().initializeOffsets(context.getPoseGeoMatched(), endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in union VehiclePose!");
    }

    return endBitPosition;
}

bool VehiclePose::operator==(const VehiclePose& other) const
{
    if (this == &other)
        return true;

    if (m_choiceTag != other.m_choiceTag)
        return false;

    if (m_objectChoice.hasValue() != other.m_objectChoice.hasValue())
        return false;

    if (!m_objectChoice.hasValue())
        return true;

    switch (m_choiceTag)
    {
    case CHOICE_poseRaw:
        return m_objectChoice.get<::nds::core::vehicle::PoseRaw>() == other.m_objectChoice.get<::nds::core::vehicle::PoseRaw>();
    case CHOICE_poseGeoMatched:
        return m_objectChoice.get<::nds::core::vehicle::PoseGeoMatched>() == other.m_objectChoice.get<::nds::core::vehicle::PoseGeoMatched>();
    default:
        return true; // UNDEFINED_CHOICE
    }
}

uint32_t VehiclePose::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, static_cast<int32_t>(m_choiceTag));
    if (m_objectChoice.hasValue())
    {
        switch (m_choiceTag)
        {
        case CHOICE_poseRaw:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::core::vehicle::PoseRaw>());
            break;
        case CHOICE_poseGeoMatched:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::core::vehicle::PoseGeoMatched>());
            break;
        default:
            // UNDEFINED_CHOICE
            break;
        }
    }

    return result;
}

void VehiclePose::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(static_cast<uint32_t>(m_choiceTag));

    switch (m_choiceTag)
    {
    case CHOICE_poseRaw:
        m_objectChoice.get<::nds::core::vehicle::PoseRaw>().write(out);
        break;
    case CHOICE_poseGeoMatched:
        m_objectChoice.get<::nds::core::vehicle::PoseGeoMatched>().write(out);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in union VehiclePose!");
    }
}

void VehiclePose::write(VehiclePose::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getChoiceTag().write<::zserio::VarSizeArrayTraits>(out, static_cast<uint32_t>(m_choiceTag));

    switch (m_choiceTag)
    {
    case CHOICE_poseRaw:
        m_objectChoice.get<::nds::core::vehicle::PoseRaw>().write(context.getPoseRaw(), out);
        break;
    case CHOICE_poseGeoMatched:
        m_objectChoice.get<::nds::core::vehicle::PoseGeoMatched>().write(context.getPoseGeoMatched(), out);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in union VehiclePose!");
    }
}

VehiclePose::ChoiceTag VehiclePose::readChoiceTag(::zserio::BitStreamReader& in)
{
    return static_cast<VehiclePose::ChoiceTag>(static_cast<int32_t>(in.readVarSize()));
}

VehiclePose::ChoiceTag VehiclePose::readChoiceTag(VehiclePose::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return static_cast<VehiclePose::ChoiceTag>(static_cast<int32_t>(context.getChoiceTag().read<::zserio::VarSizeArrayTraits>(in)));
}

::zserio::AnyHolder<> VehiclePose::readObject(::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (m_choiceTag)
    {
    case CHOICE_poseRaw:
        return ::zserio::AnyHolder<>(::nds::core::vehicle::PoseRaw(in, allocator), allocator);
    case CHOICE_poseGeoMatched:
        return ::zserio::AnyHolder<>(::nds::core::vehicle::PoseGeoMatched(in, allocator), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in union VehiclePose!");
    }
}

::zserio::AnyHolder<> VehiclePose::readObject(VehiclePose::ZserioPackingContext& context,
        ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (m_choiceTag)
    {
    case CHOICE_poseRaw:
        return ::zserio::AnyHolder<>(::nds::core::vehicle::PoseRaw(context.getPoseRaw(), in, allocator), allocator);
    case CHOICE_poseGeoMatched:
        return ::zserio::AnyHolder<>(::nds::core::vehicle::PoseGeoMatched(context.getPoseGeoMatched(), in, allocator), allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in union VehiclePose!");
    }
}

::zserio::AnyHolder<> VehiclePose::copyObject(const allocator_type& allocator) const
{
    switch (m_choiceTag)
    {
    case CHOICE_poseRaw:
        return ::zserio::allocatorPropagatingCopy<::nds::core::vehicle::PoseRaw>(m_objectChoice, allocator);
    case CHOICE_poseGeoMatched:
        return ::zserio::allocatorPropagatingCopy<::nds::core::vehicle::PoseGeoMatched>(m_objectChoice, allocator);
    default:
        return ::zserio::AnyHolder<>(allocator);
    }
}

} // namespace vehicle
} // namespace core
} // namespace nds
