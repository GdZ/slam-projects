/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ConstraintException.h>

#include <nds/core/packaging/PackagingDetails.h>
#include <nds/core/packaging/NO_COMPRESSION.h>
#include <nds/core/packaging/NO_ENCRYPTION.h>

namespace nds
{
namespace core
{
namespace packaging
{

PackagingDetails::PackagingDetails(const allocator_type& allocator) noexcept :
        m_signatureId_(::nds::core::packaging::SignatureId()),
        m_compressionType_(::nds::core::packaging::CompressionType()),
        m_encryptionType_(::nds::core::packaging::EncryptionType()),
        m_encryptionKeyId_(::zserio::NullOpt),
        m_deltaEncodingDetails_(allocator)
{
}

PackagingDetails::PackagingDetails(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_signatureId_(readSignatureId(in)),
        m_compressionType_(readCompressionType(in)),
        m_encryptionType_(readEncryptionType(in)),
        m_encryptionKeyId_(readEncryptionKeyId(in)),
        m_deltaEncodingDetails_(readDeltaEncodingDetails(in, allocator))
{
}

PackagingDetails::PackagingDetails(PackagingDetails::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_signatureId_(readSignatureId(context, in)),
        m_compressionType_(readCompressionType(context, in)),
        m_encryptionType_(readEncryptionType(context, in)),
        m_encryptionKeyId_(readEncryptionKeyId(context, in)),
        m_deltaEncodingDetails_(readDeltaEncodingDetails(context, in, allocator))
{
}

PackagingDetails::PackagingDetails(::zserio::PropagateAllocatorT,
        const PackagingDetails& other, const allocator_type& allocator) :
        m_signatureId_(::zserio::allocatorPropagatingCopy(other.m_signatureId_, allocator)),
        m_compressionType_(::zserio::allocatorPropagatingCopy(other.m_compressionType_, allocator)),
        m_encryptionType_(::zserio::allocatorPropagatingCopy(other.m_encryptionType_, allocator)),
        m_encryptionKeyId_(::zserio::allocatorPropagatingCopy(other.m_encryptionKeyId_, allocator)),
        m_deltaEncodingDetails_(::zserio::allocatorPropagatingCopy(other.m_deltaEncodingDetails_, allocator))
{
}

::nds::core::packaging::SignatureId PackagingDetails::getSignatureId() const
{
    return m_signatureId_;
}

void PackagingDetails::setSignatureId(::nds::core::packaging::SignatureId signatureId_)
{
    m_signatureId_ = signatureId_;
}

::nds::core::packaging::CompressionType PackagingDetails::getCompressionType() const
{
    return m_compressionType_;
}

void PackagingDetails::setCompressionType(::nds::core::packaging::CompressionType compressionType_)
{
    m_compressionType_ = compressionType_;
}

::nds::core::packaging::EncryptionType PackagingDetails::getEncryptionType() const
{
    return m_encryptionType_;
}

void PackagingDetails::setEncryptionType(::nds::core::packaging::EncryptionType encryptionType_)
{
    m_encryptionType_ = encryptionType_;
}

::nds::core::packaging::EncryptionKeyId PackagingDetails::getEncryptionKeyId() const
{
    return m_encryptionKeyId_.value();
}

void PackagingDetails::setEncryptionKeyId(::nds::core::packaging::EncryptionKeyId encryptionKeyId_)
{
    m_encryptionKeyId_ = encryptionKeyId_;
}

bool PackagingDetails::isEncryptionKeyIdUsed() const
{
    return (getEncryptionType() != ::nds::core::packaging::NO_ENCRYPTION);
}

bool PackagingDetails::isEncryptionKeyIdSet() const
{
    return m_encryptionKeyId_.hasValue();
}

void PackagingDetails::resetEncryptionKeyId()
{
    m_encryptionKeyId_.reset();
}

::nds::core::packaging::DeltaEncodingDetails& PackagingDetails::getDeltaEncodingDetails()
{
    return m_deltaEncodingDetails_;
}

const ::nds::core::packaging::DeltaEncodingDetails& PackagingDetails::getDeltaEncodingDetails() const
{
    return m_deltaEncodingDetails_;
}

void PackagingDetails::setDeltaEncodingDetails(const ::nds::core::packaging::DeltaEncodingDetails& deltaEncodingDetails_)
{
    m_deltaEncodingDetails_ = deltaEncodingDetails_;
}

void PackagingDetails::setDeltaEncodingDetails(::nds::core::packaging::DeltaEncodingDetails&& deltaEncodingDetails_)
{
    m_deltaEncodingDetails_ = ::std::move(deltaEncodingDetails_);
}

void PackagingDetails::initPackingContext(PackagingDetails::ZserioPackingContext& context) const
{
    context.getSignatureId().init<::zserio::VarIntNNArrayTraits<::nds::core::packaging::SignatureId>>(m_signatureId_);
    context.getCompressionType().init<::zserio::VarIntNNArrayTraits<::nds::core::packaging::CompressionType>>(m_compressionType_);
    context.getEncryptionType().init<::zserio::VarIntNNArrayTraits<::nds::core::packaging::EncryptionType>>(m_encryptionType_);
    if (getEncryptionType() != ::nds::core::packaging::NO_ENCRYPTION)
    {
        context.getEncryptionKeyId().init<::zserio::VarIntNNArrayTraits<::nds::core::packaging::EncryptionKeyId>>(m_encryptionKeyId_.value());
    }
    m_deltaEncodingDetails_.initPackingContext(context.getDeltaEncodingDetails());
}

size_t PackagingDetails::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_signatureId_);
    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_compressionType_);
    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_encryptionType_);
    if (getEncryptionType() != ::nds::core::packaging::NO_ENCRYPTION)
    {
        endBitPosition += ::zserio::bitSizeOfVarUInt32(m_encryptionKeyId_.value());
    }
    endBitPosition += m_deltaEncodingDetails_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t PackagingDetails::bitSizeOf(PackagingDetails::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getSignatureId().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::packaging::SignatureId>>(m_signatureId_);
    endBitPosition += context.getCompressionType().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::packaging::CompressionType>>(m_compressionType_);
    endBitPosition += context.getEncryptionType().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::packaging::EncryptionType>>(m_encryptionType_);
    if (getEncryptionType() != ::nds::core::packaging::NO_ENCRYPTION)
    {
        endBitPosition += context.getEncryptionKeyId().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::packaging::EncryptionKeyId>>(m_encryptionKeyId_.value());
    }
    endBitPosition += m_deltaEncodingDetails_.bitSizeOf(context.getDeltaEncodingDetails(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t PackagingDetails::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_signatureId_);
    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_compressionType_);
    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_encryptionType_);
    if (getEncryptionType() != ::nds::core::packaging::NO_ENCRYPTION)
    {
        endBitPosition += ::zserio::bitSizeOfVarUInt32(m_encryptionKeyId_.value());
    }
    endBitPosition = m_deltaEncodingDetails_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t PackagingDetails::initializeOffsets(PackagingDetails::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getSignatureId().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::packaging::SignatureId>>(m_signatureId_);
    endBitPosition += context.getCompressionType().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::packaging::CompressionType>>(m_compressionType_);
    endBitPosition += context.getEncryptionType().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::packaging::EncryptionType>>(m_encryptionType_);
    if (getEncryptionType() != ::nds::core::packaging::NO_ENCRYPTION)
    {
        endBitPosition += context.getEncryptionKeyId().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::packaging::EncryptionKeyId>>(m_encryptionKeyId_.value());
    }
    endBitPosition = m_deltaEncodingDetails_.initializeOffsets(context.getDeltaEncodingDetails(), endBitPosition);

    return endBitPosition;
}

bool PackagingDetails::operator==(const PackagingDetails& other) const
{
    if (this != &other)
    {
        return
                (m_signatureId_ == other.m_signatureId_) &&
                (m_compressionType_ == other.m_compressionType_) &&
                (m_encryptionType_ == other.m_encryptionType_) &&
                (!isEncryptionKeyIdUsed() ? !other.isEncryptionKeyIdUsed() : (m_encryptionKeyId_ == other.m_encryptionKeyId_)) &&
                (m_deltaEncodingDetails_ == other.m_deltaEncodingDetails_);
    }

    return true;
}

uint32_t PackagingDetails::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_signatureId_);
    result = ::zserio::calcHashCode(result, m_compressionType_);
    result = ::zserio::calcHashCode(result, m_encryptionType_);
    if (isEncryptionKeyIdUsed())
        result = ::zserio::calcHashCode(result, m_encryptionKeyId_);
    result = ::zserio::calcHashCode(result, m_deltaEncodingDetails_);

    return result;
}

void PackagingDetails::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt16(m_signatureId_);

    out.writeVarUInt16(m_compressionType_);

    // check constraint
    if (!((getEncryptionType() != ::nds::core::packaging::NO_ENCRYPTION && getCompressionType() != ::nds::core::packaging::NO_COMPRESSION) || (getEncryptionType() == ::nds::core::packaging::NO_ENCRYPTION)))
        throw ::zserio::ConstraintException("Write: Constraint violated at PackagingDetails.encryptionType!");
    out.writeVarUInt16(m_encryptionType_);

    if (getEncryptionType() != ::nds::core::packaging::NO_ENCRYPTION)
    {
        out.writeVarUInt32(m_encryptionKeyId_.value());
    }

    m_deltaEncodingDetails_.write(out);
}

void PackagingDetails::write(PackagingDetails::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getSignatureId().write<::zserio::VarIntNNArrayTraits<::nds::core::packaging::SignatureId>>(out, m_signatureId_);

    context.getCompressionType().write<::zserio::VarIntNNArrayTraits<::nds::core::packaging::CompressionType>>(out, m_compressionType_);

    // check constraint
    if (!((getEncryptionType() != ::nds::core::packaging::NO_ENCRYPTION && getCompressionType() != ::nds::core::packaging::NO_COMPRESSION) || (getEncryptionType() == ::nds::core::packaging::NO_ENCRYPTION)))
        throw ::zserio::ConstraintException("Write: Constraint violated at PackagingDetails.encryptionType!");
    context.getEncryptionType().write<::zserio::VarIntNNArrayTraits<::nds::core::packaging::EncryptionType>>(out, m_encryptionType_);

    if (getEncryptionType() != ::nds::core::packaging::NO_ENCRYPTION)
    {
        context.getEncryptionKeyId().write<::zserio::VarIntNNArrayTraits<::nds::core::packaging::EncryptionKeyId>>(out, m_encryptionKeyId_.value());
    }

    m_deltaEncodingDetails_.write(context.getDeltaEncodingDetails(), out);
}

::nds::core::packaging::SignatureId PackagingDetails::readSignatureId(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::packaging::SignatureId>(in.readVarUInt16());
}

::nds::core::packaging::SignatureId PackagingDetails::readSignatureId(PackagingDetails::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getSignatureId().read<::zserio::VarIntNNArrayTraits<::nds::core::packaging::SignatureId>>(in);
}
::nds::core::packaging::CompressionType PackagingDetails::readCompressionType(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::packaging::CompressionType>(in.readVarUInt16());
}

::nds::core::packaging::CompressionType PackagingDetails::readCompressionType(PackagingDetails::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getCompressionType().read<::zserio::VarIntNNArrayTraits<::nds::core::packaging::CompressionType>>(in);
}
::nds::core::packaging::EncryptionType PackagingDetails::readEncryptionType(::zserio::BitStreamReader& in)
{
    ::nds::core::packaging::EncryptionType readField = static_cast<::nds::core::packaging::EncryptionType>(in.readVarUInt16());
    // check constraint
    if (!((readField != ::nds::core::packaging::NO_ENCRYPTION && getCompressionType() != ::nds::core::packaging::NO_COMPRESSION) || (readField == ::nds::core::packaging::NO_ENCRYPTION)))
        throw ::zserio::ConstraintException("Read: Constraint violated at PackagingDetails.encryptionType!");

    return readField;
}

::nds::core::packaging::EncryptionType PackagingDetails::readEncryptionType(PackagingDetails::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    ::nds::core::packaging::EncryptionType readField = context.getEncryptionType().read<::zserio::VarIntNNArrayTraits<::nds::core::packaging::EncryptionType>>(in);
    // check constraint
    if (!((readField != ::nds::core::packaging::NO_ENCRYPTION && getCompressionType() != ::nds::core::packaging::NO_COMPRESSION) || (readField == ::nds::core::packaging::NO_ENCRYPTION)))
        throw ::zserio::ConstraintException("Read: Constraint violated at PackagingDetails.encryptionType!");

    return readField;
}
::zserio::InplaceOptionalHolder<::nds::core::packaging::EncryptionKeyId> PackagingDetails::readEncryptionKeyId(::zserio::BitStreamReader& in)
{
    if (getEncryptionType() != ::nds::core::packaging::NO_ENCRYPTION)
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::packaging::EncryptionKeyId>(static_cast<::nds::core::packaging::EncryptionKeyId>(in.readVarUInt32()));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::packaging::EncryptionKeyId>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::packaging::EncryptionKeyId> PackagingDetails::readEncryptionKeyId(PackagingDetails::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (getEncryptionType() != ::nds::core::packaging::NO_ENCRYPTION)
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::packaging::EncryptionKeyId>(context.getEncryptionKeyId().read<::zserio::VarIntNNArrayTraits<::nds::core::packaging::EncryptionKeyId>>(in));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::packaging::EncryptionKeyId>(::zserio::NullOpt);
}
::nds::core::packaging::DeltaEncodingDetails PackagingDetails::readDeltaEncodingDetails(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::packaging::DeltaEncodingDetails(in, allocator);
}

::nds::core::packaging::DeltaEncodingDetails PackagingDetails::readDeltaEncodingDetails(PackagingDetails::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::packaging::DeltaEncodingDetails(context.getDeltaEncodingDetails(), in, allocator);
}

} // namespace packaging
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/core/packaging/SignatureDefinition.h>

namespace nds
{
namespace core
{
namespace packaging
{

SignatureDefinition::SignatureDefinition(const allocator_type& allocator) noexcept :
        m_id_(::nds::core::packaging::SignatureId()),
        m_type_(::nds::core::packaging::SignatureType()),
        m_size_(::nds::core::packaging::SignatureSize()),
        m_hashType_(::nds::core::packaging::HashType()),
        m_name_(allocator),
        m_keyUri_(allocator)
{
}

SignatureDefinition::SignatureDefinition(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_id_(readId(in)),
        m_type_(readType(in)),
        m_size_(readSize(in)),
        m_hashType_(readHashType(in)),
        m_name_(readName(in, allocator)),
        m_keyUri_(readKeyUri(in, allocator))
{
}

SignatureDefinition::SignatureDefinition(SignatureDefinition::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_id_(readId(context, in)),
        m_type_(readType(context, in)),
        m_size_(readSize(context, in)),
        m_hashType_(readHashType(context, in)),
        m_name_(readName(in, allocator)),
        m_keyUri_(readKeyUri(in, allocator))
{
}

SignatureDefinition::SignatureDefinition(::zserio::PropagateAllocatorT,
        const SignatureDefinition& other, const allocator_type& allocator) :
        m_id_(::zserio::allocatorPropagatingCopy(other.m_id_, allocator)),
        m_type_(::zserio::allocatorPropagatingCopy(other.m_type_, allocator)),
        m_size_(::zserio::allocatorPropagatingCopy(other.m_size_, allocator)),
        m_hashType_(::zserio::allocatorPropagatingCopy(other.m_hashType_, allocator)),
        m_name_(::zserio::allocatorPropagatingCopy(other.m_name_, allocator)),
        m_keyUri_(::zserio::allocatorPropagatingCopy(other.m_keyUri_, allocator))
{
}

::nds::core::packaging::SignatureId SignatureDefinition::getId() const
{
    return m_id_;
}

void SignatureDefinition::setId(::nds::core::packaging::SignatureId id_)
{
    m_id_ = id_;
}

::nds::core::packaging::SignatureType SignatureDefinition::getType() const
{
    return m_type_;
}

void SignatureDefinition::setType(::nds::core::packaging::SignatureType type_)
{
    m_type_ = type_;
}

::nds::core::packaging::SignatureSize SignatureDefinition::getSize() const
{
    return m_size_;
}

void SignatureDefinition::setSize(::nds::core::packaging::SignatureSize size_)
{
    m_size_ = size_;
}

::nds::core::packaging::HashType SignatureDefinition::getHashType() const
{
    return m_hashType_;
}

void SignatureDefinition::setHashType(::nds::core::packaging::HashType hashType_)
{
    m_hashType_ = hashType_;
}

::zserio::string<>& SignatureDefinition::getName()
{
    return m_name_;
}

const ::zserio::string<>& SignatureDefinition::getName() const
{
    return m_name_;
}

void SignatureDefinition::setName(const ::zserio::string<>& name_)
{
    m_name_ = name_;
}

void SignatureDefinition::setName(::zserio::string<>&& name_)
{
    m_name_ = ::std::move(name_);
}

::zserio::string<>& SignatureDefinition::getKeyUri()
{
    return m_keyUri_;
}

const ::zserio::string<>& SignatureDefinition::getKeyUri() const
{
    return m_keyUri_;
}

void SignatureDefinition::setKeyUri(const ::zserio::string<>& keyUri_)
{
    m_keyUri_ = keyUri_;
}

void SignatureDefinition::setKeyUri(::zserio::string<>&& keyUri_)
{
    m_keyUri_ = ::std::move(keyUri_);
}

void SignatureDefinition::initPackingContext(SignatureDefinition::ZserioPackingContext& context) const
{
    context.getId().init<::zserio::VarIntNNArrayTraits<::nds::core::packaging::SignatureId>>(m_id_);
    context.getType().init<::zserio::VarIntNNArrayTraits<::nds::core::packaging::SignatureType>>(m_type_);
    context.getSize().init<::zserio::VarIntNNArrayTraits<::nds::core::packaging::SignatureSize>>(m_size_);
    context.getHashType().init<::zserio::VarIntNNArrayTraits<::nds::core::packaging::HashType>>(m_hashType_);
}

size_t SignatureDefinition::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_id_);
    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_type_);
    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_size_);
    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_hashType_);
    endBitPosition += ::zserio::bitSizeOfString(m_name_);
    endBitPosition += ::zserio::bitSizeOfString(m_keyUri_);

    return endBitPosition - bitPosition;
}

size_t SignatureDefinition::bitSizeOf(SignatureDefinition::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getId().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::packaging::SignatureId>>(m_id_);
    endBitPosition += context.getType().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::packaging::SignatureType>>(m_type_);
    endBitPosition += context.getSize().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::packaging::SignatureSize>>(m_size_);
    endBitPosition += context.getHashType().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::packaging::HashType>>(m_hashType_);
    endBitPosition += ::zserio::bitSizeOfString(m_name_);
    endBitPosition += ::zserio::bitSizeOfString(m_keyUri_);

    return endBitPosition - bitPosition;
}

size_t SignatureDefinition::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_id_);
    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_type_);
    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_size_);
    endBitPosition += ::zserio::bitSizeOfVarUInt16(m_hashType_);
    endBitPosition += ::zserio::bitSizeOfString(m_name_);
    endBitPosition += ::zserio::bitSizeOfString(m_keyUri_);

    return endBitPosition;
}

size_t SignatureDefinition::initializeOffsets(SignatureDefinition::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getId().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::packaging::SignatureId>>(m_id_);
    endBitPosition += context.getType().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::packaging::SignatureType>>(m_type_);
    endBitPosition += context.getSize().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::packaging::SignatureSize>>(m_size_);
    endBitPosition += context.getHashType().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::packaging::HashType>>(m_hashType_);
    endBitPosition += ::zserio::bitSizeOfString(m_name_);
    endBitPosition += ::zserio::bitSizeOfString(m_keyUri_);

    return endBitPosition;
}

bool SignatureDefinition::operator==(const SignatureDefinition& other) const
{
    if (this != &other)
    {
        return
                (m_id_ == other.m_id_) &&
                (m_type_ == other.m_type_) &&
                (m_size_ == other.m_size_) &&
                (m_hashType_ == other.m_hashType_) &&
                (m_name_ == other.m_name_) &&
                (m_keyUri_ == other.m_keyUri_);
    }

    return true;
}

uint32_t SignatureDefinition::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_id_);
    result = ::zserio::calcHashCode(result, m_type_);
    result = ::zserio::calcHashCode(result, m_size_);
    result = ::zserio::calcHashCode(result, m_hashType_);
    result = ::zserio::calcHashCode(result, m_name_);
    result = ::zserio::calcHashCode(result, m_keyUri_);

    return result;
}

void SignatureDefinition::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt16(m_id_);
    out.writeVarUInt16(m_type_);
    out.writeVarUInt32(m_size_);
    out.writeVarUInt16(m_hashType_);
    out.writeString(m_name_);
    out.writeString(m_keyUri_);
}

void SignatureDefinition::write(SignatureDefinition::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getId().write<::zserio::VarIntNNArrayTraits<::nds::core::packaging::SignatureId>>(out, m_id_);
    context.getType().write<::zserio::VarIntNNArrayTraits<::nds::core::packaging::SignatureType>>(out, m_type_);
    context.getSize().write<::zserio::VarIntNNArrayTraits<::nds::core::packaging::SignatureSize>>(out, m_size_);
    context.getHashType().write<::zserio::VarIntNNArrayTraits<::nds::core::packaging::HashType>>(out, m_hashType_);
    out.writeString(m_name_);
    out.writeString(m_keyUri_);
}

::nds::core::packaging::SignatureId SignatureDefinition::readId(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::packaging::SignatureId>(in.readVarUInt16());
}

::nds::core::packaging::SignatureId SignatureDefinition::readId(SignatureDefinition::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getId().read<::zserio::VarIntNNArrayTraits<::nds::core::packaging::SignatureId>>(in);
}
::nds::core::packaging::SignatureType SignatureDefinition::readType(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::packaging::SignatureType>(in.readVarUInt16());
}

::nds::core::packaging::SignatureType SignatureDefinition::readType(SignatureDefinition::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getType().read<::zserio::VarIntNNArrayTraits<::nds::core::packaging::SignatureType>>(in);
}
::nds::core::packaging::SignatureSize SignatureDefinition::readSize(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::packaging::SignatureSize>(in.readVarUInt32());
}

::nds::core::packaging::SignatureSize SignatureDefinition::readSize(SignatureDefinition::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getSize().read<::zserio::VarIntNNArrayTraits<::nds::core::packaging::SignatureSize>>(in);
}
::nds::core::packaging::HashType SignatureDefinition::readHashType(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::packaging::HashType>(in.readVarUInt16());
}

::nds::core::packaging::HashType SignatureDefinition::readHashType(SignatureDefinition::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getHashType().read<::zserio::VarIntNNArrayTraits<::nds::core::packaging::HashType>>(in);
}
::zserio::string<> SignatureDefinition::readName(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return static_cast<::zserio::string<>>(in.readString(allocator));
}
::zserio::string<> SignatureDefinition::readKeyUri(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return static_cast<::zserio::string<>>(in.readString(allocator));
}

} // namespace packaging
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/core/packaging/DeltaEncodingDetails.h>
#include <nds/core/packaging/LAYER_DELETED.h>
#include <nds/core/packaging/NO_DELTA.h>

namespace nds
{
namespace core
{
namespace packaging
{

DeltaEncodingDetails::DeltaEncodingDetails(const allocator_type&) noexcept :
        m_deltaEncodingType_(::nds::core::packaging::DeltaEncodingType()),
        m_sourceVersion_(::zserio::NullOpt)
{
}

DeltaEncodingDetails::DeltaEncodingDetails(::zserio::BitStreamReader& in, const allocator_type&) :
        m_deltaEncodingType_(readDeltaEncodingType(in)),
        m_sourceVersion_(readSourceVersion(in))
{
}

DeltaEncodingDetails::DeltaEncodingDetails(DeltaEncodingDetails::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type&) :
        m_deltaEncodingType_(readDeltaEncodingType(context, in)),
        m_sourceVersion_(readSourceVersion(context, in))
{
}

DeltaEncodingDetails::DeltaEncodingDetails(::zserio::PropagateAllocatorT,
        const DeltaEncodingDetails& other, const allocator_type& allocator) :
        m_deltaEncodingType_(::zserio::allocatorPropagatingCopy(other.m_deltaEncodingType_, allocator)),
        m_sourceVersion_(::zserio::allocatorPropagatingCopy(other.m_sourceVersion_, allocator))
{
}

::nds::core::packaging::DeltaEncodingType DeltaEncodingDetails::getDeltaEncodingType() const
{
    return m_deltaEncodingType_;
}

void DeltaEncodingDetails::setDeltaEncodingType(::nds::core::packaging::DeltaEncodingType deltaEncodingType_)
{
    m_deltaEncodingType_ = deltaEncodingType_;
}

::nds::core::types::VersionId DeltaEncodingDetails::getSourceVersion() const
{
    return m_sourceVersion_.value();
}

void DeltaEncodingDetails::setSourceVersion(::nds::core::types::VersionId sourceVersion_)
{
    m_sourceVersion_ = sourceVersion_;
}

bool DeltaEncodingDetails::isSourceVersionUsed() const
{
    return (getDeltaEncodingType() != ::nds::core::packaging::NO_DELTA && getDeltaEncodingType() != ::nds::core::packaging::LAYER_DELETED);
}

bool DeltaEncodingDetails::isSourceVersionSet() const
{
    return m_sourceVersion_.hasValue();
}

void DeltaEncodingDetails::resetSourceVersion()
{
    m_sourceVersion_.reset();
}

void DeltaEncodingDetails::initPackingContext(DeltaEncodingDetails::ZserioPackingContext& context) const
{
    context.getDeltaEncodingType().init<::zserio::StdIntArrayTraits<::nds::core::packaging::DeltaEncodingType>>(m_deltaEncodingType_);
    if (getDeltaEncodingType() != ::nds::core::packaging::NO_DELTA && getDeltaEncodingType() != ::nds::core::packaging::LAYER_DELETED)
    {
        context.getSourceVersion().init<::zserio::VarIntArrayTraits<::nds::core::types::VersionId>>(m_sourceVersion_.value());
    }
}

size_t DeltaEncodingDetails::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(8);
    if (getDeltaEncodingType() != ::nds::core::packaging::NO_DELTA && getDeltaEncodingType() != ::nds::core::packaging::LAYER_DELETED)
    {
        endBitPosition += ::zserio::bitSizeOfVarUInt(m_sourceVersion_.value());
    }

    return endBitPosition - bitPosition;
}

size_t DeltaEncodingDetails::bitSizeOf(DeltaEncodingDetails::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getDeltaEncodingType().bitSizeOf<::zserio::StdIntArrayTraits<::nds::core::packaging::DeltaEncodingType>>(m_deltaEncodingType_);
    if (getDeltaEncodingType() != ::nds::core::packaging::NO_DELTA && getDeltaEncodingType() != ::nds::core::packaging::LAYER_DELETED)
    {
        endBitPosition += context.getSourceVersion().bitSizeOf<::zserio::VarIntArrayTraits<::nds::core::types::VersionId>>(m_sourceVersion_.value());
    }

    return endBitPosition - bitPosition;
}

size_t DeltaEncodingDetails::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(8);
    if (getDeltaEncodingType() != ::nds::core::packaging::NO_DELTA && getDeltaEncodingType() != ::nds::core::packaging::LAYER_DELETED)
    {
        endBitPosition += ::zserio::bitSizeOfVarUInt(m_sourceVersion_.value());
    }

    return endBitPosition;
}

size_t DeltaEncodingDetails::initializeOffsets(DeltaEncodingDetails::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getDeltaEncodingType().bitSizeOf<::zserio::StdIntArrayTraits<::nds::core::packaging::DeltaEncodingType>>(m_deltaEncodingType_);
    if (getDeltaEncodingType() != ::nds::core::packaging::NO_DELTA && getDeltaEncodingType() != ::nds::core::packaging::LAYER_DELETED)
    {
        endBitPosition += context.getSourceVersion().bitSizeOf<::zserio::VarIntArrayTraits<::nds::core::types::VersionId>>(m_sourceVersion_.value());
    }

    return endBitPosition;
}

bool DeltaEncodingDetails::operator==(const DeltaEncodingDetails& other) const
{
    if (this != &other)
    {
        return
                (m_deltaEncodingType_ == other.m_deltaEncodingType_) &&
                (!isSourceVersionUsed() ? !other.isSourceVersionUsed() : (m_sourceVersion_ == other.m_sourceVersion_));
    }

    return true;
}

uint32_t DeltaEncodingDetails::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_deltaEncodingType_);
    if (isSourceVersionUsed())
        result = ::zserio::calcHashCode(result, m_sourceVersion_);

    return result;
}

void DeltaEncodingDetails::write(::zserio::BitStreamWriter& out) const
{
    out.writeBits(m_deltaEncodingType_, UINT8_C(8));
    if (getDeltaEncodingType() != ::nds::core::packaging::NO_DELTA && getDeltaEncodingType() != ::nds::core::packaging::LAYER_DELETED)
    {
        out.writeVarUInt(m_sourceVersion_.value());
    }
}

void DeltaEncodingDetails::write(DeltaEncodingDetails::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getDeltaEncodingType().write<::zserio::StdIntArrayTraits<::nds::core::packaging::DeltaEncodingType>>(out, m_deltaEncodingType_);
    if (getDeltaEncodingType() != ::nds::core::packaging::NO_DELTA && getDeltaEncodingType() != ::nds::core::packaging::LAYER_DELETED)
    {
        context.getSourceVersion().write<::zserio::VarIntArrayTraits<::nds::core::types::VersionId>>(out, m_sourceVersion_.value());
    }
}

::nds::core::packaging::DeltaEncodingType DeltaEncodingDetails::readDeltaEncodingType(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::packaging::DeltaEncodingType>(in.readBits(UINT8_C(8)));
}

::nds::core::packaging::DeltaEncodingType DeltaEncodingDetails::readDeltaEncodingType(DeltaEncodingDetails::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getDeltaEncodingType().read<::zserio::StdIntArrayTraits<::nds::core::packaging::DeltaEncodingType>>(in);
}
::zserio::InplaceOptionalHolder<::nds::core::types::VersionId> DeltaEncodingDetails::readSourceVersion(::zserio::BitStreamReader& in)
{
    if (getDeltaEncodingType() != ::nds::core::packaging::NO_DELTA && getDeltaEncodingType() != ::nds::core::packaging::LAYER_DELETED)
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::types::VersionId>(static_cast<::nds::core::types::VersionId>(in.readVarUInt()));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::types::VersionId>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::types::VersionId> DeltaEncodingDetails::readSourceVersion(DeltaEncodingDetails::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    if (getDeltaEncodingType() != ::nds::core::packaging::NO_DELTA && getDeltaEncodingType() != ::nds::core::packaging::LAYER_DELETED)
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::types::VersionId>(context.getSourceVersion().read<::zserio::VarIntArrayTraits<::nds::core::types::VersionId>>(in));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::types::VersionId>(::zserio::NullOpt);
}

} // namespace packaging
} // namespace core
} // namespace nds
