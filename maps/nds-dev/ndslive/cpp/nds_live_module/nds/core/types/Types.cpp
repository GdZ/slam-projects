/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/core/types/ElectricCurrent.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for ElectricCurrent enumeration.
constexpr ::std::array<const char*, 2> EnumTraits<::nds::core::types::ElectricCurrent>::names;
constexpr ::std::array<::nds::core::types::ElectricCurrent, 2> EnumTraits<::nds::core::types::ElectricCurrent>::values;
constexpr const char* EnumTraits<::nds::core::types::ElectricCurrent>::enumName;

template <>
size_t enumToOrdinal(::nds::core::types::ElectricCurrent value)
{
    switch (value)
    {
    case ::nds::core::types::ElectricCurrent::AC:
        return 0;
    case ::nds::core::types::ElectricCurrent::DC:
        return 1;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration ElectricCurrent: ") <<
                static_cast<typename ::std::underlying_type<::nds::core::types::ElectricCurrent>::type>(value) << "!";
    }
}

template <>
::nds::core::types::ElectricCurrent valueToEnum(
        typename ::std::underlying_type<::nds::core::types::ElectricCurrent>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
        return static_cast<::nds::core::types::ElectricCurrent>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration ElectricCurrent: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::core::types::ElectricCurrent>(::nds::core::types::ElectricCurrent value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::core::types::ElectricCurrent value)
{
    context.init<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::core::types::ElectricCurrent>::type, UINT8_C(1)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::core::types::ElectricCurrent)
{
    return UINT8_C(1);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::core::types::ElectricCurrent value)
{
    return context.bitSizeOf<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::core::types::ElectricCurrent>::type, UINT8_C(1)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::core::types::ElectricCurrent value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::core::types::ElectricCurrent value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::core::types::ElectricCurrent read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::core::types::ElectricCurrent>(
            static_cast<typename ::std::underlying_type<::nds::core::types::ElectricCurrent>::type>(
                    in.readBits(UINT8_C(1))));
}

template <>
::nds::core::types::ElectricCurrent read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::core::types::ElectricCurrent>(context.read<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::core::types::ElectricCurrent>::type, UINT8_C(1)>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::core::types::ElectricCurrent value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(1));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::core::types::ElectricCurrent value)
{
    context.write<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::core::types::ElectricCurrent>::type, UINT8_C(1)>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/core/types/Direction.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for Direction enumeration.
constexpr ::std::array<const char*, 3> EnumTraits<::nds::core::types::Direction>::names;
constexpr ::std::array<::nds::core::types::Direction, 3> EnumTraits<::nds::core::types::Direction>::values;
constexpr const char* EnumTraits<::nds::core::types::Direction>::enumName;

template <>
size_t enumToOrdinal(::nds::core::types::Direction value)
{
    switch (value)
    {
    case ::nds::core::types::Direction::IN_POSITIVE_DIRECTION:
        return 0;
    case ::nds::core::types::Direction::IN_NEGATIVE_DIRECTION:
        return 1;
    case ::nds::core::types::Direction::IN_BOTH_DIRECTIONS:
        return 2;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration Direction: ") <<
                static_cast<typename ::std::underlying_type<::nds::core::types::Direction>::type>(value) << "!";
    }
}

template <>
::nds::core::types::Direction valueToEnum(
        typename ::std::underlying_type<::nds::core::types::Direction>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
        return static_cast<::nds::core::types::Direction>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration Direction: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::core::types::Direction>(::nds::core::types::Direction value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::core::types::Direction value)
{
    context.init<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::core::types::Direction>::type, UINT8_C(2)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::core::types::Direction)
{
    return UINT8_C(2);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::core::types::Direction value)
{
    return context.bitSizeOf<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::core::types::Direction>::type, UINT8_C(2)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::core::types::Direction value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::core::types::Direction value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::core::types::Direction read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::core::types::Direction>(
            static_cast<typename ::std::underlying_type<::nds::core::types::Direction>::type>(
                    in.readBits(UINT8_C(2))));
}

template <>
::nds::core::types::Direction read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::core::types::Direction>(context.read<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::core::types::Direction>::type, UINT8_C(2)>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::core::types::Direction value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(2));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::core::types::Direction value)
{
    context.write<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::core::types::Direction>::type, UINT8_C(2)>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/core/types/RoadForm.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for RoadForm enumeration.
constexpr ::std::array<const char*, 14> EnumTraits<::nds::core::types::RoadForm>::names;
constexpr ::std::array<::nds::core::types::RoadForm, 14> EnumTraits<::nds::core::types::RoadForm>::values;
constexpr const char* EnumTraits<::nds::core::types::RoadForm>::enumName;

template <>
size_t enumToOrdinal(::nds::core::types::RoadForm value)
{
    switch (value)
    {
    case ::nds::core::types::RoadForm::ANY:
        return 0;
    case ::nds::core::types::RoadForm::NORMAL:
        return 1;
    case ::nds::core::types::RoadForm::DUAL_CARRIAGEWAY:
        return 2;
    case ::nds::core::types::RoadForm::SLIP_ROAD:
        return 3;
    case ::nds::core::types::RoadForm::RAMP:
        return 4;
    case ::nds::core::types::RoadForm::INTERCHANGE:
        return 5;
    case ::nds::core::types::RoadForm::ROUNDABOUT:
        return 6;
    case ::nds::core::types::RoadForm::ROUNDABOUT_INTERIOR:
        return 7;
    case ::nds::core::types::RoadForm::SQUARE:
        return 8;
    case ::nds::core::types::RoadForm::PEDESTRIAN_WAY:
        return 9;
    case ::nds::core::types::RoadForm::SPECIAL_TRAFFIC_FIGURE:
        return 10;
    case ::nds::core::types::RoadForm::PARALLEL_ROAD:
        return 11;
    case ::nds::core::types::RoadForm::SERVICE_ROAD:
        return 12;
    case ::nds::core::types::RoadForm::MINI_ROUNDABOUT:
        return 13;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration RoadForm: ") <<
                static_cast<typename ::std::underlying_type<::nds::core::types::RoadForm>::type>(value) << "!";
    }
}

template <>
::nds::core::types::RoadForm valueToEnum(
        typename ::std::underlying_type<::nds::core::types::RoadForm>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
    case UINT8_C(3):
    case UINT8_C(4):
    case UINT8_C(5):
    case UINT8_C(6):
    case UINT8_C(7):
    case UINT8_C(8):
    case UINT8_C(9):
    case UINT8_C(10):
    case UINT8_C(11):
    case UINT8_C(12):
    case UINT8_C(13):
        return static_cast<::nds::core::types::RoadForm>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration RoadForm: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::core::types::RoadForm>(::nds::core::types::RoadForm value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::core::types::RoadForm value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::core::types::RoadForm>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::core::types::RoadForm)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::core::types::RoadForm value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::core::types::RoadForm>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::core::types::RoadForm value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::core::types::RoadForm value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::core::types::RoadForm read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::core::types::RoadForm>(
            static_cast<typename ::std::underlying_type<::nds::core::types::RoadForm>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::core::types::RoadForm read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::core::types::RoadForm>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::core::types::RoadForm>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::core::types::RoadForm value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::core::types::RoadForm value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::core::types::RoadForm>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/core/types/RoadCharacter.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for RoadCharacter enumeration.
constexpr ::std::array<const char*, 32> EnumTraits<::nds::core::types::RoadCharacter>::names;
constexpr ::std::array<::nds::core::types::RoadCharacter, 32> EnumTraits<::nds::core::types::RoadCharacter>::values;
constexpr const char* EnumTraits<::nds::core::types::RoadCharacter>::enumName;

template <>
size_t enumToOrdinal(::nds::core::types::RoadCharacter value)
{
    switch (value)
    {
    case ::nds::core::types::RoadCharacter::URBAN:
        return 0;
    case ::nds::core::types::RoadCharacter::SERVICE_AREA:
        return 1;
    case ::nds::core::types::RoadCharacter::PARKING:
        return 2;
    case ::nds::core::types::RoadCharacter::COVERED:
        return 3;
    case ::nds::core::types::RoadCharacter::MOTORWAY:
        return 4;
    case ::nds::core::types::RoadCharacter::EXPRESSWAY:
        return 5;
    case ::nds::core::types::RoadCharacter::FERRY:
        return 6;
    case ::nds::core::types::RoadCharacter::TUNNEL:
        return 7;
    case ::nds::core::types::RoadCharacter::BRIDGE:
        return 8;
    case ::nds::core::types::RoadCharacter::MULTI_DIGITIZED:
        return 9;
    case ::nds::core::types::RoadCharacter::COMPLEX_INTERSECTION:
        return 10;
    case ::nds::core::types::RoadCharacter::IS_ELEVATED_ROAD:
        return 11;
    case ::nds::core::types::RoadCharacter::OVERPASS:
        return 12;
    case ::nds::core::types::RoadCharacter::UNDERPASS:
        return 13;
    case ::nds::core::types::RoadCharacter::RACE_TRACK:
        return 14;
    case ::nds::core::types::RoadCharacter::INSIDE_CITY_LIMITS:
        return 15;
    case ::nds::core::types::RoadCharacter::PEDESTRIAN_ZONE:
        return 16;
    case ::nds::core::types::RoadCharacter::CONTROLLED_ACCESS:
        return 17;
    case ::nds::core::types::RoadCharacter::PHYSICALLY_SEPARATED:
        return 18;
    case ::nds::core::types::RoadCharacter::TRACKS_ON_ROAD:
        return 19;
    case ::nds::core::types::RoadCharacter::BICYCLE_PATH:
        return 20;
    case ::nds::core::types::RoadCharacter::BUS_ROAD:
        return 21;
    case ::nds::core::types::RoadCharacter::HORSE_WAY:
        return 22;
    case ::nds::core::types::RoadCharacter::TAXI_ROAD:
        return 23;
    case ::nds::core::types::RoadCharacter::EMERGENCY_ROAD:
        return 24;
    case ::nds::core::types::RoadCharacter::TRUCK_ESCAPE_RAMP:
        return 25;
    case ::nds::core::types::RoadCharacter::EXPRESS_ROAD:
        return 26;
    case ::nds::core::types::RoadCharacter::STATION_PLAZA:
        return 27;
    case ::nds::core::types::RoadCharacter::HAS_SHOULDER_LANE:
        return 28;
    case ::nds::core::types::RoadCharacter::TOLL_ROAD:
        return 29;
    case ::nds::core::types::RoadCharacter::MAIN_ROAD:
        return 30;
    case ::nds::core::types::RoadCharacter::U_TURN_ROAD:
        return 31;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration RoadCharacter: ") <<
                static_cast<typename ::std::underlying_type<::nds::core::types::RoadCharacter>::type>(value) << "!";
    }
}

template <>
::nds::core::types::RoadCharacter valueToEnum(
        typename ::std::underlying_type<::nds::core::types::RoadCharacter>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
    case UINT8_C(3):
    case UINT8_C(4):
    case UINT8_C(5):
    case UINT8_C(6):
    case UINT8_C(7):
    case UINT8_C(8):
    case UINT8_C(9):
    case UINT8_C(10):
    case UINT8_C(11):
    case UINT8_C(12):
    case UINT8_C(13):
    case UINT8_C(14):
    case UINT8_C(15):
    case UINT8_C(16):
    case UINT8_C(17):
    case UINT8_C(18):
    case UINT8_C(19):
    case UINT8_C(20):
    case UINT8_C(21):
    case UINT8_C(22):
    case UINT8_C(23):
    case UINT8_C(24):
    case UINT8_C(25):
    case UINT8_C(26):
    case UINT8_C(27):
    case UINT8_C(28):
    case UINT8_C(29):
    case UINT8_C(30):
    case UINT8_C(31):
        return static_cast<::nds::core::types::RoadCharacter>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration RoadCharacter: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::core::types::RoadCharacter>(::nds::core::types::RoadCharacter value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::core::types::RoadCharacter value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::core::types::RoadCharacter>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::core::types::RoadCharacter)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::core::types::RoadCharacter value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::core::types::RoadCharacter>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::core::types::RoadCharacter value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::core::types::RoadCharacter value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::core::types::RoadCharacter read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::core::types::RoadCharacter>(
            static_cast<typename ::std::underlying_type<::nds::core::types::RoadCharacter>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::core::types::RoadCharacter read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::core::types::RoadCharacter>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::core::types::RoadCharacter>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::core::types::RoadCharacter value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::core::types::RoadCharacter value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::core::types::RoadCharacter>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/core/types/LaneFunctionalType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for LaneFunctionalType enumeration.
constexpr ::std::array<const char*, 10> EnumTraits<::nds::core::types::LaneFunctionalType>::names;
constexpr ::std::array<::nds::core::types::LaneFunctionalType, 10> EnumTraits<::nds::core::types::LaneFunctionalType>::values;
constexpr const char* EnumTraits<::nds::core::types::LaneFunctionalType>::enumName;

template <>
size_t enumToOrdinal(::nds::core::types::LaneFunctionalType value)
{
    switch (value)
    {
    case ::nds::core::types::LaneFunctionalType::NORMAL_LANE:
        return 0;
    case ::nds::core::types::LaneFunctionalType::EXIT_LANE:
        return 1;
    case ::nds::core::types::LaneFunctionalType::ENTRY_LANE:
        return 2;
    case ::nds::core::types::LaneFunctionalType::ENTRY_AND_EXIT_LANE:
        return 3;
    case ::nds::core::types::LaneFunctionalType::TURNING_LANE:
        return 4;
    case ::nds::core::types::LaneFunctionalType::PARKING_LANE:
        return 5;
    case ::nds::core::types::LaneFunctionalType::TRUCK_PARKING_LANE:
        return 6;
    case ::nds::core::types::LaneFunctionalType::WAITING_LANE:
        return 7;
    case ::nds::core::types::LaneFunctionalType::ANY:
        return 8;
    case ::nds::core::types::LaneFunctionalType::U_TURN_LANE:
        return 9;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration LaneFunctionalType: ") <<
                static_cast<typename ::std::underlying_type<::nds::core::types::LaneFunctionalType>::type>(value) << "!";
    }
}

template <>
::nds::core::types::LaneFunctionalType valueToEnum(
        typename ::std::underlying_type<::nds::core::types::LaneFunctionalType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT16_C(0):
    case UINT16_C(1):
    case UINT16_C(2):
    case UINT16_C(3):
    case UINT16_C(4):
    case UINT16_C(5):
    case UINT16_C(6):
    case UINT16_C(7):
    case UINT16_C(8):
    case UINT16_C(9):
        return static_cast<::nds::core::types::LaneFunctionalType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration LaneFunctionalType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::core::types::LaneFunctionalType>(::nds::core::types::LaneFunctionalType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::core::types::LaneFunctionalType value)
{
    context.init<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::core::types::LaneFunctionalType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::core::types::LaneFunctionalType value)
{
    return ::zserio::bitSizeOfVarUInt16(::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::core::types::LaneFunctionalType value)
{
    return context.bitSizeOf<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::core::types::LaneFunctionalType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::core::types::LaneFunctionalType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::core::types::LaneFunctionalType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::core::types::LaneFunctionalType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::core::types::LaneFunctionalType>(
            static_cast<typename ::std::underlying_type<::nds::core::types::LaneFunctionalType>::type>(
                    in.readVarUInt16()));
}

template <>
::nds::core::types::LaneFunctionalType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::core::types::LaneFunctionalType>(context.read<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::core::types::LaneFunctionalType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::core::types::LaneFunctionalType value)
{
    out.writeVarUInt16(::zserio::enumToValue(value));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::core::types::LaneFunctionalType value)
{
    context.write<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::core::types::LaneFunctionalType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/core/types/TrafficEnforcementCameraType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for TrafficEnforcementCameraType enumeration.
constexpr ::std::array<const char*, 26> EnumTraits<::nds::core::types::TrafficEnforcementCameraType>::names;
constexpr ::std::array<::nds::core::types::TrafficEnforcementCameraType, 26> EnumTraits<::nds::core::types::TrafficEnforcementCameraType>::values;
constexpr const char* EnumTraits<::nds::core::types::TrafficEnforcementCameraType>::enumName;

template <>
size_t enumToOrdinal(::nds::core::types::TrafficEnforcementCameraType value)
{
    switch (value)
    {
    case ::nds::core::types::TrafficEnforcementCameraType::FIXED_SPEED:
        return 0;
    case ::nds::core::types::TrafficEnforcementCameraType::MOBILE_SPEED:
        return 1;
    case ::nds::core::types::TrafficEnforcementCameraType::REDLIGHT:
        return 2;
    case ::nds::core::types::TrafficEnforcementCameraType::TOLLROAD:
        return 3;
    case ::nds::core::types::TrafficEnforcementCameraType::PECCANCY:
        return 4;
    case ::nds::core::types::TrafficEnforcementCameraType::SPECIAL_LANE:
        return 5;
    case ::nds::core::types::TrafficEnforcementCameraType::FIXED_SPEED_AND_RED_LIGHT:
        return 6;
    case ::nds::core::types::TrafficEnforcementCameraType::BUS_LANE:
        return 7;
    case ::nds::core::types::TrafficEnforcementCameraType::FAKE:
        return 8;
    case ::nds::core::types::TrafficEnforcementCameraType::PARKING_VIOLATION:
        return 9;
    case ::nds::core::types::TrafficEnforcementCameraType::TRAFFIC_ENFORCEMENT_ZONE_ENTRY:
        return 10;
    case ::nds::core::types::TrafficEnforcementCameraType::TRAFFIC_ENFORCEMENT_ZONE_EXIT:
        return 11;
    case ::nds::core::types::TrafficEnforcementCameraType::MARKING_VIOLATION:
        return 12;
    case ::nds::core::types::TrafficEnforcementCameraType::TRAFFIC_INFORMATION_COLLECTION:
        return 13;
    case ::nds::core::types::TrafficEnforcementCameraType::BUS_LANE_AND_FIXED_SPEED:
        return 14;
    case ::nds::core::types::TrafficEnforcementCameraType::SHOULDER_LANE:
        return 15;
    case ::nds::core::types::TrafficEnforcementCameraType::MERGING_TRAFFIC:
        return 16;
    case ::nds::core::types::TrafficEnforcementCameraType::RAMP_METERING:
        return 17;
    case ::nds::core::types::TrafficEnforcementCameraType::NON_MOTORIZED_VEHICLE:
        return 18;
    case ::nds::core::types::TrafficEnforcementCameraType::YIELD_TO_PEDESTRIANS:
        return 19;
    case ::nds::core::types::TrafficEnforcementCameraType::ILLEGAL_LANE_OCCUPATION:
        return 20;
    case ::nds::core::types::TrafficEnforcementCameraType::PHONE_USAGE:
        return 21;
    case ::nds::core::types::TrafficEnforcementCameraType::SEAT_BELT:
        return 22;
    case ::nds::core::types::TrafficEnforcementCameraType::HORN_USAGE:
        return 23;
    case ::nds::core::types::TrafficEnforcementCameraType::ILLEGAL_LAMP_USAGE:
        return 24;
    case ::nds::core::types::TrafficEnforcementCameraType::OTHER:
        return 25;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration TrafficEnforcementCameraType: ") <<
                static_cast<typename ::std::underlying_type<::nds::core::types::TrafficEnforcementCameraType>::type>(value) << "!";
    }
}

template <>
::nds::core::types::TrafficEnforcementCameraType valueToEnum(
        typename ::std::underlying_type<::nds::core::types::TrafficEnforcementCameraType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
    case UINT8_C(3):
    case UINT8_C(4):
    case UINT8_C(5):
    case UINT8_C(6):
    case UINT8_C(7):
    case UINT8_C(8):
    case UINT8_C(9):
    case UINT8_C(10):
    case UINT8_C(11):
    case UINT8_C(12):
    case UINT8_C(13):
    case UINT8_C(14):
    case UINT8_C(15):
    case UINT8_C(16):
    case UINT8_C(17):
    case UINT8_C(18):
    case UINT8_C(19):
    case UINT8_C(20):
    case UINT8_C(21):
    case UINT8_C(22):
    case UINT8_C(23):
    case UINT8_C(24):
    case UINT8_C(31):
        return static_cast<::nds::core::types::TrafficEnforcementCameraType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration TrafficEnforcementCameraType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::core::types::TrafficEnforcementCameraType>(::nds::core::types::TrafficEnforcementCameraType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::core::types::TrafficEnforcementCameraType value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::core::types::TrafficEnforcementCameraType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::core::types::TrafficEnforcementCameraType)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::core::types::TrafficEnforcementCameraType value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::core::types::TrafficEnforcementCameraType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::core::types::TrafficEnforcementCameraType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::core::types::TrafficEnforcementCameraType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::core::types::TrafficEnforcementCameraType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::core::types::TrafficEnforcementCameraType>(
            static_cast<typename ::std::underlying_type<::nds::core::types::TrafficEnforcementCameraType>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::core::types::TrafficEnforcementCameraType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::core::types::TrafficEnforcementCameraType>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::core::types::TrafficEnforcementCameraType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::core::types::TrafficEnforcementCameraType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::core::types::TrafficEnforcementCameraType value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::core::types::TrafficEnforcementCameraType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/core/types/TrafficEnforcementZoneType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for TrafficEnforcementZoneType enumeration.
constexpr ::std::array<const char*, 6> EnumTraits<::nds::core::types::TrafficEnforcementZoneType>::names;
constexpr ::std::array<::nds::core::types::TrafficEnforcementZoneType, 6> EnumTraits<::nds::core::types::TrafficEnforcementZoneType>::values;
constexpr const char* EnumTraits<::nds::core::types::TrafficEnforcementZoneType>::enumName;

template <>
size_t enumToOrdinal(::nds::core::types::TrafficEnforcementZoneType value)
{
    switch (value)
    {
    case ::nds::core::types::TrafficEnforcementZoneType::AVERAGE_SPEED_ZONE:
        return 0;
    case ::nds::core::types::TrafficEnforcementZoneType::SPEED_ENFORCEMENT_ZONE:
        return 1;
    case ::nds::core::types::TrafficEnforcementZoneType::DANGER_ZONE:
        return 2;
    case ::nds::core::types::TrafficEnforcementZoneType::MOBILE_SPEED_HOTSPOT_ZONE:
        return 3;
    case ::nds::core::types::TrafficEnforcementZoneType::ACCIDENT_BLACKSPOT_ZONE:
        return 4;
    case ::nds::core::types::TrafficEnforcementZoneType::RISK_ZONE:
        return 5;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration TrafficEnforcementZoneType: ") <<
                static_cast<typename ::std::underlying_type<::nds::core::types::TrafficEnforcementZoneType>::type>(value) << "!";
    }
}

template <>
::nds::core::types::TrafficEnforcementZoneType valueToEnum(
        typename ::std::underlying_type<::nds::core::types::TrafficEnforcementZoneType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
    case UINT8_C(3):
    case UINT8_C(4):
    case UINT8_C(5):
        return static_cast<::nds::core::types::TrafficEnforcementZoneType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration TrafficEnforcementZoneType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::core::types::TrafficEnforcementZoneType>(::nds::core::types::TrafficEnforcementZoneType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::core::types::TrafficEnforcementZoneType value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::core::types::TrafficEnforcementZoneType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::core::types::TrafficEnforcementZoneType)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::core::types::TrafficEnforcementZoneType value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::core::types::TrafficEnforcementZoneType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::core::types::TrafficEnforcementZoneType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::core::types::TrafficEnforcementZoneType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::core::types::TrafficEnforcementZoneType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::core::types::TrafficEnforcementZoneType>(
            static_cast<typename ::std::underlying_type<::nds::core::types::TrafficEnforcementZoneType>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::core::types::TrafficEnforcementZoneType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::core::types::TrafficEnforcementZoneType>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::core::types::TrafficEnforcementZoneType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::core::types::TrafficEnforcementZoneType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::core::types::TrafficEnforcementZoneType value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::core::types::TrafficEnforcementZoneType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/core/types/Currency.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for Currency enumeration.
constexpr ::std::array<const char*, 167> EnumTraits<::nds::core::types::Currency>::names;
constexpr ::std::array<::nds::core::types::Currency, 167> EnumTraits<::nds::core::types::Currency>::values;
constexpr const char* EnumTraits<::nds::core::types::Currency>::enumName;

template <>
size_t enumToOrdinal(::nds::core::types::Currency value)
{
    switch (value)
    {
    case ::nds::core::types::Currency::AED:
        return 0;
    case ::nds::core::types::Currency::AFN:
        return 1;
    case ::nds::core::types::Currency::ALL:
        return 2;
    case ::nds::core::types::Currency::AMD:
        return 3;
    case ::nds::core::types::Currency::ANG:
        return 4;
    case ::nds::core::types::Currency::AOA:
        return 5;
    case ::nds::core::types::Currency::ARS:
        return 6;
    case ::nds::core::types::Currency::AUD:
        return 7;
    case ::nds::core::types::Currency::AWG:
        return 8;
    case ::nds::core::types::Currency::AZN:
        return 9;
    case ::nds::core::types::Currency::BAM:
        return 10;
    case ::nds::core::types::Currency::BBD:
        return 11;
    case ::nds::core::types::Currency::BDT:
        return 12;
    case ::nds::core::types::Currency::BGN:
        return 13;
    case ::nds::core::types::Currency::BHD:
        return 14;
    case ::nds::core::types::Currency::BIF:
        return 15;
    case ::nds::core::types::Currency::BMD:
        return 16;
    case ::nds::core::types::Currency::BND:
        return 17;
    case ::nds::core::types::Currency::BOB:
        return 18;
    case ::nds::core::types::Currency::BRL:
        return 19;
    case ::nds::core::types::Currency::BSD:
        return 20;
    case ::nds::core::types::Currency::BTN:
        return 21;
    case ::nds::core::types::Currency::BWP:
        return 22;
    case ::nds::core::types::Currency::BYR:
        return 23;
    case ::nds::core::types::Currency::BZD:
        return 24;
    case ::nds::core::types::Currency::CAD:
        return 25;
    case ::nds::core::types::Currency::CDF:
        return 26;
    case ::nds::core::types::Currency::CHF:
        return 27;
    case ::nds::core::types::Currency::CLP:
        return 28;
    case ::nds::core::types::Currency::CNY:
        return 29;
    case ::nds::core::types::Currency::COP:
        return 30;
    case ::nds::core::types::Currency::CRC:
        return 31;
    case ::nds::core::types::Currency::CUP:
        return 32;
    case ::nds::core::types::Currency::CVE:
        return 33;
    case ::nds::core::types::Currency::CZK:
        return 34;
    case ::nds::core::types::Currency::DJF:
        return 35;
    case ::nds::core::types::Currency::DKK:
        return 36;
    case ::nds::core::types::Currency::DOP:
        return 37;
    case ::nds::core::types::Currency::DZD:
        return 38;
    case ::nds::core::types::Currency::EEK:
        return 39;
    case ::nds::core::types::Currency::EGP:
        return 40;
    case ::nds::core::types::Currency::ERN:
        return 41;
    case ::nds::core::types::Currency::ETB:
        return 42;
    case ::nds::core::types::Currency::EUR:
        return 43;
    case ::nds::core::types::Currency::FJD:
        return 44;
    case ::nds::core::types::Currency::FKP:
        return 45;
    case ::nds::core::types::Currency::GBP:
        return 46;
    case ::nds::core::types::Currency::GEL:
        return 47;
    case ::nds::core::types::Currency::GGP:
        return 48;
    case ::nds::core::types::Currency::GHS:
        return 49;
    case ::nds::core::types::Currency::GIP:
        return 50;
    case ::nds::core::types::Currency::GMD:
        return 51;
    case ::nds::core::types::Currency::GNF:
        return 52;
    case ::nds::core::types::Currency::GTQ:
        return 53;
    case ::nds::core::types::Currency::GYD:
        return 54;
    case ::nds::core::types::Currency::HKD:
        return 55;
    case ::nds::core::types::Currency::HNL:
        return 56;
    case ::nds::core::types::Currency::HRK:
        return 57;
    case ::nds::core::types::Currency::HTG:
        return 58;
    case ::nds::core::types::Currency::HUF:
        return 59;
    case ::nds::core::types::Currency::IDR:
        return 60;
    case ::nds::core::types::Currency::ILS:
        return 61;
    case ::nds::core::types::Currency::IMP:
        return 62;
    case ::nds::core::types::Currency::INR:
        return 63;
    case ::nds::core::types::Currency::IQD:
        return 64;
    case ::nds::core::types::Currency::IRR:
        return 65;
    case ::nds::core::types::Currency::ISK:
        return 66;
    case ::nds::core::types::Currency::JEP:
        return 67;
    case ::nds::core::types::Currency::JMD:
        return 68;
    case ::nds::core::types::Currency::JOD:
        return 69;
    case ::nds::core::types::Currency::JPY:
        return 70;
    case ::nds::core::types::Currency::KES:
        return 71;
    case ::nds::core::types::Currency::KGS:
        return 72;
    case ::nds::core::types::Currency::KHR:
        return 73;
    case ::nds::core::types::Currency::KMF:
        return 74;
    case ::nds::core::types::Currency::KPW:
        return 75;
    case ::nds::core::types::Currency::KRW:
        return 76;
    case ::nds::core::types::Currency::KWD:
        return 77;
    case ::nds::core::types::Currency::KYD:
        return 78;
    case ::nds::core::types::Currency::KZT:
        return 79;
    case ::nds::core::types::Currency::LAK:
        return 80;
    case ::nds::core::types::Currency::LBP:
        return 81;
    case ::nds::core::types::Currency::LKR:
        return 82;
    case ::nds::core::types::Currency::LRD:
        return 83;
    case ::nds::core::types::Currency::LSL:
        return 84;
    case ::nds::core::types::Currency::LTL:
        return 85;
    case ::nds::core::types::Currency::LVL:
        return 86;
    case ::nds::core::types::Currency::LYD:
        return 87;
    case ::nds::core::types::Currency::MAD:
        return 88;
    case ::nds::core::types::Currency::MDL:
        return 89;
    case ::nds::core::types::Currency::MGA:
        return 90;
    case ::nds::core::types::Currency::MKD:
        return 91;
    case ::nds::core::types::Currency::MMK:
        return 92;
    case ::nds::core::types::Currency::MNT:
        return 93;
    case ::nds::core::types::Currency::MOP:
        return 94;
    case ::nds::core::types::Currency::MRO:
        return 95;
    case ::nds::core::types::Currency::MUR:
        return 96;
    case ::nds::core::types::Currency::MVR:
        return 97;
    case ::nds::core::types::Currency::MWK:
        return 98;
    case ::nds::core::types::Currency::MXN:
        return 99;
    case ::nds::core::types::Currency::MYR:
        return 100;
    case ::nds::core::types::Currency::MZN:
        return 101;
    case ::nds::core::types::Currency::NAD:
        return 102;
    case ::nds::core::types::Currency::NGN:
        return 103;
    case ::nds::core::types::Currency::NIO:
        return 104;
    case ::nds::core::types::Currency::NOK:
        return 105;
    case ::nds::core::types::Currency::NPR:
        return 106;
    case ::nds::core::types::Currency::NZD:
        return 107;
    case ::nds::core::types::Currency::OMR:
        return 108;
    case ::nds::core::types::Currency::PAB:
        return 109;
    case ::nds::core::types::Currency::PEN:
        return 110;
    case ::nds::core::types::Currency::PGK:
        return 111;
    case ::nds::core::types::Currency::PHP:
        return 112;
    case ::nds::core::types::Currency::PKR:
        return 113;
    case ::nds::core::types::Currency::PLN:
        return 114;
    case ::nds::core::types::Currency::PYG:
        return 115;
    case ::nds::core::types::Currency::QAR:
        return 116;
    case ::nds::core::types::Currency::RON:
        return 117;
    case ::nds::core::types::Currency::RSD:
        return 118;
    case ::nds::core::types::Currency::RUB:
        return 119;
    case ::nds::core::types::Currency::RWF:
        return 120;
    case ::nds::core::types::Currency::SAR:
        return 121;
    case ::nds::core::types::Currency::SBD:
        return 122;
    case ::nds::core::types::Currency::SCR:
        return 123;
    case ::nds::core::types::Currency::SDG:
        return 124;
    case ::nds::core::types::Currency::SEK:
        return 125;
    case ::nds::core::types::Currency::SGD:
        return 126;
    case ::nds::core::types::Currency::SHP:
        return 127;
    case ::nds::core::types::Currency::SLL:
        return 128;
    case ::nds::core::types::Currency::SOS:
        return 129;
    case ::nds::core::types::Currency::SPL:
        return 130;
    case ::nds::core::types::Currency::SRD:
        return 131;
    case ::nds::core::types::Currency::STD:
        return 132;
    case ::nds::core::types::Currency::SVC:
        return 133;
    case ::nds::core::types::Currency::SYP:
        return 134;
    case ::nds::core::types::Currency::SZL:
        return 135;
    case ::nds::core::types::Currency::THB:
        return 136;
    case ::nds::core::types::Currency::TJS:
        return 137;
    case ::nds::core::types::Currency::TMM:
        return 138;
    case ::nds::core::types::Currency::TND:
        return 139;
    case ::nds::core::types::Currency::TOP:
        return 140;
    case ::nds::core::types::Currency::TRY:
        return 141;
    case ::nds::core::types::Currency::TTD:
        return 142;
    case ::nds::core::types::Currency::TVD:
        return 143;
    case ::nds::core::types::Currency::TWD:
        return 144;
    case ::nds::core::types::Currency::TZS:
        return 145;
    case ::nds::core::types::Currency::UAH:
        return 146;
    case ::nds::core::types::Currency::UGX:
        return 147;
    case ::nds::core::types::Currency::USD:
        return 148;
    case ::nds::core::types::Currency::UYU:
        return 149;
    case ::nds::core::types::Currency::UZS:
        return 150;
    case ::nds::core::types::Currency::VEF:
        return 151;
    case ::nds::core::types::Currency::VND:
        return 152;
    case ::nds::core::types::Currency::VUV:
        return 153;
    case ::nds::core::types::Currency::WST:
        return 154;
    case ::nds::core::types::Currency::XAF:
        return 155;
    case ::nds::core::types::Currency::XAG:
        return 156;
    case ::nds::core::types::Currency::XAU:
        return 157;
    case ::nds::core::types::Currency::XCD:
        return 158;
    case ::nds::core::types::Currency::XOF:
        return 159;
    case ::nds::core::types::Currency::XPD:
        return 160;
    case ::nds::core::types::Currency::XPF:
        return 161;
    case ::nds::core::types::Currency::XPT:
        return 162;
    case ::nds::core::types::Currency::YER:
        return 163;
    case ::nds::core::types::Currency::ZAR:
        return 164;
    case ::nds::core::types::Currency::ZMK:
        return 165;
    case ::nds::core::types::Currency::ZWD:
        return 166;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration Currency: ") <<
                static_cast<typename ::std::underlying_type<::nds::core::types::Currency>::type>(value) << "!";
    }
}

template <>
::nds::core::types::Currency valueToEnum(
        typename ::std::underlying_type<::nds::core::types::Currency>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
    case UINT8_C(3):
    case UINT8_C(4):
    case UINT8_C(5):
    case UINT8_C(6):
    case UINT8_C(7):
    case UINT8_C(8):
    case UINT8_C(9):
    case UINT8_C(10):
    case UINT8_C(11):
    case UINT8_C(12):
    case UINT8_C(13):
    case UINT8_C(14):
    case UINT8_C(15):
    case UINT8_C(16):
    case UINT8_C(17):
    case UINT8_C(18):
    case UINT8_C(19):
    case UINT8_C(20):
    case UINT8_C(21):
    case UINT8_C(22):
    case UINT8_C(23):
    case UINT8_C(24):
    case UINT8_C(25):
    case UINT8_C(26):
    case UINT8_C(27):
    case UINT8_C(28):
    case UINT8_C(29):
    case UINT8_C(30):
    case UINT8_C(31):
    case UINT8_C(32):
    case UINT8_C(33):
    case UINT8_C(34):
    case UINT8_C(35):
    case UINT8_C(36):
    case UINT8_C(37):
    case UINT8_C(38):
    case UINT8_C(39):
    case UINT8_C(40):
    case UINT8_C(41):
    case UINT8_C(42):
    case UINT8_C(43):
    case UINT8_C(44):
    case UINT8_C(45):
    case UINT8_C(46):
    case UINT8_C(47):
    case UINT8_C(48):
    case UINT8_C(49):
    case UINT8_C(50):
    case UINT8_C(51):
    case UINT8_C(52):
    case UINT8_C(53):
    case UINT8_C(54):
    case UINT8_C(55):
    case UINT8_C(56):
    case UINT8_C(57):
    case UINT8_C(58):
    case UINT8_C(59):
    case UINT8_C(60):
    case UINT8_C(61):
    case UINT8_C(62):
    case UINT8_C(63):
    case UINT8_C(64):
    case UINT8_C(65):
    case UINT8_C(66):
    case UINT8_C(67):
    case UINT8_C(68):
    case UINT8_C(69):
    case UINT8_C(70):
    case UINT8_C(71):
    case UINT8_C(72):
    case UINT8_C(73):
    case UINT8_C(74):
    case UINT8_C(75):
    case UINT8_C(76):
    case UINT8_C(77):
    case UINT8_C(78):
    case UINT8_C(79):
    case UINT8_C(80):
    case UINT8_C(81):
    case UINT8_C(82):
    case UINT8_C(83):
    case UINT8_C(84):
    case UINT8_C(85):
    case UINT8_C(86):
    case UINT8_C(87):
    case UINT8_C(88):
    case UINT8_C(89):
    case UINT8_C(90):
    case UINT8_C(91):
    case UINT8_C(92):
    case UINT8_C(93):
    case UINT8_C(94):
    case UINT8_C(95):
    case UINT8_C(96):
    case UINT8_C(97):
    case UINT8_C(98):
    case UINT8_C(99):
    case UINT8_C(100):
    case UINT8_C(101):
    case UINT8_C(102):
    case UINT8_C(103):
    case UINT8_C(104):
    case UINT8_C(105):
    case UINT8_C(106):
    case UINT8_C(107):
    case UINT8_C(108):
    case UINT8_C(109):
    case UINT8_C(110):
    case UINT8_C(111):
    case UINT8_C(112):
    case UINT8_C(113):
    case UINT8_C(114):
    case UINT8_C(115):
    case UINT8_C(116):
    case UINT8_C(117):
    case UINT8_C(118):
    case UINT8_C(119):
    case UINT8_C(120):
    case UINT8_C(121):
    case UINT8_C(122):
    case UINT8_C(123):
    case UINT8_C(124):
    case UINT8_C(125):
    case UINT8_C(126):
    case UINT8_C(127):
    case UINT8_C(128):
    case UINT8_C(129):
    case UINT8_C(130):
    case UINT8_C(131):
    case UINT8_C(132):
    case UINT8_C(133):
    case UINT8_C(134):
    case UINT8_C(135):
    case UINT8_C(136):
    case UINT8_C(137):
    case UINT8_C(138):
    case UINT8_C(139):
    case UINT8_C(140):
    case UINT8_C(141):
    case UINT8_C(142):
    case UINT8_C(143):
    case UINT8_C(144):
    case UINT8_C(145):
    case UINT8_C(146):
    case UINT8_C(147):
    case UINT8_C(148):
    case UINT8_C(149):
    case UINT8_C(150):
    case UINT8_C(151):
    case UINT8_C(152):
    case UINT8_C(153):
    case UINT8_C(154):
    case UINT8_C(155):
    case UINT8_C(156):
    case UINT8_C(157):
    case UINT8_C(158):
    case UINT8_C(159):
    case UINT8_C(160):
    case UINT8_C(161):
    case UINT8_C(162):
    case UINT8_C(163):
    case UINT8_C(164):
    case UINT8_C(165):
    case UINT8_C(166):
        return static_cast<::nds::core::types::Currency>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration Currency: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::core::types::Currency>(::nds::core::types::Currency value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::core::types::Currency value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::core::types::Currency>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::core::types::Currency)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::core::types::Currency value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::core::types::Currency>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::core::types::Currency value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::core::types::Currency value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::core::types::Currency read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::core::types::Currency>(
            static_cast<typename ::std::underlying_type<::nds::core::types::Currency>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::core::types::Currency read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::core::types::Currency>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::core::types::Currency>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::core::types::Currency value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::core::types::Currency value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::core::types::Currency>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/HashCodeUtil.h>
#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/core/types/LaneAccessType.h>

namespace nds
{
namespace core
{
namespace types
{

LaneAccessType::LaneAccessType(::zserio::BitStreamReader& in) :
        m_value(readValue(in))
{}

LaneAccessType::LaneAccessType(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in) :
        m_value(readValue(context, in))
{}

LaneAccessType::LaneAccessType(underlying_type value) :
        m_value(value)
{
    if (m_value > UINT32_C(536870911))
        throw ::zserio::CppRuntimeException("Value for bitmask 'LaneAccessType' out of bounds: ") << value << "!";
}

void LaneAccessType::initPackingContext(::zserio::DeltaContext& context) const
{
    context.init<::zserio::VarIntNNArrayTraits<::nds::core::types::LaneAccessType::underlying_type>>(m_value);
}

size_t LaneAccessType::bitSizeOf(size_t) const
{
    return ::zserio::bitSizeOfVarUInt32(m_value);
}

size_t LaneAccessType::bitSizeOf(::zserio::DeltaContext& context, size_t) const
{
    return context.bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::types::LaneAccessType::underlying_type>>(m_value);
}

size_t LaneAccessType::initializeOffsets(size_t bitPosition) const
{
    return bitPosition + bitSizeOf(bitPosition);
}

size_t LaneAccessType::initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition) const
{
    return bitPosition + bitSizeOf(context, bitPosition);
}

uint32_t LaneAccessType::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, m_value);
    return result;
}

void LaneAccessType::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt32(m_value);
}

void LaneAccessType::write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out) const
{
    context.write<::zserio::VarIntNNArrayTraits<::nds::core::types::LaneAccessType::underlying_type>>(out, m_value);
}

::zserio::string<> LaneAccessType::toString(const ::zserio::string<>::allocator_type& allocator) const
{
    ::zserio::string<> result(allocator);
    if ((*this & LaneAccessType::Values::EXPRESS_LANE) == LaneAccessType::Values::EXPRESS_LANE)
        result += result.empty() ? "EXPRESS_LANE" : " | EXPRESS_LANE";
    if ((*this & LaneAccessType::Values::TOLL_LANE) == LaneAccessType::Values::TOLL_LANE)
        result += result.empty() ? "TOLL_LANE" : " | TOLL_LANE";
    if ((*this & LaneAccessType::Values::SLOW_LANE) == LaneAccessType::Values::SLOW_LANE)
        result += result.empty() ? "SLOW_LANE" : " | SLOW_LANE";
    if ((*this & LaneAccessType::Values::CARPOOL_LANE) == LaneAccessType::Values::CARPOOL_LANE)
        result += result.empty() ? "CARPOOL_LANE" : " | CARPOOL_LANE";
    if ((*this & LaneAccessType::Values::REGULATED_ACCESS_LANE) == LaneAccessType::Values::REGULATED_ACCESS_LANE)
        result += result.empty() ? "REGULATED_ACCESS_LANE" : " | REGULATED_ACCESS_LANE";
    if ((*this & LaneAccessType::Values::BICYCLE_LANE) == LaneAccessType::Values::BICYCLE_LANE)
        result += result.empty() ? "BICYCLE_LANE" : " | BICYCLE_LANE";
    if ((*this & LaneAccessType::Values::BUS_LANE) == LaneAccessType::Values::BUS_LANE)
        result += result.empty() ? "BUS_LANE" : " | BUS_LANE";
    if ((*this & LaneAccessType::Values::TRAM_LANE) == LaneAccessType::Values::TRAM_LANE)
        result += result.empty() ? "TRAM_LANE" : " | TRAM_LANE";
    if ((*this & LaneAccessType::Values::PASSING_LANE) == LaneAccessType::Values::PASSING_LANE)
        result += result.empty() ? "PASSING_LANE" : " | PASSING_LANE";
    if ((*this & LaneAccessType::Values::DRIVABLE_SHOULDER_LANE) == LaneAccessType::Values::DRIVABLE_SHOULDER_LANE)
        result += result.empty() ? "DRIVABLE_SHOULDER_LANE" : " | DRIVABLE_SHOULDER_LANE";
    if ((*this & LaneAccessType::Values::SOFT_SHOULDER_LANE) == LaneAccessType::Values::SOFT_SHOULDER_LANE)
        result += result.empty() ? "SOFT_SHOULDER_LANE" : " | SOFT_SHOULDER_LANE";
    if ((*this & LaneAccessType::Values::EMERGENCY_SHOULDER_LANE) == LaneAccessType::Values::EMERGENCY_SHOULDER_LANE)
        result += result.empty() ? "EMERGENCY_SHOULDER_LANE" : " | EMERGENCY_SHOULDER_LANE";
    if ((*this & LaneAccessType::Values::EMERGENCY_SHOULDER_PARKING_BAY) == LaneAccessType::Values::EMERGENCY_SHOULDER_PARKING_BAY)
        result += result.empty() ? "EMERGENCY_SHOULDER_PARKING_BAY" : " | EMERGENCY_SHOULDER_PARKING_BAY";
    if ((*this & LaneAccessType::Values::TAXI_LANE) == LaneAccessType::Values::TAXI_LANE)
        result += result.empty() ? "TAXI_LANE" : " | TAXI_LANE";
    if ((*this & LaneAccessType::Values::REVERSIBLE_LANE) == LaneAccessType::Values::REVERSIBLE_LANE)
        result += result.empty() ? "REVERSIBLE_LANE" : " | REVERSIBLE_LANE";

    return ::zserio::toString<::zserio::string<>::allocator_type>(m_value, allocator) + "[" + result + "]";
}

LaneAccessType::underlying_type LaneAccessType::readValue(::zserio::BitStreamReader& in)
{
    return static_cast<underlying_type>(in.readVarUInt32());
}

LaneAccessType::underlying_type LaneAccessType::readValue(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return context.read<::zserio::VarIntNNArrayTraits<::nds::core::types::LaneAccessType::underlying_type>>(
            in);
}

} // namespace types
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ConstraintException.h>

#include <nds/core/types/Var4ByteId.h>

namespace nds
{
namespace core
{
namespace types
{

Var4ByteId::Var4ByteId(const allocator_type&) noexcept :
        m_id_(uint32_t())
{
}

Var4ByteId::Var4ByteId(::zserio::BitStreamReader& in, const allocator_type&) :
        m_id_(readId(in))
{
}

Var4ByteId::Var4ByteId(Var4ByteId::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type&) :
        m_id_(readId(context, in))
{
}

Var4ByteId::Var4ByteId(::zserio::PropagateAllocatorT,
        const Var4ByteId& other, const allocator_type& allocator) :
        m_id_(::zserio::allocatorPropagatingCopy(other.m_id_, allocator))
{
}

uint32_t Var4ByteId::getId() const
{
    return m_id_;
}

void Var4ByteId::setId(uint32_t id_)
{
    m_id_ = id_;
}

bool Var4ByteId::funcIsUnknown() const
{
    return static_cast<bool>(((getId() == 0)) ? true : false);
}

void Var4ByteId::initPackingContext(Var4ByteId::ZserioPackingContext& context) const
{
    context.getId().init<::zserio::VarIntNNArrayTraits<uint32_t>>(m_id_);
}

size_t Var4ByteId::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_id_);

    return endBitPosition - bitPosition;
}

size_t Var4ByteId::bitSizeOf(Var4ByteId::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getId().bitSizeOf<::zserio::VarIntNNArrayTraits<uint32_t>>(m_id_);

    return endBitPosition - bitPosition;
}

size_t Var4ByteId::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_id_);

    return endBitPosition;
}

size_t Var4ByteId::initializeOffsets(Var4ByteId::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getId().bitSizeOf<::zserio::VarIntNNArrayTraits<uint32_t>>(m_id_);

    return endBitPosition;
}

bool Var4ByteId::operator==(const Var4ByteId& other) const
{
    if (this != &other)
    {
        return
                (m_id_ == other.m_id_);
    }

    return true;
}

uint32_t Var4ByteId::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_id_);

    return result;
}

void Var4ByteId::write(::zserio::BitStreamWriter& out) const
{
    // check constraint
    if (!(getId() <= 268435455))
        throw ::zserio::ConstraintException("Write: Constraint violated at Var4ByteId.id!");
    out.writeVarUInt32(m_id_);
}

void Var4ByteId::write(Var4ByteId::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    // check constraint
    if (!(getId() <= 268435455))
        throw ::zserio::ConstraintException("Write: Constraint violated at Var4ByteId.id!");
    context.getId().write<::zserio::VarIntNNArrayTraits<uint32_t>>(out, m_id_);
}

uint32_t Var4ByteId::readId(::zserio::BitStreamReader& in)
{
    uint32_t readField = static_cast<uint32_t>(in.readVarUInt32());
    // check constraint
    if (!(readField <= 268435455))
        throw ::zserio::ConstraintException("Read: Constraint violated at Var4ByteId.id!");

    return readField;
}

uint32_t Var4ByteId::readId(Var4ByteId::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    uint32_t readField = context.getId().read<::zserio::VarIntNNArrayTraits<uint32_t>>(in);
    // check constraint
    if (!(readField <= 268435455))
        throw ::zserio::ConstraintException("Read: Constraint violated at Var4ByteId.id!");

    return readField;
}

} // namespace types
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ConstraintException.h>

#include <nds/core/types/Var4ByteDirectedReference.h>

namespace nds
{
namespace core
{
namespace types
{

Var4ByteDirectedReference::Var4ByteDirectedReference(const allocator_type&) noexcept :
        m_value_(int32_t())
{
}

Var4ByteDirectedReference::Var4ByteDirectedReference(::zserio::BitStreamReader& in, const allocator_type&) :
        m_value_(readValue(in))
{
}

Var4ByteDirectedReference::Var4ByteDirectedReference(Var4ByteDirectedReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type&) :
        m_value_(readValue(context, in))
{
}

Var4ByteDirectedReference::Var4ByteDirectedReference(::zserio::PropagateAllocatorT,
        const Var4ByteDirectedReference& other, const allocator_type& allocator) :
        m_value_(::zserio::allocatorPropagatingCopy(other.m_value_, allocator))
{
}

int32_t Var4ByteDirectedReference::getValue() const
{
    return m_value_;
}

void Var4ByteDirectedReference::setValue(int32_t value_)
{
    m_value_ = value_;
}

bool Var4ByteDirectedReference::funcIsPositive() const
{
    return static_cast<bool>(((getValue() > 0)) ? true : false);
}

bool Var4ByteDirectedReference::funcIsNegative() const
{
    return static_cast<bool>(((getValue() < 0)) ? true : false);
}

uint32_t Var4ByteDirectedReference::funcGetId() const
{
    return static_cast<uint32_t>(((getValue() < 0)) ? (getValue() * -1) : getValue());
}

void Var4ByteDirectedReference::initPackingContext(Var4ByteDirectedReference::ZserioPackingContext& context) const
{
    context.getValue().init<::zserio::VarIntNNArrayTraits<int32_t>>(m_value_);
}

size_t Var4ByteDirectedReference::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarInt32(m_value_);

    return endBitPosition - bitPosition;
}

size_t Var4ByteDirectedReference::bitSizeOf(Var4ByteDirectedReference::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getValue().bitSizeOf<::zserio::VarIntNNArrayTraits<int32_t>>(m_value_);

    return endBitPosition - bitPosition;
}

size_t Var4ByteDirectedReference::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarInt32(m_value_);

    return endBitPosition;
}

size_t Var4ByteDirectedReference::initializeOffsets(Var4ByteDirectedReference::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getValue().bitSizeOf<::zserio::VarIntNNArrayTraits<int32_t>>(m_value_);

    return endBitPosition;
}

bool Var4ByteDirectedReference::operator==(const Var4ByteDirectedReference& other) const
{
    if (this != &other)
    {
        return
                (m_value_ == other.m_value_);
    }

    return true;
}

uint32_t Var4ByteDirectedReference::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_value_);

    return result;
}

void Var4ByteDirectedReference::write(::zserio::BitStreamWriter& out) const
{
    // check constraint
    if (!((getValue() >= -268435455 && getValue() < 0) || (getValue() > 0 && getValue() <= 268435455)))
        throw ::zserio::ConstraintException("Write: Constraint violated at Var4ByteDirectedReference.value!");
    out.writeVarInt32(m_value_);
}

void Var4ByteDirectedReference::write(Var4ByteDirectedReference::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    // check constraint
    if (!((getValue() >= -268435455 && getValue() < 0) || (getValue() > 0 && getValue() <= 268435455)))
        throw ::zserio::ConstraintException("Write: Constraint violated at Var4ByteDirectedReference.value!");
    context.getValue().write<::zserio::VarIntNNArrayTraits<int32_t>>(out, m_value_);
}

int32_t Var4ByteDirectedReference::readValue(::zserio::BitStreamReader& in)
{
    int32_t readField = static_cast<int32_t>(in.readVarInt32());
    // check constraint
    if (!((readField >= -268435455 && readField < 0) || (readField > 0 && readField <= 268435455)))
        throw ::zserio::ConstraintException("Read: Constraint violated at Var4ByteDirectedReference.value!");

    return readField;
}

int32_t Var4ByteDirectedReference::readValue(Var4ByteDirectedReference::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    int32_t readField = context.getValue().read<::zserio::VarIntNNArrayTraits<int32_t>>(in);
    // check constraint
    if (!((readField >= -268435455 && readField < 0) || (readField > 0 && readField <= 268435455)))
        throw ::zserio::ConstraintException("Read: Constraint violated at Var4ByteDirectedReference.value!");

    return readField;
}

} // namespace types
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/core/types/Empty.h>

namespace nds
{
namespace core
{
namespace types
{

Empty::Empty(const allocator_type&) noexcept
{
}

Empty::Empty(::zserio::BitStreamReader&, const allocator_type&)
{
}

Empty::Empty(::zserio::PropagateAllocatorT,
        const Empty&, const allocator_type&)
{
}

size_t Empty::bitSizeOf(size_t) const
{
    return 0;
}

size_t Empty::initializeOffsets(size_t bitPosition)
{
    return bitPosition;
}

bool Empty::operator==(const Empty&) const
{
    return true;
}

uint32_t Empty::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    return result;
}

void Empty::write(::zserio::BitStreamWriter&) const
{
}

} // namespace types
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/core/types/Flag.h>

namespace nds
{
namespace core
{
namespace types
{

Flag::Flag(const allocator_type&) noexcept
{
}

Flag::Flag(::zserio::BitStreamReader&, const allocator_type&)
{
}

Flag::Flag(::zserio::PropagateAllocatorT,
        const Flag&, const allocator_type&)
{
}

size_t Flag::bitSizeOf(size_t) const
{
    return 0;
}

size_t Flag::initializeOffsets(size_t bitPosition)
{
    return bitPosition;
}

bool Flag::operator==(const Flag&) const
{
    return true;
}

uint32_t Flag::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    return result;
}

void Flag::write(::zserio::BitStreamWriter&) const
{
}

} // namespace types
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/core/types/TimeStamp.h>

namespace nds
{
namespace core
{
namespace types
{

TimeStamp::TimeStamp(const allocator_type&) noexcept :
        m_seconds_(uint64_t()),
        m_nanoseconds_(uint64_t())
{
}

TimeStamp::TimeStamp(::zserio::BitStreamReader& in, const allocator_type&) :
        m_seconds_(readSeconds(in)),
        m_nanoseconds_(readNanoseconds(in))
{
}

TimeStamp::TimeStamp(TimeStamp::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type&) :
        m_seconds_(readSeconds(context, in)),
        m_nanoseconds_(readNanoseconds(context, in))
{
}

TimeStamp::TimeStamp(::zserio::PropagateAllocatorT,
        const TimeStamp& other, const allocator_type& allocator) :
        m_seconds_(::zserio::allocatorPropagatingCopy(other.m_seconds_, allocator)),
        m_nanoseconds_(::zserio::allocatorPropagatingCopy(other.m_nanoseconds_, allocator))
{
}

uint64_t TimeStamp::getSeconds() const
{
    return m_seconds_;
}

void TimeStamp::setSeconds(uint64_t seconds_)
{
    m_seconds_ = seconds_;
}

uint64_t TimeStamp::getNanoseconds() const
{
    return m_nanoseconds_;
}

void TimeStamp::setNanoseconds(uint64_t nanoseconds_)
{
    m_nanoseconds_ = nanoseconds_;
}

void TimeStamp::initPackingContext(TimeStamp::ZserioPackingContext& context) const
{
    context.getSeconds().init<::zserio::VarIntArrayTraits<uint64_t>>(m_seconds_);
    context.getNanoseconds().init<::zserio::VarIntArrayTraits<uint64_t>>(m_nanoseconds_);
}

size_t TimeStamp::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt(m_seconds_);
    endBitPosition += ::zserio::bitSizeOfVarUInt(m_nanoseconds_);

    return endBitPosition - bitPosition;
}

size_t TimeStamp::bitSizeOf(TimeStamp::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getSeconds().bitSizeOf<::zserio::VarIntArrayTraits<uint64_t>>(m_seconds_);
    endBitPosition += context.getNanoseconds().bitSizeOf<::zserio::VarIntArrayTraits<uint64_t>>(m_nanoseconds_);

    return endBitPosition - bitPosition;
}

size_t TimeStamp::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt(m_seconds_);
    endBitPosition += ::zserio::bitSizeOfVarUInt(m_nanoseconds_);

    return endBitPosition;
}

size_t TimeStamp::initializeOffsets(TimeStamp::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getSeconds().bitSizeOf<::zserio::VarIntArrayTraits<uint64_t>>(m_seconds_);
    endBitPosition += context.getNanoseconds().bitSizeOf<::zserio::VarIntArrayTraits<uint64_t>>(m_nanoseconds_);

    return endBitPosition;
}

bool TimeStamp::operator==(const TimeStamp& other) const
{
    if (this != &other)
    {
        return
                (m_seconds_ == other.m_seconds_) &&
                (m_nanoseconds_ == other.m_nanoseconds_);
    }

    return true;
}

uint32_t TimeStamp::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_seconds_);
    result = ::zserio::calcHashCode(result, m_nanoseconds_);

    return result;
}

void TimeStamp::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt(m_seconds_);
    out.writeVarUInt(m_nanoseconds_);
}

void TimeStamp::write(TimeStamp::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getSeconds().write<::zserio::VarIntArrayTraits<uint64_t>>(out, m_seconds_);
    context.getNanoseconds().write<::zserio::VarIntArrayTraits<uint64_t>>(out, m_nanoseconds_);
}

uint64_t TimeStamp::readSeconds(::zserio::BitStreamReader& in)
{
    return static_cast<uint64_t>(in.readVarUInt());
}

uint64_t TimeStamp::readSeconds(TimeStamp::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getSeconds().read<::zserio::VarIntArrayTraits<uint64_t>>(in);
}
uint64_t TimeStamp::readNanoseconds(::zserio::BitStreamReader& in)
{
    return static_cast<uint64_t>(in.readVarUInt());
}

uint64_t TimeStamp::readNanoseconds(TimeStamp::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNanoseconds().read<::zserio::VarIntArrayTraits<uint64_t>>(in);
}

} // namespace types
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/core/types/TimeWithZone.h>

namespace nds
{
namespace core
{
namespace types
{

TimeWithZone::TimeWithZone(const allocator_type&) noexcept :
        m_seconds_(uint64_t()),
        m_utcOffset_(::nds::core::types::QuarterHourTimeOffset())
{
}

TimeWithZone::TimeWithZone(::zserio::BitStreamReader& in, const allocator_type&) :
        m_seconds_(readSeconds(in)),
        m_utcOffset_(readUtcOffset(in))
{
}

TimeWithZone::TimeWithZone(TimeWithZone::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type&) :
        m_seconds_(readSeconds(context, in)),
        m_utcOffset_(readUtcOffset(context, in))
{
}

TimeWithZone::TimeWithZone(::zserio::PropagateAllocatorT,
        const TimeWithZone& other, const allocator_type& allocator) :
        m_seconds_(::zserio::allocatorPropagatingCopy(other.m_seconds_, allocator)),
        m_utcOffset_(::zserio::allocatorPropagatingCopy(other.m_utcOffset_, allocator))
{
}

uint64_t TimeWithZone::getSeconds() const
{
    return m_seconds_;
}

void TimeWithZone::setSeconds(uint64_t seconds_)
{
    m_seconds_ = seconds_;
}

::nds::core::types::QuarterHourTimeOffset TimeWithZone::getUtcOffset() const
{
    return m_utcOffset_;
}

void TimeWithZone::setUtcOffset(::nds::core::types::QuarterHourTimeOffset utcOffset_)
{
    m_utcOffset_ = utcOffset_;
}

void TimeWithZone::initPackingContext(TimeWithZone::ZserioPackingContext& context) const
{
    context.getSeconds().init<::zserio::VarIntArrayTraits<uint64_t>>(m_seconds_);
    context.getUtcOffset().init<::zserio::StdIntArrayTraits<::nds::core::types::QuarterHourTimeOffset>>(m_utcOffset_);
}

size_t TimeWithZone::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt(m_seconds_);
    endBitPosition += UINT8_C(8);

    return endBitPosition - bitPosition;
}

size_t TimeWithZone::bitSizeOf(TimeWithZone::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getSeconds().bitSizeOf<::zserio::VarIntArrayTraits<uint64_t>>(m_seconds_);
    endBitPosition += context.getUtcOffset().bitSizeOf<::zserio::StdIntArrayTraits<::nds::core::types::QuarterHourTimeOffset>>(m_utcOffset_);

    return endBitPosition - bitPosition;
}

size_t TimeWithZone::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt(m_seconds_);
    endBitPosition += UINT8_C(8);

    return endBitPosition;
}

size_t TimeWithZone::initializeOffsets(TimeWithZone::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getSeconds().bitSizeOf<::zserio::VarIntArrayTraits<uint64_t>>(m_seconds_);
    endBitPosition += context.getUtcOffset().bitSizeOf<::zserio::StdIntArrayTraits<::nds::core::types::QuarterHourTimeOffset>>(m_utcOffset_);

    return endBitPosition;
}

bool TimeWithZone::operator==(const TimeWithZone& other) const
{
    if (this != &other)
    {
        return
                (m_seconds_ == other.m_seconds_) &&
                (m_utcOffset_ == other.m_utcOffset_);
    }

    return true;
}

uint32_t TimeWithZone::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_seconds_);
    result = ::zserio::calcHashCode(result, m_utcOffset_);

    return result;
}

void TimeWithZone::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt(m_seconds_);
    out.writeSignedBits(m_utcOffset_, UINT8_C(8));
}

void TimeWithZone::write(TimeWithZone::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getSeconds().write<::zserio::VarIntArrayTraits<uint64_t>>(out, m_seconds_);
    context.getUtcOffset().write<::zserio::StdIntArrayTraits<::nds::core::types::QuarterHourTimeOffset>>(out, m_utcOffset_);
}

uint64_t TimeWithZone::readSeconds(::zserio::BitStreamReader& in)
{
    return static_cast<uint64_t>(in.readVarUInt());
}

uint64_t TimeWithZone::readSeconds(TimeWithZone::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getSeconds().read<::zserio::VarIntArrayTraits<uint64_t>>(in);
}
::nds::core::types::QuarterHourTimeOffset TimeWithZone::readUtcOffset(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::types::QuarterHourTimeOffset>(in.readSignedBits(UINT8_C(8)));
}

::nds::core::types::QuarterHourTimeOffset TimeWithZone::readUtcOffset(TimeWithZone::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getUtcOffset().read<::zserio::StdIntArrayTraits<::nds::core::types::QuarterHourTimeOffset>>(in);
}

} // namespace types
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ConstraintException.h>

#include <nds/core/types/ScaleRangeList.h>

namespace nds
{
namespace core
{
namespace types
{

ScaleRangeList::ScaleRangeList(const allocator_type& allocator) noexcept :
        m_numEntries_(uint32_t()),
        m_scales_(allocator)
{
}

ScaleRangeList::ScaleRangeList(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numEntries_(readNumEntries(in)),
        m_scales_(readScales(in, allocator))
{
}

ScaleRangeList::ScaleRangeList(ScaleRangeList::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numEntries_(readNumEntries(context, in)),
        m_scales_(readScales(context, in, allocator))
{
}

ScaleRangeList::ScaleRangeList(::zserio::PropagateAllocatorT,
        const ScaleRangeList& other, const allocator_type& allocator) :
        m_numEntries_(::zserio::allocatorPropagatingCopy(other.m_numEntries_, allocator)),
        m_scales_(::zserio::allocatorPropagatingCopy(other.m_scales_, allocator))
{
}

uint32_t ScaleRangeList::getNumEntries() const
{
    return m_numEntries_;
}

void ScaleRangeList::setNumEntries(uint32_t numEntries_)
{
    m_numEntries_ = numEntries_;
}

::zserio::vector<::nds::core::types::ScaleRange>& ScaleRangeList::getScales()
{
    return m_scales_.getRawArray();
}

const ::zserio::vector<::nds::core::types::ScaleRange>& ScaleRangeList::getScales() const
{
    return m_scales_.getRawArray();
}

void ScaleRangeList::setScales(const ::zserio::vector<::nds::core::types::ScaleRange>& scales_)
{
    m_scales_ = ZserioArrayType_scales(scales_);
}

void ScaleRangeList::setScales(::zserio::vector<::nds::core::types::ScaleRange>&& scales_)
{
    m_scales_ = ZserioArrayType_scales(std::move(scales_));
}

void ScaleRangeList::initPackingContext(ScaleRangeList::ZserioPackingContext& context) const
{
    context.getNumEntries().init<::zserio::VarSizeArrayTraits>(m_numEntries_);
}

size_t ScaleRangeList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numEntries_);
    endBitPosition += m_scales_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ScaleRangeList::bitSizeOf(ScaleRangeList::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumEntries().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numEntries_);
    endBitPosition += m_scales_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t ScaleRangeList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numEntries_);
    endBitPosition = m_scales_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t ScaleRangeList::initializeOffsets(ScaleRangeList::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumEntries().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numEntries_);
    endBitPosition = m_scales_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool ScaleRangeList::operator==(const ScaleRangeList& other) const
{
    if (this != &other)
    {
        return
                (m_numEntries_ == other.m_numEntries_) &&
                (m_scales_ == other.m_scales_);
    }

    return true;
}

uint32_t ScaleRangeList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_numEntries_);
    result = ::zserio::calcHashCode(result, m_scales_);

    return result;
}

void ScaleRangeList::write(::zserio::BitStreamWriter& out) const
{
    // check constraint
    if (!(getNumEntries() > 0))
        throw ::zserio::ConstraintException("Write: Constraint violated at ScaleRangeList.numEntries!");
    out.writeVarSize(m_numEntries_);

    // check array length
    if (m_scales_.getRawArray().size() != static_cast<size_t>(getNumEntries()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ScaleRangeList.scales: ") <<
                m_scales_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumEntries()) << "!";
    }
    m_scales_.writePacked(*this, out);
}

void ScaleRangeList::write(ScaleRangeList::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    // check constraint
    if (!(getNumEntries() > 0))
        throw ::zserio::ConstraintException("Write: Constraint violated at ScaleRangeList.numEntries!");
    context.getNumEntries().write<::zserio::VarSizeArrayTraits>(out, m_numEntries_);

    // check array length
    if (m_scales_.getRawArray().size() != static_cast<size_t>(getNumEntries()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field ScaleRangeList.scales: ") <<
                m_scales_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumEntries()) << "!";
    }
    m_scales_.writePacked(*this, out);
}

void ScaleRangeList::ZserioElementFactory_scales::create(ScaleRangeList&        ,
        ::zserio::vector<::nds::core::types::ScaleRange>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void ScaleRangeList::ZserioElementFactory_scales::create(ScaleRangeList&        ,
        ::zserio::vector<::nds::core::types::ScaleRange>& array,
        ::nds::core::types::ScaleRange::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

uint32_t ScaleRangeList::readNumEntries(::zserio::BitStreamReader& in)
{
    uint32_t readField = static_cast<uint32_t>(in.readVarSize());
    // check constraint
    if (!(readField > 0))
        throw ::zserio::ConstraintException("Read: Constraint violated at ScaleRangeList.numEntries!");

    return readField;
}

uint32_t ScaleRangeList::readNumEntries(ScaleRangeList::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    uint32_t readField = context.getNumEntries().read<::zserio::VarSizeArrayTraits>(in);
    // check constraint
    if (!(readField > 0))
        throw ::zserio::ConstraintException("Read: Constraint violated at ScaleRangeList.numEntries!");

    return readField;
}
ScaleRangeList::ZserioArrayType_scales ScaleRangeList::readScales(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_scales readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumEntries()));

    return readField;
}

ScaleRangeList::ZserioArrayType_scales ScaleRangeList::readScales(ScaleRangeList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_scales readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumEntries()));

    return readField;
}

} // namespace types
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ConstraintException.h>

#include <nds/core/types/ScaleRange.h>

namespace nds
{
namespace core
{
namespace types
{

ScaleRange::ScaleRange(const allocator_type&) noexcept :
        m_scaleRangeId_(::nds::core::types::ScaleRangeId()),
        m_minScaleDenominator_(::nds::core::types::ScaleDenominator()),
        m_maxScaleDenominator_(::nds::core::types::ScaleDenominator())
{
}

ScaleRange::ScaleRange(::zserio::BitStreamReader& in, const allocator_type&) :
        m_scaleRangeId_(readScaleRangeId(in)),
        m_minScaleDenominator_(readMinScaleDenominator(in)),
        m_maxScaleDenominator_(readMaxScaleDenominator(in))
{
}

ScaleRange::ScaleRange(ScaleRange::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type&) :
        m_scaleRangeId_(readScaleRangeId(context, in)),
        m_minScaleDenominator_(readMinScaleDenominator(context, in)),
        m_maxScaleDenominator_(readMaxScaleDenominator(context, in))
{
}

ScaleRange::ScaleRange(::zserio::PropagateAllocatorT,
        const ScaleRange& other, const allocator_type& allocator) :
        m_scaleRangeId_(::zserio::allocatorPropagatingCopy(other.m_scaleRangeId_, allocator)),
        m_minScaleDenominator_(::zserio::allocatorPropagatingCopy(other.m_minScaleDenominator_, allocator)),
        m_maxScaleDenominator_(::zserio::allocatorPropagatingCopy(other.m_maxScaleDenominator_, allocator))
{
}

::nds::core::types::ScaleRangeId ScaleRange::getScaleRangeId() const
{
    return m_scaleRangeId_;
}

void ScaleRange::setScaleRangeId(::nds::core::types::ScaleRangeId scaleRangeId_)
{
    m_scaleRangeId_ = scaleRangeId_;
}

::nds::core::types::ScaleDenominator ScaleRange::getMinScaleDenominator() const
{
    return m_minScaleDenominator_;
}

void ScaleRange::setMinScaleDenominator(::nds::core::types::ScaleDenominator minScaleDenominator_)
{
    m_minScaleDenominator_ = minScaleDenominator_;
}

::nds::core::types::ScaleDenominator ScaleRange::getMaxScaleDenominator() const
{
    return m_maxScaleDenominator_;
}

void ScaleRange::setMaxScaleDenominator(::nds::core::types::ScaleDenominator maxScaleDenominator_)
{
    m_maxScaleDenominator_ = maxScaleDenominator_;
}

void ScaleRange::initPackingContext(ScaleRange::ZserioPackingContext& context) const
{
    context.getScaleRangeId().init<::zserio::VarIntNNArrayTraits<::nds::core::types::ScaleRangeId>>(m_scaleRangeId_);
    context.getMinScaleDenominator().init<::zserio::StdIntArrayTraits<::nds::core::types::ScaleDenominator>>(m_minScaleDenominator_);
    context.getMaxScaleDenominator().init<::zserio::StdIntArrayTraits<::nds::core::types::ScaleDenominator>>(m_maxScaleDenominator_);
}

size_t ScaleRange::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_scaleRangeId_);
    endBitPosition += UINT8_C(32);
    endBitPosition += UINT8_C(32);

    return endBitPosition - bitPosition;
}

size_t ScaleRange::bitSizeOf(ScaleRange::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getScaleRangeId().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::types::ScaleRangeId>>(m_scaleRangeId_);
    endBitPosition += context.getMinScaleDenominator().bitSizeOf<::zserio::StdIntArrayTraits<::nds::core::types::ScaleDenominator>>(m_minScaleDenominator_);
    endBitPosition += context.getMaxScaleDenominator().bitSizeOf<::zserio::StdIntArrayTraits<::nds::core::types::ScaleDenominator>>(m_maxScaleDenominator_);

    return endBitPosition - bitPosition;
}

size_t ScaleRange::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_scaleRangeId_);
    endBitPosition += UINT8_C(32);
    endBitPosition += UINT8_C(32);

    return endBitPosition;
}

size_t ScaleRange::initializeOffsets(ScaleRange::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getScaleRangeId().bitSizeOf<::zserio::VarIntNNArrayTraits<::nds::core::types::ScaleRangeId>>(m_scaleRangeId_);
    endBitPosition += context.getMinScaleDenominator().bitSizeOf<::zserio::StdIntArrayTraits<::nds::core::types::ScaleDenominator>>(m_minScaleDenominator_);
    endBitPosition += context.getMaxScaleDenominator().bitSizeOf<::zserio::StdIntArrayTraits<::nds::core::types::ScaleDenominator>>(m_maxScaleDenominator_);

    return endBitPosition;
}

bool ScaleRange::operator==(const ScaleRange& other) const
{
    if (this != &other)
    {
        return
                (m_scaleRangeId_ == other.m_scaleRangeId_) &&
                (m_minScaleDenominator_ == other.m_minScaleDenominator_) &&
                (m_maxScaleDenominator_ == other.m_maxScaleDenominator_);
    }

    return true;
}

uint32_t ScaleRange::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_scaleRangeId_);
    result = ::zserio::calcHashCode(result, m_minScaleDenominator_);
    result = ::zserio::calcHashCode(result, m_maxScaleDenominator_);

    return result;
}

void ScaleRange::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarUInt32(m_scaleRangeId_);

    // check constraint
    if (!(getMinScaleDenominator() > 0))
        throw ::zserio::ConstraintException("Write: Constraint violated at ScaleRange.minScaleDenominator!");
    out.writeBits(m_minScaleDenominator_, UINT8_C(32));

    // check constraint
    if (!(getMaxScaleDenominator() > getMinScaleDenominator()))
        throw ::zserio::ConstraintException("Write: Constraint violated at ScaleRange.maxScaleDenominator!");
    out.writeBits(m_maxScaleDenominator_, UINT8_C(32));
}

void ScaleRange::write(ScaleRange::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getScaleRangeId().write<::zserio::VarIntNNArrayTraits<::nds::core::types::ScaleRangeId>>(out, m_scaleRangeId_);

    // check constraint
    if (!(getMinScaleDenominator() > 0))
        throw ::zserio::ConstraintException("Write: Constraint violated at ScaleRange.minScaleDenominator!");
    context.getMinScaleDenominator().write<::zserio::StdIntArrayTraits<::nds::core::types::ScaleDenominator>>(out, m_minScaleDenominator_);

    // check constraint
    if (!(getMaxScaleDenominator() > getMinScaleDenominator()))
        throw ::zserio::ConstraintException("Write: Constraint violated at ScaleRange.maxScaleDenominator!");
    context.getMaxScaleDenominator().write<::zserio::StdIntArrayTraits<::nds::core::types::ScaleDenominator>>(out, m_maxScaleDenominator_);
}

::nds::core::types::ScaleRangeId ScaleRange::readScaleRangeId(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::types::ScaleRangeId>(in.readVarUInt32());
}

::nds::core::types::ScaleRangeId ScaleRange::readScaleRangeId(ScaleRange::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getScaleRangeId().read<::zserio::VarIntNNArrayTraits<::nds::core::types::ScaleRangeId>>(in);
}
::nds::core::types::ScaleDenominator ScaleRange::readMinScaleDenominator(::zserio::BitStreamReader& in)
{
    ::nds::core::types::ScaleDenominator readField = static_cast<::nds::core::types::ScaleDenominator>(in.readBits(UINT8_C(32)));
    // check constraint
    if (!(readField > 0))
        throw ::zserio::ConstraintException("Read: Constraint violated at ScaleRange.minScaleDenominator!");

    return readField;
}

::nds::core::types::ScaleDenominator ScaleRange::readMinScaleDenominator(ScaleRange::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    ::nds::core::types::ScaleDenominator readField = context.getMinScaleDenominator().read<::zserio::StdIntArrayTraits<::nds::core::types::ScaleDenominator>>(in);
    // check constraint
    if (!(readField > 0))
        throw ::zserio::ConstraintException("Read: Constraint violated at ScaleRange.minScaleDenominator!");

    return readField;
}
::nds::core::types::ScaleDenominator ScaleRange::readMaxScaleDenominator(::zserio::BitStreamReader& in)
{
    ::nds::core::types::ScaleDenominator readField = static_cast<::nds::core::types::ScaleDenominator>(in.readBits(UINT8_C(32)));
    // check constraint
    if (!(readField > getMinScaleDenominator()))
        throw ::zserio::ConstraintException("Read: Constraint violated at ScaleRange.maxScaleDenominator!");

    return readField;
}

::nds::core::types::ScaleDenominator ScaleRange::readMaxScaleDenominator(ScaleRange::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    ::nds::core::types::ScaleDenominator readField = context.getMaxScaleDenominator().read<::zserio::StdIntArrayTraits<::nds::core::types::ScaleDenominator>>(in);
    // check constraint
    if (!(readField > getMinScaleDenominator()))
        throw ::zserio::ConstraintException("Read: Constraint violated at ScaleRange.maxScaleDenominator!");

    return readField;
}

} // namespace types
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/core/types/TileId.h>

namespace nds
{
namespace core
{
namespace types
{

TileId::TileId(const allocator_type&) noexcept :
        m_id_(::nds::core::types::PackedTileId())
{
}

TileId::TileId(::zserio::BitStreamReader& in, const allocator_type&) :
        m_id_(readId(in))
{
}

TileId::TileId(TileId::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type&) :
        m_id_(readId(context, in))
{
}

TileId::TileId(::zserio::PropagateAllocatorT,
        const TileId& other, const allocator_type& allocator) :
        m_id_(::zserio::allocatorPropagatingCopy(other.m_id_, allocator))
{
}

::nds::core::types::PackedTileId TileId::getId() const
{
    return m_id_;
}

void TileId::setId(::nds::core::types::PackedTileId id_)
{
    m_id_ = id_;
}

void TileId::initPackingContext(TileId::ZserioPackingContext& context) const
{
    context.getId().init<::zserio::StdIntArrayTraits<::nds::core::types::PackedTileId>>(m_id_);
}

size_t TileId::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(32);

    return endBitPosition - bitPosition;
}

size_t TileId::bitSizeOf(TileId::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getId().bitSizeOf<::zserio::StdIntArrayTraits<::nds::core::types::PackedTileId>>(m_id_);

    return endBitPosition - bitPosition;
}

size_t TileId::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(32);

    return endBitPosition;
}

size_t TileId::initializeOffsets(TileId::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getId().bitSizeOf<::zserio::StdIntArrayTraits<::nds::core::types::PackedTileId>>(m_id_);

    return endBitPosition;
}

bool TileId::operator==(const TileId& other) const
{
    if (this != &other)
    {
        return
                (m_id_ == other.m_id_);
    }

    return true;
}

uint32_t TileId::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_id_);

    return result;
}

void TileId::write(::zserio::BitStreamWriter& out) const
{
    out.writeSignedBits(m_id_, UINT8_C(32));
}

void TileId::write(TileId::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getId().write<::zserio::StdIntArrayTraits<::nds::core::types::PackedTileId>>(out, m_id_);
}

::nds::core::types::PackedTileId TileId::readId(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::types::PackedTileId>(in.readSignedBits(UINT8_C(32)));
}

::nds::core::types::PackedTileId TileId::readId(TileId::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getId().read<::zserio::StdIntArrayTraits<::nds::core::types::PackedTileId>>(in);
}

} // namespace types
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/core/types/TileIdList.h>

namespace nds
{
namespace core
{
namespace types
{

TileIdList::TileIdList(const allocator_type& allocator) noexcept :
        m_id_(allocator)
{
}

TileIdList::TileIdList(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_id_(readId(in, allocator))
{
}

TileIdList::TileIdList(TileIdList::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_id_(readId(context, in, allocator))
{
}

TileIdList::TileIdList(::zserio::PropagateAllocatorT,
        const TileIdList& other, const allocator_type& allocator) :
        m_id_(::zserio::allocatorPropagatingCopy(other.m_id_, allocator))
{
}

::zserio::vector<::nds::core::types::PackedTileId>& TileIdList::getId()
{
    return m_id_.getRawArray();
}

const ::zserio::vector<::nds::core::types::PackedTileId>& TileIdList::getId() const
{
    return m_id_.getRawArray();
}

void TileIdList::setId(const ::zserio::vector<::nds::core::types::PackedTileId>& id_)
{
    m_id_ = ZserioArrayType_id(id_);
}

void TileIdList::setId(::zserio::vector<::nds::core::types::PackedTileId>&& id_)
{
    m_id_ = ZserioArrayType_id(std::move(id_));
}

void TileIdList::initPackingContext(TileIdList::ZserioPackingContext&) const
{
}

size_t TileIdList::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_id_.bitSizeOfPacked(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TileIdList::bitSizeOf(TileIdList::ZserioPackingContext&, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_id_.bitSizeOfPacked(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t TileIdList::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_id_.initializeOffsetsPacked(endBitPosition);

    return endBitPosition;
}

size_t TileIdList::initializeOffsets(TileIdList::ZserioPackingContext&, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_id_.initializeOffsetsPacked(endBitPosition);

    return endBitPosition;
}

bool TileIdList::operator==(const TileIdList& other) const
{
    if (this != &other)
    {
        return
                (m_id_ == other.m_id_);
    }

    return true;
}

uint32_t TileIdList::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_id_);

    return result;
}

void TileIdList::write(::zserio::BitStreamWriter& out) const
{
    m_id_.writePacked(out);
}

void TileIdList::write(TileIdList::ZserioPackingContext&, ::zserio::BitStreamWriter& out) const
{
    m_id_.writePacked(out);
}

TileIdList::ZserioArrayType_id TileIdList::readId(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_id readField(allocator);
    readField.readPacked(in);

    return readField;
}

TileIdList::ZserioArrayType_id TileIdList::readId(TileIdList::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_id readField(allocator);
    readField.readPacked(in);

    return readField;
}

} // namespace types
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/core/types/Range.h>

namespace nds
{
namespace core
{
namespace types
{

Range::Range(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_start_(allocator),
        m_end_(allocator)
{
}

Range::Range(::zserio::BitStreamReader& in,
        uint32_t length_, const allocator_type& allocator) :
        m_length_(length_),
        m_isInitialized(true),
        m_start_(readStart(in, allocator)),
        m_end_(readEnd(in, allocator))
{
}

Range::Range(Range::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        uint32_t length_, const allocator_type& allocator) :
        m_length_(length_),
        m_isInitialized(true),
        m_start_(readStart(context, in, allocator)),
        m_end_(readEnd(context, in, allocator))
{
}

Range::Range(const Range& other) :
        m_start_(other.m_start_),
        m_end_(other.m_end_)
{
    if (other.m_isInitialized)
        initialize(other.m_length_);
    else
        m_isInitialized = false;
}

Range& Range::operator=(const Range& other)
{
    m_start_ = other.m_start_;
    m_end_ = other.m_end_;
    if (other.m_isInitialized)
        initialize(other.m_length_);
    else
        m_isInitialized = false;

    return *this;
}

Range::Range(Range&& other) :
        m_start_(::std::move(other.m_start_)),
        m_end_(::std::move(other.m_end_))
{
    if (other.m_isInitialized)
        initialize(other.m_length_);
    else
        m_isInitialized = false;
}

Range& Range::operator=(Range&& other)
{
    m_start_ = ::std::move(other.m_start_);
    m_end_ = ::std::move(other.m_end_);
    if (other.m_isInitialized)
        initialize(other.m_length_);
    else
        m_isInitialized = false;

    return *this;
}

Range::Range(::zserio::PropagateAllocatorT,
        const Range& other, const allocator_type& allocator) :
        m_start_(::zserio::allocatorPropagatingCopy(other.m_start_, allocator)),
        m_end_(::zserio::allocatorPropagatingCopy(other.m_end_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_length_);
    else
        m_isInitialized = false;
}

void Range::initialize(
        uint32_t length_)
{
    m_length_ = length_;
    m_isInitialized = true;

    initializeChildren();
}

bool Range::isInitialized() const
{
    return m_isInitialized;
}

void Range::initializeChildren()
{
    m_start_.initialize(static_cast<uint32_t>(getLength()));
    m_end_.initialize(static_cast<uint32_t>(getLength()));
}

uint32_t Range::getLength() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'length' of compound 'Range' is not initialized!");

    return m_length_;
}

::nds::core::types::RangePosition& Range::getStart()
{
    return m_start_;
}

const ::nds::core::types::RangePosition& Range::getStart() const
{
    return m_start_;
}

void Range::setStart(const ::nds::core::types::RangePosition& start_)
{
    m_start_ = start_;
}

void Range::setStart(::nds::core::types::RangePosition&& start_)
{
    m_start_ = ::std::move(start_);
}

::nds::core::types::RangePosition& Range::getEnd()
{
    return m_end_;
}

const ::nds::core::types::RangePosition& Range::getEnd() const
{
    return m_end_;
}

void Range::setEnd(const ::nds::core::types::RangePosition& end_)
{
    m_end_ = end_;
}

void Range::setEnd(::nds::core::types::RangePosition&& end_)
{
    m_end_ = ::std::move(end_);
}

void Range::initPackingContext(Range::ZserioPackingContext& context) const
{
    m_start_.initPackingContext(context.getStart());
    m_end_.initPackingContext(context.getEnd());
}

size_t Range::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_start_.bitSizeOf(endBitPosition);
    endBitPosition += m_end_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t Range::bitSizeOf(Range::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_start_.bitSizeOf(context.getStart(), endBitPosition);
    endBitPosition += m_end_.bitSizeOf(context.getEnd(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t Range::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_start_.initializeOffsets(endBitPosition);
    endBitPosition = m_end_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t Range::initializeOffsets(Range::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_start_.initializeOffsets(context.getStart(), endBitPosition);
    endBitPosition = m_end_.initializeOffsets(context.getEnd(), endBitPosition);

    return endBitPosition;
}

bool Range::operator==(const Range& other) const
{
    if (this != &other)
    {
        return
                (getLength() == other.getLength()) &&
                (m_start_ == other.m_start_) &&
                (m_end_ == other.m_end_);
    }

    return true;
}

uint32_t Range::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getLength());
    result = ::zserio::calcHashCode(result, m_start_);
    result = ::zserio::calcHashCode(result, m_end_);

    return result;
}

void Range::write(::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_start_.getLength() != static_cast<uint32_t>(getLength()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter length for field Range.start: ") <<
                m_start_.getLength() << " != " << static_cast<uint32_t>(getLength()) << "!";
    }
    m_start_.write(out);

    // check parameters
    if (m_end_.getLength() != static_cast<uint32_t>(getLength()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter length for field Range.end: ") <<
                m_end_.getLength() << " != " << static_cast<uint32_t>(getLength()) << "!";
    }
    m_end_.write(out);
}

void Range::write(Range::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_start_.getLength() != static_cast<uint32_t>(getLength()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter length for field Range.start: ") <<
                m_start_.getLength() << " != " << static_cast<uint32_t>(getLength()) << "!";
    }
    m_start_.write(context.getStart(), out);

    // check parameters
    if (m_end_.getLength() != static_cast<uint32_t>(getLength()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter length for field Range.end: ") <<
                m_end_.getLength() << " != " << static_cast<uint32_t>(getLength()) << "!";
    }
    m_end_.write(context.getEnd(), out);
}

::nds::core::types::RangePosition Range::readStart(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::types::RangePosition(in, static_cast<uint32_t>(getLength()), allocator);
}

::nds::core::types::RangePosition Range::readStart(Range::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::types::RangePosition(context.getStart(), in, static_cast<uint32_t>(getLength()), allocator);
}
::nds::core::types::RangePosition Range::readEnd(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::types::RangePosition(in, static_cast<uint32_t>(getLength()), allocator);
}

::nds::core::types::RangePosition Range::readEnd(Range::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::types::RangePosition(context.getEnd(), in, static_cast<uint32_t>(getLength()), allocator);
}

} // namespace types
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ConstraintException.h>

#include <nds/core/types/RangePosition.h>

namespace nds
{
namespace core
{
namespace types
{

RangePosition::RangePosition(const allocator_type&) noexcept :
        m_isInitialized(false),
        m_position_(uint32_t())
{
}

RangePosition::RangePosition(::zserio::BitStreamReader& in,
        uint32_t length_, const allocator_type&) :
        m_length_(length_),
        m_isInitialized(true),
        m_position_(readPosition(in))
{
}

RangePosition::RangePosition(RangePosition::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        uint32_t length_, const allocator_type&) :
        m_length_(length_),
        m_isInitialized(true),
        m_position_(readPosition(context, in))
{
}

RangePosition::RangePosition(const RangePosition& other) :
        m_position_(other.m_position_)
{
    if (other.m_isInitialized)
        initialize(other.m_length_);
    else
        m_isInitialized = false;
}

RangePosition& RangePosition::operator=(const RangePosition& other)
{
    m_position_ = other.m_position_;
    if (other.m_isInitialized)
        initialize(other.m_length_);
    else
        m_isInitialized = false;

    return *this;
}

RangePosition::RangePosition(RangePosition&& other) :
        m_position_(::std::move(other.m_position_))
{
    if (other.m_isInitialized)
        initialize(other.m_length_);
    else
        m_isInitialized = false;
}

RangePosition& RangePosition::operator=(RangePosition&& other)
{
    m_position_ = ::std::move(other.m_position_);
    if (other.m_isInitialized)
        initialize(other.m_length_);
    else
        m_isInitialized = false;

    return *this;
}

RangePosition::RangePosition(::zserio::PropagateAllocatorT,
        const RangePosition& other, const allocator_type& allocator) :
        m_position_(::zserio::allocatorPropagatingCopy(other.m_position_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_length_);
    else
        m_isInitialized = false;
}

void RangePosition::initialize(
        uint32_t length_)
{
    m_length_ = length_;
    m_isInitialized = true;
}

bool RangePosition::isInitialized() const
{
    return m_isInitialized;
}

uint32_t RangePosition::getLength() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'length' of compound 'RangePosition' is not initialized!");

    return m_length_;
}

uint32_t RangePosition::getPosition() const
{
    return m_position_;
}

void RangePosition::setPosition(uint32_t position_)
{
    m_position_ = position_;
}

void RangePosition::initPackingContext(RangePosition::ZserioPackingContext& context) const
{
    context.getPosition().init<::zserio::VarIntNNArrayTraits<uint32_t>>(m_position_);
}

size_t RangePosition::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_position_);

    return endBitPosition - bitPosition;
}

size_t RangePosition::bitSizeOf(RangePosition::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getPosition().bitSizeOf<::zserio::VarIntNNArrayTraits<uint32_t>>(m_position_);

    return endBitPosition - bitPosition;
}

size_t RangePosition::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarUInt32(m_position_);

    return endBitPosition;
}

size_t RangePosition::initializeOffsets(RangePosition::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getPosition().bitSizeOf<::zserio::VarIntNNArrayTraits<uint32_t>>(m_position_);

    return endBitPosition;
}

bool RangePosition::operator==(const RangePosition& other) const
{
    if (this != &other)
    {
        return
                (getLength() == other.getLength()) &&
                (m_position_ == other.m_position_);
    }

    return true;
}

uint32_t RangePosition::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getLength());
    result = ::zserio::calcHashCode(result, m_position_);

    return result;
}

void RangePosition::write(::zserio::BitStreamWriter& out) const
{
    // check constraint
    if (!(getPosition() <= getLength()))
        throw ::zserio::ConstraintException("Write: Constraint violated at RangePosition.position!");
    out.writeVarUInt32(m_position_);
}

void RangePosition::write(RangePosition::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    // check constraint
    if (!(getPosition() <= getLength()))
        throw ::zserio::ConstraintException("Write: Constraint violated at RangePosition.position!");
    context.getPosition().write<::zserio::VarIntNNArrayTraits<uint32_t>>(out, m_position_);
}

uint32_t RangePosition::readPosition(::zserio::BitStreamReader& in)
{
    uint32_t readField = static_cast<uint32_t>(in.readVarUInt32());
    // check constraint
    if (!(readField <= getLength()))
        throw ::zserio::ConstraintException("Read: Constraint violated at RangePosition.position!");

    return readField;
}

uint32_t RangePosition::readPosition(RangePosition::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    uint32_t readField = context.getPosition().read<::zserio::VarIntNNArrayTraits<uint32_t>>(in);
    // check constraint
    if (!(readField <= getLength()))
        throw ::zserio::ConstraintException("Read: Constraint violated at RangePosition.position!");

    return readField;
}

} // namespace types
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ConstraintException.h>

#include <nds/core/types/PercentageRange.h>

namespace nds
{
namespace core
{
namespace types
{

PercentageRange::PercentageRange(const allocator_type&) noexcept :
        m_numBits_(uint8_t()),
        m_startPosition_(uint32_t()),
        m_endPosition_(uint32_t())
{
}

PercentageRange::PercentageRange(::zserio::BitStreamReader& in, const allocator_type&) :
        m_numBits_(readNumBits(in)),
        m_startPosition_(readStartPosition(in)),
        m_endPosition_(readEndPosition(in))
{
}

PercentageRange::PercentageRange(PercentageRange::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type&) :
        m_numBits_(readNumBits(context, in)),
        m_startPosition_(readStartPosition(context, in)),
        m_endPosition_(readEndPosition(context, in))
{
}

PercentageRange::PercentageRange(::zserio::PropagateAllocatorT,
        const PercentageRange& other, const allocator_type& allocator) :
        m_numBits_(::zserio::allocatorPropagatingCopy(other.m_numBits_, allocator)),
        m_startPosition_(::zserio::allocatorPropagatingCopy(other.m_startPosition_, allocator)),
        m_endPosition_(::zserio::allocatorPropagatingCopy(other.m_endPosition_, allocator))
{
}

uint8_t PercentageRange::getNumBits() const
{
    return m_numBits_;
}

void PercentageRange::setNumBits(uint8_t numBits_)
{
    m_numBits_ = numBits_;
}

uint32_t PercentageRange::getStartPosition() const
{
    return m_startPosition_;
}

void PercentageRange::setStartPosition(uint32_t startPosition_)
{
    m_startPosition_ = startPosition_;
}

uint32_t PercentageRange::getEndPosition() const
{
    return m_endPosition_;
}

void PercentageRange::setEndPosition(uint32_t endPosition_)
{
    m_endPosition_ = endPosition_;
}

double PercentageRange::funcStartPercentageValue() const
{
    return static_cast<double>((getStartPosition() + 0.0) / ((1 << getNumBits()) - 1));
}

double PercentageRange::funcEndPercentageValue() const
{
    return static_cast<double>((getEndPosition() + 0.0) / ((1 << getNumBits()) - 1));
}

void PercentageRange::initPackingContext(PercentageRange::ZserioPackingContext& context) const
{
    context.getNumBits().init<::zserio::BitFieldArrayTraits<uint8_t, UINT8_C(5)>>(m_numBits_);
    context.getStartPosition().init<::zserio::DynamicBitFieldArrayTraits<uint32_t, ZserioElementBitSize_startPosition>>(*this, m_startPosition_);
    context.getEndPosition().init<::zserio::DynamicBitFieldArrayTraits<uint32_t, ZserioElementBitSize_endPosition>>(*this, m_endPosition_);
}

size_t PercentageRange::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(5);
    endBitPosition += static_cast<uint8_t>(getNumBits());
    endBitPosition += static_cast<uint8_t>(getNumBits());

    return endBitPosition - bitPosition;
}

size_t PercentageRange::bitSizeOf(PercentageRange::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumBits().bitSizeOf<::zserio::BitFieldArrayTraits<uint8_t, UINT8_C(5)>>(m_numBits_);
    endBitPosition += context.getStartPosition().bitSizeOf<::zserio::DynamicBitFieldArrayTraits<uint32_t, ZserioElementBitSize_startPosition>>(*this, m_startPosition_);
    endBitPosition += context.getEndPosition().bitSizeOf<::zserio::DynamicBitFieldArrayTraits<uint32_t, ZserioElementBitSize_endPosition>>(*this, m_endPosition_);

    return endBitPosition - bitPosition;
}

size_t PercentageRange::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(5);
    endBitPosition += static_cast<uint8_t>(getNumBits());
    endBitPosition += static_cast<uint8_t>(getNumBits());

    return endBitPosition;
}

size_t PercentageRange::initializeOffsets(PercentageRange::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumBits().bitSizeOf<::zserio::BitFieldArrayTraits<uint8_t, UINT8_C(5)>>(m_numBits_);
    endBitPosition += context.getStartPosition().bitSizeOf<::zserio::DynamicBitFieldArrayTraits<uint32_t, ZserioElementBitSize_startPosition>>(*this, m_startPosition_);
    endBitPosition += context.getEndPosition().bitSizeOf<::zserio::DynamicBitFieldArrayTraits<uint32_t, ZserioElementBitSize_endPosition>>(*this, m_endPosition_);

    return endBitPosition;
}

bool PercentageRange::operator==(const PercentageRange& other) const
{
    if (this != &other)
    {
        return
                (m_numBits_ == other.m_numBits_) &&
                (m_startPosition_ == other.m_startPosition_) &&
                (m_endPosition_ == other.m_endPosition_);
    }

    return true;
}

uint32_t PercentageRange::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_numBits_);
    result = ::zserio::calcHashCode(result, m_startPosition_);
    result = ::zserio::calcHashCode(result, m_endPosition_);

    return result;
}

void PercentageRange::write(::zserio::BitStreamWriter& out) const
{
    // check constraint
    if (!(getNumBits() > 0))
        throw ::zserio::ConstraintException("Write: Constraint violated at PercentageRange.numBits!");
    out.writeBits(m_numBits_, UINT8_C(5));

    out.writeBits(m_startPosition_, static_cast<uint8_t>(getNumBits()));

    // check constraint
    if (!(getEndPosition() > getStartPosition()))
        throw ::zserio::ConstraintException("Write: Constraint violated at PercentageRange.endPosition!");
    out.writeBits(m_endPosition_, static_cast<uint8_t>(getNumBits()));
}

void PercentageRange::write(PercentageRange::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    // check constraint
    if (!(getNumBits() > 0))
        throw ::zserio::ConstraintException("Write: Constraint violated at PercentageRange.numBits!");
    context.getNumBits().write<::zserio::BitFieldArrayTraits<uint8_t, UINT8_C(5)>>(out, m_numBits_);

    context.getStartPosition().write<::zserio::DynamicBitFieldArrayTraits<uint32_t, ZserioElementBitSize_startPosition>>(*this, out, m_startPosition_);

    // check constraint
    if (!(getEndPosition() > getStartPosition()))
        throw ::zserio::ConstraintException("Write: Constraint violated at PercentageRange.endPosition!");
    context.getEndPosition().write<::zserio::DynamicBitFieldArrayTraits<uint32_t, ZserioElementBitSize_endPosition>>(*this, out, m_endPosition_);
}

uint8_t PercentageRange::ZserioElementBitSize_startPosition::get(const PercentageRange& owner)
{
    return static_cast<uint8_t>(owner.getNumBits());
}

uint8_t PercentageRange::ZserioElementBitSize_endPosition::get(const PercentageRange& owner)
{
    return static_cast<uint8_t>(owner.getNumBits());
}

uint8_t PercentageRange::readNumBits(::zserio::BitStreamReader& in)
{
    uint8_t readField = static_cast<uint8_t>(in.readBits(UINT8_C(5)));
    // check constraint
    if (!(readField > 0))
        throw ::zserio::ConstraintException("Read: Constraint violated at PercentageRange.numBits!");

    return readField;
}

uint8_t PercentageRange::readNumBits(PercentageRange::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    uint8_t readField = context.getNumBits().read<::zserio::BitFieldArrayTraits<uint8_t, UINT8_C(5)>>(in);
    // check constraint
    if (!(readField > 0))
        throw ::zserio::ConstraintException("Read: Constraint violated at PercentageRange.numBits!");

    return readField;
}
uint32_t PercentageRange::readStartPosition(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readBits(static_cast<uint8_t>(getNumBits())));
}

uint32_t PercentageRange::readStartPosition(PercentageRange::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getStartPosition().read<::zserio::DynamicBitFieldArrayTraits<uint32_t, ZserioElementBitSize_startPosition>>(*this, in);
}
uint32_t PercentageRange::readEndPosition(::zserio::BitStreamReader& in)
{
    uint32_t readField = static_cast<uint32_t>(in.readBits(static_cast<uint8_t>(getNumBits())));
    // check constraint
    if (!(readField > getStartPosition()))
        throw ::zserio::ConstraintException("Read: Constraint violated at PercentageRange.endPosition!");

    return readField;
}

uint32_t PercentageRange::readEndPosition(PercentageRange::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    uint32_t readField = context.getEndPosition().read<::zserio::DynamicBitFieldArrayTraits<uint32_t, ZserioElementBitSize_endPosition>>(*this, in);
    // check constraint
    if (!(readField > getStartPosition()))
        throw ::zserio::ConstraintException("Read: Constraint violated at PercentageRange.endPosition!");

    return readField;
}

} // namespace types
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ConstraintException.h>

#include <nds/core/types/PercentagePosition.h>

namespace nds
{
namespace core
{
namespace types
{

PercentagePosition::PercentagePosition(const allocator_type&) noexcept :
        m_numBits_(uint8_t()),
        m_position_(uint32_t())
{
}

PercentagePosition::PercentagePosition(::zserio::BitStreamReader& in, const allocator_type&) :
        m_numBits_(readNumBits(in)),
        m_position_(readPosition(in))
{
}

PercentagePosition::PercentagePosition(PercentagePosition::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type&) :
        m_numBits_(readNumBits(context, in)),
        m_position_(readPosition(context, in))
{
}

PercentagePosition::PercentagePosition(::zserio::PropagateAllocatorT,
        const PercentagePosition& other, const allocator_type& allocator) :
        m_numBits_(::zserio::allocatorPropagatingCopy(other.m_numBits_, allocator)),
        m_position_(::zserio::allocatorPropagatingCopy(other.m_position_, allocator))
{
}

uint8_t PercentagePosition::getNumBits() const
{
    return m_numBits_;
}

void PercentagePosition::setNumBits(uint8_t numBits_)
{
    m_numBits_ = numBits_;
}

uint32_t PercentagePosition::getPosition() const
{
    return m_position_;
}

void PercentagePosition::setPosition(uint32_t position_)
{
    m_position_ = position_;
}

double PercentagePosition::funcPercentageValue() const
{
    return static_cast<double>((getPosition() + 0.0) / ((1 << getNumBits()) - 1));
}

void PercentagePosition::initPackingContext(PercentagePosition::ZserioPackingContext& context) const
{
    context.getNumBits().init<::zserio::BitFieldArrayTraits<uint8_t, UINT8_C(5)>>(m_numBits_);
    context.getPosition().init<::zserio::DynamicBitFieldArrayTraits<uint32_t, ZserioElementBitSize_position>>(*this, m_position_);
}

size_t PercentagePosition::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(5);
    endBitPosition += static_cast<uint8_t>(getNumBits());

    return endBitPosition - bitPosition;
}

size_t PercentagePosition::bitSizeOf(PercentagePosition::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumBits().bitSizeOf<::zserio::BitFieldArrayTraits<uint8_t, UINT8_C(5)>>(m_numBits_);
    endBitPosition += context.getPosition().bitSizeOf<::zserio::DynamicBitFieldArrayTraits<uint32_t, ZserioElementBitSize_position>>(*this, m_position_);

    return endBitPosition - bitPosition;
}

size_t PercentagePosition::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(5);
    endBitPosition += static_cast<uint8_t>(getNumBits());

    return endBitPosition;
}

size_t PercentagePosition::initializeOffsets(PercentagePosition::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumBits().bitSizeOf<::zserio::BitFieldArrayTraits<uint8_t, UINT8_C(5)>>(m_numBits_);
    endBitPosition += context.getPosition().bitSizeOf<::zserio::DynamicBitFieldArrayTraits<uint32_t, ZserioElementBitSize_position>>(*this, m_position_);

    return endBitPosition;
}

bool PercentagePosition::operator==(const PercentagePosition& other) const
{
    if (this != &other)
    {
        return
                (m_numBits_ == other.m_numBits_) &&
                (m_position_ == other.m_position_);
    }

    return true;
}

uint32_t PercentagePosition::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_numBits_);
    result = ::zserio::calcHashCode(result, m_position_);

    return result;
}

void PercentagePosition::write(::zserio::BitStreamWriter& out) const
{
    // check constraint
    if (!(getNumBits() > 0))
        throw ::zserio::ConstraintException("Write: Constraint violated at PercentagePosition.numBits!");
    out.writeBits(m_numBits_, UINT8_C(5));

    out.writeBits(m_position_, static_cast<uint8_t>(getNumBits()));
}

void PercentagePosition::write(PercentagePosition::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    // check constraint
    if (!(getNumBits() > 0))
        throw ::zserio::ConstraintException("Write: Constraint violated at PercentagePosition.numBits!");
    context.getNumBits().write<::zserio::BitFieldArrayTraits<uint8_t, UINT8_C(5)>>(out, m_numBits_);

    context.getPosition().write<::zserio::DynamicBitFieldArrayTraits<uint32_t, ZserioElementBitSize_position>>(*this, out, m_position_);
}

uint8_t PercentagePosition::ZserioElementBitSize_position::get(const PercentagePosition& owner)
{
    return static_cast<uint8_t>(owner.getNumBits());
}

uint8_t PercentagePosition::readNumBits(::zserio::BitStreamReader& in)
{
    uint8_t readField = static_cast<uint8_t>(in.readBits(UINT8_C(5)));
    // check constraint
    if (!(readField > 0))
        throw ::zserio::ConstraintException("Read: Constraint violated at PercentagePosition.numBits!");

    return readField;
}

uint8_t PercentagePosition::readNumBits(PercentagePosition::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    uint8_t readField = context.getNumBits().read<::zserio::BitFieldArrayTraits<uint8_t, UINT8_C(5)>>(in);
    // check constraint
    if (!(readField > 0))
        throw ::zserio::ConstraintException("Read: Constraint violated at PercentagePosition.numBits!");

    return readField;
}
uint32_t PercentagePosition::readPosition(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readBits(static_cast<uint8_t>(getNumBits())));
}

uint32_t PercentagePosition::readPosition(PercentagePosition::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getPosition().read<::zserio::DynamicBitFieldArrayTraits<uint32_t, ZserioElementBitSize_position>>(*this, in);
}

} // namespace types
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/core/types/RoadType.h>

namespace nds
{
namespace core
{
namespace types
{

RoadType::RoadType(const allocator_type&) noexcept :
        m_form_(::nds::core::types::RoadForm()),
        m_characteristics_(::zserio::NullOpt)
{
}

RoadType::RoadType(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_form_(readForm(in)),
        m_characteristics_(readCharacteristics(in, allocator))
{
}

RoadType::RoadType(RoadType::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_form_(readForm(context, in)),
        m_characteristics_(readCharacteristics(context, in, allocator))
{
}

RoadType::RoadType(::zserio::PropagateAllocatorT,
        const RoadType& other, const allocator_type& allocator) :
        m_form_(::zserio::allocatorPropagatingCopy(other.m_form_, allocator)),
        m_characteristics_(::zserio::allocatorPropagatingCopy(other.m_characteristics_, allocator))
{
}

::nds::core::types::RoadForm RoadType::getForm() const
{
    return m_form_;
}

void RoadType::setForm(::nds::core::types::RoadForm form_)
{
    m_form_ = form_;
}

::zserio::vector<::nds::core::types::RoadCharacter>& RoadType::getCharacteristics()
{
    return m_characteristics_.value().getRawArray();
}

const ::zserio::vector<::nds::core::types::RoadCharacter>& RoadType::getCharacteristics() const
{
    return m_characteristics_.value().getRawArray();
}

void RoadType::setCharacteristics(const ::zserio::vector<::nds::core::types::RoadCharacter>& characteristics_)
{
    m_characteristics_ = ZserioArrayType_characteristics(characteristics_);
}

void RoadType::setCharacteristics(::zserio::vector<::nds::core::types::RoadCharacter>&& characteristics_)
{
    m_characteristics_ = ZserioArrayType_characteristics(std::move(characteristics_));
}

bool RoadType::isCharacteristicsUsed() const
{
    return (isCharacteristicsSet());
}

bool RoadType::isCharacteristicsSet() const
{
    return m_characteristics_.hasValue();
}

void RoadType::resetCharacteristics()
{
    m_characteristics_.reset();
}

void RoadType::initPackingContext(RoadType::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getForm(), m_form_);
}

size_t RoadType::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_form_);
    endBitPosition += 1;
    if (isCharacteristicsSet())
    {
        endBitPosition += m_characteristics_.value().bitSizeOfPacked(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t RoadType::bitSizeOf(RoadType::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getForm(), m_form_);
    endBitPosition += 1;
    if (isCharacteristicsSet())
    {
        endBitPosition += m_characteristics_.value().bitSizeOfPacked(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t RoadType::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_form_);
    endBitPosition += 1;
    if (isCharacteristicsSet())
    {
        endBitPosition = m_characteristics_.value().initializeOffsetsPacked(endBitPosition);
    }

    return endBitPosition;
}

size_t RoadType::initializeOffsets(RoadType::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getForm(), endBitPosition,
        m_form_);
    endBitPosition += 1;
    if (isCharacteristicsSet())
    {
        endBitPosition = m_characteristics_.value().initializeOffsetsPacked(endBitPosition);
    }

    return endBitPosition;
}

bool RoadType::operator==(const RoadType& other) const
{
    if (this != &other)
    {
        return
                (m_form_ == other.m_form_) &&
                (!isCharacteristicsUsed() ? !other.isCharacteristicsUsed() : (m_characteristics_ == other.m_characteristics_));
    }

    return true;
}

uint32_t RoadType::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_form_);
    if (isCharacteristicsUsed())
        result = ::zserio::calcHashCode(result, m_characteristics_);

    return result;
}

void RoadType::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_form_);
    if (isCharacteristicsSet())
    {
        out.writeBool(true);
        m_characteristics_.value().writePacked(out);
    }
    else
    {
        out.writeBool(false);
    }
}

void RoadType::write(RoadType::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getForm(), out, m_form_);
    if (isCharacteristicsSet())
    {
        out.writeBool(true);
        m_characteristics_.value().writePacked(out);
    }
    else
    {
        out.writeBool(false);
    }
}

::nds::core::types::RoadForm RoadType::readForm(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::core::types::RoadForm>(in);
}

::nds::core::types::RoadForm RoadType::readForm(RoadType::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::core::types::RoadForm>(context.getForm(), in);
}
::zserio::InplaceOptionalHolder<RoadType::ZserioArrayType_characteristics> RoadType::readCharacteristics(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        ZserioArrayType_characteristics readField(allocator);
        readField.readPacked(in);

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_characteristics>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_characteristics>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<RoadType::ZserioArrayType_characteristics> RoadType::readCharacteristics(RoadType::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        ZserioArrayType_characteristics readField(allocator);
        readField.readPacked(in);

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_characteristics>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_characteristics>(::zserio::NullOpt);
}

} // namespace types
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/core/types/RoadCharacterValued.h>

namespace nds
{
namespace core
{
namespace types
{

RoadCharacterValued::RoadCharacterValued(const allocator_type&) noexcept :
        m_character_(::nds::core::types::RoadCharacter()),
        m_value_(bool())
{
}

RoadCharacterValued::RoadCharacterValued(::zserio::BitStreamReader& in, const allocator_type&) :
        m_character_(readCharacter(in)),
        m_value_(readValue(in))
{
}

RoadCharacterValued::RoadCharacterValued(RoadCharacterValued::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type&) :
        m_character_(readCharacter(context, in)),
        m_value_(readValue(in))
{
}

RoadCharacterValued::RoadCharacterValued(::zserio::PropagateAllocatorT,
        const RoadCharacterValued& other, const allocator_type& allocator) :
        m_character_(::zserio::allocatorPropagatingCopy(other.m_character_, allocator)),
        m_value_(::zserio::allocatorPropagatingCopy(other.m_value_, allocator))
{
}

::nds::core::types::RoadCharacter RoadCharacterValued::getCharacter() const
{
    return m_character_;
}

void RoadCharacterValued::setCharacter(::nds::core::types::RoadCharacter character_)
{
    m_character_ = character_;
}

bool RoadCharacterValued::getValue() const
{
    return m_value_;
}

void RoadCharacterValued::setValue(bool value_)
{
    m_value_ = value_;
}

void RoadCharacterValued::initPackingContext(RoadCharacterValued::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getCharacter(), m_character_);
}

size_t RoadCharacterValued::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_character_);
    endBitPosition += UINT8_C(1);

    return endBitPosition - bitPosition;
}

size_t RoadCharacterValued::bitSizeOf(RoadCharacterValued::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getCharacter(), m_character_);
    endBitPosition += UINT8_C(1);

    return endBitPosition - bitPosition;
}

size_t RoadCharacterValued::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_character_);
    endBitPosition += UINT8_C(1);

    return endBitPosition;
}

size_t RoadCharacterValued::initializeOffsets(RoadCharacterValued::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getCharacter(), endBitPosition,
        m_character_);
    endBitPosition += UINT8_C(1);

    return endBitPosition;
}

bool RoadCharacterValued::operator==(const RoadCharacterValued& other) const
{
    if (this != &other)
    {
        return
                (m_character_ == other.m_character_) &&
                (m_value_ == other.m_value_);
    }

    return true;
}

uint32_t RoadCharacterValued::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_character_);
    result = ::zserio::calcHashCode(result, m_value_);

    return result;
}

void RoadCharacterValued::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_character_);
    out.writeBool(m_value_);
}

void RoadCharacterValued::write(RoadCharacterValued::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getCharacter(), out, m_character_);
    out.writeBool(m_value_);
}

::nds::core::types::RoadCharacter RoadCharacterValued::readCharacter(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::core::types::RoadCharacter>(in);
}

::nds::core::types::RoadCharacter RoadCharacterValued::readCharacter(RoadCharacterValued::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::core::types::RoadCharacter>(context.getCharacter(), in);
}
bool RoadCharacterValued::readValue(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}

} // namespace types
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/core/types/RoadTypeSet.h>

namespace nds
{
namespace core
{
namespace types
{

RoadTypeSet::RoadTypeSet(const allocator_type&) noexcept :
        m_form_(::nds::core::types::RoadForm()),
        m_characteristics_(::zserio::NullOpt)
{
}

RoadTypeSet::RoadTypeSet(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_form_(readForm(in)),
        m_characteristics_(readCharacteristics(in, allocator))
{
}

RoadTypeSet::RoadTypeSet(RoadTypeSet::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_form_(readForm(context, in)),
        m_characteristics_(readCharacteristics(context, in, allocator))
{
}

RoadTypeSet::RoadTypeSet(::zserio::PropagateAllocatorT,
        const RoadTypeSet& other, const allocator_type& allocator) :
        m_form_(::zserio::allocatorPropagatingCopy(other.m_form_, allocator)),
        m_characteristics_(::zserio::allocatorPropagatingCopy(other.m_characteristics_, allocator))
{
}

::nds::core::types::RoadForm RoadTypeSet::getForm() const
{
    return m_form_;
}

void RoadTypeSet::setForm(::nds::core::types::RoadForm form_)
{
    m_form_ = form_;
}

::zserio::vector<::nds::core::types::RoadCharacterValued>& RoadTypeSet::getCharacteristics()
{
    return m_characteristics_.value().getRawArray();
}

const ::zserio::vector<::nds::core::types::RoadCharacterValued>& RoadTypeSet::getCharacteristics() const
{
    return m_characteristics_.value().getRawArray();
}

void RoadTypeSet::setCharacteristics(const ::zserio::vector<::nds::core::types::RoadCharacterValued>& characteristics_)
{
    m_characteristics_ = ZserioArrayType_characteristics(characteristics_);
}

void RoadTypeSet::setCharacteristics(::zserio::vector<::nds::core::types::RoadCharacterValued>&& characteristics_)
{
    m_characteristics_ = ZserioArrayType_characteristics(std::move(characteristics_));
}

bool RoadTypeSet::isCharacteristicsUsed() const
{
    return (isCharacteristicsSet());
}

bool RoadTypeSet::isCharacteristicsSet() const
{
    return m_characteristics_.hasValue();
}

void RoadTypeSet::resetCharacteristics()
{
    m_characteristics_.reset();
}

void RoadTypeSet::initPackingContext(RoadTypeSet::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getForm(), m_form_);
}

size_t RoadTypeSet::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_form_);
    endBitPosition += 1;
    if (isCharacteristicsSet())
    {
        endBitPosition += m_characteristics_.value().bitSizeOfPacked(*this, endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t RoadTypeSet::bitSizeOf(RoadTypeSet::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getForm(), m_form_);
    endBitPosition += 1;
    if (isCharacteristicsSet())
    {
        endBitPosition += m_characteristics_.value().bitSizeOfPacked(*this, endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t RoadTypeSet::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_form_);
    endBitPosition += 1;
    if (isCharacteristicsSet())
    {
        endBitPosition = m_characteristics_.value().initializeOffsetsPacked(*this, endBitPosition);
    }

    return endBitPosition;
}

size_t RoadTypeSet::initializeOffsets(RoadTypeSet::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getForm(), endBitPosition,
        m_form_);
    endBitPosition += 1;
    if (isCharacteristicsSet())
    {
        endBitPosition = m_characteristics_.value().initializeOffsetsPacked(*this, endBitPosition);
    }

    return endBitPosition;
}

bool RoadTypeSet::operator==(const RoadTypeSet& other) const
{
    if (this != &other)
    {
        return
                (m_form_ == other.m_form_) &&
                (!isCharacteristicsUsed() ? !other.isCharacteristicsUsed() : (m_characteristics_ == other.m_characteristics_));
    }

    return true;
}

uint32_t RoadTypeSet::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_form_);
    if (isCharacteristicsUsed())
        result = ::zserio::calcHashCode(result, m_characteristics_);

    return result;
}

void RoadTypeSet::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_form_);
    if (isCharacteristicsSet())
    {
        out.writeBool(true);
        m_characteristics_.value().writePacked(*this, out);
    }
    else
    {
        out.writeBool(false);
    }
}

void RoadTypeSet::write(RoadTypeSet::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getForm(), out, m_form_);
    if (isCharacteristicsSet())
    {
        out.writeBool(true);
        m_characteristics_.value().writePacked(*this, out);
    }
    else
    {
        out.writeBool(false);
    }
}

void RoadTypeSet::ZserioElementFactory_characteristics::create(RoadTypeSet&        ,
        ::zserio::vector<::nds::core::types::RoadCharacterValued>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void RoadTypeSet::ZserioElementFactory_characteristics::create(RoadTypeSet&        ,
        ::zserio::vector<::nds::core::types::RoadCharacterValued>& array,
        ::nds::core::types::RoadCharacterValued::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::nds::core::types::RoadForm RoadTypeSet::readForm(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::core::types::RoadForm>(in);
}

::nds::core::types::RoadForm RoadTypeSet::readForm(RoadTypeSet::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::core::types::RoadForm>(context.getForm(), in);
}
::zserio::InplaceOptionalHolder<RoadTypeSet::ZserioArrayType_characteristics> RoadTypeSet::readCharacteristics(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        ZserioArrayType_characteristics readField(allocator);
        readField.readPacked(*this, in);

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_characteristics>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_characteristics>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<RoadTypeSet::ZserioArrayType_characteristics> RoadTypeSet::readCharacteristics(RoadTypeSet::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        ZserioArrayType_characteristics readField(allocator);
        readField.readPacked(*this, in);

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_characteristics>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_characteristics>(::zserio::NullOpt);
}

} // namespace types
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/core/types/LaneType.h>

namespace nds
{
namespace core
{
namespace types
{

LaneType::LaneType(const allocator_type& allocator) noexcept :
        m_functionalLaneType_(::nds::core::types::LaneFunctionalType()),
        m_accessLaneType_(::nds::core::types::LaneAccessType()),
        m_roadType_(allocator)
{
}

LaneType::LaneType(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_functionalLaneType_(readFunctionalLaneType(in)),
        m_accessLaneType_(readAccessLaneType(in)),
        m_roadType_(readRoadType(in, allocator))
{
}

LaneType::LaneType(LaneType::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_functionalLaneType_(readFunctionalLaneType(context, in)),
        m_accessLaneType_(readAccessLaneType(context, in)),
        m_roadType_(readRoadType(context, in, allocator))
{
}

LaneType::LaneType(::zserio::PropagateAllocatorT,
        const LaneType& other, const allocator_type& allocator) :
        m_functionalLaneType_(::zserio::allocatorPropagatingCopy(other.m_functionalLaneType_, allocator)),
        m_accessLaneType_(::zserio::allocatorPropagatingCopy(other.m_accessLaneType_, allocator)),
        m_roadType_(::zserio::allocatorPropagatingCopy(other.m_roadType_, allocator))
{
}

::nds::core::types::LaneFunctionalType LaneType::getFunctionalLaneType() const
{
    return m_functionalLaneType_;
}

void LaneType::setFunctionalLaneType(::nds::core::types::LaneFunctionalType functionalLaneType_)
{
    m_functionalLaneType_ = functionalLaneType_;
}

::nds::core::types::LaneAccessType LaneType::getAccessLaneType() const
{
    return m_accessLaneType_;
}

void LaneType::setAccessLaneType(::nds::core::types::LaneAccessType accessLaneType_)
{
    m_accessLaneType_ = accessLaneType_;
}

::nds::core::types::RoadType& LaneType::getRoadType()
{
    return m_roadType_;
}

const ::nds::core::types::RoadType& LaneType::getRoadType() const
{
    return m_roadType_;
}

void LaneType::setRoadType(const ::nds::core::types::RoadType& roadType_)
{
    m_roadType_ = roadType_;
}

void LaneType::setRoadType(::nds::core::types::RoadType&& roadType_)
{
    m_roadType_ = ::std::move(roadType_);
}

void LaneType::initPackingContext(LaneType::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getFunctionalLaneType(), m_functionalLaneType_);
    m_accessLaneType_.initPackingContext(context.getAccessLaneType());
    m_roadType_.initPackingContext(context.getRoadType());
}

size_t LaneType::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_functionalLaneType_);
    endBitPosition += m_accessLaneType_.bitSizeOf(endBitPosition);
    endBitPosition += m_roadType_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LaneType::bitSizeOf(LaneType::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getFunctionalLaneType(), m_functionalLaneType_);
    endBitPosition += m_accessLaneType_.bitSizeOf(context.getAccessLaneType(), endBitPosition);
    endBitPosition += m_roadType_.bitSizeOf(context.getRoadType(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LaneType::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_functionalLaneType_);
    endBitPosition = m_accessLaneType_.initializeOffsets(endBitPosition);
    endBitPosition = m_roadType_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t LaneType::initializeOffsets(LaneType::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getFunctionalLaneType(), endBitPosition,
        m_functionalLaneType_);
    endBitPosition = m_accessLaneType_.initializeOffsets(context.getAccessLaneType(), endBitPosition);
    endBitPosition = m_roadType_.initializeOffsets(context.getRoadType(), endBitPosition);

    return endBitPosition;
}

bool LaneType::operator==(const LaneType& other) const
{
    if (this != &other)
    {
        return
                (m_functionalLaneType_ == other.m_functionalLaneType_) &&
                (m_accessLaneType_ == other.m_accessLaneType_) &&
                (m_roadType_ == other.m_roadType_);
    }

    return true;
}

uint32_t LaneType::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_functionalLaneType_);
    result = ::zserio::calcHashCode(result, m_accessLaneType_);
    result = ::zserio::calcHashCode(result, m_roadType_);

    return result;
}

void LaneType::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_functionalLaneType_);
    m_accessLaneType_.write(out);
    m_roadType_.write(out);
}

void LaneType::write(LaneType::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getFunctionalLaneType(), out, m_functionalLaneType_);
    m_accessLaneType_.write(context.getAccessLaneType(), out);
    m_roadType_.write(context.getRoadType(), out);
}

::nds::core::types::LaneFunctionalType LaneType::readFunctionalLaneType(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::core::types::LaneFunctionalType>(in);
}

::nds::core::types::LaneFunctionalType LaneType::readFunctionalLaneType(LaneType::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::core::types::LaneFunctionalType>(context.getFunctionalLaneType(), in);
}
::nds::core::types::LaneAccessType LaneType::readAccessLaneType(::zserio::BitStreamReader& in)
{
    return ::nds::core::types::LaneAccessType(in);
}

::nds::core::types::LaneAccessType LaneType::readAccessLaneType(LaneType::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::nds::core::types::LaneAccessType(context.getAccessLaneType(), in);
}
::nds::core::types::RoadType LaneType::readRoadType(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::types::RoadType(in, allocator);
}

::nds::core::types::RoadType LaneType::readRoadType(LaneType::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::types::RoadType(context.getRoadType(), in, allocator);
}

} // namespace types
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/core/types/MonetaryAmount.h>

namespace nds
{
namespace core
{
namespace types
{

MonetaryAmount::MonetaryAmount(const allocator_type&) noexcept :
        m_amount_(int64_t()),
        m_currency_(::nds::core::types::Currency())
{
}

MonetaryAmount::MonetaryAmount(::zserio::BitStreamReader& in, const allocator_type&) :
        m_amount_(readAmount(in)),
        m_currency_(readCurrency(in))
{
}

MonetaryAmount::MonetaryAmount(MonetaryAmount::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type&) :
        m_amount_(readAmount(context, in)),
        m_currency_(readCurrency(context, in))
{
}

MonetaryAmount::MonetaryAmount(::zserio::PropagateAllocatorT,
        const MonetaryAmount& other, const allocator_type& allocator) :
        m_amount_(::zserio::allocatorPropagatingCopy(other.m_amount_, allocator)),
        m_currency_(::zserio::allocatorPropagatingCopy(other.m_currency_, allocator))
{
}

int64_t MonetaryAmount::getAmount() const
{
    return m_amount_;
}

void MonetaryAmount::setAmount(int64_t amount_)
{
    m_amount_ = amount_;
}

::nds::core::types::Currency MonetaryAmount::getCurrency() const
{
    return m_currency_;
}

void MonetaryAmount::setCurrency(::nds::core::types::Currency currency_)
{
    m_currency_ = currency_;
}

void MonetaryAmount::initPackingContext(MonetaryAmount::ZserioPackingContext& context) const
{
    context.getAmount().init<::zserio::VarIntArrayTraits<int64_t>>(m_amount_);
    ::zserio::initPackingContext(context.getCurrency(), m_currency_);
}

size_t MonetaryAmount::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarInt(m_amount_);
    endBitPosition += ::zserio::bitSizeOf(m_currency_);

    return endBitPosition - bitPosition;
}

size_t MonetaryAmount::bitSizeOf(MonetaryAmount::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getAmount().bitSizeOf<::zserio::VarIntArrayTraits<int64_t>>(m_amount_);
    endBitPosition += ::zserio::bitSizeOf(context.getCurrency(), m_currency_);

    return endBitPosition - bitPosition;
}

size_t MonetaryAmount::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarInt(m_amount_);
    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_currency_);

    return endBitPosition;
}

size_t MonetaryAmount::initializeOffsets(MonetaryAmount::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getAmount().bitSizeOf<::zserio::VarIntArrayTraits<int64_t>>(m_amount_);
    endBitPosition = ::zserio::initializeOffsets(context.getCurrency(), endBitPosition,
        m_currency_);

    return endBitPosition;
}

bool MonetaryAmount::operator==(const MonetaryAmount& other) const
{
    if (this != &other)
    {
        return
                (m_amount_ == other.m_amount_) &&
                (m_currency_ == other.m_currency_);
    }

    return true;
}

uint32_t MonetaryAmount::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_amount_);
    result = ::zserio::calcHashCode(result, m_currency_);

    return result;
}

void MonetaryAmount::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarInt(m_amount_);
    ::zserio::write(out, m_currency_);
}

void MonetaryAmount::write(MonetaryAmount::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getAmount().write<::zserio::VarIntArrayTraits<int64_t>>(out, m_amount_);
    ::zserio::write(context.getCurrency(), out, m_currency_);
}

int64_t MonetaryAmount::readAmount(::zserio::BitStreamReader& in)
{
    return static_cast<int64_t>(in.readVarInt());
}

int64_t MonetaryAmount::readAmount(MonetaryAmount::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getAmount().read<::zserio::VarIntArrayTraits<int64_t>>(in);
}
::nds::core::types::Currency MonetaryAmount::readCurrency(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::core::types::Currency>(in);
}

::nds::core::types::Currency MonetaryAmount::readCurrency(MonetaryAmount::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::core::types::Currency>(context.getCurrency(), in);
}

} // namespace types
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/core/types/Iso3166Codes.h>

namespace nds
{
namespace core
{
namespace types
{

Iso3166Codes::Iso3166Codes(const allocator_type& allocator) noexcept :
        m_isoCountryCode_(allocator),
        m_isoSubCountryCode_(::zserio::NullOpt)
{
}

Iso3166Codes::Iso3166Codes(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_isoCountryCode_(readIsoCountryCode(in, allocator)),
        m_isoSubCountryCode_(readIsoSubCountryCode(in, allocator))
{
}

Iso3166Codes::Iso3166Codes(::zserio::PropagateAllocatorT,
        const Iso3166Codes& other, const allocator_type& allocator) :
        m_isoCountryCode_(::zserio::allocatorPropagatingCopy(other.m_isoCountryCode_, allocator)),
        m_isoSubCountryCode_(::zserio::allocatorPropagatingCopy(other.m_isoSubCountryCode_, allocator))
{
}

::zserio::string<>& Iso3166Codes::getIsoCountryCode()
{
    return m_isoCountryCode_;
}

const ::zserio::string<>& Iso3166Codes::getIsoCountryCode() const
{
    return m_isoCountryCode_;
}

void Iso3166Codes::setIsoCountryCode(const ::zserio::string<>& isoCountryCode_)
{
    m_isoCountryCode_ = isoCountryCode_;
}

void Iso3166Codes::setIsoCountryCode(::zserio::string<>&& isoCountryCode_)
{
    m_isoCountryCode_ = ::std::move(isoCountryCode_);
}

::zserio::string<>& Iso3166Codes::getIsoSubCountryCode()
{
    return m_isoSubCountryCode_.value();
}

const ::zserio::string<>& Iso3166Codes::getIsoSubCountryCode() const
{
    return m_isoSubCountryCode_.value();
}

void Iso3166Codes::setIsoSubCountryCode(const ::zserio::string<>& isoSubCountryCode_)
{
    m_isoSubCountryCode_ = isoSubCountryCode_;
}

void Iso3166Codes::setIsoSubCountryCode(::zserio::string<>&& isoSubCountryCode_)
{
    m_isoSubCountryCode_ = ::std::move(isoSubCountryCode_);
}

bool Iso3166Codes::isIsoSubCountryCodeUsed() const
{
    return (isIsoSubCountryCodeSet());
}

bool Iso3166Codes::isIsoSubCountryCodeSet() const
{
    return m_isoSubCountryCode_.hasValue();
}

void Iso3166Codes::resetIsoSubCountryCode()
{
    m_isoSubCountryCode_.reset();
}

size_t Iso3166Codes::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfString(m_isoCountryCode_);
    endBitPosition += 1;
    if (isIsoSubCountryCodeSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_isoSubCountryCode_.value());
    }

    return endBitPosition - bitPosition;
}

size_t Iso3166Codes::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfString(m_isoCountryCode_);
    endBitPosition += 1;
    if (isIsoSubCountryCodeSet())
    {
        endBitPosition += ::zserio::bitSizeOfString(m_isoSubCountryCode_.value());
    }

    return endBitPosition;
}

bool Iso3166Codes::operator==(const Iso3166Codes& other) const
{
    if (this != &other)
    {
        return
                (m_isoCountryCode_ == other.m_isoCountryCode_) &&
                (!isIsoSubCountryCodeUsed() ? !other.isIsoSubCountryCodeUsed() : (m_isoSubCountryCode_ == other.m_isoSubCountryCode_));
    }

    return true;
}

uint32_t Iso3166Codes::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_isoCountryCode_);
    if (isIsoSubCountryCodeUsed())
        result = ::zserio::calcHashCode(result, m_isoSubCountryCode_);

    return result;
}

void Iso3166Codes::write(::zserio::BitStreamWriter& out) const
{
    out.writeString(m_isoCountryCode_);
    if (isIsoSubCountryCodeSet())
    {
        out.writeBool(true);
        out.writeString(m_isoSubCountryCode_.value());
    }
    else
    {
        out.writeBool(false);
    }
}

::zserio::string<> Iso3166Codes::readIsoCountryCode(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return static_cast<::zserio::string<>>(in.readString(allocator));
}
::zserio::InplaceOptionalHolder<::zserio::string<>> Iso3166Codes::readIsoSubCountryCode(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::zserio::string<>>(static_cast<::zserio::string<>>(in.readString(allocator)));
    }

    return ::zserio::InplaceOptionalHolder<::zserio::string<>>(::zserio::NullOpt);
}

} // namespace types
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/core/types/Currencies.h>

namespace nds
{
namespace core
{
namespace types
{

Currencies::Currencies(const allocator_type& allocator) noexcept :
        m_numCurrencies_(uint8_t()),
        m_currencies_(allocator)
{
}

Currencies::Currencies(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numCurrencies_(readNumCurrencies(in)),
        m_currencies_(readCurrencies(in, allocator))
{
}

Currencies::Currencies(Currencies::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_numCurrencies_(readNumCurrencies(context, in)),
        m_currencies_(readCurrencies(context, in, allocator))
{
}

Currencies::Currencies(::zserio::PropagateAllocatorT,
        const Currencies& other, const allocator_type& allocator) :
        m_numCurrencies_(::zserio::allocatorPropagatingCopy(other.m_numCurrencies_, allocator)),
        m_currencies_(::zserio::allocatorPropagatingCopy(other.m_currencies_, allocator))
{
}

uint8_t Currencies::getNumCurrencies() const
{
    return m_numCurrencies_;
}

void Currencies::setNumCurrencies(uint8_t numCurrencies_)
{
    m_numCurrencies_ = numCurrencies_;
}

::zserio::vector<::nds::core::types::Currency>& Currencies::getCurrencies()
{
    return m_currencies_.getRawArray();
}

const ::zserio::vector<::nds::core::types::Currency>& Currencies::getCurrencies() const
{
    return m_currencies_.getRawArray();
}

void Currencies::setCurrencies(const ::zserio::vector<::nds::core::types::Currency>& currencies_)
{
    m_currencies_ = ZserioArrayType_currencies(currencies_);
}

void Currencies::setCurrencies(::zserio::vector<::nds::core::types::Currency>&& currencies_)
{
    m_currencies_ = ZserioArrayType_currencies(std::move(currencies_));
}

void Currencies::initPackingContext(Currencies::ZserioPackingContext& context) const
{
    context.getNumCurrencies().init<::zserio::StdIntArrayTraits<uint8_t>>(m_numCurrencies_);
}

size_t Currencies::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(8);
    endBitPosition += m_currencies_.bitSizeOfPacked(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t Currencies::bitSizeOf(Currencies::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumCurrencies().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_numCurrencies_);
    endBitPosition += m_currencies_.bitSizeOfPacked(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t Currencies::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += UINT8_C(8);
    endBitPosition = m_currencies_.initializeOffsetsPacked(endBitPosition);

    return endBitPosition;
}

size_t Currencies::initializeOffsets(Currencies::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumCurrencies().bitSizeOf<::zserio::StdIntArrayTraits<uint8_t>>(m_numCurrencies_);
    endBitPosition = m_currencies_.initializeOffsetsPacked(endBitPosition);

    return endBitPosition;
}

bool Currencies::operator==(const Currencies& other) const
{
    if (this != &other)
    {
        return
                (m_numCurrencies_ == other.m_numCurrencies_) &&
                (m_currencies_ == other.m_currencies_);
    }

    return true;
}

uint32_t Currencies::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_numCurrencies_);
    result = ::zserio::calcHashCode(result, m_currencies_);

    return result;
}

void Currencies::write(::zserio::BitStreamWriter& out) const
{
    out.writeBits(m_numCurrencies_, UINT8_C(8));

    // check array length
    if (m_currencies_.getRawArray().size() != static_cast<size_t>(getNumCurrencies()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field Currencies.currencies: ") <<
                m_currencies_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumCurrencies()) << "!";
    }
    m_currencies_.writePacked(out);
}

void Currencies::write(Currencies::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumCurrencies().write<::zserio::StdIntArrayTraits<uint8_t>>(out, m_numCurrencies_);

    // check array length
    if (m_currencies_.getRawArray().size() != static_cast<size_t>(getNumCurrencies()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field Currencies.currencies: ") <<
                m_currencies_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumCurrencies()) << "!";
    }
    m_currencies_.writePacked(out);
}

uint8_t Currencies::readNumCurrencies(::zserio::BitStreamReader& in)
{
    return static_cast<uint8_t>(in.readBits(UINT8_C(8)));
}

uint8_t Currencies::readNumCurrencies(Currencies::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumCurrencies().read<::zserio::StdIntArrayTraits<uint8_t>>(in);
}
Currencies::ZserioArrayType_currencies Currencies::readCurrencies(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_currencies readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumCurrencies()));

    return readField;
}

Currencies::ZserioArrayType_currencies Currencies::readCurrencies(Currencies::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_currencies readField(allocator);
    readField.readPacked(in, static_cast<size_t>(getNumCurrencies()));

    return readField;
}

} // namespace types
} // namespace core
} // namespace nds
