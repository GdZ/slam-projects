/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/core/properties/CorePropertyType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for CorePropertyType enumeration.
constexpr ::std::array<const char*, 11> EnumTraits<::nds::core::properties::CorePropertyType>::names;
constexpr ::std::array<::nds::core::properties::CorePropertyType, 11> EnumTraits<::nds::core::properties::CorePropertyType>::values;
constexpr const char* EnumTraits<::nds::core::properties::CorePropertyType>::enumName;

template <>
size_t enumToOrdinal(::nds::core::properties::CorePropertyType value)
{
    switch (value)
    {
    case ::nds::core::properties::CorePropertyType::ATTRIBUTE_REASON:
        return 0;
    case ::nds::core::properties::CorePropertyType::METRIC_UNIT:
        return 1;
    case ::nds::core::properties::CorePropertyType::IMPERIAL_UNIT:
        return 2;
    case ::nds::core::properties::CorePropertyType::ATTRIBUTE_CONFIDENCE:
        return 3;
    case ::nds::core::properties::CorePropertyType::ATTRIBUTE_AGE:
        return 4;
    case ::nds::core::properties::CorePropertyType::ATTRIBUTE_SOURCE:
        return 5;
    case ::nds::core::properties::CorePropertyType::ICON_SET_REFERENCE:
        return 6;
    case ::nds::core::properties::CorePropertyType::ICON_SET_REFERENCE_WITH_HEADING:
        return 7;
    case ::nds::core::properties::CorePropertyType::GLOBAL_ICON_SET_REFERENCE:
        return 8;
    case ::nds::core::properties::CorePropertyType::GLOBAL_ICON_SET_REFERENCE_WITH_HEADING:
        return 9;
    case ::nds::core::properties::CorePropertyType::TOLL_PAYMENT:
        return 10;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration CorePropertyType: ") <<
                static_cast<typename ::std::underlying_type<::nds::core::properties::CorePropertyType>::type>(value) << "!";
    }
}

template <>
::nds::core::properties::CorePropertyType valueToEnum(
        typename ::std::underlying_type<::nds::core::properties::CorePropertyType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT16_C(0):
    case UINT16_C(1):
    case UINT16_C(2):
    case UINT16_C(3):
    case UINT16_C(4):
    case UINT16_C(5):
    case UINT16_C(6):
    case UINT16_C(7):
    case UINT16_C(8):
    case UINT16_C(9):
    case UINT16_C(10):
        return static_cast<::nds::core::properties::CorePropertyType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration CorePropertyType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::core::properties::CorePropertyType>(::nds::core::properties::CorePropertyType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::core::properties::CorePropertyType value)
{
    context.init<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::core::properties::CorePropertyType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::core::properties::CorePropertyType value)
{
    return ::zserio::bitSizeOfVarUInt16(::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::core::properties::CorePropertyType value)
{
    return context.bitSizeOf<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::core::properties::CorePropertyType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::core::properties::CorePropertyType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::core::properties::CorePropertyType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::core::properties::CorePropertyType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::core::properties::CorePropertyType>(
            static_cast<typename ::std::underlying_type<::nds::core::properties::CorePropertyType>::type>(
                    in.readVarUInt16()));
}

template <>
::nds::core::properties::CorePropertyType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::core::properties::CorePropertyType>(context.read<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::core::properties::CorePropertyType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::core::properties::CorePropertyType value)
{
    out.writeVarUInt16(::zserio::enumToValue(value));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::core::properties::CorePropertyType value)
{
    context.write<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::core::properties::CorePropertyType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/core/properties/AttributeReasonPositionAvailability.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for AttributeReasonPositionAvailability enumeration.
constexpr ::std::array<const char*, 3> EnumTraits<::nds::core::properties::AttributeReasonPositionAvailability>::names;
constexpr ::std::array<::nds::core::properties::AttributeReasonPositionAvailability, 3> EnumTraits<::nds::core::properties::AttributeReasonPositionAvailability>::values;
constexpr const char* EnumTraits<::nds::core::properties::AttributeReasonPositionAvailability>::enumName;

template <>
size_t enumToOrdinal(::nds::core::properties::AttributeReasonPositionAvailability value)
{
    switch (value)
    {
    case ::nds::core::properties::AttributeReasonPositionAvailability::NONE:
        return 0;
    case ::nds::core::properties::AttributeReasonPositionAvailability::POSITION_2D:
        return 1;
    case ::nds::core::properties::AttributeReasonPositionAvailability::POSITION_3D:
        return 2;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration AttributeReasonPositionAvailability: ") <<
                static_cast<typename ::std::underlying_type<::nds::core::properties::AttributeReasonPositionAvailability>::type>(value) << "!";
    }
}

template <>
::nds::core::properties::AttributeReasonPositionAvailability valueToEnum(
        typename ::std::underlying_type<::nds::core::properties::AttributeReasonPositionAvailability>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
        return static_cast<::nds::core::properties::AttributeReasonPositionAvailability>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration AttributeReasonPositionAvailability: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::core::properties::AttributeReasonPositionAvailability>(::nds::core::properties::AttributeReasonPositionAvailability value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::core::properties::AttributeReasonPositionAvailability value)
{
    context.init<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::core::properties::AttributeReasonPositionAvailability>::type, UINT8_C(2)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::core::properties::AttributeReasonPositionAvailability)
{
    return UINT8_C(2);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::core::properties::AttributeReasonPositionAvailability value)
{
    return context.bitSizeOf<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::core::properties::AttributeReasonPositionAvailability>::type, UINT8_C(2)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::core::properties::AttributeReasonPositionAvailability value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::core::properties::AttributeReasonPositionAvailability value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::core::properties::AttributeReasonPositionAvailability read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::core::properties::AttributeReasonPositionAvailability>(
            static_cast<typename ::std::underlying_type<::nds::core::properties::AttributeReasonPositionAvailability>::type>(
                    in.readBits(UINT8_C(2))));
}

template <>
::nds::core::properties::AttributeReasonPositionAvailability read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::core::properties::AttributeReasonPositionAvailability>(context.read<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::core::properties::AttributeReasonPositionAvailability>::type, UINT8_C(2)>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::core::properties::AttributeReasonPositionAvailability value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(2));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::core::properties::AttributeReasonPositionAvailability value)
{
    context.write<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::core::properties::AttributeReasonPositionAvailability>::type, UINT8_C(2)>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/core/properties/AttributeSourceType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for AttributeSourceType enumeration.
constexpr ::std::array<const char*, 3> EnumTraits<::nds::core::properties::AttributeSourceType>::names;
constexpr ::std::array<::nds::core::properties::AttributeSourceType, 3> EnumTraits<::nds::core::properties::AttributeSourceType>::values;
constexpr const char* EnumTraits<::nds::core::properties::AttributeSourceType>::enumName;

template <>
size_t enumToOrdinal(::nds::core::properties::AttributeSourceType value)
{
    switch (value)
    {
    case ::nds::core::properties::AttributeSourceType::CAPTURED:
        return 0;
    case ::nds::core::properties::AttributeSourceType::FLEET_DATA:
        return 1;
    case ::nds::core::properties::AttributeSourceType::ARTIFICIAL:
        return 2;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration AttributeSourceType: ") <<
                static_cast<typename ::std::underlying_type<::nds::core::properties::AttributeSourceType>::type>(value) << "!";
    }
}

template <>
::nds::core::properties::AttributeSourceType valueToEnum(
        typename ::std::underlying_type<::nds::core::properties::AttributeSourceType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
        return static_cast<::nds::core::properties::AttributeSourceType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration AttributeSourceType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::core::properties::AttributeSourceType>(::nds::core::properties::AttributeSourceType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::core::properties::AttributeSourceType value)
{
    context.init<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::core::properties::AttributeSourceType>::type, UINT8_C(4)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::core::properties::AttributeSourceType)
{
    return UINT8_C(4);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::core::properties::AttributeSourceType value)
{
    return context.bitSizeOf<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::core::properties::AttributeSourceType>::type, UINT8_C(4)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::core::properties::AttributeSourceType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::core::properties::AttributeSourceType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::core::properties::AttributeSourceType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::core::properties::AttributeSourceType>(
            static_cast<typename ::std::underlying_type<::nds::core::properties::AttributeSourceType>::type>(
                    in.readBits(UINT8_C(4))));
}

template <>
::nds::core::properties::AttributeSourceType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::core::properties::AttributeSourceType>(context.read<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::core::properties::AttributeSourceType>::type, UINT8_C(4)>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::core::properties::AttributeSourceType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(4));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::core::properties::AttributeSourceType value)
{
    context.write<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::core::properties::AttributeSourceType>::type, UINT8_C(4)>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/core/properties/AttributeReasonType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for AttributeReasonType enumeration.
constexpr ::std::array<const char*, 3> EnumTraits<::nds::core::properties::AttributeReasonType>::names;
constexpr ::std::array<::nds::core::properties::AttributeReasonType, 3> EnumTraits<::nds::core::properties::AttributeReasonType>::values;
constexpr const char* EnumTraits<::nds::core::properties::AttributeReasonType>::enumName;

template <>
size_t enumToOrdinal(::nds::core::properties::AttributeReasonType value)
{
    switch (value)
    {
    case ::nds::core::properties::AttributeReasonType::DYNAMICALLY_CONTROLLED:
        return 0;
    case ::nds::core::properties::AttributeReasonType::POSTED:
        return 1;
    case ::nds::core::properties::AttributeReasonType::COUNTRY_DRIVING_RULES:
        return 2;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration AttributeReasonType: ") <<
                static_cast<typename ::std::underlying_type<::nds::core::properties::AttributeReasonType>::type>(value) << "!";
    }
}

template <>
::nds::core::properties::AttributeReasonType valueToEnum(
        typename ::std::underlying_type<::nds::core::properties::AttributeReasonType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
        return static_cast<::nds::core::properties::AttributeReasonType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration AttributeReasonType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::core::properties::AttributeReasonType>(::nds::core::properties::AttributeReasonType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::core::properties::AttributeReasonType value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::core::properties::AttributeReasonType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::core::properties::AttributeReasonType)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::core::properties::AttributeReasonType value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::core::properties::AttributeReasonType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::core::properties::AttributeReasonType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::core::properties::AttributeReasonType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::core::properties::AttributeReasonType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::core::properties::AttributeReasonType>(
            static_cast<typename ::std::underlying_type<::nds::core::properties::AttributeReasonType>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::core::properties::AttributeReasonType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::core::properties::AttributeReasonType>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::core::properties::AttributeReasonType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::core::properties::AttributeReasonType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::core::properties::AttributeReasonType value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::core::properties::AttributeReasonType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/core/properties/TollPaymentMethodType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for TollPaymentMethodType enumeration.
constexpr ::std::array<const char*, 13> EnumTraits<::nds::core::properties::TollPaymentMethodType>::names;
constexpr ::std::array<::nds::core::properties::TollPaymentMethodType, 13> EnumTraits<::nds::core::properties::TollPaymentMethodType>::values;
constexpr const char* EnumTraits<::nds::core::properties::TollPaymentMethodType>::enumName;

template <>
size_t enumToOrdinal(::nds::core::properties::TollPaymentMethodType value)
{
    switch (value)
    {
    case ::nds::core::properties::TollPaymentMethodType::VARIABLE:
        return 0;
    case ::nds::core::properties::TollPaymentMethodType::CASH_COINS_AND_BILLS:
        return 1;
    case ::nds::core::properties::TollPaymentMethodType::CASH_BILLS_ONLY:
        return 2;
    case ::nds::core::properties::TollPaymentMethodType::CASH_COINS_ONLY:
        return 3;
    case ::nds::core::properties::TollPaymentMethodType::CASH_EXACT_CHANGE:
        return 4;
    case ::nds::core::properties::TollPaymentMethodType::CREDIT_CARD:
        return 5;
    case ::nds::core::properties::TollPaymentMethodType::DEBIT_CARD:
        return 6;
    case ::nds::core::properties::TollPaymentMethodType::TRAVEL_CARD:
        return 7;
    case ::nds::core::properties::TollPaymentMethodType::ETC:
        return 8;
    case ::nds::core::properties::TollPaymentMethodType::ETC_TRANSPONDER:
        return 9;
    case ::nds::core::properties::TollPaymentMethodType::ETC_VIDEO_CAMERA:
        return 10;
    case ::nds::core::properties::TollPaymentMethodType::SUBSCRIPTION:
        return 11;
    case ::nds::core::properties::TollPaymentMethodType::VIGNETTE:
        return 12;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration TollPaymentMethodType: ") <<
                static_cast<typename ::std::underlying_type<::nds::core::properties::TollPaymentMethodType>::type>(value) << "!";
    }
}

template <>
::nds::core::properties::TollPaymentMethodType valueToEnum(
        typename ::std::underlying_type<::nds::core::properties::TollPaymentMethodType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT16_C(0):
    case UINT16_C(1):
    case UINT16_C(2):
    case UINT16_C(3):
    case UINT16_C(4):
    case UINT16_C(5):
    case UINT16_C(6):
    case UINT16_C(7):
    case UINT16_C(8):
    case UINT16_C(9):
    case UINT16_C(10):
    case UINT16_C(11):
    case UINT16_C(12):
        return static_cast<::nds::core::properties::TollPaymentMethodType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration TollPaymentMethodType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::core::properties::TollPaymentMethodType>(::nds::core::properties::TollPaymentMethodType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::core::properties::TollPaymentMethodType value)
{
    context.init<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::core::properties::TollPaymentMethodType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::core::properties::TollPaymentMethodType value)
{
    return ::zserio::bitSizeOfVarUInt16(::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::core::properties::TollPaymentMethodType value)
{
    return context.bitSizeOf<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::core::properties::TollPaymentMethodType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::core::properties::TollPaymentMethodType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::core::properties::TollPaymentMethodType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::core::properties::TollPaymentMethodType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::core::properties::TollPaymentMethodType>(
            static_cast<typename ::std::underlying_type<::nds::core::properties::TollPaymentMethodType>::type>(
                    in.readVarUInt16()));
}

template <>
::nds::core::properties::TollPaymentMethodType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::core::properties::TollPaymentMethodType>(context.read<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::core::properties::TollPaymentMethodType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::core::properties::TollPaymentMethodType value)
{
    out.writeVarUInt16(::zserio::enumToValue(value));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::core::properties::TollPaymentMethodType value)
{
    context.write<::zserio::VarIntNNArrayTraits<typename ::std::underlying_type<::nds::core::properties::TollPaymentMethodType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ArrayTraits.h>

#include <nds/core/properties/AttributeReason.h>
#include <nds/core/properties/AttributeReasonPositionAvailability.h>

namespace nds
{
namespace core
{
namespace properties
{

AttributeReason::AttributeReason(const allocator_type&) noexcept :
        m_areChildrenInitialized(false),
        m_type_(::nds::core::properties::AttributeReasonType()),
        m_hasPosition_(::nds::core::properties::AttributeReasonPositionAvailability()),
        m_position2D_(::zserio::NullOpt),
        m_position3D_(::zserio::NullOpt)
{
}

AttributeReason::AttributeReason(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_type_(readType(in)),
        m_hasPosition_(readHasPosition(in)),
        m_position2D_(readPosition2D(in, allocator)),
        m_position3D_(readPosition3D(in, allocator))
{
}

AttributeReason::AttributeReason(AttributeReason::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_type_(readType(context, in)),
        m_hasPosition_(readHasPosition(context, in)),
        m_position2D_(readPosition2D(context, in, allocator)),
        m_position3D_(readPosition3D(context, in, allocator))
{
}

AttributeReason::AttributeReason(const AttributeReason& other) :
        m_type_(other.m_type_),
        m_hasPosition_(other.m_hasPosition_),
        m_position2D_(other.m_position2D_),
        m_position3D_(other.m_position3D_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

AttributeReason& AttributeReason::operator=(const AttributeReason& other)
{
    m_type_ = other.m_type_;
    m_hasPosition_ = other.m_hasPosition_;
    m_position2D_ = other.m_position2D_;
    m_position3D_ = other.m_position3D_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

AttributeReason::AttributeReason(AttributeReason&& other) :
        m_type_(::std::move(other.m_type_)),
        m_hasPosition_(::std::move(other.m_hasPosition_)),
        m_position2D_(::std::move(other.m_position2D_)),
        m_position3D_(::std::move(other.m_position3D_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

AttributeReason& AttributeReason::operator=(AttributeReason&& other)
{
    m_type_ = ::std::move(other.m_type_);
    m_hasPosition_ = ::std::move(other.m_hasPosition_);
    m_position2D_ = ::std::move(other.m_position2D_);
    m_position3D_ = ::std::move(other.m_position3D_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

AttributeReason::AttributeReason(::zserio::PropagateAllocatorT,
        const AttributeReason& other, const allocator_type& allocator) :
        m_type_(::zserio::allocatorPropagatingCopy(other.m_type_, allocator)),
        m_hasPosition_(::zserio::allocatorPropagatingCopy(other.m_hasPosition_, allocator)),
        m_position2D_(::zserio::allocatorPropagatingCopy(other.m_position2D_, allocator)),
        m_position3D_(::zserio::allocatorPropagatingCopy(other.m_position3D_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void AttributeReason::initializeChildren()
{
    if (getHasPosition() == ::nds::core::properties::AttributeReasonPositionAvailability::POSITION_2D)
        m_position2D_.value().initialize(static_cast<::nds::core::geometry::CoordShift>(0));
    if (getHasPosition() == ::nds::core::properties::AttributeReasonPositionAvailability::POSITION_3D)
        m_position3D_.value().initialize(static_cast<::nds::core::geometry::CoordShift>(0), static_cast<::nds::core::geometry::CoordShift>(0));

    m_areChildrenInitialized = true;
}

::nds::core::properties::AttributeReasonType AttributeReason::getType() const
{
    return m_type_;
}

void AttributeReason::setType(::nds::core::properties::AttributeReasonType type_)
{
    m_type_ = type_;
}

::nds::core::properties::AttributeReasonPositionAvailability AttributeReason::getHasPosition() const
{
    return m_hasPosition_;
}

void AttributeReason::setHasPosition(::nds::core::properties::AttributeReasonPositionAvailability hasPosition_)
{
    m_hasPosition_ = hasPosition_;
}

::nds::core::geometry::Position2D& AttributeReason::getPosition2D()
{
    return m_position2D_.value();
}

const ::nds::core::geometry::Position2D& AttributeReason::getPosition2D() const
{
    return m_position2D_.value();
}

void AttributeReason::setPosition2D(const ::nds::core::geometry::Position2D& position2D_)
{
    m_position2D_ = position2D_;
}

void AttributeReason::setPosition2D(::nds::core::geometry::Position2D&& position2D_)
{
    m_position2D_ = ::std::move(position2D_);
}

bool AttributeReason::isPosition2DUsed() const
{
    return (getHasPosition() == ::nds::core::properties::AttributeReasonPositionAvailability::POSITION_2D);
}

bool AttributeReason::isPosition2DSet() const
{
    return m_position2D_.hasValue();
}

void AttributeReason::resetPosition2D()
{
    m_position2D_.reset();
}

::nds::core::geometry::Position3D& AttributeReason::getPosition3D()
{
    return m_position3D_.value();
}

const ::nds::core::geometry::Position3D& AttributeReason::getPosition3D() const
{
    return m_position3D_.value();
}

void AttributeReason::setPosition3D(const ::nds::core::geometry::Position3D& position3D_)
{
    m_position3D_ = position3D_;
}

void AttributeReason::setPosition3D(::nds::core::geometry::Position3D&& position3D_)
{
    m_position3D_ = ::std::move(position3D_);
}

bool AttributeReason::isPosition3DUsed() const
{
    return (getHasPosition() == ::nds::core::properties::AttributeReasonPositionAvailability::POSITION_3D);
}

bool AttributeReason::isPosition3DSet() const
{
    return m_position3D_.hasValue();
}

void AttributeReason::resetPosition3D()
{
    m_position3D_.reset();
}

void AttributeReason::initPackingContext(AttributeReason::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getType(), m_type_);
    ::zserio::initPackingContext(context.getHasPosition(), m_hasPosition_);
    if (getHasPosition() == ::nds::core::properties::AttributeReasonPositionAvailability::POSITION_2D)
    {
        m_position2D_.value().initPackingContext(context.getPosition2D());
    }
    if (getHasPosition() == ::nds::core::properties::AttributeReasonPositionAvailability::POSITION_3D)
    {
        m_position3D_.value().initPackingContext(context.getPosition3D());
    }
}

size_t AttributeReason::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_type_);
    endBitPosition += ::zserio::bitSizeOf(m_hasPosition_);
    if (getHasPosition() == ::nds::core::properties::AttributeReasonPositionAvailability::POSITION_2D)
    {
        endBitPosition += m_position2D_.value().bitSizeOf(endBitPosition);
    }
    if (getHasPosition() == ::nds::core::properties::AttributeReasonPositionAvailability::POSITION_3D)
    {
        endBitPosition += m_position3D_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t AttributeReason::bitSizeOf(AttributeReason::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getType(), m_type_);
    endBitPosition += ::zserio::bitSizeOf(context.getHasPosition(), m_hasPosition_);
    if (getHasPosition() == ::nds::core::properties::AttributeReasonPositionAvailability::POSITION_2D)
    {
        endBitPosition += m_position2D_.value().bitSizeOf(context.getPosition2D(), endBitPosition);
    }
    if (getHasPosition() == ::nds::core::properties::AttributeReasonPositionAvailability::POSITION_3D)
    {
        endBitPosition += m_position3D_.value().bitSizeOf(context.getPosition3D(), endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t AttributeReason::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_type_);
    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_hasPosition_);
    if (getHasPosition() == ::nds::core::properties::AttributeReasonPositionAvailability::POSITION_2D)
    {
        endBitPosition = m_position2D_.value().initializeOffsets(endBitPosition);
    }
    if (getHasPosition() == ::nds::core::properties::AttributeReasonPositionAvailability::POSITION_3D)
    {
        endBitPosition = m_position3D_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

size_t AttributeReason::initializeOffsets(AttributeReason::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getType(), endBitPosition,
        m_type_);
    endBitPosition = ::zserio::initializeOffsets(context.getHasPosition(), endBitPosition,
        m_hasPosition_);
    if (getHasPosition() == ::nds::core::properties::AttributeReasonPositionAvailability::POSITION_2D)
    {
        endBitPosition = m_position2D_.value().initializeOffsets(context.getPosition2D(), endBitPosition);
    }
    if (getHasPosition() == ::nds::core::properties::AttributeReasonPositionAvailability::POSITION_3D)
    {
        endBitPosition = m_position3D_.value().initializeOffsets(context.getPosition3D(), endBitPosition);
    }

    return endBitPosition;
}

bool AttributeReason::operator==(const AttributeReason& other) const
{
    if (this != &other)
    {
        return
                (m_type_ == other.m_type_) &&
                (m_hasPosition_ == other.m_hasPosition_) &&
                (!isPosition2DUsed() ? !other.isPosition2DUsed() : (m_position2D_ == other.m_position2D_)) &&
                (!isPosition3DUsed() ? !other.isPosition3DUsed() : (m_position3D_ == other.m_position3D_));
    }

    return true;
}

uint32_t AttributeReason::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_type_);
    result = ::zserio::calcHashCode(result, m_hasPosition_);
    if (isPosition2DUsed())
        result = ::zserio::calcHashCode(result, m_position2D_);
    if (isPosition3DUsed())
        result = ::zserio::calcHashCode(result, m_position3D_);

    return result;
}

void AttributeReason::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_type_);

    ::zserio::write(out, m_hasPosition_);

    if (getHasPosition() == ::nds::core::properties::AttributeReasonPositionAvailability::POSITION_2D)
    {
        // check parameters
        if (m_position2D_.value().getShift() != static_cast<::nds::core::geometry::CoordShift>(0))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field AttributeReason.position2D: ") <<
                    m_position2D_.value().getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(0) << "!";
        }
        m_position2D_.value().write(out);
    }

    if (getHasPosition() == ::nds::core::properties::AttributeReasonPositionAvailability::POSITION_3D)
    {
        // check parameters
        if (m_position3D_.value().getShiftXY() != static_cast<::nds::core::geometry::CoordShift>(0))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter shiftXY for field AttributeReason.position3D: ") <<
                    m_position3D_.value().getShiftXY() << " != " << static_cast<::nds::core::geometry::CoordShift>(0) << "!";
        }
        if (m_position3D_.value().getShiftZ() != static_cast<::nds::core::geometry::CoordShift>(0))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter shiftZ for field AttributeReason.position3D: ") <<
                    m_position3D_.value().getShiftZ() << " != " << static_cast<::nds::core::geometry::CoordShift>(0) << "!";
        }
        m_position3D_.value().write(out);
    }
}

void AttributeReason::write(AttributeReason::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getType(), out, m_type_);

    ::zserio::write(context.getHasPosition(), out, m_hasPosition_);

    if (getHasPosition() == ::nds::core::properties::AttributeReasonPositionAvailability::POSITION_2D)
    {
        // check parameters
        if (m_position2D_.value().getShift() != static_cast<::nds::core::geometry::CoordShift>(0))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field AttributeReason.position2D: ") <<
                    m_position2D_.value().getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(0) << "!";
        }
        m_position2D_.value().write(context.getPosition2D(), out);
    }

    if (getHasPosition() == ::nds::core::properties::AttributeReasonPositionAvailability::POSITION_3D)
    {
        // check parameters
        if (m_position3D_.value().getShiftXY() != static_cast<::nds::core::geometry::CoordShift>(0))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter shiftXY for field AttributeReason.position3D: ") <<
                    m_position3D_.value().getShiftXY() << " != " << static_cast<::nds::core::geometry::CoordShift>(0) << "!";
        }
        if (m_position3D_.value().getShiftZ() != static_cast<::nds::core::geometry::CoordShift>(0))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter shiftZ for field AttributeReason.position3D: ") <<
                    m_position3D_.value().getShiftZ() << " != " << static_cast<::nds::core::geometry::CoordShift>(0) << "!";
        }
        m_position3D_.value().write(context.getPosition3D(), out);
    }
}

::nds::core::properties::AttributeReasonType AttributeReason::readType(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::core::properties::AttributeReasonType>(in);
}

::nds::core::properties::AttributeReasonType AttributeReason::readType(AttributeReason::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::core::properties::AttributeReasonType>(context.getType(), in);
}
::nds::core::properties::AttributeReasonPositionAvailability AttributeReason::readHasPosition(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::core::properties::AttributeReasonPositionAvailability>(in);
}

::nds::core::properties::AttributeReasonPositionAvailability AttributeReason::readHasPosition(AttributeReason::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::core::properties::AttributeReasonPositionAvailability>(context.getHasPosition(), in);
}
::zserio::InplaceOptionalHolder<::nds::core::geometry::Position2D> AttributeReason::readPosition2D(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getHasPosition() == ::nds::core::properties::AttributeReasonPositionAvailability::POSITION_2D)
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::geometry::Position2D>(::nds::core::geometry::Position2D(in, static_cast<::nds::core::geometry::CoordShift>(0), allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::geometry::Position2D>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::geometry::Position2D> AttributeReason::readPosition2D(AttributeReason::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getHasPosition() == ::nds::core::properties::AttributeReasonPositionAvailability::POSITION_2D)
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::geometry::Position2D>(::nds::core::geometry::Position2D(context.getPosition2D(), in, static_cast<::nds::core::geometry::CoordShift>(0), allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::geometry::Position2D>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::core::geometry::Position3D> AttributeReason::readPosition3D(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getHasPosition() == ::nds::core::properties::AttributeReasonPositionAvailability::POSITION_3D)
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::geometry::Position3D>(::nds::core::geometry::Position3D(in, static_cast<::nds::core::geometry::CoordShift>(0), static_cast<::nds::core::geometry::CoordShift>(0), allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::geometry::Position3D>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::geometry::Position3D> AttributeReason::readPosition3D(AttributeReason::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getHasPosition() == ::nds::core::properties::AttributeReasonPositionAvailability::POSITION_3D)
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::geometry::Position3D>(::nds::core::geometry::Position3D(context.getPosition3D(), in, static_cast<::nds::core::geometry::CoordShift>(0), static_cast<::nds::core::geometry::CoordShift>(0), allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::geometry::Position3D>(::zserio::NullOpt);
}

} // namespace properties
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/core/properties/TollPaymentMethod.h>

namespace nds
{
namespace core
{
namespace properties
{

TollPaymentMethod::TollPaymentMethod(const allocator_type&) noexcept :
        m_type_(::nds::core::properties::TollPaymentMethodType()),
        m_provider_(::zserio::NullOpt)
{
}

TollPaymentMethod::TollPaymentMethod(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_type_(readType(in)),
        m_provider_(readProvider(in, allocator))
{
}

TollPaymentMethod::TollPaymentMethod(TollPaymentMethod::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_type_(readType(context, in)),
        m_provider_(readProvider(in, allocator))
{
}

TollPaymentMethod::TollPaymentMethod(::zserio::PropagateAllocatorT,
        const TollPaymentMethod& other, const allocator_type& allocator) :
        m_type_(::zserio::allocatorPropagatingCopy(other.m_type_, allocator)),
        m_provider_(::zserio::allocatorPropagatingCopy(other.m_provider_, allocator))
{
}

::nds::core::properties::TollPaymentMethodType TollPaymentMethod::getType() const
{
    return m_type_;
}

void TollPaymentMethod::setType(::nds::core::properties::TollPaymentMethodType type_)
{
    m_type_ = type_;
}

::zserio::vector<::nds::core::properties::TollCollectionProvider>& TollPaymentMethod::getProvider()
{
    return m_provider_.value().getRawArray();
}

const ::zserio::vector<::nds::core::properties::TollCollectionProvider>& TollPaymentMethod::getProvider() const
{
    return m_provider_.value().getRawArray();
}

void TollPaymentMethod::setProvider(const ::zserio::vector<::nds::core::properties::TollCollectionProvider>& provider_)
{
    m_provider_ = ZserioArrayType_provider(provider_);
}

void TollPaymentMethod::setProvider(::zserio::vector<::nds::core::properties::TollCollectionProvider>&& provider_)
{
    m_provider_ = ZserioArrayType_provider(std::move(provider_));
}

bool TollPaymentMethod::isProviderUsed() const
{
    return (isProviderSet());
}

bool TollPaymentMethod::isProviderSet() const
{
    return m_provider_.hasValue();
}

void TollPaymentMethod::resetProvider()
{
    m_provider_.reset();
}

void TollPaymentMethod::initPackingContext(TollPaymentMethod::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getType(), m_type_);
}

size_t TollPaymentMethod::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_type_);
    endBitPosition += 1;
    if (isProviderSet())
    {
        endBitPosition += m_provider_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t TollPaymentMethod::bitSizeOf(TollPaymentMethod::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getType(), m_type_);
    endBitPosition += 1;
    if (isProviderSet())
    {
        endBitPosition += m_provider_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t TollPaymentMethod::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_type_);
    endBitPosition += 1;
    if (isProviderSet())
    {
        endBitPosition = m_provider_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

size_t TollPaymentMethod::initializeOffsets(TollPaymentMethod::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getType(), endBitPosition,
        m_type_);
    endBitPosition += 1;
    if (isProviderSet())
    {
        endBitPosition = m_provider_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

bool TollPaymentMethod::operator==(const TollPaymentMethod& other) const
{
    if (this != &other)
    {
        return
                (m_type_ == other.m_type_) &&
                (!isProviderUsed() ? !other.isProviderUsed() : (m_provider_ == other.m_provider_));
    }

    return true;
}

uint32_t TollPaymentMethod::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_type_);
    if (isProviderUsed())
        result = ::zserio::calcHashCode(result, m_provider_);

    return result;
}

void TollPaymentMethod::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_type_);
    if (isProviderSet())
    {
        out.writeBool(true);
        m_provider_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
}

void TollPaymentMethod::write(TollPaymentMethod::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getType(), out, m_type_);
    if (isProviderSet())
    {
        out.writeBool(true);
        m_provider_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
}

::nds::core::properties::TollPaymentMethodType TollPaymentMethod::readType(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::core::properties::TollPaymentMethodType>(in);
}

::nds::core::properties::TollPaymentMethodType TollPaymentMethod::readType(TollPaymentMethod::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::core::properties::TollPaymentMethodType>(context.getType(), in);
}
::zserio::InplaceOptionalHolder<TollPaymentMethod::ZserioArrayType_provider> TollPaymentMethod::readProvider(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        ZserioArrayType_provider readField(allocator);
        readField.read(in);

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_provider>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_provider>(::zserio::NullOpt);
}

} // namespace properties
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ConstraintException.h>

#include <nds/core/properties/CorePropertyValue.h>

namespace nds
{
namespace core
{
namespace properties
{

CorePropertyValue::CorePropertyValue(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_objectChoice(allocator)
{
}

CorePropertyValue::CorePropertyValue(::zserio::BitStreamReader& in,
        ::nds::core::properties::CorePropertyType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(in, allocator), allocator)
{
}

CorePropertyValue::CorePropertyValue(CorePropertyValue::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::properties::CorePropertyType type_, const allocator_type& allocator) :
        m_type_(type_),
        m_isInitialized(true),
        m_objectChoice(readObject(context, in, allocator), allocator)
{
}

CorePropertyValue::CorePropertyValue(const CorePropertyValue& other) :
        m_objectChoice(other.m_objectChoice)
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

CorePropertyValue& CorePropertyValue::operator=(const CorePropertyValue& other)
{
    m_objectChoice = other.m_objectChoice;
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

CorePropertyValue::CorePropertyValue(CorePropertyValue&& other) :
        m_objectChoice(::std::move(other.m_objectChoice))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

CorePropertyValue& CorePropertyValue::operator=(CorePropertyValue&& other)
{
    m_objectChoice = ::std::move(other.m_objectChoice);
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

CorePropertyValue::CorePropertyValue(::zserio::PropagateAllocatorT,
        const CorePropertyValue& other, const allocator_type& allocator) :
        m_objectChoice(other.copyObject(allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_type_);
    else
        m_isInitialized = false;
}

void CorePropertyValue::initialize(
        ::nds::core::properties::CorePropertyType type_)
{
    m_type_ = type_;
    m_isInitialized = true;

    initializeChildren();
}

bool CorePropertyValue::isInitialized() const
{
    return m_isInitialized;
}

void CorePropertyValue::initializeChildren()
{
    switch (getType())
    {
    case ::nds::core::properties::CorePropertyType::ATTRIBUTE_REASON:
        m_objectChoice.get<::nds::core::properties::AttributeReason>().initializeChildren();
        break;
    case ::nds::core::properties::CorePropertyType::METRIC_UNIT:
        // empty
        break;
    case ::nds::core::properties::CorePropertyType::IMPERIAL_UNIT:
        // empty
        break;
    case ::nds::core::properties::CorePropertyType::ATTRIBUTE_CONFIDENCE:
        break;
    case ::nds::core::properties::CorePropertyType::ATTRIBUTE_AGE:
        break;
    case ::nds::core::properties::CorePropertyType::ATTRIBUTE_SOURCE:
        break;
    case ::nds::core::properties::CorePropertyType::ICON_SET_REFERENCE:
        break;
    case ::nds::core::properties::CorePropertyType::ICON_SET_REFERENCE_WITH_HEADING:
        break;
    case ::nds::core::properties::CorePropertyType::GLOBAL_ICON_SET_REFERENCE:
        break;
    case ::nds::core::properties::CorePropertyType::GLOBAL_ICON_SET_REFERENCE_WITH_HEADING:
        break;
    case ::nds::core::properties::CorePropertyType::TOLL_PAYMENT:
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice CorePropertyValue!");
    }
}

::nds::core::properties::CorePropertyType CorePropertyValue::getType() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'type' of compound 'CorePropertyValue' is not initialized!");

    return m_type_;
}

::nds::core::properties::AttributeReason& CorePropertyValue::getReason()
{
    return m_objectChoice.get<::nds::core::properties::AttributeReason>();
}

const ::nds::core::properties::AttributeReason& CorePropertyValue::getReason() const
{
    return m_objectChoice.get<::nds::core::properties::AttributeReason>();
}

void CorePropertyValue::setReason(const ::nds::core::properties::AttributeReason& reason_)
{
    m_objectChoice = reason_;
}

void CorePropertyValue::setReason(::nds::core::properties::AttributeReason&& reason_)
{
    m_objectChoice = ::std::move(reason_);
}

::nds::core::properties::AttributeConfidence CorePropertyValue::getConfidence() const
{
    return m_objectChoice.get<::nds::core::properties::AttributeConfidence>();
}

void CorePropertyValue::setConfidence(::nds::core::properties::AttributeConfidence confidence_)
{
    m_objectChoice = confidence_;
}

::nds::core::properties::AttributeAge& CorePropertyValue::getAge()
{
    return m_objectChoice.get<::nds::core::properties::AttributeAge>();
}

const ::nds::core::properties::AttributeAge& CorePropertyValue::getAge() const
{
    return m_objectChoice.get<::nds::core::properties::AttributeAge>();
}

void CorePropertyValue::setAge(const ::nds::core::properties::AttributeAge& age_)
{
    m_objectChoice = age_;
}

void CorePropertyValue::setAge(::nds::core::properties::AttributeAge&& age_)
{
    m_objectChoice = ::std::move(age_);
}

::nds::core::properties::AttributeSourceType CorePropertyValue::getSource() const
{
    return m_objectChoice.get<::nds::core::properties::AttributeSourceType>();
}

void CorePropertyValue::setSource(::nds::core::properties::AttributeSourceType source_)
{
    m_objectChoice = source_;
}

::nds::core::icons::IconSetReference CorePropertyValue::getIconSetReference() const
{
    return m_objectChoice.get<::nds::core::icons::IconSetReference>();
}

void CorePropertyValue::setIconSetReference(::nds::core::icons::IconSetReference iconSetReference_)
{
    m_objectChoice = iconSetReference_;
}

::nds::core::icons::IconSetReferenceWithHeading& CorePropertyValue::getIconSetReferenceWithHeading()
{
    return m_objectChoice.get<::nds::core::icons::IconSetReferenceWithHeading>();
}

const ::nds::core::icons::IconSetReferenceWithHeading& CorePropertyValue::getIconSetReferenceWithHeading() const
{
    return m_objectChoice.get<::nds::core::icons::IconSetReferenceWithHeading>();
}

void CorePropertyValue::setIconSetReferenceWithHeading(const ::nds::core::icons::IconSetReferenceWithHeading& iconSetReferenceWithHeading_)
{
    m_objectChoice = iconSetReferenceWithHeading_;
}

void CorePropertyValue::setIconSetReferenceWithHeading(::nds::core::icons::IconSetReferenceWithHeading&& iconSetReferenceWithHeading_)
{
    m_objectChoice = ::std::move(iconSetReferenceWithHeading_);
}

::nds::core::icons::IconSetReference CorePropertyValue::getGlobalIconSetReference() const
{
    return m_objectChoice.get<::nds::core::icons::IconSetReference>();
}

void CorePropertyValue::setGlobalIconSetReference(::nds::core::icons::IconSetReference globalIconSetReference_)
{
    m_objectChoice = globalIconSetReference_;
}

::nds::core::icons::IconSetReferenceWithHeading& CorePropertyValue::getGlobalIconSetReferenceWithHeading()
{
    return m_objectChoice.get<::nds::core::icons::IconSetReferenceWithHeading>();
}

const ::nds::core::icons::IconSetReferenceWithHeading& CorePropertyValue::getGlobalIconSetReferenceWithHeading() const
{
    return m_objectChoice.get<::nds::core::icons::IconSetReferenceWithHeading>();
}

void CorePropertyValue::setGlobalIconSetReferenceWithHeading(const ::nds::core::icons::IconSetReferenceWithHeading& globalIconSetReferenceWithHeading_)
{
    m_objectChoice = globalIconSetReferenceWithHeading_;
}

void CorePropertyValue::setGlobalIconSetReferenceWithHeading(::nds::core::icons::IconSetReferenceWithHeading&& globalIconSetReferenceWithHeading_)
{
    m_objectChoice = ::std::move(globalIconSetReferenceWithHeading_);
}

::zserio::vector<::nds::core::properties::TollPaymentMethod>& CorePropertyValue::getTollPaymentMethod()
{
    return m_objectChoice.get<ZserioArrayType_tollPaymentMethod>().getRawArray();
}

const ::zserio::vector<::nds::core::properties::TollPaymentMethod>& CorePropertyValue::getTollPaymentMethod() const
{
    return m_objectChoice.get<ZserioArrayType_tollPaymentMethod>().getRawArray();
}

void CorePropertyValue::setTollPaymentMethod(const ::zserio::vector<::nds::core::properties::TollPaymentMethod>& tollPaymentMethod_)
{
    m_objectChoice = ZserioArrayType_tollPaymentMethod(tollPaymentMethod_);
}

void CorePropertyValue::setTollPaymentMethod(::zserio::vector<::nds::core::properties::TollPaymentMethod>&& tollPaymentMethod_)
{
    m_objectChoice = ZserioArrayType_tollPaymentMethod(std::move(tollPaymentMethod_));
}

CorePropertyValue::ChoiceTag CorePropertyValue::choiceTag() const
{
    switch (getType())
    {
    case ::nds::core::properties::CorePropertyType::ATTRIBUTE_REASON:
        return CHOICE_reason;
    case ::nds::core::properties::CorePropertyType::METRIC_UNIT:
        return UNDEFINED_CHOICE;
    case ::nds::core::properties::CorePropertyType::IMPERIAL_UNIT:
        return UNDEFINED_CHOICE;
    case ::nds::core::properties::CorePropertyType::ATTRIBUTE_CONFIDENCE:
        return CHOICE_confidence;
    case ::nds::core::properties::CorePropertyType::ATTRIBUTE_AGE:
        return CHOICE_age;
    case ::nds::core::properties::CorePropertyType::ATTRIBUTE_SOURCE:
        return CHOICE_source;
    case ::nds::core::properties::CorePropertyType::ICON_SET_REFERENCE:
        return CHOICE_iconSetReference;
    case ::nds::core::properties::CorePropertyType::ICON_SET_REFERENCE_WITH_HEADING:
        return CHOICE_iconSetReferenceWithHeading;
    case ::nds::core::properties::CorePropertyType::GLOBAL_ICON_SET_REFERENCE:
        return CHOICE_globalIconSetReference;
    case ::nds::core::properties::CorePropertyType::GLOBAL_ICON_SET_REFERENCE_WITH_HEADING:
        return CHOICE_globalIconSetReferenceWithHeading;
    case ::nds::core::properties::CorePropertyType::TOLL_PAYMENT:
        return CHOICE_tollPaymentMethod;
    default:
        return UNDEFINED_CHOICE;
    }
}

void CorePropertyValue::initPackingContext(CorePropertyValue::ZserioPackingContext& context) const
{
    switch (getType())
    {
    case ::nds::core::properties::CorePropertyType::ATTRIBUTE_REASON:
        m_objectChoice.get<::nds::core::properties::AttributeReason>().initPackingContext(context.getReason());
        break;
    case ::nds::core::properties::CorePropertyType::METRIC_UNIT:
        // empty
        break;
    case ::nds::core::properties::CorePropertyType::IMPERIAL_UNIT:
        // empty
        break;
    case ::nds::core::properties::CorePropertyType::ATTRIBUTE_CONFIDENCE:
        context.getConfidence().init<::zserio::StdIntArrayTraits<::nds::core::properties::AttributeConfidence>>(m_objectChoice.get<::nds::core::properties::AttributeConfidence>());
        break;
    case ::nds::core::properties::CorePropertyType::ATTRIBUTE_AGE:
        m_objectChoice.get<::nds::core::properties::AttributeAge>().initPackingContext(context.getAge());
        break;
    case ::nds::core::properties::CorePropertyType::ATTRIBUTE_SOURCE:
        ::zserio::initPackingContext(context.getSource(), m_objectChoice.get<::nds::core::properties::AttributeSourceType>());
        break;
    case ::nds::core::properties::CorePropertyType::ICON_SET_REFERENCE:
        context.getIconSetReference().init<::zserio::VarIntArrayTraits<::nds::core::icons::IconSetReference>>(m_objectChoice.get<::nds::core::icons::IconSetReference>());
        break;
    case ::nds::core::properties::CorePropertyType::ICON_SET_REFERENCE_WITH_HEADING:
        m_objectChoice.get<::nds::core::icons::IconSetReferenceWithHeading>().initPackingContext(context.getIconSetReferenceWithHeading());
        break;
    case ::nds::core::properties::CorePropertyType::GLOBAL_ICON_SET_REFERENCE:
        context.getGlobalIconSetReference().init<::zserio::VarIntArrayTraits<::nds::core::icons::IconSetReference>>(m_objectChoice.get<::nds::core::icons::IconSetReference>());
        break;
    case ::nds::core::properties::CorePropertyType::GLOBAL_ICON_SET_REFERENCE_WITH_HEADING:
        m_objectChoice.get<::nds::core::icons::IconSetReferenceWithHeading>().initPackingContext(context.getGlobalIconSetReferenceWithHeading());
        break;
    case ::nds::core::properties::CorePropertyType::TOLL_PAYMENT:
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice CorePropertyValue!");
    }
}

size_t CorePropertyValue::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::core::properties::CorePropertyType::ATTRIBUTE_REASON:
        endBitPosition += m_objectChoice.get<::nds::core::properties::AttributeReason>().bitSizeOf(endBitPosition);
        break;
    case ::nds::core::properties::CorePropertyType::METRIC_UNIT:
        // empty
        break;
    case ::nds::core::properties::CorePropertyType::IMPERIAL_UNIT:
        // empty
        break;
    case ::nds::core::properties::CorePropertyType::ATTRIBUTE_CONFIDENCE:
        endBitPosition += UINT8_C(8);
        break;
    case ::nds::core::properties::CorePropertyType::ATTRIBUTE_AGE:
        endBitPosition += m_objectChoice.get<::nds::core::properties::AttributeAge>().bitSizeOf(endBitPosition);
        break;
    case ::nds::core::properties::CorePropertyType::ATTRIBUTE_SOURCE:
        endBitPosition += ::zserio::bitSizeOf(m_objectChoice.get<::nds::core::properties::AttributeSourceType>());
        break;
    case ::nds::core::properties::CorePropertyType::ICON_SET_REFERENCE:
        endBitPosition += ::zserio::bitSizeOfVarUInt(m_objectChoice.get<::nds::core::icons::IconSetReference>());
        break;
    case ::nds::core::properties::CorePropertyType::ICON_SET_REFERENCE_WITH_HEADING:
        endBitPosition += m_objectChoice.get<::nds::core::icons::IconSetReferenceWithHeading>().bitSizeOf(endBitPosition);
        break;
    case ::nds::core::properties::CorePropertyType::GLOBAL_ICON_SET_REFERENCE:
        endBitPosition += ::zserio::bitSizeOfVarUInt(m_objectChoice.get<::nds::core::icons::IconSetReference>());
        break;
    case ::nds::core::properties::CorePropertyType::GLOBAL_ICON_SET_REFERENCE_WITH_HEADING:
        endBitPosition += m_objectChoice.get<::nds::core::icons::IconSetReferenceWithHeading>().bitSizeOf(endBitPosition);
        break;
    case ::nds::core::properties::CorePropertyType::TOLL_PAYMENT:
        endBitPosition += m_objectChoice.get<ZserioArrayType_tollPaymentMethod>().bitSizeOf(*this, endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice CorePropertyValue!");
    }

    return endBitPosition - bitPosition;
}

size_t CorePropertyValue::bitSizeOf(CorePropertyValue::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::core::properties::CorePropertyType::ATTRIBUTE_REASON:
        endBitPosition += m_objectChoice.get<::nds::core::properties::AttributeReason>().bitSizeOf(context.getReason(), endBitPosition);
        break;
    case ::nds::core::properties::CorePropertyType::METRIC_UNIT:
        // empty
        break;
    case ::nds::core::properties::CorePropertyType::IMPERIAL_UNIT:
        // empty
        break;
    case ::nds::core::properties::CorePropertyType::ATTRIBUTE_CONFIDENCE:
        endBitPosition += context.getConfidence().bitSizeOf<::zserio::StdIntArrayTraits<::nds::core::properties::AttributeConfidence>>(m_objectChoice.get<::nds::core::properties::AttributeConfidence>());
        break;
    case ::nds::core::properties::CorePropertyType::ATTRIBUTE_AGE:
        endBitPosition += m_objectChoice.get<::nds::core::properties::AttributeAge>().bitSizeOf(context.getAge(), endBitPosition);
        break;
    case ::nds::core::properties::CorePropertyType::ATTRIBUTE_SOURCE:
        endBitPosition += ::zserio::bitSizeOf(context.getSource(), m_objectChoice.get<::nds::core::properties::AttributeSourceType>());
        break;
    case ::nds::core::properties::CorePropertyType::ICON_SET_REFERENCE:
        endBitPosition += context.getIconSetReference().bitSizeOf<::zserio::VarIntArrayTraits<::nds::core::icons::IconSetReference>>(m_objectChoice.get<::nds::core::icons::IconSetReference>());
        break;
    case ::nds::core::properties::CorePropertyType::ICON_SET_REFERENCE_WITH_HEADING:
        endBitPosition += m_objectChoice.get<::nds::core::icons::IconSetReferenceWithHeading>().bitSizeOf(context.getIconSetReferenceWithHeading(), endBitPosition);
        break;
    case ::nds::core::properties::CorePropertyType::GLOBAL_ICON_SET_REFERENCE:
        endBitPosition += context.getGlobalIconSetReference().bitSizeOf<::zserio::VarIntArrayTraits<::nds::core::icons::IconSetReference>>(m_objectChoice.get<::nds::core::icons::IconSetReference>());
        break;
    case ::nds::core::properties::CorePropertyType::GLOBAL_ICON_SET_REFERENCE_WITH_HEADING:
        endBitPosition += m_objectChoice.get<::nds::core::icons::IconSetReferenceWithHeading>().bitSizeOf(context.getGlobalIconSetReferenceWithHeading(), endBitPosition);
        break;
    case ::nds::core::properties::CorePropertyType::TOLL_PAYMENT:
        endBitPosition += m_objectChoice.get<ZserioArrayType_tollPaymentMethod>().bitSizeOfPacked(*this, endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice CorePropertyValue!");
    }

    return endBitPosition - bitPosition;
}

size_t CorePropertyValue::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::core::properties::CorePropertyType::ATTRIBUTE_REASON:
        endBitPosition = m_objectChoice.get<::nds::core::properties::AttributeReason>().initializeOffsets(endBitPosition);
        break;
    case ::nds::core::properties::CorePropertyType::METRIC_UNIT:
        // empty
        break;
    case ::nds::core::properties::CorePropertyType::IMPERIAL_UNIT:
        // empty
        break;
    case ::nds::core::properties::CorePropertyType::ATTRIBUTE_CONFIDENCE:
        endBitPosition += UINT8_C(8);
        break;
    case ::nds::core::properties::CorePropertyType::ATTRIBUTE_AGE:
        endBitPosition = m_objectChoice.get<::nds::core::properties::AttributeAge>().initializeOffsets(endBitPosition);
        break;
    case ::nds::core::properties::CorePropertyType::ATTRIBUTE_SOURCE:
        endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_objectChoice.get<::nds::core::properties::AttributeSourceType>());
        break;
    case ::nds::core::properties::CorePropertyType::ICON_SET_REFERENCE:
        endBitPosition += ::zserio::bitSizeOfVarUInt(m_objectChoice.get<::nds::core::icons::IconSetReference>());
        break;
    case ::nds::core::properties::CorePropertyType::ICON_SET_REFERENCE_WITH_HEADING:
        endBitPosition = m_objectChoice.get<::nds::core::icons::IconSetReferenceWithHeading>().initializeOffsets(endBitPosition);
        break;
    case ::nds::core::properties::CorePropertyType::GLOBAL_ICON_SET_REFERENCE:
        endBitPosition += ::zserio::bitSizeOfVarUInt(m_objectChoice.get<::nds::core::icons::IconSetReference>());
        break;
    case ::nds::core::properties::CorePropertyType::GLOBAL_ICON_SET_REFERENCE_WITH_HEADING:
        endBitPosition = m_objectChoice.get<::nds::core::icons::IconSetReferenceWithHeading>().initializeOffsets(endBitPosition);
        break;
    case ::nds::core::properties::CorePropertyType::TOLL_PAYMENT:
        endBitPosition = m_objectChoice.get<ZserioArrayType_tollPaymentMethod>().initializeOffsets(*this, endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice CorePropertyValue!");
    }

    return endBitPosition;
}

size_t CorePropertyValue::initializeOffsets(CorePropertyValue::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::core::properties::CorePropertyType::ATTRIBUTE_REASON:
        endBitPosition = m_objectChoice.get<::nds::core::properties::AttributeReason>().initializeOffsets(context.getReason(), endBitPosition);
        break;
    case ::nds::core::properties::CorePropertyType::METRIC_UNIT:
        // empty
        break;
    case ::nds::core::properties::CorePropertyType::IMPERIAL_UNIT:
        // empty
        break;
    case ::nds::core::properties::CorePropertyType::ATTRIBUTE_CONFIDENCE:
        endBitPosition += context.getConfidence().bitSizeOf<::zserio::StdIntArrayTraits<::nds::core::properties::AttributeConfidence>>(m_objectChoice.get<::nds::core::properties::AttributeConfidence>());
        break;
    case ::nds::core::properties::CorePropertyType::ATTRIBUTE_AGE:
        endBitPosition = m_objectChoice.get<::nds::core::properties::AttributeAge>().initializeOffsets(context.getAge(), endBitPosition);
        break;
    case ::nds::core::properties::CorePropertyType::ATTRIBUTE_SOURCE:
        endBitPosition = ::zserio::initializeOffsets(context.getSource(), endBitPosition,
        m_objectChoice.get<::nds::core::properties::AttributeSourceType>());
        break;
    case ::nds::core::properties::CorePropertyType::ICON_SET_REFERENCE:
        endBitPosition += context.getIconSetReference().bitSizeOf<::zserio::VarIntArrayTraits<::nds::core::icons::IconSetReference>>(m_objectChoice.get<::nds::core::icons::IconSetReference>());
        break;
    case ::nds::core::properties::CorePropertyType::ICON_SET_REFERENCE_WITH_HEADING:
        endBitPosition = m_objectChoice.get<::nds::core::icons::IconSetReferenceWithHeading>().initializeOffsets(context.getIconSetReferenceWithHeading(), endBitPosition);
        break;
    case ::nds::core::properties::CorePropertyType::GLOBAL_ICON_SET_REFERENCE:
        endBitPosition += context.getGlobalIconSetReference().bitSizeOf<::zserio::VarIntArrayTraits<::nds::core::icons::IconSetReference>>(m_objectChoice.get<::nds::core::icons::IconSetReference>());
        break;
    case ::nds::core::properties::CorePropertyType::GLOBAL_ICON_SET_REFERENCE_WITH_HEADING:
        endBitPosition = m_objectChoice.get<::nds::core::icons::IconSetReferenceWithHeading>().initializeOffsets(context.getGlobalIconSetReferenceWithHeading(), endBitPosition);
        break;
    case ::nds::core::properties::CorePropertyType::TOLL_PAYMENT:
        endBitPosition = m_objectChoice.get<ZserioArrayType_tollPaymentMethod>().initializeOffsetsPacked(*this, endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice CorePropertyValue!");
    }

    return endBitPosition;
}

bool CorePropertyValue::operator==(const CorePropertyValue& other) const
{
    if (this == &other)
        return true;

    if (!(getType() == other.getType()))
        return false;

    switch (getType())
    {
    case ::nds::core::properties::CorePropertyType::ATTRIBUTE_REASON:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::core::properties::AttributeReason>() == other.m_objectChoice.get<::nds::core::properties::AttributeReason>());
    case ::nds::core::properties::CorePropertyType::METRIC_UNIT:
        return true; // empty
    case ::nds::core::properties::CorePropertyType::IMPERIAL_UNIT:
        return true; // empty
    case ::nds::core::properties::CorePropertyType::ATTRIBUTE_CONFIDENCE:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::core::properties::AttributeConfidence>() == other.m_objectChoice.get<::nds::core::properties::AttributeConfidence>());
    case ::nds::core::properties::CorePropertyType::ATTRIBUTE_AGE:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::core::properties::AttributeAge>() == other.m_objectChoice.get<::nds::core::properties::AttributeAge>());
    case ::nds::core::properties::CorePropertyType::ATTRIBUTE_SOURCE:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::core::properties::AttributeSourceType>() == other.m_objectChoice.get<::nds::core::properties::AttributeSourceType>());
    case ::nds::core::properties::CorePropertyType::ICON_SET_REFERENCE:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::core::icons::IconSetReference>() == other.m_objectChoice.get<::nds::core::icons::IconSetReference>());
    case ::nds::core::properties::CorePropertyType::ICON_SET_REFERENCE_WITH_HEADING:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::core::icons::IconSetReferenceWithHeading>() == other.m_objectChoice.get<::nds::core::icons::IconSetReferenceWithHeading>());
    case ::nds::core::properties::CorePropertyType::GLOBAL_ICON_SET_REFERENCE:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::core::icons::IconSetReference>() == other.m_objectChoice.get<::nds::core::icons::IconSetReference>());
    case ::nds::core::properties::CorePropertyType::GLOBAL_ICON_SET_REFERENCE_WITH_HEADING:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::core::icons::IconSetReferenceWithHeading>() == other.m_objectChoice.get<::nds::core::icons::IconSetReferenceWithHeading>());
    case ::nds::core::properties::CorePropertyType::TOLL_PAYMENT:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<ZserioArrayType_tollPaymentMethod>() == other.m_objectChoice.get<ZserioArrayType_tollPaymentMethod>());
    default:
        throw ::zserio::CppRuntimeException("No match in choice CorePropertyValue!");
    }
}

uint32_t CorePropertyValue::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getType());
    if (m_objectChoice.hasValue())
    {
        switch (getType())
        {
        case ::nds::core::properties::CorePropertyType::ATTRIBUTE_REASON:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::core::properties::AttributeReason>());
            break;
        case ::nds::core::properties::CorePropertyType::METRIC_UNIT:
            // empty
            break;
        case ::nds::core::properties::CorePropertyType::IMPERIAL_UNIT:
            // empty
            break;
        case ::nds::core::properties::CorePropertyType::ATTRIBUTE_CONFIDENCE:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::core::properties::AttributeConfidence>());
            break;
        case ::nds::core::properties::CorePropertyType::ATTRIBUTE_AGE:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::core::properties::AttributeAge>());
            break;
        case ::nds::core::properties::CorePropertyType::ATTRIBUTE_SOURCE:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::core::properties::AttributeSourceType>());
            break;
        case ::nds::core::properties::CorePropertyType::ICON_SET_REFERENCE:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::core::icons::IconSetReference>());
            break;
        case ::nds::core::properties::CorePropertyType::ICON_SET_REFERENCE_WITH_HEADING:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::core::icons::IconSetReferenceWithHeading>());
            break;
        case ::nds::core::properties::CorePropertyType::GLOBAL_ICON_SET_REFERENCE:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::core::icons::IconSetReference>());
            break;
        case ::nds::core::properties::CorePropertyType::GLOBAL_ICON_SET_REFERENCE_WITH_HEADING:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::core::icons::IconSetReferenceWithHeading>());
            break;
        case ::nds::core::properties::CorePropertyType::TOLL_PAYMENT:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<ZserioArrayType_tollPaymentMethod>());
            break;
        default:
            break;
        }
    }

    return result;
}

void CorePropertyValue::write(::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::core::properties::CorePropertyType::ATTRIBUTE_REASON:
        m_objectChoice.get<::nds::core::properties::AttributeReason>().write(out);
        break;
    case ::nds::core::properties::CorePropertyType::METRIC_UNIT:
        // empty
        break;
    case ::nds::core::properties::CorePropertyType::IMPERIAL_UNIT:
        // empty
        break;
    case ::nds::core::properties::CorePropertyType::ATTRIBUTE_CONFIDENCE:
        // check constraint
        if (!(getConfidence() <= 100))
            throw ::zserio::ConstraintException("Write: Constraint violated at CorePropertyValue.confidence!");
        out.writeBits(m_objectChoice.get<::nds::core::properties::AttributeConfidence>(), UINT8_C(8));
        break;
    case ::nds::core::properties::CorePropertyType::ATTRIBUTE_AGE:
        m_objectChoice.get<::nds::core::properties::AttributeAge>().write(out);
        break;
    case ::nds::core::properties::CorePropertyType::ATTRIBUTE_SOURCE:
        ::zserio::write(out, m_objectChoice.get<::nds::core::properties::AttributeSourceType>());
        break;
    case ::nds::core::properties::CorePropertyType::ICON_SET_REFERENCE:
        out.writeVarUInt(m_objectChoice.get<::nds::core::icons::IconSetReference>());
        break;
    case ::nds::core::properties::CorePropertyType::ICON_SET_REFERENCE_WITH_HEADING:
        m_objectChoice.get<::nds::core::icons::IconSetReferenceWithHeading>().write(out);
        break;
    case ::nds::core::properties::CorePropertyType::GLOBAL_ICON_SET_REFERENCE:
        out.writeVarUInt(m_objectChoice.get<::nds::core::icons::IconSetReference>());
        break;
    case ::nds::core::properties::CorePropertyType::GLOBAL_ICON_SET_REFERENCE_WITH_HEADING:
        m_objectChoice.get<::nds::core::icons::IconSetReferenceWithHeading>().write(out);
        break;
    case ::nds::core::properties::CorePropertyType::TOLL_PAYMENT:
        m_objectChoice.get<ZserioArrayType_tollPaymentMethod>().write(*this, out);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice CorePropertyValue!");
    }
}

void CorePropertyValue::write(CorePropertyValue::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::core::properties::CorePropertyType::ATTRIBUTE_REASON:
        m_objectChoice.get<::nds::core::properties::AttributeReason>().write(context.getReason(), out);
        break;
    case ::nds::core::properties::CorePropertyType::METRIC_UNIT:
        // empty
        break;
    case ::nds::core::properties::CorePropertyType::IMPERIAL_UNIT:
        // empty
        break;
    case ::nds::core::properties::CorePropertyType::ATTRIBUTE_CONFIDENCE:
        // check constraint
        if (!(getConfidence() <= 100))
            throw ::zserio::ConstraintException("Write: Constraint violated at CorePropertyValue.confidence!");
        context.getConfidence().write<::zserio::StdIntArrayTraits<::nds::core::properties::AttributeConfidence>>(out, m_objectChoice.get<::nds::core::properties::AttributeConfidence>());
        break;
    case ::nds::core::properties::CorePropertyType::ATTRIBUTE_AGE:
        m_objectChoice.get<::nds::core::properties::AttributeAge>().write(context.getAge(), out);
        break;
    case ::nds::core::properties::CorePropertyType::ATTRIBUTE_SOURCE:
        ::zserio::write(context.getSource(), out, m_objectChoice.get<::nds::core::properties::AttributeSourceType>());
        break;
    case ::nds::core::properties::CorePropertyType::ICON_SET_REFERENCE:
        context.getIconSetReference().write<::zserio::VarIntArrayTraits<::nds::core::icons::IconSetReference>>(out, m_objectChoice.get<::nds::core::icons::IconSetReference>());
        break;
    case ::nds::core::properties::CorePropertyType::ICON_SET_REFERENCE_WITH_HEADING:
        m_objectChoice.get<::nds::core::icons::IconSetReferenceWithHeading>().write(context.getIconSetReferenceWithHeading(), out);
        break;
    case ::nds::core::properties::CorePropertyType::GLOBAL_ICON_SET_REFERENCE:
        context.getGlobalIconSetReference().write<::zserio::VarIntArrayTraits<::nds::core::icons::IconSetReference>>(out, m_objectChoice.get<::nds::core::icons::IconSetReference>());
        break;
    case ::nds::core::properties::CorePropertyType::GLOBAL_ICON_SET_REFERENCE_WITH_HEADING:
        m_objectChoice.get<::nds::core::icons::IconSetReferenceWithHeading>().write(context.getGlobalIconSetReferenceWithHeading(), out);
        break;
    case ::nds::core::properties::CorePropertyType::TOLL_PAYMENT:
        m_objectChoice.get<ZserioArrayType_tollPaymentMethod>().writePacked(*this, out);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice CorePropertyValue!");
    }
}

void CorePropertyValue::ZserioElementFactory_tollPaymentMethod::create(CorePropertyValue&        ,
        ::zserio::vector<::nds::core::properties::TollPaymentMethod>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, array.get_allocator());
}

void CorePropertyValue::ZserioElementFactory_tollPaymentMethod::create(CorePropertyValue&        ,
        ::zserio::vector<::nds::core::properties::TollPaymentMethod>& array,
        ::nds::core::properties::TollPaymentMethod::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, array.get_allocator());
}

::zserio::AnyHolder<> CorePropertyValue::readObject(::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::core::properties::CorePropertyType::ATTRIBUTE_REASON:
        return ::zserio::AnyHolder<>(::nds::core::properties::AttributeReason(in, allocator), allocator);
    case ::nds::core::properties::CorePropertyType::METRIC_UNIT:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::core::properties::CorePropertyType::IMPERIAL_UNIT:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::core::properties::CorePropertyType::ATTRIBUTE_CONFIDENCE:
        {
            ::nds::core::properties::AttributeConfidence readField = static_cast<::nds::core::properties::AttributeConfidence>(in.readBits(UINT8_C(8)));
            // check constraint
            if (!(readField <= 100))
                throw ::zserio::ConstraintException("Read: Constraint violated at CorePropertyValue.confidence!");

            return ::zserio::AnyHolder<>(::std::move(readField), allocator);
        }
    case ::nds::core::properties::CorePropertyType::ATTRIBUTE_AGE:
        return ::zserio::AnyHolder<>(::nds::core::properties::AttributeAge(in, allocator), allocator);
    case ::nds::core::properties::CorePropertyType::ATTRIBUTE_SOURCE:
        return ::zserio::AnyHolder<>(::zserio::read<::nds::core::properties::AttributeSourceType>(in), allocator);
    case ::nds::core::properties::CorePropertyType::ICON_SET_REFERENCE:
        return ::zserio::AnyHolder<>(static_cast<::nds::core::icons::IconSetReference>(in.readVarUInt()), allocator);
    case ::nds::core::properties::CorePropertyType::ICON_SET_REFERENCE_WITH_HEADING:
        return ::zserio::AnyHolder<>(::nds::core::icons::IconSetReferenceWithHeading(in, allocator), allocator);
    case ::nds::core::properties::CorePropertyType::GLOBAL_ICON_SET_REFERENCE:
        return ::zserio::AnyHolder<>(static_cast<::nds::core::icons::IconSetReference>(in.readVarUInt()), allocator);
    case ::nds::core::properties::CorePropertyType::GLOBAL_ICON_SET_REFERENCE_WITH_HEADING:
        return ::zserio::AnyHolder<>(::nds::core::icons::IconSetReferenceWithHeading(in, allocator), allocator);
    case ::nds::core::properties::CorePropertyType::TOLL_PAYMENT:
        {
            ZserioArrayType_tollPaymentMethod readField(allocator);
            readField.read(*this, in);

            return ::zserio::AnyHolder<>(::std::move(readField), allocator);
        }
    default:
        throw ::zserio::CppRuntimeException("No match in choice CorePropertyValue!");
    }
}

::zserio::AnyHolder<> CorePropertyValue::readObject(CorePropertyValue::ZserioPackingContext& context,
        ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::core::properties::CorePropertyType::ATTRIBUTE_REASON:
        return ::zserio::AnyHolder<>(::nds::core::properties::AttributeReason(context.getReason(), in, allocator), allocator);
    case ::nds::core::properties::CorePropertyType::METRIC_UNIT:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::core::properties::CorePropertyType::IMPERIAL_UNIT:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::core::properties::CorePropertyType::ATTRIBUTE_CONFIDENCE:
        {
            ::nds::core::properties::AttributeConfidence readField = context.getConfidence().read<::zserio::StdIntArrayTraits<::nds::core::properties::AttributeConfidence>>(in);
            // check constraint
            if (!(readField <= 100))
                throw ::zserio::ConstraintException("Read: Constraint violated at CorePropertyValue.confidence!");

            return ::zserio::AnyHolder<>(::std::move(readField), allocator);
        }
    case ::nds::core::properties::CorePropertyType::ATTRIBUTE_AGE:
        return ::zserio::AnyHolder<>(::nds::core::properties::AttributeAge(context.getAge(), in, allocator), allocator);
    case ::nds::core::properties::CorePropertyType::ATTRIBUTE_SOURCE:
        return ::zserio::AnyHolder<>(::zserio::read<::nds::core::properties::AttributeSourceType>(context.getSource(), in), allocator);
    case ::nds::core::properties::CorePropertyType::ICON_SET_REFERENCE:
        return ::zserio::AnyHolder<>(context.getIconSetReference().read<::zserio::VarIntArrayTraits<::nds::core::icons::IconSetReference>>(in), allocator);
    case ::nds::core::properties::CorePropertyType::ICON_SET_REFERENCE_WITH_HEADING:
        return ::zserio::AnyHolder<>(::nds::core::icons::IconSetReferenceWithHeading(context.getIconSetReferenceWithHeading(), in, allocator), allocator);
    case ::nds::core::properties::CorePropertyType::GLOBAL_ICON_SET_REFERENCE:
        return ::zserio::AnyHolder<>(context.getGlobalIconSetReference().read<::zserio::VarIntArrayTraits<::nds::core::icons::IconSetReference>>(in), allocator);
    case ::nds::core::properties::CorePropertyType::GLOBAL_ICON_SET_REFERENCE_WITH_HEADING:
        return ::zserio::AnyHolder<>(::nds::core::icons::IconSetReferenceWithHeading(context.getGlobalIconSetReferenceWithHeading(), in, allocator), allocator);
    case ::nds::core::properties::CorePropertyType::TOLL_PAYMENT:
        {
            ZserioArrayType_tollPaymentMethod readField(allocator);
            readField.readPacked(*this, in);

            return ::zserio::AnyHolder<>(::std::move(readField), allocator);
        }
    default:
        throw ::zserio::CppRuntimeException("No match in choice CorePropertyValue!");
    }
}

::zserio::AnyHolder<> CorePropertyValue::copyObject(const allocator_type& allocator) const
{
    switch (getType())
    {
    case ::nds::core::properties::CorePropertyType::ATTRIBUTE_REASON:
        return ::zserio::allocatorPropagatingCopy<::nds::core::properties::AttributeReason>(m_objectChoice, allocator);
    case ::nds::core::properties::CorePropertyType::METRIC_UNIT:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::core::properties::CorePropertyType::IMPERIAL_UNIT:
        return ::zserio::AnyHolder<>(allocator);
    case ::nds::core::properties::CorePropertyType::ATTRIBUTE_CONFIDENCE:
        return ::zserio::allocatorPropagatingCopy<::nds::core::properties::AttributeConfidence>(m_objectChoice, allocator);
    case ::nds::core::properties::CorePropertyType::ATTRIBUTE_AGE:
        return ::zserio::allocatorPropagatingCopy<::nds::core::properties::AttributeAge>(m_objectChoice, allocator);
    case ::nds::core::properties::CorePropertyType::ATTRIBUTE_SOURCE:
        return ::zserio::allocatorPropagatingCopy<::nds::core::properties::AttributeSourceType>(m_objectChoice, allocator);
    case ::nds::core::properties::CorePropertyType::ICON_SET_REFERENCE:
        return ::zserio::allocatorPropagatingCopy<::nds::core::icons::IconSetReference>(m_objectChoice, allocator);
    case ::nds::core::properties::CorePropertyType::ICON_SET_REFERENCE_WITH_HEADING:
        return ::zserio::allocatorPropagatingCopy<::nds::core::icons::IconSetReferenceWithHeading>(m_objectChoice, allocator);
    case ::nds::core::properties::CorePropertyType::GLOBAL_ICON_SET_REFERENCE:
        return ::zserio::allocatorPropagatingCopy<::nds::core::icons::IconSetReference>(m_objectChoice, allocator);
    case ::nds::core::properties::CorePropertyType::GLOBAL_ICON_SET_REFERENCE_WITH_HEADING:
        return ::zserio::allocatorPropagatingCopy<::nds::core::icons::IconSetReferenceWithHeading>(m_objectChoice, allocator);
    case ::nds::core::properties::CorePropertyType::TOLL_PAYMENT:
        return ::zserio::allocatorPropagatingCopy<ZserioArrayType_tollPaymentMethod>(m_objectChoice, allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice CorePropertyValue!");
    }
}

} // namespace properties
} // namespace core
} // namespace nds
