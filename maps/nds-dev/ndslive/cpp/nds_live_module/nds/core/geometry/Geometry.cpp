/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/core/geometry/GeometryLayerType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for GeometryLayerType enumeration.
constexpr ::std::array<const char*, 9> EnumTraits<::nds::core::geometry::GeometryLayerType>::names;
constexpr ::std::array<::nds::core::geometry::GeometryLayerType, 9> EnumTraits<::nds::core::geometry::GeometryLayerType>::values;
constexpr const char* EnumTraits<::nds::core::geometry::GeometryLayerType>::enumName;

template <>
size_t enumToOrdinal(::nds::core::geometry::GeometryLayerType value)
{
    switch (value)
    {
    case ::nds::core::geometry::GeometryLayerType::POSITION_2D:
        return 0;
    case ::nds::core::geometry::GeometryLayerType::POSITION_3D:
        return 1;
    case ::nds::core::geometry::GeometryLayerType::LINE_2D:
        return 2;
    case ::nds::core::geometry::GeometryLayerType::LINE_3D:
        return 3;
    case ::nds::core::geometry::GeometryLayerType::POLYGON_2D:
        return 4;
    case ::nds::core::geometry::GeometryLayerType::POLYGON_3D:
        return 5;
    case ::nds::core::geometry::GeometryLayerType::MESH_3D:
        return 6;
    case ::nds::core::geometry::GeometryLayerType::SIMPLE_POLYGON_2D:
        return 7;
    case ::nds::core::geometry::GeometryLayerType::SIMPLE_POLYGON_SET_2D:
        return 8;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration GeometryLayerType: ") <<
                static_cast<typename ::std::underlying_type<::nds::core::geometry::GeometryLayerType>::type>(value) << "!";
    }
}

template <>
::nds::core::geometry::GeometryLayerType valueToEnum(
        typename ::std::underlying_type<::nds::core::geometry::GeometryLayerType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
    case UINT8_C(3):
    case UINT8_C(4):
    case UINT8_C(5):
    case UINT8_C(6):
    case UINT8_C(7):
    case UINT8_C(8):
        return static_cast<::nds::core::geometry::GeometryLayerType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration GeometryLayerType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::core::geometry::GeometryLayerType>(::nds::core::geometry::GeometryLayerType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::core::geometry::GeometryLayerType value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::core::geometry::GeometryLayerType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::core::geometry::GeometryLayerType)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::core::geometry::GeometryLayerType value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::core::geometry::GeometryLayerType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::core::geometry::GeometryLayerType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::core::geometry::GeometryLayerType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::core::geometry::GeometryLayerType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::core::geometry::GeometryLayerType>(
            static_cast<typename ::std::underlying_type<::nds::core::geometry::GeometryLayerType>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::core::geometry::GeometryLayerType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::core::geometry::GeometryLayerType>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::core::geometry::GeometryLayerType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::core::geometry::GeometryLayerType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::core::geometry::GeometryLayerType value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::core::geometry::GeometryLayerType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/core/geometry/MapProjectionMethod.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for MapProjectionMethod enumeration.
constexpr ::std::array<const char*, 2> EnumTraits<::nds::core::geometry::MapProjectionMethod>::names;
constexpr ::std::array<::nds::core::geometry::MapProjectionMethod, 2> EnumTraits<::nds::core::geometry::MapProjectionMethod>::values;
constexpr const char* EnumTraits<::nds::core::geometry::MapProjectionMethod>::enumName;

template <>
size_t enumToOrdinal(::nds::core::geometry::MapProjectionMethod value)
{
    switch (value)
    {
    case ::nds::core::geometry::MapProjectionMethod::WGS_84_EPSG_4326:
        return 0;
    case ::nds::core::geometry::MapProjectionMethod::WEB_MERCATOR_EPSG_3857:
        return 1;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration MapProjectionMethod: ") <<
                static_cast<typename ::std::underlying_type<::nds::core::geometry::MapProjectionMethod>::type>(value) << "!";
    }
}

template <>
::nds::core::geometry::MapProjectionMethod valueToEnum(
        typename ::std::underlying_type<::nds::core::geometry::MapProjectionMethod>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
        return static_cast<::nds::core::geometry::MapProjectionMethod>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration MapProjectionMethod: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::core::geometry::MapProjectionMethod>(::nds::core::geometry::MapProjectionMethod value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::core::geometry::MapProjectionMethod value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::core::geometry::MapProjectionMethod>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::core::geometry::MapProjectionMethod)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::core::geometry::MapProjectionMethod value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::core::geometry::MapProjectionMethod>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::core::geometry::MapProjectionMethod value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::core::geometry::MapProjectionMethod value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::core::geometry::MapProjectionMethod read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::core::geometry::MapProjectionMethod>(
            static_cast<typename ::std::underlying_type<::nds::core::geometry::MapProjectionMethod>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::core::geometry::MapProjectionMethod read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::core::geometry::MapProjectionMethod>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::core::geometry::MapProjectionMethod>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::core::geometry::MapProjectionMethod value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::core::geometry::MapProjectionMethod value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::core::geometry::MapProjectionMethod>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/core/geometry/RangeOffsetType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for RangeOffsetType enumeration.
constexpr ::std::array<const char*, 3> EnumTraits<::nds::core::geometry::RangeOffsetType>::names;
constexpr ::std::array<::nds::core::geometry::RangeOffsetType, 3> EnumTraits<::nds::core::geometry::RangeOffsetType>::values;
constexpr const char* EnumTraits<::nds::core::geometry::RangeOffsetType>::enumName;

template <>
size_t enumToOrdinal(::nds::core::geometry::RangeOffsetType value)
{
    switch (value)
    {
    case ::nds::core::geometry::RangeOffsetType::START:
        return 0;
    case ::nds::core::geometry::RangeOffsetType::END:
        return 1;
    case ::nds::core::geometry::RangeOffsetType::START_AND_END:
        return 2;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration RangeOffsetType: ") <<
                static_cast<typename ::std::underlying_type<::nds::core::geometry::RangeOffsetType>::type>(value) << "!";
    }
}

template <>
::nds::core::geometry::RangeOffsetType valueToEnum(
        typename ::std::underlying_type<::nds::core::geometry::RangeOffsetType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
        return static_cast<::nds::core::geometry::RangeOffsetType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration RangeOffsetType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::core::geometry::RangeOffsetType>(::nds::core::geometry::RangeOffsetType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::core::geometry::RangeOffsetType value)
{
    context.init<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::core::geometry::RangeOffsetType>::type, UINT8_C(2)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::core::geometry::RangeOffsetType)
{
    return UINT8_C(2);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::core::geometry::RangeOffsetType value)
{
    return context.bitSizeOf<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::core::geometry::RangeOffsetType>::type, UINT8_C(2)>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::core::geometry::RangeOffsetType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::core::geometry::RangeOffsetType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::core::geometry::RangeOffsetType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::core::geometry::RangeOffsetType>(
            static_cast<typename ::std::underlying_type<::nds::core::geometry::RangeOffsetType>::type>(
                    in.readBits(UINT8_C(2))));
}

template <>
::nds::core::geometry::RangeOffsetType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::core::geometry::RangeOffsetType>(context.read<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::core::geometry::RangeOffsetType>::type, UINT8_C(2)>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::core::geometry::RangeOffsetType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(2));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::core::geometry::RangeOffsetType value)
{
    context.write<::zserio::BitFieldArrayTraits<typename ::std::underlying_type<::nds::core::geometry::RangeOffsetType>::type, UINT8_C(2)>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/core/geometry/IndexType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for IndexType enumeration.
constexpr ::std::array<const char*, 3> EnumTraits<::nds::core::geometry::IndexType>::names;
constexpr ::std::array<::nds::core::geometry::IndexType, 3> EnumTraits<::nds::core::geometry::IndexType>::values;
constexpr const char* EnumTraits<::nds::core::geometry::IndexType>::enumName;

template <>
size_t enumToOrdinal(::nds::core::geometry::IndexType value)
{
    switch (value)
    {
    case ::nds::core::geometry::IndexType::TRIANGLES:
        return 0;
    case ::nds::core::geometry::IndexType::TRIANGLE_STRIP:
        return 1;
    case ::nds::core::geometry::IndexType::TRIANGLE_FAN:
        return 2;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration IndexType: ") <<
                static_cast<typename ::std::underlying_type<::nds::core::geometry::IndexType>::type>(value) << "!";
    }
}

template <>
::nds::core::geometry::IndexType valueToEnum(
        typename ::std::underlying_type<::nds::core::geometry::IndexType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
    case UINT8_C(2):
        return static_cast<::nds::core::geometry::IndexType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration IndexType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::core::geometry::IndexType>(::nds::core::geometry::IndexType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::core::geometry::IndexType value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::core::geometry::IndexType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::core::geometry::IndexType)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::core::geometry::IndexType value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::core::geometry::IndexType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::core::geometry::IndexType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::core::geometry::IndexType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::core::geometry::IndexType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::core::geometry::IndexType>(
            static_cast<typename ::std::underlying_type<::nds::core::geometry::IndexType>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::core::geometry::IndexType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::core::geometry::IndexType>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::core::geometry::IndexType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::core::geometry::IndexType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::core::geometry::IndexType value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::core::geometry::IndexType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>

#include <nds/core/geometry/PolyMesh3DType.h>

namespace zserio
{

// This is full specialization of enumeration traits and methods for PolyMesh3DType enumeration.
constexpr ::std::array<const char*, 2> EnumTraits<::nds::core::geometry::PolyMesh3DType>::names;
constexpr ::std::array<::nds::core::geometry::PolyMesh3DType, 2> EnumTraits<::nds::core::geometry::PolyMesh3DType>::values;
constexpr const char* EnumTraits<::nds::core::geometry::PolyMesh3DType>::enumName;

template <>
size_t enumToOrdinal(::nds::core::geometry::PolyMesh3DType value)
{
    switch (value)
    {
    case ::nds::core::geometry::PolyMesh3DType::POLYGON:
        return 0;
    case ::nds::core::geometry::PolyMesh3DType::MESH:
        return 1;
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration PolyMesh3DType: ") <<
                static_cast<typename ::std::underlying_type<::nds::core::geometry::PolyMesh3DType>::type>(value) << "!";
    }
}

template <>
::nds::core::geometry::PolyMesh3DType valueToEnum(
        typename ::std::underlying_type<::nds::core::geometry::PolyMesh3DType>::type rawValue)
{
    switch (rawValue)
    {
    case UINT8_C(0):
    case UINT8_C(1):
        return static_cast<::nds::core::geometry::PolyMesh3DType>(rawValue);
    default:
        throw ::zserio::CppRuntimeException("Unknown value for enumeration PolyMesh3DType: ") << rawValue << "!";
    }
}

template <>
uint32_t enumHashCode<::nds::core::geometry::PolyMesh3DType>(::nds::core::geometry::PolyMesh3DType value)
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, enumToValue(value));
    return result;
}

template <>
void initPackingContext(::zserio::DeltaContext& context, ::nds::core::geometry::PolyMesh3DType value)
{
    context.init<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::core::geometry::PolyMesh3DType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t bitSizeOf(::nds::core::geometry::PolyMesh3DType)
{
    return UINT8_C(8);
}

template <>
size_t bitSizeOf(::zserio::DeltaContext& context, ::nds::core::geometry::PolyMesh3DType value)
{
    return context.bitSizeOf<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::core::geometry::PolyMesh3DType>::type>>(
            ::zserio::enumToValue(value));
}

template <>
size_t initializeOffsets(size_t bitPosition, ::nds::core::geometry::PolyMesh3DType value)
{
    return bitPosition + bitSizeOf(value);
}

template <>
size_t initializeOffsets(::zserio::DeltaContext& context, size_t bitPosition, ::nds::core::geometry::PolyMesh3DType value)
{
    return bitPosition + bitSizeOf(context, value);
}

template <>
::nds::core::geometry::PolyMesh3DType read(::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::core::geometry::PolyMesh3DType>(
            static_cast<typename ::std::underlying_type<::nds::core::geometry::PolyMesh3DType>::type>(
                    in.readBits(UINT8_C(8))));
}

template <>
::nds::core::geometry::PolyMesh3DType read(::zserio::DeltaContext& context, ::zserio::BitStreamReader& in)
{
    return valueToEnum<::nds::core::geometry::PolyMesh3DType>(context.read<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::core::geometry::PolyMesh3DType>::type>>(
            in));
}

template <>
void write(::zserio::BitStreamWriter& out, ::nds::core::geometry::PolyMesh3DType value)
{
    out.writeBits(::zserio::enumToValue(value), UINT8_C(8));
}

template <>
void write(::zserio::DeltaContext& context, ::zserio::BitStreamWriter& out, ::nds::core::geometry::PolyMesh3DType value)
{
    context.write<::zserio::StdIntArrayTraits<typename ::std::underlying_type<::nds::core::geometry::PolyMesh3DType>::type>>(
            out, ::zserio::enumToValue(value));
}

} // namespace zserio

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/core/geometry/Position2D.h>

namespace nds
{
namespace core
{
namespace geometry
{

Position2D::Position2D(const allocator_type&) noexcept :
        m_isInitialized(false),
        m_longitude_(int32_t()),
        m_latitude_(int32_t())
{
}

Position2D::Position2D(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift shift_, const allocator_type&) :
        m_shift_(shift_),
        m_isInitialized(true),
        m_longitude_(readLongitude(in)),
        m_latitude_(readLatitude(in))
{
}

Position2D::Position2D(Position2D::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift shift_, const allocator_type&) :
        m_shift_(shift_),
        m_isInitialized(true),
        m_longitude_(readLongitude(context, in)),
        m_latitude_(readLatitude(context, in))
{
}

Position2D::Position2D(const Position2D& other) :
        m_longitude_(other.m_longitude_),
        m_latitude_(other.m_latitude_)
{
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;
}

Position2D& Position2D::operator=(const Position2D& other)
{
    m_longitude_ = other.m_longitude_;
    m_latitude_ = other.m_latitude_;
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;

    return *this;
}

Position2D::Position2D(Position2D&& other) :
        m_longitude_(::std::move(other.m_longitude_)),
        m_latitude_(::std::move(other.m_latitude_))
{
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;
}

Position2D& Position2D::operator=(Position2D&& other)
{
    m_longitude_ = ::std::move(other.m_longitude_);
    m_latitude_ = ::std::move(other.m_latitude_);
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;

    return *this;
}

Position2D::Position2D(::zserio::PropagateAllocatorT,
        const Position2D& other, const allocator_type& allocator) :
        m_longitude_(::zserio::allocatorPropagatingCopy(other.m_longitude_, allocator)),
        m_latitude_(::zserio::allocatorPropagatingCopy(other.m_latitude_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;
}

void Position2D::initialize(
        ::nds::core::geometry::CoordShift shift_)
{
    m_shift_ = shift_;
    m_isInitialized = true;
}

bool Position2D::isInitialized() const
{
    return m_isInitialized;
}

::nds::core::geometry::CoordShift Position2D::getShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'shift' of compound 'Position2D' is not initialized!");

    return m_shift_;
}

int32_t Position2D::getLongitude() const
{
    return m_longitude_;
}

void Position2D::setLongitude(int32_t longitude_)
{
    m_longitude_ = longitude_;
}

int32_t Position2D::getLatitude() const
{
    return m_latitude_;
}

void Position2D::setLatitude(int32_t latitude_)
{
    m_latitude_ = latitude_;
}

::nds::core::geometry::Longitude Position2D::funcLon() const
{
    return static_cast<::nds::core::geometry::Longitude>((getLongitude() << getShift()));
}

::nds::core::geometry::Latitude Position2D::funcLat() const
{
    return static_cast<::nds::core::geometry::Latitude>((getLatitude() << getShift()));
}

void Position2D::initPackingContext(Position2D::ZserioPackingContext& context) const
{
    context.getLongitude().init<::zserio::DynamicBitFieldArrayTraits<int32_t, ZserioElementBitSize_longitude>>(*this, m_longitude_);
    context.getLatitude().init<::zserio::DynamicBitFieldArrayTraits<int32_t, ZserioElementBitSize_latitude>>(*this, m_latitude_);
}

size_t Position2D::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += static_cast<uint8_t>((31 - getShift()) + 1);
    endBitPosition += static_cast<uint8_t>((31 - getShift()) + 1);

    return endBitPosition - bitPosition;
}

size_t Position2D::bitSizeOf(Position2D::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getLongitude().bitSizeOf<::zserio::DynamicBitFieldArrayTraits<int32_t, ZserioElementBitSize_longitude>>(*this, m_longitude_);
    endBitPosition += context.getLatitude().bitSizeOf<::zserio::DynamicBitFieldArrayTraits<int32_t, ZserioElementBitSize_latitude>>(*this, m_latitude_);

    return endBitPosition - bitPosition;
}

size_t Position2D::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += static_cast<uint8_t>((31 - getShift()) + 1);
    endBitPosition += static_cast<uint8_t>((31 - getShift()) + 1);

    return endBitPosition;
}

size_t Position2D::initializeOffsets(Position2D::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getLongitude().bitSizeOf<::zserio::DynamicBitFieldArrayTraits<int32_t, ZserioElementBitSize_longitude>>(*this, m_longitude_);
    endBitPosition += context.getLatitude().bitSizeOf<::zserio::DynamicBitFieldArrayTraits<int32_t, ZserioElementBitSize_latitude>>(*this, m_latitude_);

    return endBitPosition;
}

bool Position2D::operator==(const Position2D& other) const
{
    if (this != &other)
    {
        return
                (getShift() == other.getShift()) &&
                (m_longitude_ == other.m_longitude_) &&
                (m_latitude_ == other.m_latitude_);
    }

    return true;
}

uint32_t Position2D::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getShift());
    result = ::zserio::calcHashCode(result, m_longitude_);
    result = ::zserio::calcHashCode(result, m_latitude_);

    return result;
}

void Position2D::write(::zserio::BitStreamWriter& out) const
{
    out.writeSignedBits(m_longitude_, static_cast<uint8_t>((31 - getShift()) + 1));
    out.writeSignedBits(m_latitude_, static_cast<uint8_t>((31 - getShift()) + 1));
}

void Position2D::write(Position2D::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getLongitude().write<::zserio::DynamicBitFieldArrayTraits<int32_t, ZserioElementBitSize_longitude>>(*this, out, m_longitude_);
    context.getLatitude().write<::zserio::DynamicBitFieldArrayTraits<int32_t, ZserioElementBitSize_latitude>>(*this, out, m_latitude_);
}

uint8_t Position2D::ZserioElementBitSize_longitude::get(const Position2D& owner)
{
    return static_cast<uint8_t>((31 - owner.getShift()) + 1);
}

uint8_t Position2D::ZserioElementBitSize_latitude::get(const Position2D& owner)
{
    return static_cast<uint8_t>((31 - owner.getShift()) + 1);
}

int32_t Position2D::readLongitude(::zserio::BitStreamReader& in)
{
    return static_cast<int32_t>(in.readSignedBits(static_cast<uint8_t>((31 - getShift()) + 1)));
}

int32_t Position2D::readLongitude(Position2D::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getLongitude().read<::zserio::DynamicBitFieldArrayTraits<int32_t, ZserioElementBitSize_longitude>>(*this, in);
}
int32_t Position2D::readLatitude(::zserio::BitStreamReader& in)
{
    return static_cast<int32_t>(in.readSignedBits(static_cast<uint8_t>((31 - getShift()) + 1)));
}

int32_t Position2D::readLatitude(Position2D::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getLatitude().read<::zserio::DynamicBitFieldArrayTraits<int32_t, ZserioElementBitSize_latitude>>(*this, in);
}

} // namespace geometry
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/core/geometry/PositionOffset2D.h>

namespace nds
{
namespace core
{
namespace geometry
{

PositionOffset2D::PositionOffset2D(const allocator_type&) noexcept :
        m_isInitialized(false),
        m_deltaLongitude_(int32_t()),
        m_deltaLatitude_(int32_t())
{
}

PositionOffset2D::PositionOffset2D(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordWidth numBits_,
        ::nds::core::geometry::CoordShift shift_, const allocator_type&) :
        m_numBits_(numBits_),
        m_shift_(shift_),
        m_isInitialized(true),
        m_deltaLongitude_(readDeltaLongitude(in)),
        m_deltaLatitude_(readDeltaLatitude(in))
{
}

PositionOffset2D::PositionOffset2D(PositionOffset2D::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordWidth numBits_,
        ::nds::core::geometry::CoordShift shift_, const allocator_type&) :
        m_numBits_(numBits_),
        m_shift_(shift_),
        m_isInitialized(true),
        m_deltaLongitude_(readDeltaLongitude(context, in)),
        m_deltaLatitude_(readDeltaLatitude(context, in))
{
}

PositionOffset2D::PositionOffset2D(const PositionOffset2D& other) :
        m_deltaLongitude_(other.m_deltaLongitude_),
        m_deltaLatitude_(other.m_deltaLatitude_)
{
    if (other.m_isInitialized)
        initialize(other.m_numBits_, other.m_shift_);
    else
        m_isInitialized = false;
}

PositionOffset2D& PositionOffset2D::operator=(const PositionOffset2D& other)
{
    m_deltaLongitude_ = other.m_deltaLongitude_;
    m_deltaLatitude_ = other.m_deltaLatitude_;
    if (other.m_isInitialized)
        initialize(other.m_numBits_, other.m_shift_);
    else
        m_isInitialized = false;

    return *this;
}

PositionOffset2D::PositionOffset2D(PositionOffset2D&& other) :
        m_deltaLongitude_(::std::move(other.m_deltaLongitude_)),
        m_deltaLatitude_(::std::move(other.m_deltaLatitude_))
{
    if (other.m_isInitialized)
        initialize(other.m_numBits_, other.m_shift_);
    else
        m_isInitialized = false;
}

PositionOffset2D& PositionOffset2D::operator=(PositionOffset2D&& other)
{
    m_deltaLongitude_ = ::std::move(other.m_deltaLongitude_);
    m_deltaLatitude_ = ::std::move(other.m_deltaLatitude_);
    if (other.m_isInitialized)
        initialize(other.m_numBits_, other.m_shift_);
    else
        m_isInitialized = false;

    return *this;
}

PositionOffset2D::PositionOffset2D(::zserio::PropagateAllocatorT,
        const PositionOffset2D& other, const allocator_type& allocator) :
        m_deltaLongitude_(::zserio::allocatorPropagatingCopy(other.m_deltaLongitude_, allocator)),
        m_deltaLatitude_(::zserio::allocatorPropagatingCopy(other.m_deltaLatitude_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_numBits_, other.m_shift_);
    else
        m_isInitialized = false;
}

void PositionOffset2D::initialize(
        ::nds::core::geometry::CoordWidth numBits_,
        ::nds::core::geometry::CoordShift shift_)
{
    m_numBits_ = numBits_;
    m_shift_ = shift_;
    m_isInitialized = true;
}

bool PositionOffset2D::isInitialized() const
{
    return m_isInitialized;
}

::nds::core::geometry::CoordWidth PositionOffset2D::getNumBits() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'numBits' of compound 'PositionOffset2D' is not initialized!");

    return m_numBits_;
}

::nds::core::geometry::CoordShift PositionOffset2D::getShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'shift' of compound 'PositionOffset2D' is not initialized!");

    return m_shift_;
}

int32_t PositionOffset2D::getDeltaLongitude() const
{
    return m_deltaLongitude_;
}

void PositionOffset2D::setDeltaLongitude(int32_t deltaLongitude_)
{
    m_deltaLongitude_ = deltaLongitude_;
}

int32_t PositionOffset2D::getDeltaLatitude() const
{
    return m_deltaLatitude_;
}

void PositionOffset2D::setDeltaLatitude(int32_t deltaLatitude_)
{
    m_deltaLatitude_ = deltaLatitude_;
}

::nds::core::geometry::DeltaLongitude PositionOffset2D::funcLon() const
{
    return static_cast<::nds::core::geometry::DeltaLongitude>(getDeltaLongitude() << getShift());
}

::nds::core::geometry::DeltaLatitude PositionOffset2D::funcLat() const
{
    return static_cast<::nds::core::geometry::DeltaLatitude>(getDeltaLatitude() << getShift());
}

void PositionOffset2D::initPackingContext(PositionOffset2D::ZserioPackingContext& context) const
{
    context.getDeltaLongitude().init<::zserio::DynamicBitFieldArrayTraits<int32_t, ZserioElementBitSize_deltaLongitude>>(*this, m_deltaLongitude_);
    context.getDeltaLatitude().init<::zserio::DynamicBitFieldArrayTraits<int32_t, ZserioElementBitSize_deltaLatitude>>(*this, m_deltaLatitude_);
}

size_t PositionOffset2D::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += static_cast<uint8_t>(getNumBits() + 1);
    endBitPosition += static_cast<uint8_t>(getNumBits() + 1);

    return endBitPosition - bitPosition;
}

size_t PositionOffset2D::bitSizeOf(PositionOffset2D::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getDeltaLongitude().bitSizeOf<::zserio::DynamicBitFieldArrayTraits<int32_t, ZserioElementBitSize_deltaLongitude>>(*this, m_deltaLongitude_);
    endBitPosition += context.getDeltaLatitude().bitSizeOf<::zserio::DynamicBitFieldArrayTraits<int32_t, ZserioElementBitSize_deltaLatitude>>(*this, m_deltaLatitude_);

    return endBitPosition - bitPosition;
}

size_t PositionOffset2D::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += static_cast<uint8_t>(getNumBits() + 1);
    endBitPosition += static_cast<uint8_t>(getNumBits() + 1);

    return endBitPosition;
}

size_t PositionOffset2D::initializeOffsets(PositionOffset2D::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getDeltaLongitude().bitSizeOf<::zserio::DynamicBitFieldArrayTraits<int32_t, ZserioElementBitSize_deltaLongitude>>(*this, m_deltaLongitude_);
    endBitPosition += context.getDeltaLatitude().bitSizeOf<::zserio::DynamicBitFieldArrayTraits<int32_t, ZserioElementBitSize_deltaLatitude>>(*this, m_deltaLatitude_);

    return endBitPosition;
}

bool PositionOffset2D::operator==(const PositionOffset2D& other) const
{
    if (this != &other)
    {
        return
                (getNumBits() == other.getNumBits()) &&
                (getShift() == other.getShift()) &&
                (m_deltaLongitude_ == other.m_deltaLongitude_) &&
                (m_deltaLatitude_ == other.m_deltaLatitude_);
    }

    return true;
}

uint32_t PositionOffset2D::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getNumBits());
    result = ::zserio::calcHashCode(result, getShift());
    result = ::zserio::calcHashCode(result, m_deltaLongitude_);
    result = ::zserio::calcHashCode(result, m_deltaLatitude_);

    return result;
}

void PositionOffset2D::write(::zserio::BitStreamWriter& out) const
{
    out.writeSignedBits(m_deltaLongitude_, static_cast<uint8_t>(getNumBits() + 1));
    out.writeSignedBits(m_deltaLatitude_, static_cast<uint8_t>(getNumBits() + 1));
}

void PositionOffset2D::write(PositionOffset2D::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getDeltaLongitude().write<::zserio::DynamicBitFieldArrayTraits<int32_t, ZserioElementBitSize_deltaLongitude>>(*this, out, m_deltaLongitude_);
    context.getDeltaLatitude().write<::zserio::DynamicBitFieldArrayTraits<int32_t, ZserioElementBitSize_deltaLatitude>>(*this, out, m_deltaLatitude_);
}

uint8_t PositionOffset2D::ZserioElementBitSize_deltaLongitude::get(const PositionOffset2D& owner)
{
    return static_cast<uint8_t>(owner.getNumBits() + 1);
}

uint8_t PositionOffset2D::ZserioElementBitSize_deltaLatitude::get(const PositionOffset2D& owner)
{
    return static_cast<uint8_t>(owner.getNumBits() + 1);
}

int32_t PositionOffset2D::readDeltaLongitude(::zserio::BitStreamReader& in)
{
    return static_cast<int32_t>(in.readSignedBits(static_cast<uint8_t>(getNumBits() + 1)));
}

int32_t PositionOffset2D::readDeltaLongitude(PositionOffset2D::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getDeltaLongitude().read<::zserio::DynamicBitFieldArrayTraits<int32_t, ZserioElementBitSize_deltaLongitude>>(*this, in);
}
int32_t PositionOffset2D::readDeltaLatitude(::zserio::BitStreamReader& in)
{
    return static_cast<int32_t>(in.readSignedBits(static_cast<uint8_t>(getNumBits() + 1)));
}

int32_t PositionOffset2D::readDeltaLatitude(PositionOffset2D::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getDeltaLatitude().read<::zserio::DynamicBitFieldArrayTraits<int32_t, ZserioElementBitSize_deltaLatitude>>(*this, in);
}

} // namespace geometry
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/core/geometry/Position3D.h>

namespace nds
{
namespace core
{
namespace geometry
{

Position3D::Position3D(const allocator_type&) noexcept :
        m_isInitialized(false),
        m_longitude_(int32_t()),
        m_latitude_(int32_t()),
        m_elevation_(int32_t())
{
}

Position3D::Position3D(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift shiftXY_,
        ::nds::core::geometry::CoordShift shiftZ_, const allocator_type&) :
        m_shiftXY_(shiftXY_),
        m_shiftZ_(shiftZ_),
        m_isInitialized(true),
        m_longitude_(readLongitude(in)),
        m_latitude_(readLatitude(in)),
        m_elevation_(readElevation(in))
{
}

Position3D::Position3D(Position3D::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift shiftXY_,
        ::nds::core::geometry::CoordShift shiftZ_, const allocator_type&) :
        m_shiftXY_(shiftXY_),
        m_shiftZ_(shiftZ_),
        m_isInitialized(true),
        m_longitude_(readLongitude(context, in)),
        m_latitude_(readLatitude(context, in)),
        m_elevation_(readElevation(context, in))
{
}

Position3D::Position3D(const Position3D& other) :
        m_longitude_(other.m_longitude_),
        m_latitude_(other.m_latitude_),
        m_elevation_(other.m_elevation_)
{
    if (other.m_isInitialized)
        initialize(other.m_shiftXY_, other.m_shiftZ_);
    else
        m_isInitialized = false;
}

Position3D& Position3D::operator=(const Position3D& other)
{
    m_longitude_ = other.m_longitude_;
    m_latitude_ = other.m_latitude_;
    m_elevation_ = other.m_elevation_;
    if (other.m_isInitialized)
        initialize(other.m_shiftXY_, other.m_shiftZ_);
    else
        m_isInitialized = false;

    return *this;
}

Position3D::Position3D(Position3D&& other) :
        m_longitude_(::std::move(other.m_longitude_)),
        m_latitude_(::std::move(other.m_latitude_)),
        m_elevation_(::std::move(other.m_elevation_))
{
    if (other.m_isInitialized)
        initialize(other.m_shiftXY_, other.m_shiftZ_);
    else
        m_isInitialized = false;
}

Position3D& Position3D::operator=(Position3D&& other)
{
    m_longitude_ = ::std::move(other.m_longitude_);
    m_latitude_ = ::std::move(other.m_latitude_);
    m_elevation_ = ::std::move(other.m_elevation_);
    if (other.m_isInitialized)
        initialize(other.m_shiftXY_, other.m_shiftZ_);
    else
        m_isInitialized = false;

    return *this;
}

Position3D::Position3D(::zserio::PropagateAllocatorT,
        const Position3D& other, const allocator_type& allocator) :
        m_longitude_(::zserio::allocatorPropagatingCopy(other.m_longitude_, allocator)),
        m_latitude_(::zserio::allocatorPropagatingCopy(other.m_latitude_, allocator)),
        m_elevation_(::zserio::allocatorPropagatingCopy(other.m_elevation_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_shiftXY_, other.m_shiftZ_);
    else
        m_isInitialized = false;
}

void Position3D::initialize(
        ::nds::core::geometry::CoordShift shiftXY_,
        ::nds::core::geometry::CoordShift shiftZ_)
{
    m_shiftXY_ = shiftXY_;
    m_shiftZ_ = shiftZ_;
    m_isInitialized = true;
}

bool Position3D::isInitialized() const
{
    return m_isInitialized;
}

::nds::core::geometry::CoordShift Position3D::getShiftXY() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'shiftXY' of compound 'Position3D' is not initialized!");

    return m_shiftXY_;
}

::nds::core::geometry::CoordShift Position3D::getShiftZ() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'shiftZ' of compound 'Position3D' is not initialized!");

    return m_shiftZ_;
}

int32_t Position3D::getLongitude() const
{
    return m_longitude_;
}

void Position3D::setLongitude(int32_t longitude_)
{
    m_longitude_ = longitude_;
}

int32_t Position3D::getLatitude() const
{
    return m_latitude_;
}

void Position3D::setLatitude(int32_t latitude_)
{
    m_latitude_ = latitude_;
}

int32_t Position3D::getElevation() const
{
    return m_elevation_;
}

void Position3D::setElevation(int32_t elevation_)
{
    m_elevation_ = elevation_;
}

::nds::core::geometry::Longitude Position3D::funcLon() const
{
    return static_cast<::nds::core::geometry::Longitude>(getLongitude() << getShiftXY());
}

::nds::core::geometry::Latitude Position3D::funcLat() const
{
    return static_cast<::nds::core::geometry::Latitude>(getLatitude() << getShiftXY());
}

::nds::core::geometry::Elevation Position3D::funcEle() const
{
    return static_cast<::nds::core::geometry::Elevation>(getElevation() << getShiftZ());
}

void Position3D::initPackingContext(Position3D::ZserioPackingContext& context) const
{
    context.getLongitude().init<::zserio::DynamicBitFieldArrayTraits<int32_t, ZserioElementBitSize_longitude>>(*this, m_longitude_);
    context.getLatitude().init<::zserio::DynamicBitFieldArrayTraits<int32_t, ZserioElementBitSize_latitude>>(*this, m_latitude_);
    context.getElevation().init<::zserio::DynamicBitFieldArrayTraits<int32_t, ZserioElementBitSize_elevation>>(*this, m_elevation_);
}

size_t Position3D::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += static_cast<uint8_t>((31 - getShiftXY()) + 1);
    endBitPosition += static_cast<uint8_t>((31 - getShiftXY()) + 1);
    endBitPosition += static_cast<uint8_t>(31 - getShiftZ() + 1);

    return endBitPosition - bitPosition;
}

size_t Position3D::bitSizeOf(Position3D::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getLongitude().bitSizeOf<::zserio::DynamicBitFieldArrayTraits<int32_t, ZserioElementBitSize_longitude>>(*this, m_longitude_);
    endBitPosition += context.getLatitude().bitSizeOf<::zserio::DynamicBitFieldArrayTraits<int32_t, ZserioElementBitSize_latitude>>(*this, m_latitude_);
    endBitPosition += context.getElevation().bitSizeOf<::zserio::DynamicBitFieldArrayTraits<int32_t, ZserioElementBitSize_elevation>>(*this, m_elevation_);

    return endBitPosition - bitPosition;
}

size_t Position3D::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += static_cast<uint8_t>((31 - getShiftXY()) + 1);
    endBitPosition += static_cast<uint8_t>((31 - getShiftXY()) + 1);
    endBitPosition += static_cast<uint8_t>(31 - getShiftZ() + 1);

    return endBitPosition;
}

size_t Position3D::initializeOffsets(Position3D::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getLongitude().bitSizeOf<::zserio::DynamicBitFieldArrayTraits<int32_t, ZserioElementBitSize_longitude>>(*this, m_longitude_);
    endBitPosition += context.getLatitude().bitSizeOf<::zserio::DynamicBitFieldArrayTraits<int32_t, ZserioElementBitSize_latitude>>(*this, m_latitude_);
    endBitPosition += context.getElevation().bitSizeOf<::zserio::DynamicBitFieldArrayTraits<int32_t, ZserioElementBitSize_elevation>>(*this, m_elevation_);

    return endBitPosition;
}

bool Position3D::operator==(const Position3D& other) const
{
    if (this != &other)
    {
        return
                (getShiftXY() == other.getShiftXY()) &&
                (getShiftZ() == other.getShiftZ()) &&
                (m_longitude_ == other.m_longitude_) &&
                (m_latitude_ == other.m_latitude_) &&
                (m_elevation_ == other.m_elevation_);
    }

    return true;
}

uint32_t Position3D::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getShiftXY());
    result = ::zserio::calcHashCode(result, getShiftZ());
    result = ::zserio::calcHashCode(result, m_longitude_);
    result = ::zserio::calcHashCode(result, m_latitude_);
    result = ::zserio::calcHashCode(result, m_elevation_);

    return result;
}

void Position3D::write(::zserio::BitStreamWriter& out) const
{
    out.writeSignedBits(m_longitude_, static_cast<uint8_t>((31 - getShiftXY()) + 1));
    out.writeSignedBits(m_latitude_, static_cast<uint8_t>((31 - getShiftXY()) + 1));
    out.writeSignedBits(m_elevation_, static_cast<uint8_t>(31 - getShiftZ() + 1));
}

void Position3D::write(Position3D::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getLongitude().write<::zserio::DynamicBitFieldArrayTraits<int32_t, ZserioElementBitSize_longitude>>(*this, out, m_longitude_);
    context.getLatitude().write<::zserio::DynamicBitFieldArrayTraits<int32_t, ZserioElementBitSize_latitude>>(*this, out, m_latitude_);
    context.getElevation().write<::zserio::DynamicBitFieldArrayTraits<int32_t, ZserioElementBitSize_elevation>>(*this, out, m_elevation_);
}

uint8_t Position3D::ZserioElementBitSize_longitude::get(const Position3D& owner)
{
    return static_cast<uint8_t>((31 - owner.getShiftXY()) + 1);
}

uint8_t Position3D::ZserioElementBitSize_latitude::get(const Position3D& owner)
{
    return static_cast<uint8_t>((31 - owner.getShiftXY()) + 1);
}

uint8_t Position3D::ZserioElementBitSize_elevation::get(const Position3D& owner)
{
    return static_cast<uint8_t>(31 - owner.getShiftZ() + 1);
}

int32_t Position3D::readLongitude(::zserio::BitStreamReader& in)
{
    return static_cast<int32_t>(in.readSignedBits(static_cast<uint8_t>((31 - getShiftXY()) + 1)));
}

int32_t Position3D::readLongitude(Position3D::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getLongitude().read<::zserio::DynamicBitFieldArrayTraits<int32_t, ZserioElementBitSize_longitude>>(*this, in);
}
int32_t Position3D::readLatitude(::zserio::BitStreamReader& in)
{
    return static_cast<int32_t>(in.readSignedBits(static_cast<uint8_t>((31 - getShiftXY()) + 1)));
}

int32_t Position3D::readLatitude(Position3D::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getLatitude().read<::zserio::DynamicBitFieldArrayTraits<int32_t, ZserioElementBitSize_latitude>>(*this, in);
}
int32_t Position3D::readElevation(::zserio::BitStreamReader& in)
{
    return static_cast<int32_t>(in.readSignedBits(static_cast<uint8_t>(31 - getShiftZ() + 1)));
}

int32_t Position3D::readElevation(Position3D::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getElevation().read<::zserio::DynamicBitFieldArrayTraits<int32_t, ZserioElementBitSize_elevation>>(*this, in);
}

} // namespace geometry
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/core/geometry/PositionOffset3D.h>

namespace nds
{
namespace core
{
namespace geometry
{

PositionOffset3D::PositionOffset3D(const allocator_type&) noexcept :
        m_isInitialized(false),
        m_deltaLongitude_(int32_t()),
        m_deltaLatitude_(int32_t()),
        m_deltaElevation_(int32_t())
{
}

PositionOffset3D::PositionOffset3D(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordWidth numBitsXY_,
        ::nds::core::geometry::CoordWidth numBitsZ_,
        ::nds::core::geometry::CoordShift shiftXY_,
        ::nds::core::geometry::CoordShift shiftZ_, const allocator_type&) :
        m_numBitsXY_(numBitsXY_),
        m_numBitsZ_(numBitsZ_),
        m_shiftXY_(shiftXY_),
        m_shiftZ_(shiftZ_),
        m_isInitialized(true),
        m_deltaLongitude_(readDeltaLongitude(in)),
        m_deltaLatitude_(readDeltaLatitude(in)),
        m_deltaElevation_(readDeltaElevation(in))
{
}

PositionOffset3D::PositionOffset3D(PositionOffset3D::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordWidth numBitsXY_,
        ::nds::core::geometry::CoordWidth numBitsZ_,
        ::nds::core::geometry::CoordShift shiftXY_,
        ::nds::core::geometry::CoordShift shiftZ_, const allocator_type&) :
        m_numBitsXY_(numBitsXY_),
        m_numBitsZ_(numBitsZ_),
        m_shiftXY_(shiftXY_),
        m_shiftZ_(shiftZ_),
        m_isInitialized(true),
        m_deltaLongitude_(readDeltaLongitude(context, in)),
        m_deltaLatitude_(readDeltaLatitude(context, in)),
        m_deltaElevation_(readDeltaElevation(context, in))
{
}

PositionOffset3D::PositionOffset3D(const PositionOffset3D& other) :
        m_deltaLongitude_(other.m_deltaLongitude_),
        m_deltaLatitude_(other.m_deltaLatitude_),
        m_deltaElevation_(other.m_deltaElevation_)
{
    if (other.m_isInitialized)
        initialize(other.m_numBitsXY_, other.m_numBitsZ_, other.m_shiftXY_, other.m_shiftZ_);
    else
        m_isInitialized = false;
}

PositionOffset3D& PositionOffset3D::operator=(const PositionOffset3D& other)
{
    m_deltaLongitude_ = other.m_deltaLongitude_;
    m_deltaLatitude_ = other.m_deltaLatitude_;
    m_deltaElevation_ = other.m_deltaElevation_;
    if (other.m_isInitialized)
        initialize(other.m_numBitsXY_, other.m_numBitsZ_, other.m_shiftXY_, other.m_shiftZ_);
    else
        m_isInitialized = false;

    return *this;
}

PositionOffset3D::PositionOffset3D(PositionOffset3D&& other) :
        m_deltaLongitude_(::std::move(other.m_deltaLongitude_)),
        m_deltaLatitude_(::std::move(other.m_deltaLatitude_)),
        m_deltaElevation_(::std::move(other.m_deltaElevation_))
{
    if (other.m_isInitialized)
        initialize(other.m_numBitsXY_, other.m_numBitsZ_, other.m_shiftXY_, other.m_shiftZ_);
    else
        m_isInitialized = false;
}

PositionOffset3D& PositionOffset3D::operator=(PositionOffset3D&& other)
{
    m_deltaLongitude_ = ::std::move(other.m_deltaLongitude_);
    m_deltaLatitude_ = ::std::move(other.m_deltaLatitude_);
    m_deltaElevation_ = ::std::move(other.m_deltaElevation_);
    if (other.m_isInitialized)
        initialize(other.m_numBitsXY_, other.m_numBitsZ_, other.m_shiftXY_, other.m_shiftZ_);
    else
        m_isInitialized = false;

    return *this;
}

PositionOffset3D::PositionOffset3D(::zserio::PropagateAllocatorT,
        const PositionOffset3D& other, const allocator_type& allocator) :
        m_deltaLongitude_(::zserio::allocatorPropagatingCopy(other.m_deltaLongitude_, allocator)),
        m_deltaLatitude_(::zserio::allocatorPropagatingCopy(other.m_deltaLatitude_, allocator)),
        m_deltaElevation_(::zserio::allocatorPropagatingCopy(other.m_deltaElevation_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_numBitsXY_, other.m_numBitsZ_, other.m_shiftXY_, other.m_shiftZ_);
    else
        m_isInitialized = false;
}

void PositionOffset3D::initialize(
        ::nds::core::geometry::CoordWidth numBitsXY_,
        ::nds::core::geometry::CoordWidth numBitsZ_,
        ::nds::core::geometry::CoordShift shiftXY_,
        ::nds::core::geometry::CoordShift shiftZ_)
{
    m_numBitsXY_ = numBitsXY_;
    m_numBitsZ_ = numBitsZ_;
    m_shiftXY_ = shiftXY_;
    m_shiftZ_ = shiftZ_;
    m_isInitialized = true;
}

bool PositionOffset3D::isInitialized() const
{
    return m_isInitialized;
}

::nds::core::geometry::CoordWidth PositionOffset3D::getNumBitsXY() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'numBitsXY' of compound 'PositionOffset3D' is not initialized!");

    return m_numBitsXY_;
}

::nds::core::geometry::CoordWidth PositionOffset3D::getNumBitsZ() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'numBitsZ' of compound 'PositionOffset3D' is not initialized!");

    return m_numBitsZ_;
}

::nds::core::geometry::CoordShift PositionOffset3D::getShiftXY() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'shiftXY' of compound 'PositionOffset3D' is not initialized!");

    return m_shiftXY_;
}

::nds::core::geometry::CoordShift PositionOffset3D::getShiftZ() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'shiftZ' of compound 'PositionOffset3D' is not initialized!");

    return m_shiftZ_;
}

int32_t PositionOffset3D::getDeltaLongitude() const
{
    return m_deltaLongitude_;
}

void PositionOffset3D::setDeltaLongitude(int32_t deltaLongitude_)
{
    m_deltaLongitude_ = deltaLongitude_;
}

int32_t PositionOffset3D::getDeltaLatitude() const
{
    return m_deltaLatitude_;
}

void PositionOffset3D::setDeltaLatitude(int32_t deltaLatitude_)
{
    m_deltaLatitude_ = deltaLatitude_;
}

int32_t PositionOffset3D::getDeltaElevation() const
{
    return m_deltaElevation_;
}

void PositionOffset3D::setDeltaElevation(int32_t deltaElevation_)
{
    m_deltaElevation_ = deltaElevation_;
}

::nds::core::geometry::DeltaLongitude PositionOffset3D::funcLon() const
{
    return static_cast<::nds::core::geometry::DeltaLongitude>(getDeltaLongitude() << getShiftXY());
}

::nds::core::geometry::DeltaLatitude PositionOffset3D::funcLat() const
{
    return static_cast<::nds::core::geometry::DeltaLatitude>(getDeltaLatitude() << getShiftXY());
}

::nds::core::geometry::DeltaElevation PositionOffset3D::funcEle() const
{
    return static_cast<::nds::core::geometry::DeltaElevation>(getDeltaElevation() << getShiftZ());
}

void PositionOffset3D::initPackingContext(PositionOffset3D::ZserioPackingContext& context) const
{
    context.getDeltaLongitude().init<::zserio::DynamicBitFieldArrayTraits<int32_t, ZserioElementBitSize_deltaLongitude>>(*this, m_deltaLongitude_);
    context.getDeltaLatitude().init<::zserio::DynamicBitFieldArrayTraits<int32_t, ZserioElementBitSize_deltaLatitude>>(*this, m_deltaLatitude_);
    context.getDeltaElevation().init<::zserio::DynamicBitFieldArrayTraits<int32_t, ZserioElementBitSize_deltaElevation>>(*this, m_deltaElevation_);
}

size_t PositionOffset3D::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += static_cast<uint8_t>(getNumBitsXY() + 1);
    endBitPosition += static_cast<uint8_t>(getNumBitsXY() + 1);
    endBitPosition += static_cast<uint8_t>(getNumBitsZ() + 1);

    return endBitPosition - bitPosition;
}

size_t PositionOffset3D::bitSizeOf(PositionOffset3D::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getDeltaLongitude().bitSizeOf<::zserio::DynamicBitFieldArrayTraits<int32_t, ZserioElementBitSize_deltaLongitude>>(*this, m_deltaLongitude_);
    endBitPosition += context.getDeltaLatitude().bitSizeOf<::zserio::DynamicBitFieldArrayTraits<int32_t, ZserioElementBitSize_deltaLatitude>>(*this, m_deltaLatitude_);
    endBitPosition += context.getDeltaElevation().bitSizeOf<::zserio::DynamicBitFieldArrayTraits<int32_t, ZserioElementBitSize_deltaElevation>>(*this, m_deltaElevation_);

    return endBitPosition - bitPosition;
}

size_t PositionOffset3D::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += static_cast<uint8_t>(getNumBitsXY() + 1);
    endBitPosition += static_cast<uint8_t>(getNumBitsXY() + 1);
    endBitPosition += static_cast<uint8_t>(getNumBitsZ() + 1);

    return endBitPosition;
}

size_t PositionOffset3D::initializeOffsets(PositionOffset3D::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getDeltaLongitude().bitSizeOf<::zserio::DynamicBitFieldArrayTraits<int32_t, ZserioElementBitSize_deltaLongitude>>(*this, m_deltaLongitude_);
    endBitPosition += context.getDeltaLatitude().bitSizeOf<::zserio::DynamicBitFieldArrayTraits<int32_t, ZserioElementBitSize_deltaLatitude>>(*this, m_deltaLatitude_);
    endBitPosition += context.getDeltaElevation().bitSizeOf<::zserio::DynamicBitFieldArrayTraits<int32_t, ZserioElementBitSize_deltaElevation>>(*this, m_deltaElevation_);

    return endBitPosition;
}

bool PositionOffset3D::operator==(const PositionOffset3D& other) const
{
    if (this != &other)
    {
        return
                (getNumBitsXY() == other.getNumBitsXY()) &&
                (getNumBitsZ() == other.getNumBitsZ()) &&
                (getShiftXY() == other.getShiftXY()) &&
                (getShiftZ() == other.getShiftZ()) &&
                (m_deltaLongitude_ == other.m_deltaLongitude_) &&
                (m_deltaLatitude_ == other.m_deltaLatitude_) &&
                (m_deltaElevation_ == other.m_deltaElevation_);
    }

    return true;
}

uint32_t PositionOffset3D::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getNumBitsXY());
    result = ::zserio::calcHashCode(result, getNumBitsZ());
    result = ::zserio::calcHashCode(result, getShiftXY());
    result = ::zserio::calcHashCode(result, getShiftZ());
    result = ::zserio::calcHashCode(result, m_deltaLongitude_);
    result = ::zserio::calcHashCode(result, m_deltaLatitude_);
    result = ::zserio::calcHashCode(result, m_deltaElevation_);

    return result;
}

void PositionOffset3D::write(::zserio::BitStreamWriter& out) const
{
    out.writeSignedBits(m_deltaLongitude_, static_cast<uint8_t>(getNumBitsXY() + 1));
    out.writeSignedBits(m_deltaLatitude_, static_cast<uint8_t>(getNumBitsXY() + 1));
    out.writeSignedBits(m_deltaElevation_, static_cast<uint8_t>(getNumBitsZ() + 1));
}

void PositionOffset3D::write(PositionOffset3D::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getDeltaLongitude().write<::zserio::DynamicBitFieldArrayTraits<int32_t, ZserioElementBitSize_deltaLongitude>>(*this, out, m_deltaLongitude_);
    context.getDeltaLatitude().write<::zserio::DynamicBitFieldArrayTraits<int32_t, ZserioElementBitSize_deltaLatitude>>(*this, out, m_deltaLatitude_);
    context.getDeltaElevation().write<::zserio::DynamicBitFieldArrayTraits<int32_t, ZserioElementBitSize_deltaElevation>>(*this, out, m_deltaElevation_);
}

uint8_t PositionOffset3D::ZserioElementBitSize_deltaLongitude::get(const PositionOffset3D& owner)
{
    return static_cast<uint8_t>(owner.getNumBitsXY() + 1);
}

uint8_t PositionOffset3D::ZserioElementBitSize_deltaLatitude::get(const PositionOffset3D& owner)
{
    return static_cast<uint8_t>(owner.getNumBitsXY() + 1);
}

uint8_t PositionOffset3D::ZserioElementBitSize_deltaElevation::get(const PositionOffset3D& owner)
{
    return static_cast<uint8_t>(owner.getNumBitsZ() + 1);
}

int32_t PositionOffset3D::readDeltaLongitude(::zserio::BitStreamReader& in)
{
    return static_cast<int32_t>(in.readSignedBits(static_cast<uint8_t>(getNumBitsXY() + 1)));
}

int32_t PositionOffset3D::readDeltaLongitude(PositionOffset3D::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getDeltaLongitude().read<::zserio::DynamicBitFieldArrayTraits<int32_t, ZserioElementBitSize_deltaLongitude>>(*this, in);
}
int32_t PositionOffset3D::readDeltaLatitude(::zserio::BitStreamReader& in)
{
    return static_cast<int32_t>(in.readSignedBits(static_cast<uint8_t>(getNumBitsXY() + 1)));
}

int32_t PositionOffset3D::readDeltaLatitude(PositionOffset3D::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getDeltaLatitude().read<::zserio::DynamicBitFieldArrayTraits<int32_t, ZserioElementBitSize_deltaLatitude>>(*this, in);
}
int32_t PositionOffset3D::readDeltaElevation(::zserio::BitStreamReader& in)
{
    return static_cast<int32_t>(in.readSignedBits(static_cast<uint8_t>(getNumBitsZ() + 1)));
}

int32_t PositionOffset3D::readDeltaElevation(PositionOffset3D::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getDeltaElevation().read<::zserio::DynamicBitFieldArrayTraits<int32_t, ZserioElementBitSize_deltaElevation>>(*this, in);
}

} // namespace geometry
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ConstraintException.h>

#include <nds/core/geometry/Line2D.h>

namespace nds
{
namespace core
{
namespace geometry
{

Line2D::Line2D(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numPositions_(uint32_t()),
        m_positions_(allocator)
{
}

Line2D::Line2D(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift shift_, const allocator_type& allocator) :
        m_shift_(shift_),
        m_isInitialized(true),
        m_numPositions_(readNumPositions(in)),
        m_positions_(readPositions(in, allocator))
{
}

Line2D::Line2D(Line2D::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift shift_, const allocator_type& allocator) :
        m_shift_(shift_),
        m_isInitialized(true),
        m_numPositions_(readNumPositions(context, in)),
        m_positions_(readPositions(context, in, allocator))
{
}

Line2D::Line2D(const Line2D& other) :
        m_numPositions_(other.m_numPositions_),
        m_positions_(other.m_positions_)
{
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;
}

Line2D& Line2D::operator=(const Line2D& other)
{
    m_numPositions_ = other.m_numPositions_;
    m_positions_ = other.m_positions_;
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;

    return *this;
}

Line2D::Line2D(Line2D&& other) :
        m_numPositions_(::std::move(other.m_numPositions_)),
        m_positions_(::std::move(other.m_positions_))
{
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;
}

Line2D& Line2D::operator=(Line2D&& other)
{
    m_numPositions_ = ::std::move(other.m_numPositions_);
    m_positions_ = ::std::move(other.m_positions_);
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;

    return *this;
}

Line2D::Line2D(::zserio::PropagateAllocatorT,
        const Line2D& other, const allocator_type& allocator) :
        m_numPositions_(::zserio::allocatorPropagatingCopy(other.m_numPositions_, allocator)),
        m_positions_(::zserio::allocatorPropagatingCopy(other.m_positions_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;
}

void Line2D::initialize(
        ::nds::core::geometry::CoordShift shift_)
{
    m_shift_ = shift_;
    m_isInitialized = true;

    initializeChildren();
}

bool Line2D::isInitialized() const
{
    return m_isInitialized;
}

void Line2D::initializeChildren()
{
    m_positions_.initializeElements(*this);
}

::nds::core::geometry::CoordShift Line2D::getShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'shift' of compound 'Line2D' is not initialized!");

    return m_shift_;
}

uint32_t Line2D::getNumPositions() const
{
    return m_numPositions_;
}

void Line2D::setNumPositions(uint32_t numPositions_)
{
    m_numPositions_ = numPositions_;
}

::zserio::vector<::nds::core::geometry::Position2D>& Line2D::getPositions()
{
    return m_positions_.getRawArray();
}

const ::zserio::vector<::nds::core::geometry::Position2D>& Line2D::getPositions() const
{
    return m_positions_.getRawArray();
}

void Line2D::setPositions(const ::zserio::vector<::nds::core::geometry::Position2D>& positions_)
{
    m_positions_ = ZserioArrayType_positions(positions_);
}

void Line2D::setPositions(::zserio::vector<::nds::core::geometry::Position2D>&& positions_)
{
    m_positions_ = ZserioArrayType_positions(std::move(positions_));
}

uint32_t Line2D::funcLastPositionIdx() const
{
    return static_cast<uint32_t>((getNumPositions() - 1));
}

void Line2D::initPackingContext(Line2D::ZserioPackingContext& context) const
{
    context.getNumPositions().init<::zserio::VarSizeArrayTraits>(m_numPositions_);
}

size_t Line2D::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numPositions_);
    endBitPosition += m_positions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t Line2D::bitSizeOf(Line2D::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumPositions().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numPositions_);
    endBitPosition += m_positions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t Line2D::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numPositions_);
    endBitPosition = m_positions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t Line2D::initializeOffsets(Line2D::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumPositions().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numPositions_);
    endBitPosition = m_positions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool Line2D::operator==(const Line2D& other) const
{
    if (this != &other)
    {
        return
                (getShift() == other.getShift()) &&
                (m_numPositions_ == other.m_numPositions_) &&
                (m_positions_ == other.m_positions_);
    }

    return true;
}

uint32_t Line2D::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getShift());
    result = ::zserio::calcHashCode(result, m_numPositions_);
    result = ::zserio::calcHashCode(result, m_positions_);

    return result;
}

void Line2D::write(::zserio::BitStreamWriter& out) const
{
    // check constraint
    if (!(getNumPositions() > 0))
        throw ::zserio::ConstraintException("Write: Constraint violated at Line2D.numPositions!");
    out.writeVarSize(m_numPositions_);

    // check array length
    if (m_positions_.getRawArray().size() != static_cast<size_t>(getNumPositions()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field Line2D.positions: ") <<
                m_positions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumPositions()) << "!";
    }
    m_positions_.writePacked(*this, out);
}

void Line2D::write(Line2D::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    // check constraint
    if (!(getNumPositions() > 0))
        throw ::zserio::ConstraintException("Write: Constraint violated at Line2D.numPositions!");
    context.getNumPositions().write<::zserio::VarSizeArrayTraits>(out, m_numPositions_);

    // check array length
    if (m_positions_.getRawArray().size() != static_cast<size_t>(getNumPositions()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field Line2D.positions: ") <<
                m_positions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumPositions()) << "!";
    }
    m_positions_.writePacked(*this, out);
}

void Line2D::ZserioArrayExpressions_positions::initializeElement(Line2D& owner,
        ::nds::core::geometry::Position2D& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getShift()));
}

void Line2D::ZserioElementFactory_positions::create(Line2D&         owner,
        ::zserio::vector<::nds::core::geometry::Position2D>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getShift()), array.get_allocator());
}

void Line2D::ZserioElementFactory_positions::create(Line2D&         owner,
        ::zserio::vector<::nds::core::geometry::Position2D>& array,
        ::nds::core::geometry::Position2D::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getShift()), array.get_allocator());
}

uint32_t Line2D::readNumPositions(::zserio::BitStreamReader& in)
{
    uint32_t readField = static_cast<uint32_t>(in.readVarSize());
    // check constraint
    if (!(readField > 0))
        throw ::zserio::ConstraintException("Read: Constraint violated at Line2D.numPositions!");

    return readField;
}

uint32_t Line2D::readNumPositions(Line2D::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    uint32_t readField = context.getNumPositions().read<::zserio::VarSizeArrayTraits>(in);
    // check constraint
    if (!(readField > 0))
        throw ::zserio::ConstraintException("Read: Constraint violated at Line2D.numPositions!");

    return readField;
}
Line2D::ZserioArrayType_positions Line2D::readPositions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_positions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumPositions()));

    return readField;
}

Line2D::ZserioArrayType_positions Line2D::readPositions(Line2D::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_positions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumPositions()));

    return readField;
}

} // namespace geometry
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/core/geometry/LinePositionOffset2D.h>

namespace nds
{
namespace core
{
namespace geometry
{

LinePositionOffset2D::LinePositionOffset2D(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_linePosition_(::nds::core::geometry::LinePosition()),
        m_numBits_(::nds::core::geometry::CoordWidth()),
        m_offset_(allocator)
{
}

LinePositionOffset2D::LinePositionOffset2D(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift shift_, const allocator_type& allocator) :
        m_shift_(shift_),
        m_isInitialized(true),
        m_linePosition_(readLinePosition(in)),
        m_numBits_(readNumBits(in)),
        m_offset_(readOffset(in, allocator))
{
}

LinePositionOffset2D::LinePositionOffset2D(LinePositionOffset2D::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift shift_, const allocator_type& allocator) :
        m_shift_(shift_),
        m_isInitialized(true),
        m_linePosition_(readLinePosition(context, in)),
        m_numBits_(readNumBits(context, in)),
        m_offset_(readOffset(context, in, allocator))
{
}

LinePositionOffset2D::LinePositionOffset2D(const LinePositionOffset2D& other) :
        m_linePosition_(other.m_linePosition_),
        m_numBits_(other.m_numBits_),
        m_offset_(other.m_offset_)
{
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;
}

LinePositionOffset2D& LinePositionOffset2D::operator=(const LinePositionOffset2D& other)
{
    m_linePosition_ = other.m_linePosition_;
    m_numBits_ = other.m_numBits_;
    m_offset_ = other.m_offset_;
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;

    return *this;
}

LinePositionOffset2D::LinePositionOffset2D(LinePositionOffset2D&& other) :
        m_linePosition_(::std::move(other.m_linePosition_)),
        m_numBits_(::std::move(other.m_numBits_)),
        m_offset_(::std::move(other.m_offset_))
{
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;
}

LinePositionOffset2D& LinePositionOffset2D::operator=(LinePositionOffset2D&& other)
{
    m_linePosition_ = ::std::move(other.m_linePosition_);
    m_numBits_ = ::std::move(other.m_numBits_);
    m_offset_ = ::std::move(other.m_offset_);
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;

    return *this;
}

LinePositionOffset2D::LinePositionOffset2D(::zserio::PropagateAllocatorT,
        const LinePositionOffset2D& other, const allocator_type& allocator) :
        m_linePosition_(::zserio::allocatorPropagatingCopy(other.m_linePosition_, allocator)),
        m_numBits_(::zserio::allocatorPropagatingCopy(other.m_numBits_, allocator)),
        m_offset_(::zserio::allocatorPropagatingCopy(other.m_offset_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;
}

void LinePositionOffset2D::initialize(
        ::nds::core::geometry::CoordShift shift_)
{
    m_shift_ = shift_;
    m_isInitialized = true;

    initializeChildren();
}

bool LinePositionOffset2D::isInitialized() const
{
    return m_isInitialized;
}

void LinePositionOffset2D::initializeChildren()
{
    m_offset_.initialize(static_cast<::nds::core::geometry::CoordWidth>(getNumBits()), static_cast<::nds::core::geometry::CoordShift>(getShift()));
}

::nds::core::geometry::CoordShift LinePositionOffset2D::getShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'shift' of compound 'LinePositionOffset2D' is not initialized!");

    return m_shift_;
}

::nds::core::geometry::LinePosition LinePositionOffset2D::getLinePosition() const
{
    return m_linePosition_;
}

void LinePositionOffset2D::setLinePosition(::nds::core::geometry::LinePosition linePosition_)
{
    m_linePosition_ = linePosition_;
}

::nds::core::geometry::CoordWidth LinePositionOffset2D::getNumBits() const
{
    return m_numBits_;
}

void LinePositionOffset2D::setNumBits(::nds::core::geometry::CoordWidth numBits_)
{
    m_numBits_ = numBits_;
}

::nds::core::geometry::PositionOffset2D& LinePositionOffset2D::getOffset()
{
    return m_offset_;
}

const ::nds::core::geometry::PositionOffset2D& LinePositionOffset2D::getOffset() const
{
    return m_offset_;
}

void LinePositionOffset2D::setOffset(const ::nds::core::geometry::PositionOffset2D& offset_)
{
    m_offset_ = offset_;
}

void LinePositionOffset2D::setOffset(::nds::core::geometry::PositionOffset2D&& offset_)
{
    m_offset_ = ::std::move(offset_);
}

void LinePositionOffset2D::initPackingContext(LinePositionOffset2D::ZserioPackingContext& context) const
{
    context.getLinePosition().init<::zserio::VarSizeArrayTraits>(m_linePosition_);
    context.getNumBits().init<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordWidth, UINT8_C(5)>>(m_numBits_);
    m_offset_.initPackingContext(context.getOffset());
}

size_t LinePositionOffset2D::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_linePosition_);
    endBitPosition += UINT8_C(5);
    endBitPosition += m_offset_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LinePositionOffset2D::bitSizeOf(LinePositionOffset2D::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getLinePosition().bitSizeOf<::zserio::VarSizeArrayTraits>(m_linePosition_);
    endBitPosition += context.getNumBits().bitSizeOf<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordWidth, UINT8_C(5)>>(m_numBits_);
    endBitPosition += m_offset_.bitSizeOf(context.getOffset(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LinePositionOffset2D::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_linePosition_);
    endBitPosition += UINT8_C(5);
    endBitPosition = m_offset_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t LinePositionOffset2D::initializeOffsets(LinePositionOffset2D::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getLinePosition().bitSizeOf<::zserio::VarSizeArrayTraits>(m_linePosition_);
    endBitPosition += context.getNumBits().bitSizeOf<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordWidth, UINT8_C(5)>>(m_numBits_);
    endBitPosition = m_offset_.initializeOffsets(context.getOffset(), endBitPosition);

    return endBitPosition;
}

bool LinePositionOffset2D::operator==(const LinePositionOffset2D& other) const
{
    if (this != &other)
    {
        return
                (getShift() == other.getShift()) &&
                (m_linePosition_ == other.m_linePosition_) &&
                (m_numBits_ == other.m_numBits_) &&
                (m_offset_ == other.m_offset_);
    }

    return true;
}

uint32_t LinePositionOffset2D::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getShift());
    result = ::zserio::calcHashCode(result, m_linePosition_);
    result = ::zserio::calcHashCode(result, m_numBits_);
    result = ::zserio::calcHashCode(result, m_offset_);

    return result;
}

void LinePositionOffset2D::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_linePosition_);

    out.writeBits(m_numBits_, UINT8_C(5));

    // check parameters
    if (m_offset_.getNumBits() != static_cast<::nds::core::geometry::CoordWidth>(getNumBits()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numBits for field LinePositionOffset2D.offset: ") <<
                m_offset_.getNumBits() << " != " << static_cast<::nds::core::geometry::CoordWidth>(getNumBits()) << "!";
    }
    if (m_offset_.getShift() != static_cast<::nds::core::geometry::CoordShift>(getShift()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field LinePositionOffset2D.offset: ") <<
                m_offset_.getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShift()) << "!";
    }
    m_offset_.write(out);
}

void LinePositionOffset2D::write(LinePositionOffset2D::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getLinePosition().write<::zserio::VarSizeArrayTraits>(out, m_linePosition_);

    context.getNumBits().write<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordWidth, UINT8_C(5)>>(out, m_numBits_);

    // check parameters
    if (m_offset_.getNumBits() != static_cast<::nds::core::geometry::CoordWidth>(getNumBits()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numBits for field LinePositionOffset2D.offset: ") <<
                m_offset_.getNumBits() << " != " << static_cast<::nds::core::geometry::CoordWidth>(getNumBits()) << "!";
    }
    if (m_offset_.getShift() != static_cast<::nds::core::geometry::CoordShift>(getShift()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field LinePositionOffset2D.offset: ") <<
                m_offset_.getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShift()) << "!";
    }
    m_offset_.write(context.getOffset(), out);
}

::nds::core::geometry::LinePosition LinePositionOffset2D::readLinePosition(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::geometry::LinePosition>(in.readVarSize());
}

::nds::core::geometry::LinePosition LinePositionOffset2D::readLinePosition(LinePositionOffset2D::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getLinePosition().read<::zserio::VarSizeArrayTraits>(in);
}
::nds::core::geometry::CoordWidth LinePositionOffset2D::readNumBits(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::geometry::CoordWidth>(in.readBits(UINT8_C(5)));
}

::nds::core::geometry::CoordWidth LinePositionOffset2D::readNumBits(LinePositionOffset2D::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumBits().read<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordWidth, UINT8_C(5)>>(in);
}
::nds::core::geometry::PositionOffset2D LinePositionOffset2D::readOffset(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::geometry::PositionOffset2D(in, static_cast<::nds::core::geometry::CoordWidth>(getNumBits()), static_cast<::nds::core::geometry::CoordShift>(getShift()), allocator);
}

::nds::core::geometry::PositionOffset2D LinePositionOffset2D::readOffset(LinePositionOffset2D::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::geometry::PositionOffset2D(context.getOffset(), in, static_cast<::nds::core::geometry::CoordWidth>(getNumBits()), static_cast<::nds::core::geometry::CoordShift>(getShift()), allocator);
}

} // namespace geometry
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ConstraintException.h>

#include <nds/core/geometry/Line3D.h>

namespace nds
{
namespace core
{
namespace geometry
{

Line3D::Line3D(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numPositions_(uint32_t()),
        m_positions_(allocator)
{
}

Line3D::Line3D(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift shiftXY_,
        ::nds::core::geometry::CoordShift shiftZ_, const allocator_type& allocator) :
        m_shiftXY_(shiftXY_),
        m_shiftZ_(shiftZ_),
        m_isInitialized(true),
        m_numPositions_(readNumPositions(in)),
        m_positions_(readPositions(in, allocator))
{
}

Line3D::Line3D(Line3D::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift shiftXY_,
        ::nds::core::geometry::CoordShift shiftZ_, const allocator_type& allocator) :
        m_shiftXY_(shiftXY_),
        m_shiftZ_(shiftZ_),
        m_isInitialized(true),
        m_numPositions_(readNumPositions(context, in)),
        m_positions_(readPositions(context, in, allocator))
{
}

Line3D::Line3D(const Line3D& other) :
        m_numPositions_(other.m_numPositions_),
        m_positions_(other.m_positions_)
{
    if (other.m_isInitialized)
        initialize(other.m_shiftXY_, other.m_shiftZ_);
    else
        m_isInitialized = false;
}

Line3D& Line3D::operator=(const Line3D& other)
{
    m_numPositions_ = other.m_numPositions_;
    m_positions_ = other.m_positions_;
    if (other.m_isInitialized)
        initialize(other.m_shiftXY_, other.m_shiftZ_);
    else
        m_isInitialized = false;

    return *this;
}

Line3D::Line3D(Line3D&& other) :
        m_numPositions_(::std::move(other.m_numPositions_)),
        m_positions_(::std::move(other.m_positions_))
{
    if (other.m_isInitialized)
        initialize(other.m_shiftXY_, other.m_shiftZ_);
    else
        m_isInitialized = false;
}

Line3D& Line3D::operator=(Line3D&& other)
{
    m_numPositions_ = ::std::move(other.m_numPositions_);
    m_positions_ = ::std::move(other.m_positions_);
    if (other.m_isInitialized)
        initialize(other.m_shiftXY_, other.m_shiftZ_);
    else
        m_isInitialized = false;

    return *this;
}

Line3D::Line3D(::zserio::PropagateAllocatorT,
        const Line3D& other, const allocator_type& allocator) :
        m_numPositions_(::zserio::allocatorPropagatingCopy(other.m_numPositions_, allocator)),
        m_positions_(::zserio::allocatorPropagatingCopy(other.m_positions_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_shiftXY_, other.m_shiftZ_);
    else
        m_isInitialized = false;
}

void Line3D::initialize(
        ::nds::core::geometry::CoordShift shiftXY_,
        ::nds::core::geometry::CoordShift shiftZ_)
{
    m_shiftXY_ = shiftXY_;
    m_shiftZ_ = shiftZ_;
    m_isInitialized = true;

    initializeChildren();
}

bool Line3D::isInitialized() const
{
    return m_isInitialized;
}

void Line3D::initializeChildren()
{
    m_positions_.initializeElements(*this);
}

::nds::core::geometry::CoordShift Line3D::getShiftXY() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'shiftXY' of compound 'Line3D' is not initialized!");

    return m_shiftXY_;
}

::nds::core::geometry::CoordShift Line3D::getShiftZ() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'shiftZ' of compound 'Line3D' is not initialized!");

    return m_shiftZ_;
}

uint32_t Line3D::getNumPositions() const
{
    return m_numPositions_;
}

void Line3D::setNumPositions(uint32_t numPositions_)
{
    m_numPositions_ = numPositions_;
}

::zserio::vector<::nds::core::geometry::Position3D>& Line3D::getPositions()
{
    return m_positions_.getRawArray();
}

const ::zserio::vector<::nds::core::geometry::Position3D>& Line3D::getPositions() const
{
    return m_positions_.getRawArray();
}

void Line3D::setPositions(const ::zserio::vector<::nds::core::geometry::Position3D>& positions_)
{
    m_positions_ = ZserioArrayType_positions(positions_);
}

void Line3D::setPositions(::zserio::vector<::nds::core::geometry::Position3D>&& positions_)
{
    m_positions_ = ZserioArrayType_positions(std::move(positions_));
}

uint32_t Line3D::funcLastPositionIdx() const
{
    return static_cast<uint32_t>(getNumPositions() - 1);
}

void Line3D::initPackingContext(Line3D::ZserioPackingContext& context) const
{
    context.getNumPositions().init<::zserio::VarSizeArrayTraits>(m_numPositions_);
}

size_t Line3D::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numPositions_);
    endBitPosition += m_positions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t Line3D::bitSizeOf(Line3D::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumPositions().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numPositions_);
    endBitPosition += m_positions_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t Line3D::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numPositions_);
    endBitPosition = m_positions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t Line3D::initializeOffsets(Line3D::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumPositions().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numPositions_);
    endBitPosition = m_positions_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool Line3D::operator==(const Line3D& other) const
{
    if (this != &other)
    {
        return
                (getShiftXY() == other.getShiftXY()) &&
                (getShiftZ() == other.getShiftZ()) &&
                (m_numPositions_ == other.m_numPositions_) &&
                (m_positions_ == other.m_positions_);
    }

    return true;
}

uint32_t Line3D::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getShiftXY());
    result = ::zserio::calcHashCode(result, getShiftZ());
    result = ::zserio::calcHashCode(result, m_numPositions_);
    result = ::zserio::calcHashCode(result, m_positions_);

    return result;
}

void Line3D::write(::zserio::BitStreamWriter& out) const
{
    // check constraint
    if (!(getNumPositions() > 0))
        throw ::zserio::ConstraintException("Write: Constraint violated at Line3D.numPositions!");
    out.writeVarSize(m_numPositions_);

    // check array length
    if (m_positions_.getRawArray().size() != static_cast<size_t>(getNumPositions()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field Line3D.positions: ") <<
                m_positions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumPositions()) << "!";
    }
    m_positions_.writePacked(*this, out);
}

void Line3D::write(Line3D::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    // check constraint
    if (!(getNumPositions() > 0))
        throw ::zserio::ConstraintException("Write: Constraint violated at Line3D.numPositions!");
    context.getNumPositions().write<::zserio::VarSizeArrayTraits>(out, m_numPositions_);

    // check array length
    if (m_positions_.getRawArray().size() != static_cast<size_t>(getNumPositions()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field Line3D.positions: ") <<
                m_positions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumPositions()) << "!";
    }
    m_positions_.writePacked(*this, out);
}

void Line3D::ZserioArrayExpressions_positions::initializeElement(Line3D& owner,
        ::nds::core::geometry::Position3D& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getShiftXY()), static_cast<::nds::core::geometry::CoordShift>(owner.getShiftZ()));
}

void Line3D::ZserioElementFactory_positions::create(Line3D&         owner,
        ::zserio::vector<::nds::core::geometry::Position3D>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getShiftXY()), static_cast<::nds::core::geometry::CoordShift>(owner.getShiftZ()), array.get_allocator());
}

void Line3D::ZserioElementFactory_positions::create(Line3D&         owner,
        ::zserio::vector<::nds::core::geometry::Position3D>& array,
        ::nds::core::geometry::Position3D::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getShiftXY()), static_cast<::nds::core::geometry::CoordShift>(owner.getShiftZ()), array.get_allocator());
}

uint32_t Line3D::readNumPositions(::zserio::BitStreamReader& in)
{
    uint32_t readField = static_cast<uint32_t>(in.readVarSize());
    // check constraint
    if (!(readField > 0))
        throw ::zserio::ConstraintException("Read: Constraint violated at Line3D.numPositions!");

    return readField;
}

uint32_t Line3D::readNumPositions(Line3D::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    uint32_t readField = context.getNumPositions().read<::zserio::VarSizeArrayTraits>(in);
    // check constraint
    if (!(readField > 0))
        throw ::zserio::ConstraintException("Read: Constraint violated at Line3D.numPositions!");

    return readField;
}
Line3D::ZserioArrayType_positions Line3D::readPositions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_positions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumPositions()));

    return readField;
}

Line3D::ZserioArrayType_positions Line3D::readPositions(Line3D::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_positions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumPositions()));

    return readField;
}

} // namespace geometry
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/core/geometry/LinePositionOffset3D.h>

namespace nds
{
namespace core
{
namespace geometry
{

LinePositionOffset3D::LinePositionOffset3D(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_linePosition_(::nds::core::geometry::LinePosition()),
        m_numBitsXY_(::nds::core::geometry::CoordWidth()),
        m_numBitsZ_(::nds::core::geometry::CoordWidth()),
        m_offset_(allocator)
{
}

LinePositionOffset3D::LinePositionOffset3D(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift shiftXY_,
        ::nds::core::geometry::CoordShift shiftZ_, const allocator_type& allocator) :
        m_shiftXY_(shiftXY_),
        m_shiftZ_(shiftZ_),
        m_isInitialized(true),
        m_linePosition_(readLinePosition(in)),
        m_numBitsXY_(readNumBitsXY(in)),
        m_numBitsZ_(readNumBitsZ(in)),
        m_offset_(readOffset(in, allocator))
{
}

LinePositionOffset3D::LinePositionOffset3D(LinePositionOffset3D::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift shiftXY_,
        ::nds::core::geometry::CoordShift shiftZ_, const allocator_type& allocator) :
        m_shiftXY_(shiftXY_),
        m_shiftZ_(shiftZ_),
        m_isInitialized(true),
        m_linePosition_(readLinePosition(context, in)),
        m_numBitsXY_(readNumBitsXY(context, in)),
        m_numBitsZ_(readNumBitsZ(context, in)),
        m_offset_(readOffset(context, in, allocator))
{
}

LinePositionOffset3D::LinePositionOffset3D(const LinePositionOffset3D& other) :
        m_linePosition_(other.m_linePosition_),
        m_numBitsXY_(other.m_numBitsXY_),
        m_numBitsZ_(other.m_numBitsZ_),
        m_offset_(other.m_offset_)
{
    if (other.m_isInitialized)
        initialize(other.m_shiftXY_, other.m_shiftZ_);
    else
        m_isInitialized = false;
}

LinePositionOffset3D& LinePositionOffset3D::operator=(const LinePositionOffset3D& other)
{
    m_linePosition_ = other.m_linePosition_;
    m_numBitsXY_ = other.m_numBitsXY_;
    m_numBitsZ_ = other.m_numBitsZ_;
    m_offset_ = other.m_offset_;
    if (other.m_isInitialized)
        initialize(other.m_shiftXY_, other.m_shiftZ_);
    else
        m_isInitialized = false;

    return *this;
}

LinePositionOffset3D::LinePositionOffset3D(LinePositionOffset3D&& other) :
        m_linePosition_(::std::move(other.m_linePosition_)),
        m_numBitsXY_(::std::move(other.m_numBitsXY_)),
        m_numBitsZ_(::std::move(other.m_numBitsZ_)),
        m_offset_(::std::move(other.m_offset_))
{
    if (other.m_isInitialized)
        initialize(other.m_shiftXY_, other.m_shiftZ_);
    else
        m_isInitialized = false;
}

LinePositionOffset3D& LinePositionOffset3D::operator=(LinePositionOffset3D&& other)
{
    m_linePosition_ = ::std::move(other.m_linePosition_);
    m_numBitsXY_ = ::std::move(other.m_numBitsXY_);
    m_numBitsZ_ = ::std::move(other.m_numBitsZ_);
    m_offset_ = ::std::move(other.m_offset_);
    if (other.m_isInitialized)
        initialize(other.m_shiftXY_, other.m_shiftZ_);
    else
        m_isInitialized = false;

    return *this;
}

LinePositionOffset3D::LinePositionOffset3D(::zserio::PropagateAllocatorT,
        const LinePositionOffset3D& other, const allocator_type& allocator) :
        m_linePosition_(::zserio::allocatorPropagatingCopy(other.m_linePosition_, allocator)),
        m_numBitsXY_(::zserio::allocatorPropagatingCopy(other.m_numBitsXY_, allocator)),
        m_numBitsZ_(::zserio::allocatorPropagatingCopy(other.m_numBitsZ_, allocator)),
        m_offset_(::zserio::allocatorPropagatingCopy(other.m_offset_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_shiftXY_, other.m_shiftZ_);
    else
        m_isInitialized = false;
}

void LinePositionOffset3D::initialize(
        ::nds::core::geometry::CoordShift shiftXY_,
        ::nds::core::geometry::CoordShift shiftZ_)
{
    m_shiftXY_ = shiftXY_;
    m_shiftZ_ = shiftZ_;
    m_isInitialized = true;

    initializeChildren();
}

bool LinePositionOffset3D::isInitialized() const
{
    return m_isInitialized;
}

void LinePositionOffset3D::initializeChildren()
{
    m_offset_.initialize(static_cast<::nds::core::geometry::CoordWidth>(getNumBitsXY()), static_cast<::nds::core::geometry::CoordWidth>(getNumBitsZ()), static_cast<::nds::core::geometry::CoordShift>(getShiftXY()), static_cast<::nds::core::geometry::CoordShift>(getShiftZ()));
}

::nds::core::geometry::CoordShift LinePositionOffset3D::getShiftXY() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'shiftXY' of compound 'LinePositionOffset3D' is not initialized!");

    return m_shiftXY_;
}

::nds::core::geometry::CoordShift LinePositionOffset3D::getShiftZ() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'shiftZ' of compound 'LinePositionOffset3D' is not initialized!");

    return m_shiftZ_;
}

::nds::core::geometry::LinePosition LinePositionOffset3D::getLinePosition() const
{
    return m_linePosition_;
}

void LinePositionOffset3D::setLinePosition(::nds::core::geometry::LinePosition linePosition_)
{
    m_linePosition_ = linePosition_;
}

::nds::core::geometry::CoordWidth LinePositionOffset3D::getNumBitsXY() const
{
    return m_numBitsXY_;
}

void LinePositionOffset3D::setNumBitsXY(::nds::core::geometry::CoordWidth numBitsXY_)
{
    m_numBitsXY_ = numBitsXY_;
}

::nds::core::geometry::CoordWidth LinePositionOffset3D::getNumBitsZ() const
{
    return m_numBitsZ_;
}

void LinePositionOffset3D::setNumBitsZ(::nds::core::geometry::CoordWidth numBitsZ_)
{
    m_numBitsZ_ = numBitsZ_;
}

::nds::core::geometry::PositionOffset3D& LinePositionOffset3D::getOffset()
{
    return m_offset_;
}

const ::nds::core::geometry::PositionOffset3D& LinePositionOffset3D::getOffset() const
{
    return m_offset_;
}

void LinePositionOffset3D::setOffset(const ::nds::core::geometry::PositionOffset3D& offset_)
{
    m_offset_ = offset_;
}

void LinePositionOffset3D::setOffset(::nds::core::geometry::PositionOffset3D&& offset_)
{
    m_offset_ = ::std::move(offset_);
}

void LinePositionOffset3D::initPackingContext(LinePositionOffset3D::ZserioPackingContext& context) const
{
    context.getLinePosition().init<::zserio::VarSizeArrayTraits>(m_linePosition_);
    context.getNumBitsXY().init<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordWidth, UINT8_C(5)>>(m_numBitsXY_);
    context.getNumBitsZ().init<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordWidth, UINT8_C(5)>>(m_numBitsZ_);
    m_offset_.initPackingContext(context.getOffset());
}

size_t LinePositionOffset3D::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_linePosition_);
    endBitPosition += UINT8_C(5);
    endBitPosition += UINT8_C(5);
    endBitPosition += m_offset_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LinePositionOffset3D::bitSizeOf(LinePositionOffset3D::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getLinePosition().bitSizeOf<::zserio::VarSizeArrayTraits>(m_linePosition_);
    endBitPosition += context.getNumBitsXY().bitSizeOf<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordWidth, UINT8_C(5)>>(m_numBitsXY_);
    endBitPosition += context.getNumBitsZ().bitSizeOf<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordWidth, UINT8_C(5)>>(m_numBitsZ_);
    endBitPosition += m_offset_.bitSizeOf(context.getOffset(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t LinePositionOffset3D::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_linePosition_);
    endBitPosition += UINT8_C(5);
    endBitPosition += UINT8_C(5);
    endBitPosition = m_offset_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t LinePositionOffset3D::initializeOffsets(LinePositionOffset3D::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getLinePosition().bitSizeOf<::zserio::VarSizeArrayTraits>(m_linePosition_);
    endBitPosition += context.getNumBitsXY().bitSizeOf<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordWidth, UINT8_C(5)>>(m_numBitsXY_);
    endBitPosition += context.getNumBitsZ().bitSizeOf<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordWidth, UINT8_C(5)>>(m_numBitsZ_);
    endBitPosition = m_offset_.initializeOffsets(context.getOffset(), endBitPosition);

    return endBitPosition;
}

bool LinePositionOffset3D::operator==(const LinePositionOffset3D& other) const
{
    if (this != &other)
    {
        return
                (getShiftXY() == other.getShiftXY()) &&
                (getShiftZ() == other.getShiftZ()) &&
                (m_linePosition_ == other.m_linePosition_) &&
                (m_numBitsXY_ == other.m_numBitsXY_) &&
                (m_numBitsZ_ == other.m_numBitsZ_) &&
                (m_offset_ == other.m_offset_);
    }

    return true;
}

uint32_t LinePositionOffset3D::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getShiftXY());
    result = ::zserio::calcHashCode(result, getShiftZ());
    result = ::zserio::calcHashCode(result, m_linePosition_);
    result = ::zserio::calcHashCode(result, m_numBitsXY_);
    result = ::zserio::calcHashCode(result, m_numBitsZ_);
    result = ::zserio::calcHashCode(result, m_offset_);

    return result;
}

void LinePositionOffset3D::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_linePosition_);

    out.writeBits(m_numBitsXY_, UINT8_C(5));

    out.writeBits(m_numBitsZ_, UINT8_C(5));

    // check parameters
    if (m_offset_.getNumBitsXY() != static_cast<::nds::core::geometry::CoordWidth>(getNumBitsXY()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numBitsXY for field LinePositionOffset3D.offset: ") <<
                m_offset_.getNumBitsXY() << " != " << static_cast<::nds::core::geometry::CoordWidth>(getNumBitsXY()) << "!";
    }
    if (m_offset_.getNumBitsZ() != static_cast<::nds::core::geometry::CoordWidth>(getNumBitsZ()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numBitsZ for field LinePositionOffset3D.offset: ") <<
                m_offset_.getNumBitsZ() << " != " << static_cast<::nds::core::geometry::CoordWidth>(getNumBitsZ()) << "!";
    }
    if (m_offset_.getShiftXY() != static_cast<::nds::core::geometry::CoordShift>(getShiftXY()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shiftXY for field LinePositionOffset3D.offset: ") <<
                m_offset_.getShiftXY() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShiftXY()) << "!";
    }
    if (m_offset_.getShiftZ() != static_cast<::nds::core::geometry::CoordShift>(getShiftZ()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shiftZ for field LinePositionOffset3D.offset: ") <<
                m_offset_.getShiftZ() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShiftZ()) << "!";
    }
    m_offset_.write(out);
}

void LinePositionOffset3D::write(LinePositionOffset3D::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getLinePosition().write<::zserio::VarSizeArrayTraits>(out, m_linePosition_);

    context.getNumBitsXY().write<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordWidth, UINT8_C(5)>>(out, m_numBitsXY_);

    context.getNumBitsZ().write<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordWidth, UINT8_C(5)>>(out, m_numBitsZ_);

    // check parameters
    if (m_offset_.getNumBitsXY() != static_cast<::nds::core::geometry::CoordWidth>(getNumBitsXY()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numBitsXY for field LinePositionOffset3D.offset: ") <<
                m_offset_.getNumBitsXY() << " != " << static_cast<::nds::core::geometry::CoordWidth>(getNumBitsXY()) << "!";
    }
    if (m_offset_.getNumBitsZ() != static_cast<::nds::core::geometry::CoordWidth>(getNumBitsZ()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter numBitsZ for field LinePositionOffset3D.offset: ") <<
                m_offset_.getNumBitsZ() << " != " << static_cast<::nds::core::geometry::CoordWidth>(getNumBitsZ()) << "!";
    }
    if (m_offset_.getShiftXY() != static_cast<::nds::core::geometry::CoordShift>(getShiftXY()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shiftXY for field LinePositionOffset3D.offset: ") <<
                m_offset_.getShiftXY() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShiftXY()) << "!";
    }
    if (m_offset_.getShiftZ() != static_cast<::nds::core::geometry::CoordShift>(getShiftZ()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shiftZ for field LinePositionOffset3D.offset: ") <<
                m_offset_.getShiftZ() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShiftZ()) << "!";
    }
    m_offset_.write(context.getOffset(), out);
}

::nds::core::geometry::LinePosition LinePositionOffset3D::readLinePosition(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::geometry::LinePosition>(in.readVarSize());
}

::nds::core::geometry::LinePosition LinePositionOffset3D::readLinePosition(LinePositionOffset3D::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getLinePosition().read<::zserio::VarSizeArrayTraits>(in);
}
::nds::core::geometry::CoordWidth LinePositionOffset3D::readNumBitsXY(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::geometry::CoordWidth>(in.readBits(UINT8_C(5)));
}

::nds::core::geometry::CoordWidth LinePositionOffset3D::readNumBitsXY(LinePositionOffset3D::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumBitsXY().read<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordWidth, UINT8_C(5)>>(in);
}
::nds::core::geometry::CoordWidth LinePositionOffset3D::readNumBitsZ(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::geometry::CoordWidth>(in.readBits(UINT8_C(5)));
}

::nds::core::geometry::CoordWidth LinePositionOffset3D::readNumBitsZ(LinePositionOffset3D::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumBitsZ().read<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordWidth, UINT8_C(5)>>(in);
}
::nds::core::geometry::PositionOffset3D LinePositionOffset3D::readOffset(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::geometry::PositionOffset3D(in, static_cast<::nds::core::geometry::CoordWidth>(getNumBitsXY()), static_cast<::nds::core::geometry::CoordWidth>(getNumBitsZ()), static_cast<::nds::core::geometry::CoordShift>(getShiftXY()), static_cast<::nds::core::geometry::CoordShift>(getShiftZ()), allocator);
}

::nds::core::geometry::PositionOffset3D LinePositionOffset3D::readOffset(LinePositionOffset3D::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::geometry::PositionOffset3D(context.getOffset(), in, static_cast<::nds::core::geometry::CoordWidth>(getNumBitsXY()), static_cast<::nds::core::geometry::CoordWidth>(getNumBitsZ()), static_cast<::nds::core::geometry::CoordShift>(getShiftXY()), static_cast<::nds::core::geometry::CoordShift>(getShiftZ()), allocator);
}

} // namespace geometry
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ConstraintException.h>

#include <nds/core/geometry/LineRange2D.h>

namespace nds
{
namespace core
{
namespace geometry
{

LineRange2D::LineRange2D(const allocator_type&) noexcept :
        m_isInitialized(false),
        m_start_(::nds::core::geometry::LinePosition()),
        m_end_(::nds::core::geometry::LinePosition())
{
}

LineRange2D::LineRange2D(::zserio::BitStreamReader& in,
        ::nds::core::geometry::Line2D& line_, const allocator_type&) :
        m_line_(&line_),
        m_isInitialized(true),
        m_start_(readStart(in)),
        m_end_(readEnd(in))
{
}

LineRange2D::LineRange2D(LineRange2D::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::Line2D& line_, const allocator_type&) :
        m_line_(&line_),
        m_isInitialized(true),
        m_start_(readStart(context, in)),
        m_end_(readEnd(context, in))
{
}

LineRange2D::LineRange2D(const LineRange2D& other) :
        m_start_(other.m_start_),
        m_end_(other.m_end_)
{
    if (other.m_isInitialized)
        initialize(*(other.m_line_));
    else
        m_isInitialized = false;
}

LineRange2D& LineRange2D::operator=(const LineRange2D& other)
{
    m_start_ = other.m_start_;
    m_end_ = other.m_end_;
    if (other.m_isInitialized)
        initialize(*(other.m_line_));
    else
        m_isInitialized = false;

    return *this;
}

LineRange2D::LineRange2D(LineRange2D&& other) :
        m_start_(::std::move(other.m_start_)),
        m_end_(::std::move(other.m_end_))
{
    if (other.m_isInitialized)
        initialize(*(other.m_line_));
    else
        m_isInitialized = false;
}

LineRange2D& LineRange2D::operator=(LineRange2D&& other)
{
    m_start_ = ::std::move(other.m_start_);
    m_end_ = ::std::move(other.m_end_);
    if (other.m_isInitialized)
        initialize(*(other.m_line_));
    else
        m_isInitialized = false;

    return *this;
}

LineRange2D::LineRange2D(::zserio::PropagateAllocatorT,
        const LineRange2D& other, const allocator_type& allocator) :
        m_start_(::zserio::allocatorPropagatingCopy(other.m_start_, allocator)),
        m_end_(::zserio::allocatorPropagatingCopy(other.m_end_, allocator))
{
    if (other.m_isInitialized)
        initialize(*(other.m_line_));
    else
        m_isInitialized = false;
}

void LineRange2D::initialize(
        ::nds::core::geometry::Line2D& line_)
{
    m_line_ = &line_;
    m_isInitialized = true;
}

bool LineRange2D::isInitialized() const
{
    return m_isInitialized;
}

::nds::core::geometry::Line2D& LineRange2D::getLine()
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'line' of compound 'LineRange2D' is not initialized!");

    return *m_line_;
}

const ::nds::core::geometry::Line2D& LineRange2D::getLine() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'line' of compound 'LineRange2D' is not initialized!");

    return *m_line_;
}

::nds::core::geometry::LinePosition LineRange2D::getStart() const
{
    return m_start_;
}

void LineRange2D::setStart(::nds::core::geometry::LinePosition start_)
{
    m_start_ = start_;
}

::nds::core::geometry::LinePosition LineRange2D::getEnd() const
{
    return m_end_;
}

void LineRange2D::setEnd(::nds::core::geometry::LinePosition end_)
{
    m_end_ = end_;
}

void LineRange2D::initPackingContext(LineRange2D::ZserioPackingContext& context) const
{
    context.getStart().init<::zserio::VarSizeArrayTraits>(m_start_);
    context.getEnd().init<::zserio::VarSizeArrayTraits>(m_end_);
}

size_t LineRange2D::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_start_);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_end_);

    return endBitPosition - bitPosition;
}

size_t LineRange2D::bitSizeOf(LineRange2D::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getStart().bitSizeOf<::zserio::VarSizeArrayTraits>(m_start_);
    endBitPosition += context.getEnd().bitSizeOf<::zserio::VarSizeArrayTraits>(m_end_);

    return endBitPosition - bitPosition;
}

size_t LineRange2D::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_start_);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_end_);

    return endBitPosition;
}

size_t LineRange2D::initializeOffsets(LineRange2D::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getStart().bitSizeOf<::zserio::VarSizeArrayTraits>(m_start_);
    endBitPosition += context.getEnd().bitSizeOf<::zserio::VarSizeArrayTraits>(m_end_);

    return endBitPosition;
}

bool LineRange2D::operator==(const LineRange2D& other) const
{
    if (this != &other)
    {
        return
                (getLine() == other.getLine()) &&
                (m_start_ == other.m_start_) &&
                (m_end_ == other.m_end_);
    }

    return true;
}

uint32_t LineRange2D::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getLine());
    result = ::zserio::calcHashCode(result, m_start_);
    result = ::zserio::calcHashCode(result, m_end_);

    return result;
}

void LineRange2D::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_start_);

    // check constraint
    if (!(getEnd() > getStart() && getEnd() <= getLine().funcLastPositionIdx()))
        throw ::zserio::ConstraintException("Write: Constraint violated at LineRange2D.end!");
    out.writeVarSize(m_end_);
}

void LineRange2D::write(LineRange2D::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getStart().write<::zserio::VarSizeArrayTraits>(out, m_start_);

    // check constraint
    if (!(getEnd() > getStart() && getEnd() <= getLine().funcLastPositionIdx()))
        throw ::zserio::ConstraintException("Write: Constraint violated at LineRange2D.end!");
    context.getEnd().write<::zserio::VarSizeArrayTraits>(out, m_end_);
}

::nds::core::geometry::LinePosition LineRange2D::readStart(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::geometry::LinePosition>(in.readVarSize());
}

::nds::core::geometry::LinePosition LineRange2D::readStart(LineRange2D::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getStart().read<::zserio::VarSizeArrayTraits>(in);
}
::nds::core::geometry::LinePosition LineRange2D::readEnd(::zserio::BitStreamReader& in)
{
    ::nds::core::geometry::LinePosition readField = static_cast<::nds::core::geometry::LinePosition>(in.readVarSize());
    // check constraint
    if (!(readField > getStart() && readField <= getLine().funcLastPositionIdx()))
        throw ::zserio::ConstraintException("Read: Constraint violated at LineRange2D.end!");

    return readField;
}

::nds::core::geometry::LinePosition LineRange2D::readEnd(LineRange2D::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    ::nds::core::geometry::LinePosition readField = context.getEnd().read<::zserio::VarSizeArrayTraits>(in);
    // check constraint
    if (!(readField > getStart() && readField <= getLine().funcLastPositionIdx()))
        throw ::zserio::ConstraintException("Read: Constraint violated at LineRange2D.end!");

    return readField;
}

} // namespace geometry
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ConstraintException.h>

#include <nds/core/geometry/LineRange3D.h>

namespace nds
{
namespace core
{
namespace geometry
{

LineRange3D::LineRange3D(const allocator_type&) noexcept :
        m_isInitialized(false),
        m_start_(::nds::core::geometry::LinePosition()),
        m_end_(::nds::core::geometry::LinePosition())
{
}

LineRange3D::LineRange3D(::zserio::BitStreamReader& in,
        ::nds::core::geometry::Line3D& line_, const allocator_type&) :
        m_line_(&line_),
        m_isInitialized(true),
        m_start_(readStart(in)),
        m_end_(readEnd(in))
{
}

LineRange3D::LineRange3D(LineRange3D::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::Line3D& line_, const allocator_type&) :
        m_line_(&line_),
        m_isInitialized(true),
        m_start_(readStart(context, in)),
        m_end_(readEnd(context, in))
{
}

LineRange3D::LineRange3D(const LineRange3D& other) :
        m_start_(other.m_start_),
        m_end_(other.m_end_)
{
    if (other.m_isInitialized)
        initialize(*(other.m_line_));
    else
        m_isInitialized = false;
}

LineRange3D& LineRange3D::operator=(const LineRange3D& other)
{
    m_start_ = other.m_start_;
    m_end_ = other.m_end_;
    if (other.m_isInitialized)
        initialize(*(other.m_line_));
    else
        m_isInitialized = false;

    return *this;
}

LineRange3D::LineRange3D(LineRange3D&& other) :
        m_start_(::std::move(other.m_start_)),
        m_end_(::std::move(other.m_end_))
{
    if (other.m_isInitialized)
        initialize(*(other.m_line_));
    else
        m_isInitialized = false;
}

LineRange3D& LineRange3D::operator=(LineRange3D&& other)
{
    m_start_ = ::std::move(other.m_start_);
    m_end_ = ::std::move(other.m_end_);
    if (other.m_isInitialized)
        initialize(*(other.m_line_));
    else
        m_isInitialized = false;

    return *this;
}

LineRange3D::LineRange3D(::zserio::PropagateAllocatorT,
        const LineRange3D& other, const allocator_type& allocator) :
        m_start_(::zserio::allocatorPropagatingCopy(other.m_start_, allocator)),
        m_end_(::zserio::allocatorPropagatingCopy(other.m_end_, allocator))
{
    if (other.m_isInitialized)
        initialize(*(other.m_line_));
    else
        m_isInitialized = false;
}

void LineRange3D::initialize(
        ::nds::core::geometry::Line3D& line_)
{
    m_line_ = &line_;
    m_isInitialized = true;
}

bool LineRange3D::isInitialized() const
{
    return m_isInitialized;
}

::nds::core::geometry::Line3D& LineRange3D::getLine()
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'line' of compound 'LineRange3D' is not initialized!");

    return *m_line_;
}

const ::nds::core::geometry::Line3D& LineRange3D::getLine() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'line' of compound 'LineRange3D' is not initialized!");

    return *m_line_;
}

::nds::core::geometry::LinePosition LineRange3D::getStart() const
{
    return m_start_;
}

void LineRange3D::setStart(::nds::core::geometry::LinePosition start_)
{
    m_start_ = start_;
}

::nds::core::geometry::LinePosition LineRange3D::getEnd() const
{
    return m_end_;
}

void LineRange3D::setEnd(::nds::core::geometry::LinePosition end_)
{
    m_end_ = end_;
}

void LineRange3D::initPackingContext(LineRange3D::ZserioPackingContext& context) const
{
    context.getStart().init<::zserio::VarSizeArrayTraits>(m_start_);
    context.getEnd().init<::zserio::VarSizeArrayTraits>(m_end_);
}

size_t LineRange3D::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_start_);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_end_);

    return endBitPosition - bitPosition;
}

size_t LineRange3D::bitSizeOf(LineRange3D::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getStart().bitSizeOf<::zserio::VarSizeArrayTraits>(m_start_);
    endBitPosition += context.getEnd().bitSizeOf<::zserio::VarSizeArrayTraits>(m_end_);

    return endBitPosition - bitPosition;
}

size_t LineRange3D::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_start_);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_end_);

    return endBitPosition;
}

size_t LineRange3D::initializeOffsets(LineRange3D::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getStart().bitSizeOf<::zserio::VarSizeArrayTraits>(m_start_);
    endBitPosition += context.getEnd().bitSizeOf<::zserio::VarSizeArrayTraits>(m_end_);

    return endBitPosition;
}

bool LineRange3D::operator==(const LineRange3D& other) const
{
    if (this != &other)
    {
        return
                (getLine() == other.getLine()) &&
                (m_start_ == other.m_start_) &&
                (m_end_ == other.m_end_);
    }

    return true;
}

uint32_t LineRange3D::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getLine());
    result = ::zserio::calcHashCode(result, m_start_);
    result = ::zserio::calcHashCode(result, m_end_);

    return result;
}

void LineRange3D::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_start_);

    // check constraint
    if (!(getEnd() > getStart() && getEnd() <= getLine().funcLastPositionIdx()))
        throw ::zserio::ConstraintException("Write: Constraint violated at LineRange3D.end!");
    out.writeVarSize(m_end_);
}

void LineRange3D::write(LineRange3D::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getStart().write<::zserio::VarSizeArrayTraits>(out, m_start_);

    // check constraint
    if (!(getEnd() > getStart() && getEnd() <= getLine().funcLastPositionIdx()))
        throw ::zserio::ConstraintException("Write: Constraint violated at LineRange3D.end!");
    context.getEnd().write<::zserio::VarSizeArrayTraits>(out, m_end_);
}

::nds::core::geometry::LinePosition LineRange3D::readStart(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::geometry::LinePosition>(in.readVarSize());
}

::nds::core::geometry::LinePosition LineRange3D::readStart(LineRange3D::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getStart().read<::zserio::VarSizeArrayTraits>(in);
}
::nds::core::geometry::LinePosition LineRange3D::readEnd(::zserio::BitStreamReader& in)
{
    ::nds::core::geometry::LinePosition readField = static_cast<::nds::core::geometry::LinePosition>(in.readVarSize());
    // check constraint
    if (!(readField > getStart() && readField <= getLine().funcLastPositionIdx()))
        throw ::zserio::ConstraintException("Read: Constraint violated at LineRange3D.end!");

    return readField;
}

::nds::core::geometry::LinePosition LineRange3D::readEnd(LineRange3D::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    ::nds::core::geometry::LinePosition readField = context.getEnd().read<::zserio::VarSizeArrayTraits>(in);
    // check constraint
    if (!(readField > getStart() && readField <= getLine().funcLastPositionIdx()))
        throw ::zserio::ConstraintException("Read: Constraint violated at LineRange3D.end!");

    return readField;
}

} // namespace geometry
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ConstraintException.h>

#include <nds/core/geometry/LineRangeUnchecked.h>

namespace nds
{
namespace core
{
namespace geometry
{

LineRangeUnchecked::LineRangeUnchecked(const allocator_type&) noexcept :
        m_start_(::nds::core::geometry::LinePosition()),
        m_end_(::nds::core::geometry::LinePosition())
{
}

LineRangeUnchecked::LineRangeUnchecked(::zserio::BitStreamReader& in, const allocator_type&) :
        m_start_(readStart(in)),
        m_end_(readEnd(in))
{
}

LineRangeUnchecked::LineRangeUnchecked(LineRangeUnchecked::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type&) :
        m_start_(readStart(context, in)),
        m_end_(readEnd(context, in))
{
}

LineRangeUnchecked::LineRangeUnchecked(::zserio::PropagateAllocatorT,
        const LineRangeUnchecked& other, const allocator_type& allocator) :
        m_start_(::zserio::allocatorPropagatingCopy(other.m_start_, allocator)),
        m_end_(::zserio::allocatorPropagatingCopy(other.m_end_, allocator))
{
}

::nds::core::geometry::LinePosition LineRangeUnchecked::getStart() const
{
    return m_start_;
}

void LineRangeUnchecked::setStart(::nds::core::geometry::LinePosition start_)
{
    m_start_ = start_;
}

::nds::core::geometry::LinePosition LineRangeUnchecked::getEnd() const
{
    return m_end_;
}

void LineRangeUnchecked::setEnd(::nds::core::geometry::LinePosition end_)
{
    m_end_ = end_;
}

void LineRangeUnchecked::initPackingContext(LineRangeUnchecked::ZserioPackingContext& context) const
{
    context.getStart().init<::zserio::VarSizeArrayTraits>(m_start_);
    context.getEnd().init<::zserio::VarSizeArrayTraits>(m_end_);
}

size_t LineRangeUnchecked::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_start_);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_end_);

    return endBitPosition - bitPosition;
}

size_t LineRangeUnchecked::bitSizeOf(LineRangeUnchecked::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getStart().bitSizeOf<::zserio::VarSizeArrayTraits>(m_start_);
    endBitPosition += context.getEnd().bitSizeOf<::zserio::VarSizeArrayTraits>(m_end_);

    return endBitPosition - bitPosition;
}

size_t LineRangeUnchecked::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_start_);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_end_);

    return endBitPosition;
}

size_t LineRangeUnchecked::initializeOffsets(LineRangeUnchecked::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getStart().bitSizeOf<::zserio::VarSizeArrayTraits>(m_start_);
    endBitPosition += context.getEnd().bitSizeOf<::zserio::VarSizeArrayTraits>(m_end_);

    return endBitPosition;
}

bool LineRangeUnchecked::operator==(const LineRangeUnchecked& other) const
{
    if (this != &other)
    {
        return
                (m_start_ == other.m_start_) &&
                (m_end_ == other.m_end_);
    }

    return true;
}

uint32_t LineRangeUnchecked::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_start_);
    result = ::zserio::calcHashCode(result, m_end_);

    return result;
}

void LineRangeUnchecked::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_start_);

    // check constraint
    if (!(getEnd() > getStart()))
        throw ::zserio::ConstraintException("Write: Constraint violated at LineRangeUnchecked.end!");
    out.writeVarSize(m_end_);
}

void LineRangeUnchecked::write(LineRangeUnchecked::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getStart().write<::zserio::VarSizeArrayTraits>(out, m_start_);

    // check constraint
    if (!(getEnd() > getStart()))
        throw ::zserio::ConstraintException("Write: Constraint violated at LineRangeUnchecked.end!");
    context.getEnd().write<::zserio::VarSizeArrayTraits>(out, m_end_);
}

::nds::core::geometry::LinePosition LineRangeUnchecked::readStart(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::geometry::LinePosition>(in.readVarSize());
}

::nds::core::geometry::LinePosition LineRangeUnchecked::readStart(LineRangeUnchecked::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getStart().read<::zserio::VarSizeArrayTraits>(in);
}
::nds::core::geometry::LinePosition LineRangeUnchecked::readEnd(::zserio::BitStreamReader& in)
{
    ::nds::core::geometry::LinePosition readField = static_cast<::nds::core::geometry::LinePosition>(in.readVarSize());
    // check constraint
    if (!(readField > getStart()))
        throw ::zserio::ConstraintException("Read: Constraint violated at LineRangeUnchecked.end!");

    return readField;
}

::nds::core::geometry::LinePosition LineRangeUnchecked::readEnd(LineRangeUnchecked::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    ::nds::core::geometry::LinePosition readField = context.getEnd().read<::zserio::VarSizeArrayTraits>(in);
    // check constraint
    if (!(readField > getStart()))
        throw ::zserio::ConstraintException("Read: Constraint violated at LineRangeUnchecked.end!");

    return readField;
}

} // namespace geometry
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ArrayTraits.h>

#include <nds/core/geometry/LineRangeOffset2D.h>
#include <nds/core/geometry/RangeOffsetType.h>

namespace nds
{
namespace core
{
namespace geometry
{

LineRangeOffset2D::LineRangeOffset2D(const allocator_type&) noexcept :
        m_isInitialized(false),
        m_offsetType_(::nds::core::geometry::RangeOffsetType()),
        m_numBits_(::nds::core::geometry::CoordWidth()),
        m_startPosition_(::nds::core::geometry::LinePosition()),
        m_endPosition_(::nds::core::geometry::LinePosition()),
        m_startOffset_(::zserio::NullOpt),
        m_endOffset_(::zserio::NullOpt)
{
}

LineRangeOffset2D::LineRangeOffset2D(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift shift_, const allocator_type& allocator) :
        m_shift_(shift_),
        m_isInitialized(true),
        m_offsetType_(readOffsetType(in)),
        m_numBits_(readNumBits(in)),
        m_startPosition_(readStartPosition(in)),
        m_endPosition_(readEndPosition(in)),
        m_startOffset_(readStartOffset(in, allocator)),
        m_endOffset_(readEndOffset(in, allocator))
{
}

LineRangeOffset2D::LineRangeOffset2D(LineRangeOffset2D::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift shift_, const allocator_type& allocator) :
        m_shift_(shift_),
        m_isInitialized(true),
        m_offsetType_(readOffsetType(context, in)),
        m_numBits_(readNumBits(context, in)),
        m_startPosition_(readStartPosition(context, in)),
        m_endPosition_(readEndPosition(context, in)),
        m_startOffset_(readStartOffset(context, in, allocator)),
        m_endOffset_(readEndOffset(context, in, allocator))
{
}

LineRangeOffset2D::LineRangeOffset2D(const LineRangeOffset2D& other) :
        m_offsetType_(other.m_offsetType_),
        m_numBits_(other.m_numBits_),
        m_startPosition_(other.m_startPosition_),
        m_endPosition_(other.m_endPosition_),
        m_startOffset_(other.m_startOffset_),
        m_endOffset_(other.m_endOffset_)
{
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;
}

LineRangeOffset2D& LineRangeOffset2D::operator=(const LineRangeOffset2D& other)
{
    m_offsetType_ = other.m_offsetType_;
    m_numBits_ = other.m_numBits_;
    m_startPosition_ = other.m_startPosition_;
    m_endPosition_ = other.m_endPosition_;
    m_startOffset_ = other.m_startOffset_;
    m_endOffset_ = other.m_endOffset_;
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;

    return *this;
}

LineRangeOffset2D::LineRangeOffset2D(LineRangeOffset2D&& other) :
        m_offsetType_(::std::move(other.m_offsetType_)),
        m_numBits_(::std::move(other.m_numBits_)),
        m_startPosition_(::std::move(other.m_startPosition_)),
        m_endPosition_(::std::move(other.m_endPosition_)),
        m_startOffset_(::std::move(other.m_startOffset_)),
        m_endOffset_(::std::move(other.m_endOffset_))
{
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;
}

LineRangeOffset2D& LineRangeOffset2D::operator=(LineRangeOffset2D&& other)
{
    m_offsetType_ = ::std::move(other.m_offsetType_);
    m_numBits_ = ::std::move(other.m_numBits_);
    m_startPosition_ = ::std::move(other.m_startPosition_);
    m_endPosition_ = ::std::move(other.m_endPosition_);
    m_startOffset_ = ::std::move(other.m_startOffset_);
    m_endOffset_ = ::std::move(other.m_endOffset_);
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;

    return *this;
}

LineRangeOffset2D::LineRangeOffset2D(::zserio::PropagateAllocatorT,
        const LineRangeOffset2D& other, const allocator_type& allocator) :
        m_offsetType_(::zserio::allocatorPropagatingCopy(other.m_offsetType_, allocator)),
        m_numBits_(::zserio::allocatorPropagatingCopy(other.m_numBits_, allocator)),
        m_startPosition_(::zserio::allocatorPropagatingCopy(other.m_startPosition_, allocator)),
        m_endPosition_(::zserio::allocatorPropagatingCopy(other.m_endPosition_, allocator)),
        m_startOffset_(::zserio::allocatorPropagatingCopy(other.m_startOffset_, allocator)),
        m_endOffset_(::zserio::allocatorPropagatingCopy(other.m_endOffset_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;
}

void LineRangeOffset2D::initialize(
        ::nds::core::geometry::CoordShift shift_)
{
    m_shift_ = shift_;
    m_isInitialized = true;

    initializeChildren();
}

bool LineRangeOffset2D::isInitialized() const
{
    return m_isInitialized;
}

void LineRangeOffset2D::initializeChildren()
{
    if (getOffsetType() == ::nds::core::geometry::RangeOffsetType::START || getOffsetType() == ::nds::core::geometry::RangeOffsetType::START_AND_END)
        m_startOffset_.value().initialize(static_cast<::nds::core::geometry::CoordWidth>(getNumBits()), static_cast<::nds::core::geometry::CoordShift>(getShift()));
    if (getOffsetType() == ::nds::core::geometry::RangeOffsetType::END || getOffsetType() == ::nds::core::geometry::RangeOffsetType::START_AND_END)
        m_endOffset_.value().initialize(static_cast<::nds::core::geometry::CoordWidth>(getNumBits()), static_cast<::nds::core::geometry::CoordShift>(getShift()));
}

::nds::core::geometry::CoordShift LineRangeOffset2D::getShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'shift' of compound 'LineRangeOffset2D' is not initialized!");

    return m_shift_;
}

::nds::core::geometry::RangeOffsetType LineRangeOffset2D::getOffsetType() const
{
    return m_offsetType_;
}

void LineRangeOffset2D::setOffsetType(::nds::core::geometry::RangeOffsetType offsetType_)
{
    m_offsetType_ = offsetType_;
}

::nds::core::geometry::CoordWidth LineRangeOffset2D::getNumBits() const
{
    return m_numBits_;
}

void LineRangeOffset2D::setNumBits(::nds::core::geometry::CoordWidth numBits_)
{
    m_numBits_ = numBits_;
}

::nds::core::geometry::LinePosition LineRangeOffset2D::getStartPosition() const
{
    return m_startPosition_;
}

void LineRangeOffset2D::setStartPosition(::nds::core::geometry::LinePosition startPosition_)
{
    m_startPosition_ = startPosition_;
}

::nds::core::geometry::LinePosition LineRangeOffset2D::getEndPosition() const
{
    return m_endPosition_;
}

void LineRangeOffset2D::setEndPosition(::nds::core::geometry::LinePosition endPosition_)
{
    m_endPosition_ = endPosition_;
}

::nds::core::geometry::PositionOffset2D& LineRangeOffset2D::getStartOffset()
{
    return m_startOffset_.value();
}

const ::nds::core::geometry::PositionOffset2D& LineRangeOffset2D::getStartOffset() const
{
    return m_startOffset_.value();
}

void LineRangeOffset2D::setStartOffset(const ::nds::core::geometry::PositionOffset2D& startOffset_)
{
    m_startOffset_ = startOffset_;
}

void LineRangeOffset2D::setStartOffset(::nds::core::geometry::PositionOffset2D&& startOffset_)
{
    m_startOffset_ = ::std::move(startOffset_);
}

bool LineRangeOffset2D::isStartOffsetUsed() const
{
    return (getOffsetType() == ::nds::core::geometry::RangeOffsetType::START || getOffsetType() == ::nds::core::geometry::RangeOffsetType::START_AND_END);
}

bool LineRangeOffset2D::isStartOffsetSet() const
{
    return m_startOffset_.hasValue();
}

void LineRangeOffset2D::resetStartOffset()
{
    m_startOffset_.reset();
}

::nds::core::geometry::PositionOffset2D& LineRangeOffset2D::getEndOffset()
{
    return m_endOffset_.value();
}

const ::nds::core::geometry::PositionOffset2D& LineRangeOffset2D::getEndOffset() const
{
    return m_endOffset_.value();
}

void LineRangeOffset2D::setEndOffset(const ::nds::core::geometry::PositionOffset2D& endOffset_)
{
    m_endOffset_ = endOffset_;
}

void LineRangeOffset2D::setEndOffset(::nds::core::geometry::PositionOffset2D&& endOffset_)
{
    m_endOffset_ = ::std::move(endOffset_);
}

bool LineRangeOffset2D::isEndOffsetUsed() const
{
    return (getOffsetType() == ::nds::core::geometry::RangeOffsetType::END || getOffsetType() == ::nds::core::geometry::RangeOffsetType::START_AND_END);
}

bool LineRangeOffset2D::isEndOffsetSet() const
{
    return m_endOffset_.hasValue();
}

void LineRangeOffset2D::resetEndOffset()
{
    m_endOffset_.reset();
}

void LineRangeOffset2D::initPackingContext(LineRangeOffset2D::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getOffsetType(), m_offsetType_);
    context.getNumBits().init<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordWidth, UINT8_C(5)>>(m_numBits_);
    context.getStartPosition().init<::zserio::VarSizeArrayTraits>(m_startPosition_);
    context.getEndPosition().init<::zserio::VarSizeArrayTraits>(m_endPosition_);
    if (getOffsetType() == ::nds::core::geometry::RangeOffsetType::START || getOffsetType() == ::nds::core::geometry::RangeOffsetType::START_AND_END)
    {
        m_startOffset_.value().initPackingContext(context.getStartOffset());
    }
    if (getOffsetType() == ::nds::core::geometry::RangeOffsetType::END || getOffsetType() == ::nds::core::geometry::RangeOffsetType::START_AND_END)
    {
        m_endOffset_.value().initPackingContext(context.getEndOffset());
    }
}

size_t LineRangeOffset2D::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_offsetType_);
    endBitPosition += UINT8_C(5);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_startPosition_);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_endPosition_);
    if (getOffsetType() == ::nds::core::geometry::RangeOffsetType::START || getOffsetType() == ::nds::core::geometry::RangeOffsetType::START_AND_END)
    {
        endBitPosition += m_startOffset_.value().bitSizeOf(endBitPosition);
    }
    if (getOffsetType() == ::nds::core::geometry::RangeOffsetType::END || getOffsetType() == ::nds::core::geometry::RangeOffsetType::START_AND_END)
    {
        endBitPosition += m_endOffset_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t LineRangeOffset2D::bitSizeOf(LineRangeOffset2D::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getOffsetType(), m_offsetType_);
    endBitPosition += context.getNumBits().bitSizeOf<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordWidth, UINT8_C(5)>>(m_numBits_);
    endBitPosition += context.getStartPosition().bitSizeOf<::zserio::VarSizeArrayTraits>(m_startPosition_);
    endBitPosition += context.getEndPosition().bitSizeOf<::zserio::VarSizeArrayTraits>(m_endPosition_);
    if (getOffsetType() == ::nds::core::geometry::RangeOffsetType::START || getOffsetType() == ::nds::core::geometry::RangeOffsetType::START_AND_END)
    {
        endBitPosition += m_startOffset_.value().bitSizeOf(context.getStartOffset(), endBitPosition);
    }
    if (getOffsetType() == ::nds::core::geometry::RangeOffsetType::END || getOffsetType() == ::nds::core::geometry::RangeOffsetType::START_AND_END)
    {
        endBitPosition += m_endOffset_.value().bitSizeOf(context.getEndOffset(), endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t LineRangeOffset2D::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_offsetType_);
    endBitPosition += UINT8_C(5);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_startPosition_);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_endPosition_);
    if (getOffsetType() == ::nds::core::geometry::RangeOffsetType::START || getOffsetType() == ::nds::core::geometry::RangeOffsetType::START_AND_END)
    {
        endBitPosition = m_startOffset_.value().initializeOffsets(endBitPosition);
    }
    if (getOffsetType() == ::nds::core::geometry::RangeOffsetType::END || getOffsetType() == ::nds::core::geometry::RangeOffsetType::START_AND_END)
    {
        endBitPosition = m_endOffset_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

size_t LineRangeOffset2D::initializeOffsets(LineRangeOffset2D::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getOffsetType(), endBitPosition,
        m_offsetType_);
    endBitPosition += context.getNumBits().bitSizeOf<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordWidth, UINT8_C(5)>>(m_numBits_);
    endBitPosition += context.getStartPosition().bitSizeOf<::zserio::VarSizeArrayTraits>(m_startPosition_);
    endBitPosition += context.getEndPosition().bitSizeOf<::zserio::VarSizeArrayTraits>(m_endPosition_);
    if (getOffsetType() == ::nds::core::geometry::RangeOffsetType::START || getOffsetType() == ::nds::core::geometry::RangeOffsetType::START_AND_END)
    {
        endBitPosition = m_startOffset_.value().initializeOffsets(context.getStartOffset(), endBitPosition);
    }
    if (getOffsetType() == ::nds::core::geometry::RangeOffsetType::END || getOffsetType() == ::nds::core::geometry::RangeOffsetType::START_AND_END)
    {
        endBitPosition = m_endOffset_.value().initializeOffsets(context.getEndOffset(), endBitPosition);
    }

    return endBitPosition;
}

bool LineRangeOffset2D::operator==(const LineRangeOffset2D& other) const
{
    if (this != &other)
    {
        return
                (getShift() == other.getShift()) &&
                (m_offsetType_ == other.m_offsetType_) &&
                (m_numBits_ == other.m_numBits_) &&
                (m_startPosition_ == other.m_startPosition_) &&
                (m_endPosition_ == other.m_endPosition_) &&
                (!isStartOffsetUsed() ? !other.isStartOffsetUsed() : (m_startOffset_ == other.m_startOffset_)) &&
                (!isEndOffsetUsed() ? !other.isEndOffsetUsed() : (m_endOffset_ == other.m_endOffset_));
    }

    return true;
}

uint32_t LineRangeOffset2D::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getShift());
    result = ::zserio::calcHashCode(result, m_offsetType_);
    result = ::zserio::calcHashCode(result, m_numBits_);
    result = ::zserio::calcHashCode(result, m_startPosition_);
    result = ::zserio::calcHashCode(result, m_endPosition_);
    if (isStartOffsetUsed())
        result = ::zserio::calcHashCode(result, m_startOffset_);
    if (isEndOffsetUsed())
        result = ::zserio::calcHashCode(result, m_endOffset_);

    return result;
}

void LineRangeOffset2D::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_offsetType_);

    out.writeBits(m_numBits_, UINT8_C(5));

    out.writeVarSize(m_startPosition_);

    out.writeVarSize(m_endPosition_);

    if (getOffsetType() == ::nds::core::geometry::RangeOffsetType::START || getOffsetType() == ::nds::core::geometry::RangeOffsetType::START_AND_END)
    {
        // check parameters
        if (m_startOffset_.value().getNumBits() != static_cast<::nds::core::geometry::CoordWidth>(getNumBits()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter numBits for field LineRangeOffset2D.startOffset: ") <<
                    m_startOffset_.value().getNumBits() << " != " << static_cast<::nds::core::geometry::CoordWidth>(getNumBits()) << "!";
        }
        if (m_startOffset_.value().getShift() != static_cast<::nds::core::geometry::CoordShift>(getShift()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field LineRangeOffset2D.startOffset: ") <<
                    m_startOffset_.value().getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShift()) << "!";
        }
        m_startOffset_.value().write(out);
    }

    if (getOffsetType() == ::nds::core::geometry::RangeOffsetType::END || getOffsetType() == ::nds::core::geometry::RangeOffsetType::START_AND_END)
    {
        // check parameters
        if (m_endOffset_.value().getNumBits() != static_cast<::nds::core::geometry::CoordWidth>(getNumBits()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter numBits for field LineRangeOffset2D.endOffset: ") <<
                    m_endOffset_.value().getNumBits() << " != " << static_cast<::nds::core::geometry::CoordWidth>(getNumBits()) << "!";
        }
        if (m_endOffset_.value().getShift() != static_cast<::nds::core::geometry::CoordShift>(getShift()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field LineRangeOffset2D.endOffset: ") <<
                    m_endOffset_.value().getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShift()) << "!";
        }
        m_endOffset_.value().write(out);
    }
}

void LineRangeOffset2D::write(LineRangeOffset2D::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getOffsetType(), out, m_offsetType_);

    context.getNumBits().write<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordWidth, UINT8_C(5)>>(out, m_numBits_);

    context.getStartPosition().write<::zserio::VarSizeArrayTraits>(out, m_startPosition_);

    context.getEndPosition().write<::zserio::VarSizeArrayTraits>(out, m_endPosition_);

    if (getOffsetType() == ::nds::core::geometry::RangeOffsetType::START || getOffsetType() == ::nds::core::geometry::RangeOffsetType::START_AND_END)
    {
        // check parameters
        if (m_startOffset_.value().getNumBits() != static_cast<::nds::core::geometry::CoordWidth>(getNumBits()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter numBits for field LineRangeOffset2D.startOffset: ") <<
                    m_startOffset_.value().getNumBits() << " != " << static_cast<::nds::core::geometry::CoordWidth>(getNumBits()) << "!";
        }
        if (m_startOffset_.value().getShift() != static_cast<::nds::core::geometry::CoordShift>(getShift()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field LineRangeOffset2D.startOffset: ") <<
                    m_startOffset_.value().getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShift()) << "!";
        }
        m_startOffset_.value().write(context.getStartOffset(), out);
    }

    if (getOffsetType() == ::nds::core::geometry::RangeOffsetType::END || getOffsetType() == ::nds::core::geometry::RangeOffsetType::START_AND_END)
    {
        // check parameters
        if (m_endOffset_.value().getNumBits() != static_cast<::nds::core::geometry::CoordWidth>(getNumBits()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter numBits for field LineRangeOffset2D.endOffset: ") <<
                    m_endOffset_.value().getNumBits() << " != " << static_cast<::nds::core::geometry::CoordWidth>(getNumBits()) << "!";
        }
        if (m_endOffset_.value().getShift() != static_cast<::nds::core::geometry::CoordShift>(getShift()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field LineRangeOffset2D.endOffset: ") <<
                    m_endOffset_.value().getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShift()) << "!";
        }
        m_endOffset_.value().write(context.getEndOffset(), out);
    }
}

::nds::core::geometry::RangeOffsetType LineRangeOffset2D::readOffsetType(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::core::geometry::RangeOffsetType>(in);
}

::nds::core::geometry::RangeOffsetType LineRangeOffset2D::readOffsetType(LineRangeOffset2D::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::core::geometry::RangeOffsetType>(context.getOffsetType(), in);
}
::nds::core::geometry::CoordWidth LineRangeOffset2D::readNumBits(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::geometry::CoordWidth>(in.readBits(UINT8_C(5)));
}

::nds::core::geometry::CoordWidth LineRangeOffset2D::readNumBits(LineRangeOffset2D::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumBits().read<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordWidth, UINT8_C(5)>>(in);
}
::nds::core::geometry::LinePosition LineRangeOffset2D::readStartPosition(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::geometry::LinePosition>(in.readVarSize());
}

::nds::core::geometry::LinePosition LineRangeOffset2D::readStartPosition(LineRangeOffset2D::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getStartPosition().read<::zserio::VarSizeArrayTraits>(in);
}
::nds::core::geometry::LinePosition LineRangeOffset2D::readEndPosition(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::geometry::LinePosition>(in.readVarSize());
}

::nds::core::geometry::LinePosition LineRangeOffset2D::readEndPosition(LineRangeOffset2D::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getEndPosition().read<::zserio::VarSizeArrayTraits>(in);
}
::zserio::InplaceOptionalHolder<::nds::core::geometry::PositionOffset2D> LineRangeOffset2D::readStartOffset(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getOffsetType() == ::nds::core::geometry::RangeOffsetType::START || getOffsetType() == ::nds::core::geometry::RangeOffsetType::START_AND_END)
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::geometry::PositionOffset2D>(::nds::core::geometry::PositionOffset2D(in, static_cast<::nds::core::geometry::CoordWidth>(getNumBits()), static_cast<::nds::core::geometry::CoordShift>(getShift()), allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::geometry::PositionOffset2D>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::geometry::PositionOffset2D> LineRangeOffset2D::readStartOffset(LineRangeOffset2D::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getOffsetType() == ::nds::core::geometry::RangeOffsetType::START || getOffsetType() == ::nds::core::geometry::RangeOffsetType::START_AND_END)
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::geometry::PositionOffset2D>(::nds::core::geometry::PositionOffset2D(context.getStartOffset(), in, static_cast<::nds::core::geometry::CoordWidth>(getNumBits()), static_cast<::nds::core::geometry::CoordShift>(getShift()), allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::geometry::PositionOffset2D>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::core::geometry::PositionOffset2D> LineRangeOffset2D::readEndOffset(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getOffsetType() == ::nds::core::geometry::RangeOffsetType::END || getOffsetType() == ::nds::core::geometry::RangeOffsetType::START_AND_END)
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::geometry::PositionOffset2D>(::nds::core::geometry::PositionOffset2D(in, static_cast<::nds::core::geometry::CoordWidth>(getNumBits()), static_cast<::nds::core::geometry::CoordShift>(getShift()), allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::geometry::PositionOffset2D>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::geometry::PositionOffset2D> LineRangeOffset2D::readEndOffset(LineRangeOffset2D::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getOffsetType() == ::nds::core::geometry::RangeOffsetType::END || getOffsetType() == ::nds::core::geometry::RangeOffsetType::START_AND_END)
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::geometry::PositionOffset2D>(::nds::core::geometry::PositionOffset2D(context.getEndOffset(), in, static_cast<::nds::core::geometry::CoordWidth>(getNumBits()), static_cast<::nds::core::geometry::CoordShift>(getShift()), allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::geometry::PositionOffset2D>(::zserio::NullOpt);
}

} // namespace geometry
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ArrayTraits.h>

#include <nds/core/geometry/LineRangeOffset3D.h>
#include <nds/core/geometry/RangeOffsetType.h>

namespace nds
{
namespace core
{
namespace geometry
{

LineRangeOffset3D::LineRangeOffset3D(const allocator_type&) noexcept :
        m_isInitialized(false),
        m_offsetType_(::nds::core::geometry::RangeOffsetType()),
        m_numBitsXY_(::nds::core::geometry::CoordWidth()),
        m_numBitsZ_(::nds::core::geometry::CoordWidth()),
        m_startPosition_(::nds::core::geometry::LinePosition()),
        m_endPosition_(::nds::core::geometry::LinePosition()),
        m_startOffset_(::zserio::NullOpt),
        m_endOffset_(::zserio::NullOpt)
{
}

LineRangeOffset3D::LineRangeOffset3D(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift shiftXY_,
        ::nds::core::geometry::CoordShift shiftZ_, const allocator_type& allocator) :
        m_shiftXY_(shiftXY_),
        m_shiftZ_(shiftZ_),
        m_isInitialized(true),
        m_offsetType_(readOffsetType(in)),
        m_numBitsXY_(readNumBitsXY(in)),
        m_numBitsZ_(readNumBitsZ(in)),
        m_startPosition_(readStartPosition(in)),
        m_endPosition_(readEndPosition(in)),
        m_startOffset_(readStartOffset(in, allocator)),
        m_endOffset_(readEndOffset(in, allocator))
{
}

LineRangeOffset3D::LineRangeOffset3D(LineRangeOffset3D::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift shiftXY_,
        ::nds::core::geometry::CoordShift shiftZ_, const allocator_type& allocator) :
        m_shiftXY_(shiftXY_),
        m_shiftZ_(shiftZ_),
        m_isInitialized(true),
        m_offsetType_(readOffsetType(context, in)),
        m_numBitsXY_(readNumBitsXY(context, in)),
        m_numBitsZ_(readNumBitsZ(context, in)),
        m_startPosition_(readStartPosition(context, in)),
        m_endPosition_(readEndPosition(context, in)),
        m_startOffset_(readStartOffset(context, in, allocator)),
        m_endOffset_(readEndOffset(context, in, allocator))
{
}

LineRangeOffset3D::LineRangeOffset3D(const LineRangeOffset3D& other) :
        m_offsetType_(other.m_offsetType_),
        m_numBitsXY_(other.m_numBitsXY_),
        m_numBitsZ_(other.m_numBitsZ_),
        m_startPosition_(other.m_startPosition_),
        m_endPosition_(other.m_endPosition_),
        m_startOffset_(other.m_startOffset_),
        m_endOffset_(other.m_endOffset_)
{
    if (other.m_isInitialized)
        initialize(other.m_shiftXY_, other.m_shiftZ_);
    else
        m_isInitialized = false;
}

LineRangeOffset3D& LineRangeOffset3D::operator=(const LineRangeOffset3D& other)
{
    m_offsetType_ = other.m_offsetType_;
    m_numBitsXY_ = other.m_numBitsXY_;
    m_numBitsZ_ = other.m_numBitsZ_;
    m_startPosition_ = other.m_startPosition_;
    m_endPosition_ = other.m_endPosition_;
    m_startOffset_ = other.m_startOffset_;
    m_endOffset_ = other.m_endOffset_;
    if (other.m_isInitialized)
        initialize(other.m_shiftXY_, other.m_shiftZ_);
    else
        m_isInitialized = false;

    return *this;
}

LineRangeOffset3D::LineRangeOffset3D(LineRangeOffset3D&& other) :
        m_offsetType_(::std::move(other.m_offsetType_)),
        m_numBitsXY_(::std::move(other.m_numBitsXY_)),
        m_numBitsZ_(::std::move(other.m_numBitsZ_)),
        m_startPosition_(::std::move(other.m_startPosition_)),
        m_endPosition_(::std::move(other.m_endPosition_)),
        m_startOffset_(::std::move(other.m_startOffset_)),
        m_endOffset_(::std::move(other.m_endOffset_))
{
    if (other.m_isInitialized)
        initialize(other.m_shiftXY_, other.m_shiftZ_);
    else
        m_isInitialized = false;
}

LineRangeOffset3D& LineRangeOffset3D::operator=(LineRangeOffset3D&& other)
{
    m_offsetType_ = ::std::move(other.m_offsetType_);
    m_numBitsXY_ = ::std::move(other.m_numBitsXY_);
    m_numBitsZ_ = ::std::move(other.m_numBitsZ_);
    m_startPosition_ = ::std::move(other.m_startPosition_);
    m_endPosition_ = ::std::move(other.m_endPosition_);
    m_startOffset_ = ::std::move(other.m_startOffset_);
    m_endOffset_ = ::std::move(other.m_endOffset_);
    if (other.m_isInitialized)
        initialize(other.m_shiftXY_, other.m_shiftZ_);
    else
        m_isInitialized = false;

    return *this;
}

LineRangeOffset3D::LineRangeOffset3D(::zserio::PropagateAllocatorT,
        const LineRangeOffset3D& other, const allocator_type& allocator) :
        m_offsetType_(::zserio::allocatorPropagatingCopy(other.m_offsetType_, allocator)),
        m_numBitsXY_(::zserio::allocatorPropagatingCopy(other.m_numBitsXY_, allocator)),
        m_numBitsZ_(::zserio::allocatorPropagatingCopy(other.m_numBitsZ_, allocator)),
        m_startPosition_(::zserio::allocatorPropagatingCopy(other.m_startPosition_, allocator)),
        m_endPosition_(::zserio::allocatorPropagatingCopy(other.m_endPosition_, allocator)),
        m_startOffset_(::zserio::allocatorPropagatingCopy(other.m_startOffset_, allocator)),
        m_endOffset_(::zserio::allocatorPropagatingCopy(other.m_endOffset_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_shiftXY_, other.m_shiftZ_);
    else
        m_isInitialized = false;
}

void LineRangeOffset3D::initialize(
        ::nds::core::geometry::CoordShift shiftXY_,
        ::nds::core::geometry::CoordShift shiftZ_)
{
    m_shiftXY_ = shiftXY_;
    m_shiftZ_ = shiftZ_;
    m_isInitialized = true;

    initializeChildren();
}

bool LineRangeOffset3D::isInitialized() const
{
    return m_isInitialized;
}

void LineRangeOffset3D::initializeChildren()
{
    if (getOffsetType() == ::nds::core::geometry::RangeOffsetType::START || getOffsetType() == ::nds::core::geometry::RangeOffsetType::START_AND_END)
        m_startOffset_.value().initialize(static_cast<::nds::core::geometry::CoordWidth>(getNumBitsXY()), static_cast<::nds::core::geometry::CoordWidth>(getNumBitsZ()), static_cast<::nds::core::geometry::CoordShift>(getShiftXY()), static_cast<::nds::core::geometry::CoordShift>(getShiftZ()));
    if (getOffsetType() == ::nds::core::geometry::RangeOffsetType::END || getOffsetType() == ::nds::core::geometry::RangeOffsetType::START_AND_END)
        m_endOffset_.value().initialize(static_cast<::nds::core::geometry::CoordWidth>(getNumBitsXY()), static_cast<::nds::core::geometry::CoordWidth>(getNumBitsZ()), static_cast<::nds::core::geometry::CoordShift>(getShiftXY()), static_cast<::nds::core::geometry::CoordShift>(getShiftZ()));
}

::nds::core::geometry::CoordShift LineRangeOffset3D::getShiftXY() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'shiftXY' of compound 'LineRangeOffset3D' is not initialized!");

    return m_shiftXY_;
}

::nds::core::geometry::CoordShift LineRangeOffset3D::getShiftZ() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'shiftZ' of compound 'LineRangeOffset3D' is not initialized!");

    return m_shiftZ_;
}

::nds::core::geometry::RangeOffsetType LineRangeOffset3D::getOffsetType() const
{
    return m_offsetType_;
}

void LineRangeOffset3D::setOffsetType(::nds::core::geometry::RangeOffsetType offsetType_)
{
    m_offsetType_ = offsetType_;
}

::nds::core::geometry::CoordWidth LineRangeOffset3D::getNumBitsXY() const
{
    return m_numBitsXY_;
}

void LineRangeOffset3D::setNumBitsXY(::nds::core::geometry::CoordWidth numBitsXY_)
{
    m_numBitsXY_ = numBitsXY_;
}

::nds::core::geometry::CoordWidth LineRangeOffset3D::getNumBitsZ() const
{
    return m_numBitsZ_;
}

void LineRangeOffset3D::setNumBitsZ(::nds::core::geometry::CoordWidth numBitsZ_)
{
    m_numBitsZ_ = numBitsZ_;
}

::nds::core::geometry::LinePosition LineRangeOffset3D::getStartPosition() const
{
    return m_startPosition_;
}

void LineRangeOffset3D::setStartPosition(::nds::core::geometry::LinePosition startPosition_)
{
    m_startPosition_ = startPosition_;
}

::nds::core::geometry::LinePosition LineRangeOffset3D::getEndPosition() const
{
    return m_endPosition_;
}

void LineRangeOffset3D::setEndPosition(::nds::core::geometry::LinePosition endPosition_)
{
    m_endPosition_ = endPosition_;
}

::nds::core::geometry::PositionOffset3D& LineRangeOffset3D::getStartOffset()
{
    return m_startOffset_.value();
}

const ::nds::core::geometry::PositionOffset3D& LineRangeOffset3D::getStartOffset() const
{
    return m_startOffset_.value();
}

void LineRangeOffset3D::setStartOffset(const ::nds::core::geometry::PositionOffset3D& startOffset_)
{
    m_startOffset_ = startOffset_;
}

void LineRangeOffset3D::setStartOffset(::nds::core::geometry::PositionOffset3D&& startOffset_)
{
    m_startOffset_ = ::std::move(startOffset_);
}

bool LineRangeOffset3D::isStartOffsetUsed() const
{
    return (getOffsetType() == ::nds::core::geometry::RangeOffsetType::START || getOffsetType() == ::nds::core::geometry::RangeOffsetType::START_AND_END);
}

bool LineRangeOffset3D::isStartOffsetSet() const
{
    return m_startOffset_.hasValue();
}

void LineRangeOffset3D::resetStartOffset()
{
    m_startOffset_.reset();
}

::nds::core::geometry::PositionOffset3D& LineRangeOffset3D::getEndOffset()
{
    return m_endOffset_.value();
}

const ::nds::core::geometry::PositionOffset3D& LineRangeOffset3D::getEndOffset() const
{
    return m_endOffset_.value();
}

void LineRangeOffset3D::setEndOffset(const ::nds::core::geometry::PositionOffset3D& endOffset_)
{
    m_endOffset_ = endOffset_;
}

void LineRangeOffset3D::setEndOffset(::nds::core::geometry::PositionOffset3D&& endOffset_)
{
    m_endOffset_ = ::std::move(endOffset_);
}

bool LineRangeOffset3D::isEndOffsetUsed() const
{
    return (getOffsetType() == ::nds::core::geometry::RangeOffsetType::END || getOffsetType() == ::nds::core::geometry::RangeOffsetType::START_AND_END);
}

bool LineRangeOffset3D::isEndOffsetSet() const
{
    return m_endOffset_.hasValue();
}

void LineRangeOffset3D::resetEndOffset()
{
    m_endOffset_.reset();
}

void LineRangeOffset3D::initPackingContext(LineRangeOffset3D::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getOffsetType(), m_offsetType_);
    context.getNumBitsXY().init<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordWidth, UINT8_C(5)>>(m_numBitsXY_);
    context.getNumBitsZ().init<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordWidth, UINT8_C(5)>>(m_numBitsZ_);
    context.getStartPosition().init<::zserio::VarSizeArrayTraits>(m_startPosition_);
    context.getEndPosition().init<::zserio::VarSizeArrayTraits>(m_endPosition_);
    if (getOffsetType() == ::nds::core::geometry::RangeOffsetType::START || getOffsetType() == ::nds::core::geometry::RangeOffsetType::START_AND_END)
    {
        m_startOffset_.value().initPackingContext(context.getStartOffset());
    }
    if (getOffsetType() == ::nds::core::geometry::RangeOffsetType::END || getOffsetType() == ::nds::core::geometry::RangeOffsetType::START_AND_END)
    {
        m_endOffset_.value().initPackingContext(context.getEndOffset());
    }
}

size_t LineRangeOffset3D::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_offsetType_);
    endBitPosition += UINT8_C(5);
    endBitPosition += UINT8_C(5);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_startPosition_);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_endPosition_);
    if (getOffsetType() == ::nds::core::geometry::RangeOffsetType::START || getOffsetType() == ::nds::core::geometry::RangeOffsetType::START_AND_END)
    {
        endBitPosition += m_startOffset_.value().bitSizeOf(endBitPosition);
    }
    if (getOffsetType() == ::nds::core::geometry::RangeOffsetType::END || getOffsetType() == ::nds::core::geometry::RangeOffsetType::START_AND_END)
    {
        endBitPosition += m_endOffset_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t LineRangeOffset3D::bitSizeOf(LineRangeOffset3D::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getOffsetType(), m_offsetType_);
    endBitPosition += context.getNumBitsXY().bitSizeOf<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordWidth, UINT8_C(5)>>(m_numBitsXY_);
    endBitPosition += context.getNumBitsZ().bitSizeOf<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordWidth, UINT8_C(5)>>(m_numBitsZ_);
    endBitPosition += context.getStartPosition().bitSizeOf<::zserio::VarSizeArrayTraits>(m_startPosition_);
    endBitPosition += context.getEndPosition().bitSizeOf<::zserio::VarSizeArrayTraits>(m_endPosition_);
    if (getOffsetType() == ::nds::core::geometry::RangeOffsetType::START || getOffsetType() == ::nds::core::geometry::RangeOffsetType::START_AND_END)
    {
        endBitPosition += m_startOffset_.value().bitSizeOf(context.getStartOffset(), endBitPosition);
    }
    if (getOffsetType() == ::nds::core::geometry::RangeOffsetType::END || getOffsetType() == ::nds::core::geometry::RangeOffsetType::START_AND_END)
    {
        endBitPosition += m_endOffset_.value().bitSizeOf(context.getEndOffset(), endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t LineRangeOffset3D::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_offsetType_);
    endBitPosition += UINT8_C(5);
    endBitPosition += UINT8_C(5);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_startPosition_);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_endPosition_);
    if (getOffsetType() == ::nds::core::geometry::RangeOffsetType::START || getOffsetType() == ::nds::core::geometry::RangeOffsetType::START_AND_END)
    {
        endBitPosition = m_startOffset_.value().initializeOffsets(endBitPosition);
    }
    if (getOffsetType() == ::nds::core::geometry::RangeOffsetType::END || getOffsetType() == ::nds::core::geometry::RangeOffsetType::START_AND_END)
    {
        endBitPosition = m_endOffset_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

size_t LineRangeOffset3D::initializeOffsets(LineRangeOffset3D::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getOffsetType(), endBitPosition,
        m_offsetType_);
    endBitPosition += context.getNumBitsXY().bitSizeOf<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordWidth, UINT8_C(5)>>(m_numBitsXY_);
    endBitPosition += context.getNumBitsZ().bitSizeOf<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordWidth, UINT8_C(5)>>(m_numBitsZ_);
    endBitPosition += context.getStartPosition().bitSizeOf<::zserio::VarSizeArrayTraits>(m_startPosition_);
    endBitPosition += context.getEndPosition().bitSizeOf<::zserio::VarSizeArrayTraits>(m_endPosition_);
    if (getOffsetType() == ::nds::core::geometry::RangeOffsetType::START || getOffsetType() == ::nds::core::geometry::RangeOffsetType::START_AND_END)
    {
        endBitPosition = m_startOffset_.value().initializeOffsets(context.getStartOffset(), endBitPosition);
    }
    if (getOffsetType() == ::nds::core::geometry::RangeOffsetType::END || getOffsetType() == ::nds::core::geometry::RangeOffsetType::START_AND_END)
    {
        endBitPosition = m_endOffset_.value().initializeOffsets(context.getEndOffset(), endBitPosition);
    }

    return endBitPosition;
}

bool LineRangeOffset3D::operator==(const LineRangeOffset3D& other) const
{
    if (this != &other)
    {
        return
                (getShiftXY() == other.getShiftXY()) &&
                (getShiftZ() == other.getShiftZ()) &&
                (m_offsetType_ == other.m_offsetType_) &&
                (m_numBitsXY_ == other.m_numBitsXY_) &&
                (m_numBitsZ_ == other.m_numBitsZ_) &&
                (m_startPosition_ == other.m_startPosition_) &&
                (m_endPosition_ == other.m_endPosition_) &&
                (!isStartOffsetUsed() ? !other.isStartOffsetUsed() : (m_startOffset_ == other.m_startOffset_)) &&
                (!isEndOffsetUsed() ? !other.isEndOffsetUsed() : (m_endOffset_ == other.m_endOffset_));
    }

    return true;
}

uint32_t LineRangeOffset3D::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getShiftXY());
    result = ::zserio::calcHashCode(result, getShiftZ());
    result = ::zserio::calcHashCode(result, m_offsetType_);
    result = ::zserio::calcHashCode(result, m_numBitsXY_);
    result = ::zserio::calcHashCode(result, m_numBitsZ_);
    result = ::zserio::calcHashCode(result, m_startPosition_);
    result = ::zserio::calcHashCode(result, m_endPosition_);
    if (isStartOffsetUsed())
        result = ::zserio::calcHashCode(result, m_startOffset_);
    if (isEndOffsetUsed())
        result = ::zserio::calcHashCode(result, m_endOffset_);

    return result;
}

void LineRangeOffset3D::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_offsetType_);

    out.writeBits(m_numBitsXY_, UINT8_C(5));

    out.writeBits(m_numBitsZ_, UINT8_C(5));

    out.writeVarSize(m_startPosition_);

    out.writeVarSize(m_endPosition_);

    if (getOffsetType() == ::nds::core::geometry::RangeOffsetType::START || getOffsetType() == ::nds::core::geometry::RangeOffsetType::START_AND_END)
    {
        // check parameters
        if (m_startOffset_.value().getNumBitsXY() != static_cast<::nds::core::geometry::CoordWidth>(getNumBitsXY()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter numBitsXY for field LineRangeOffset3D.startOffset: ") <<
                    m_startOffset_.value().getNumBitsXY() << " != " << static_cast<::nds::core::geometry::CoordWidth>(getNumBitsXY()) << "!";
        }
        if (m_startOffset_.value().getNumBitsZ() != static_cast<::nds::core::geometry::CoordWidth>(getNumBitsZ()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter numBitsZ for field LineRangeOffset3D.startOffset: ") <<
                    m_startOffset_.value().getNumBitsZ() << " != " << static_cast<::nds::core::geometry::CoordWidth>(getNumBitsZ()) << "!";
        }
        if (m_startOffset_.value().getShiftXY() != static_cast<::nds::core::geometry::CoordShift>(getShiftXY()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter shiftXY for field LineRangeOffset3D.startOffset: ") <<
                    m_startOffset_.value().getShiftXY() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShiftXY()) << "!";
        }
        if (m_startOffset_.value().getShiftZ() != static_cast<::nds::core::geometry::CoordShift>(getShiftZ()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter shiftZ for field LineRangeOffset3D.startOffset: ") <<
                    m_startOffset_.value().getShiftZ() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShiftZ()) << "!";
        }
        m_startOffset_.value().write(out);
    }

    if (getOffsetType() == ::nds::core::geometry::RangeOffsetType::END || getOffsetType() == ::nds::core::geometry::RangeOffsetType::START_AND_END)
    {
        // check parameters
        if (m_endOffset_.value().getNumBitsXY() != static_cast<::nds::core::geometry::CoordWidth>(getNumBitsXY()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter numBitsXY for field LineRangeOffset3D.endOffset: ") <<
                    m_endOffset_.value().getNumBitsXY() << " != " << static_cast<::nds::core::geometry::CoordWidth>(getNumBitsXY()) << "!";
        }
        if (m_endOffset_.value().getNumBitsZ() != static_cast<::nds::core::geometry::CoordWidth>(getNumBitsZ()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter numBitsZ for field LineRangeOffset3D.endOffset: ") <<
                    m_endOffset_.value().getNumBitsZ() << " != " << static_cast<::nds::core::geometry::CoordWidth>(getNumBitsZ()) << "!";
        }
        if (m_endOffset_.value().getShiftXY() != static_cast<::nds::core::geometry::CoordShift>(getShiftXY()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter shiftXY for field LineRangeOffset3D.endOffset: ") <<
                    m_endOffset_.value().getShiftXY() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShiftXY()) << "!";
        }
        if (m_endOffset_.value().getShiftZ() != static_cast<::nds::core::geometry::CoordShift>(getShiftZ()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter shiftZ for field LineRangeOffset3D.endOffset: ") <<
                    m_endOffset_.value().getShiftZ() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShiftZ()) << "!";
        }
        m_endOffset_.value().write(out);
    }
}

void LineRangeOffset3D::write(LineRangeOffset3D::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getOffsetType(), out, m_offsetType_);

    context.getNumBitsXY().write<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordWidth, UINT8_C(5)>>(out, m_numBitsXY_);

    context.getNumBitsZ().write<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordWidth, UINT8_C(5)>>(out, m_numBitsZ_);

    context.getStartPosition().write<::zserio::VarSizeArrayTraits>(out, m_startPosition_);

    context.getEndPosition().write<::zserio::VarSizeArrayTraits>(out, m_endPosition_);

    if (getOffsetType() == ::nds::core::geometry::RangeOffsetType::START || getOffsetType() == ::nds::core::geometry::RangeOffsetType::START_AND_END)
    {
        // check parameters
        if (m_startOffset_.value().getNumBitsXY() != static_cast<::nds::core::geometry::CoordWidth>(getNumBitsXY()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter numBitsXY for field LineRangeOffset3D.startOffset: ") <<
                    m_startOffset_.value().getNumBitsXY() << " != " << static_cast<::nds::core::geometry::CoordWidth>(getNumBitsXY()) << "!";
        }
        if (m_startOffset_.value().getNumBitsZ() != static_cast<::nds::core::geometry::CoordWidth>(getNumBitsZ()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter numBitsZ for field LineRangeOffset3D.startOffset: ") <<
                    m_startOffset_.value().getNumBitsZ() << " != " << static_cast<::nds::core::geometry::CoordWidth>(getNumBitsZ()) << "!";
        }
        if (m_startOffset_.value().getShiftXY() != static_cast<::nds::core::geometry::CoordShift>(getShiftXY()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter shiftXY for field LineRangeOffset3D.startOffset: ") <<
                    m_startOffset_.value().getShiftXY() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShiftXY()) << "!";
        }
        if (m_startOffset_.value().getShiftZ() != static_cast<::nds::core::geometry::CoordShift>(getShiftZ()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter shiftZ for field LineRangeOffset3D.startOffset: ") <<
                    m_startOffset_.value().getShiftZ() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShiftZ()) << "!";
        }
        m_startOffset_.value().write(context.getStartOffset(), out);
    }

    if (getOffsetType() == ::nds::core::geometry::RangeOffsetType::END || getOffsetType() == ::nds::core::geometry::RangeOffsetType::START_AND_END)
    {
        // check parameters
        if (m_endOffset_.value().getNumBitsXY() != static_cast<::nds::core::geometry::CoordWidth>(getNumBitsXY()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter numBitsXY for field LineRangeOffset3D.endOffset: ") <<
                    m_endOffset_.value().getNumBitsXY() << " != " << static_cast<::nds::core::geometry::CoordWidth>(getNumBitsXY()) << "!";
        }
        if (m_endOffset_.value().getNumBitsZ() != static_cast<::nds::core::geometry::CoordWidth>(getNumBitsZ()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter numBitsZ for field LineRangeOffset3D.endOffset: ") <<
                    m_endOffset_.value().getNumBitsZ() << " != " << static_cast<::nds::core::geometry::CoordWidth>(getNumBitsZ()) << "!";
        }
        if (m_endOffset_.value().getShiftXY() != static_cast<::nds::core::geometry::CoordShift>(getShiftXY()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter shiftXY for field LineRangeOffset3D.endOffset: ") <<
                    m_endOffset_.value().getShiftXY() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShiftXY()) << "!";
        }
        if (m_endOffset_.value().getShiftZ() != static_cast<::nds::core::geometry::CoordShift>(getShiftZ()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter shiftZ for field LineRangeOffset3D.endOffset: ") <<
                    m_endOffset_.value().getShiftZ() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShiftZ()) << "!";
        }
        m_endOffset_.value().write(context.getEndOffset(), out);
    }
}

::nds::core::geometry::RangeOffsetType LineRangeOffset3D::readOffsetType(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::core::geometry::RangeOffsetType>(in);
}

::nds::core::geometry::RangeOffsetType LineRangeOffset3D::readOffsetType(LineRangeOffset3D::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::core::geometry::RangeOffsetType>(context.getOffsetType(), in);
}
::nds::core::geometry::CoordWidth LineRangeOffset3D::readNumBitsXY(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::geometry::CoordWidth>(in.readBits(UINT8_C(5)));
}

::nds::core::geometry::CoordWidth LineRangeOffset3D::readNumBitsXY(LineRangeOffset3D::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumBitsXY().read<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordWidth, UINT8_C(5)>>(in);
}
::nds::core::geometry::CoordWidth LineRangeOffset3D::readNumBitsZ(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::geometry::CoordWidth>(in.readBits(UINT8_C(5)));
}

::nds::core::geometry::CoordWidth LineRangeOffset3D::readNumBitsZ(LineRangeOffset3D::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumBitsZ().read<::zserio::BitFieldArrayTraits<::nds::core::geometry::CoordWidth, UINT8_C(5)>>(in);
}
::nds::core::geometry::LinePosition LineRangeOffset3D::readStartPosition(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::geometry::LinePosition>(in.readVarSize());
}

::nds::core::geometry::LinePosition LineRangeOffset3D::readStartPosition(LineRangeOffset3D::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getStartPosition().read<::zserio::VarSizeArrayTraits>(in);
}
::nds::core::geometry::LinePosition LineRangeOffset3D::readEndPosition(::zserio::BitStreamReader& in)
{
    return static_cast<::nds::core::geometry::LinePosition>(in.readVarSize());
}

::nds::core::geometry::LinePosition LineRangeOffset3D::readEndPosition(LineRangeOffset3D::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getEndPosition().read<::zserio::VarSizeArrayTraits>(in);
}
::zserio::InplaceOptionalHolder<::nds::core::geometry::PositionOffset3D> LineRangeOffset3D::readStartOffset(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getOffsetType() == ::nds::core::geometry::RangeOffsetType::START || getOffsetType() == ::nds::core::geometry::RangeOffsetType::START_AND_END)
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::geometry::PositionOffset3D>(::nds::core::geometry::PositionOffset3D(in, static_cast<::nds::core::geometry::CoordWidth>(getNumBitsXY()), static_cast<::nds::core::geometry::CoordWidth>(getNumBitsZ()), static_cast<::nds::core::geometry::CoordShift>(getShiftXY()), static_cast<::nds::core::geometry::CoordShift>(getShiftZ()), allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::geometry::PositionOffset3D>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::geometry::PositionOffset3D> LineRangeOffset3D::readStartOffset(LineRangeOffset3D::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getOffsetType() == ::nds::core::geometry::RangeOffsetType::START || getOffsetType() == ::nds::core::geometry::RangeOffsetType::START_AND_END)
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::geometry::PositionOffset3D>(::nds::core::geometry::PositionOffset3D(context.getStartOffset(), in, static_cast<::nds::core::geometry::CoordWidth>(getNumBitsXY()), static_cast<::nds::core::geometry::CoordWidth>(getNumBitsZ()), static_cast<::nds::core::geometry::CoordShift>(getShiftXY()), static_cast<::nds::core::geometry::CoordShift>(getShiftZ()), allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::geometry::PositionOffset3D>(::zserio::NullOpt);
}
::zserio::InplaceOptionalHolder<::nds::core::geometry::PositionOffset3D> LineRangeOffset3D::readEndOffset(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getOffsetType() == ::nds::core::geometry::RangeOffsetType::END || getOffsetType() == ::nds::core::geometry::RangeOffsetType::START_AND_END)
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::geometry::PositionOffset3D>(::nds::core::geometry::PositionOffset3D(in, static_cast<::nds::core::geometry::CoordWidth>(getNumBitsXY()), static_cast<::nds::core::geometry::CoordWidth>(getNumBitsZ()), static_cast<::nds::core::geometry::CoordShift>(getShiftXY()), static_cast<::nds::core::geometry::CoordShift>(getShiftZ()), allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::geometry::PositionOffset3D>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::geometry::PositionOffset3D> LineRangeOffset3D::readEndOffset(LineRangeOffset3D::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getOffsetType() == ::nds::core::geometry::RangeOffsetType::END || getOffsetType() == ::nds::core::geometry::RangeOffsetType::START_AND_END)
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::geometry::PositionOffset3D>(::nds::core::geometry::PositionOffset3D(context.getEndOffset(), in, static_cast<::nds::core::geometry::CoordWidth>(getNumBitsXY()), static_cast<::nds::core::geometry::CoordWidth>(getNumBitsZ()), static_cast<::nds::core::geometry::CoordShift>(getShiftXY()), static_cast<::nds::core::geometry::CoordShift>(getShiftZ()), allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::geometry::PositionOffset3D>(::zserio::NullOpt);
}

} // namespace geometry
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/core/geometry/SpatialExtent.h>

namespace nds
{
namespace core
{
namespace geometry
{

SpatialExtent::SpatialExtent(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_boundingBox_(allocator),
        m_boundingPolygon_(::zserio::NullOpt)
{
}

SpatialExtent::SpatialExtent(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_boundingBox_(readBoundingBox(in, allocator)),
        m_boundingPolygon_(readBoundingPolygon(in, allocator))
{
}

SpatialExtent::SpatialExtent(SpatialExtent::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_boundingBox_(readBoundingBox(context, in, allocator)),
        m_boundingPolygon_(readBoundingPolygon(context, in, allocator))
{
}

SpatialExtent::SpatialExtent(const SpatialExtent& other) :
        m_boundingBox_(other.m_boundingBox_),
        m_boundingPolygon_(other.m_boundingPolygon_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

SpatialExtent& SpatialExtent::operator=(const SpatialExtent& other)
{
    m_boundingBox_ = other.m_boundingBox_;
    m_boundingPolygon_ = other.m_boundingPolygon_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

SpatialExtent::SpatialExtent(SpatialExtent&& other) :
        m_boundingBox_(::std::move(other.m_boundingBox_)),
        m_boundingPolygon_(::std::move(other.m_boundingPolygon_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

SpatialExtent& SpatialExtent::operator=(SpatialExtent&& other)
{
    m_boundingBox_ = ::std::move(other.m_boundingBox_);
    m_boundingPolygon_ = ::std::move(other.m_boundingPolygon_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

SpatialExtent::SpatialExtent(::zserio::PropagateAllocatorT,
        const SpatialExtent& other, const allocator_type& allocator) :
        m_boundingBox_(::zserio::allocatorPropagatingCopy(other.m_boundingBox_, allocator)),
        m_boundingPolygon_(::zserio::allocatorPropagatingCopy(other.m_boundingPolygon_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void SpatialExtent::initializeChildren()
{
    m_boundingBox_.initializeChildren();
    if (isBoundingPolygonSet())
        m_boundingPolygon_.value().initialize(static_cast<::nds::core::geometry::CoordShift>(0));

    m_areChildrenInitialized = true;
}

::nds::core::geometry::BoundingBox2D& SpatialExtent::getBoundingBox()
{
    return m_boundingBox_;
}

const ::nds::core::geometry::BoundingBox2D& SpatialExtent::getBoundingBox() const
{
    return m_boundingBox_;
}

void SpatialExtent::setBoundingBox(const ::nds::core::geometry::BoundingBox2D& boundingBox_)
{
    m_boundingBox_ = boundingBox_;
}

void SpatialExtent::setBoundingBox(::nds::core::geometry::BoundingBox2D&& boundingBox_)
{
    m_boundingBox_ = ::std::move(boundingBox_);
}

::nds::core::geometry::BoundingPolygon2D& SpatialExtent::getBoundingPolygon()
{
    return m_boundingPolygon_.value();
}

const ::nds::core::geometry::BoundingPolygon2D& SpatialExtent::getBoundingPolygon() const
{
    return m_boundingPolygon_.value();
}

void SpatialExtent::setBoundingPolygon(const ::nds::core::geometry::BoundingPolygon2D& boundingPolygon_)
{
    m_boundingPolygon_ = boundingPolygon_;
}

void SpatialExtent::setBoundingPolygon(::nds::core::geometry::BoundingPolygon2D&& boundingPolygon_)
{
    m_boundingPolygon_ = ::std::move(boundingPolygon_);
}

bool SpatialExtent::isBoundingPolygonUsed() const
{
    return (isBoundingPolygonSet());
}

bool SpatialExtent::isBoundingPolygonSet() const
{
    return m_boundingPolygon_.hasValue();
}

void SpatialExtent::resetBoundingPolygon()
{
    m_boundingPolygon_.reset();
}

void SpatialExtent::initPackingContext(SpatialExtent::ZserioPackingContext& context) const
{
    m_boundingBox_.initPackingContext(context.getBoundingBox());
    if (isBoundingPolygonSet())
    {
        m_boundingPolygon_.value().initPackingContext(context.getBoundingPolygon());
    }
}

size_t SpatialExtent::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_boundingBox_.bitSizeOf(endBitPosition);
    endBitPosition += 1;
    if (isBoundingPolygonSet())
    {
        endBitPosition += m_boundingPolygon_.value().bitSizeOf(endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t SpatialExtent::bitSizeOf(SpatialExtent::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_boundingBox_.bitSizeOf(context.getBoundingBox(), endBitPosition);
    endBitPosition += 1;
    if (isBoundingPolygonSet())
    {
        endBitPosition += m_boundingPolygon_.value().bitSizeOf(context.getBoundingPolygon(), endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t SpatialExtent::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_boundingBox_.initializeOffsets(endBitPosition);
    endBitPosition += 1;
    if (isBoundingPolygonSet())
    {
        endBitPosition = m_boundingPolygon_.value().initializeOffsets(endBitPosition);
    }

    return endBitPosition;
}

size_t SpatialExtent::initializeOffsets(SpatialExtent::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_boundingBox_.initializeOffsets(context.getBoundingBox(), endBitPosition);
    endBitPosition += 1;
    if (isBoundingPolygonSet())
    {
        endBitPosition = m_boundingPolygon_.value().initializeOffsets(context.getBoundingPolygon(), endBitPosition);
    }

    return endBitPosition;
}

bool SpatialExtent::operator==(const SpatialExtent& other) const
{
    if (this != &other)
    {
        return
                (m_boundingBox_ == other.m_boundingBox_) &&
                (!isBoundingPolygonUsed() ? !other.isBoundingPolygonUsed() : (m_boundingPolygon_ == other.m_boundingPolygon_));
    }

    return true;
}

uint32_t SpatialExtent::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_boundingBox_);
    if (isBoundingPolygonUsed())
        result = ::zserio::calcHashCode(result, m_boundingPolygon_);

    return result;
}

void SpatialExtent::write(::zserio::BitStreamWriter& out) const
{
    m_boundingBox_.write(out);

    if (isBoundingPolygonSet())
    {
        out.writeBool(true);
        // check parameters
        if (m_boundingPolygon_.value().getShift() != static_cast<::nds::core::geometry::CoordShift>(0))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field SpatialExtent.boundingPolygon: ") <<
                    m_boundingPolygon_.value().getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(0) << "!";
        }
        m_boundingPolygon_.value().write(out);
    }
    else
    {
        out.writeBool(false);
    }
}

void SpatialExtent::write(SpatialExtent::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    m_boundingBox_.write(context.getBoundingBox(), out);

    if (isBoundingPolygonSet())
    {
        out.writeBool(true);
        // check parameters
        if (m_boundingPolygon_.value().getShift() != static_cast<::nds::core::geometry::CoordShift>(0))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field SpatialExtent.boundingPolygon: ") <<
                    m_boundingPolygon_.value().getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(0) << "!";
        }
        m_boundingPolygon_.value().write(context.getBoundingPolygon(), out);
    }
    else
    {
        out.writeBool(false);
    }
}

::nds::core::geometry::BoundingBox2D SpatialExtent::readBoundingBox(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::geometry::BoundingBox2D(in, allocator);
}

::nds::core::geometry::BoundingBox2D SpatialExtent::readBoundingBox(SpatialExtent::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::geometry::BoundingBox2D(context.getBoundingBox(), in, allocator);
}
::zserio::InplaceOptionalHolder<::nds::core::geometry::BoundingPolygon2D> SpatialExtent::readBoundingPolygon(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::geometry::BoundingPolygon2D>(::nds::core::geometry::BoundingPolygon2D(in, static_cast<::nds::core::geometry::CoordShift>(0), allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::geometry::BoundingPolygon2D>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<::nds::core::geometry::BoundingPolygon2D> SpatialExtent::readBoundingPolygon(SpatialExtent::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (in.readBool())
    {
        return ::zserio::InplaceOptionalHolder<::nds::core::geometry::BoundingPolygon2D>(::nds::core::geometry::BoundingPolygon2D(context.getBoundingPolygon(), in, static_cast<::nds::core::geometry::CoordShift>(0), allocator));
    }

    return ::zserio::InplaceOptionalHolder<::nds::core::geometry::BoundingPolygon2D>(::zserio::NullOpt);
}

} // namespace geometry
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/core/geometry/BoundingBox2D.h>

namespace nds
{
namespace core
{
namespace geometry
{

BoundingBox2D::BoundingBox2D(const allocator_type& allocator) noexcept :
        m_areChildrenInitialized(false),
        m_southWestPosition_(allocator),
        m_northEastPosition_(allocator)
{
}

BoundingBox2D::BoundingBox2D(::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_southWestPosition_(readSouthWestPosition(in, allocator)),
        m_northEastPosition_(readNorthEastPosition(in, allocator))
{
}

BoundingBox2D::BoundingBox2D(BoundingBox2D::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator) :
        m_areChildrenInitialized(true),
        m_southWestPosition_(readSouthWestPosition(context, in, allocator)),
        m_northEastPosition_(readNorthEastPosition(context, in, allocator))
{
}

BoundingBox2D::BoundingBox2D(const BoundingBox2D& other) :
        m_southWestPosition_(other.m_southWestPosition_),
        m_northEastPosition_(other.m_northEastPosition_)
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

BoundingBox2D& BoundingBox2D::operator=(const BoundingBox2D& other)
{
    m_southWestPosition_ = other.m_southWestPosition_;
    m_northEastPosition_ = other.m_northEastPosition_;
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

BoundingBox2D::BoundingBox2D(BoundingBox2D&& other) :
        m_southWestPosition_(::std::move(other.m_southWestPosition_)),
        m_northEastPosition_(::std::move(other.m_northEastPosition_))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

BoundingBox2D& BoundingBox2D::operator=(BoundingBox2D&& other)
{
    m_southWestPosition_ = ::std::move(other.m_southWestPosition_);
    m_northEastPosition_ = ::std::move(other.m_northEastPosition_);
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;

    return *this;
}

BoundingBox2D::BoundingBox2D(::zserio::PropagateAllocatorT,
        const BoundingBox2D& other, const allocator_type& allocator) :
        m_southWestPosition_(::zserio::allocatorPropagatingCopy(other.m_southWestPosition_, allocator)),
        m_northEastPosition_(::zserio::allocatorPropagatingCopy(other.m_northEastPosition_, allocator))
{
    if (other.m_areChildrenInitialized)
        initializeChildren();
    else
        m_areChildrenInitialized = false;
}

void BoundingBox2D::initializeChildren()
{
    m_southWestPosition_.initialize(static_cast<::nds::core::geometry::CoordShift>(0));
    m_northEastPosition_.initialize(static_cast<::nds::core::geometry::CoordShift>(0));

    m_areChildrenInitialized = true;
}

::nds::core::geometry::Position2D& BoundingBox2D::getSouthWestPosition()
{
    return m_southWestPosition_;
}

const ::nds::core::geometry::Position2D& BoundingBox2D::getSouthWestPosition() const
{
    return m_southWestPosition_;
}

void BoundingBox2D::setSouthWestPosition(const ::nds::core::geometry::Position2D& southWestPosition_)
{
    m_southWestPosition_ = southWestPosition_;
}

void BoundingBox2D::setSouthWestPosition(::nds::core::geometry::Position2D&& southWestPosition_)
{
    m_southWestPosition_ = ::std::move(southWestPosition_);
}

::nds::core::geometry::Position2D& BoundingBox2D::getNorthEastPosition()
{
    return m_northEastPosition_;
}

const ::nds::core::geometry::Position2D& BoundingBox2D::getNorthEastPosition() const
{
    return m_northEastPosition_;
}

void BoundingBox2D::setNorthEastPosition(const ::nds::core::geometry::Position2D& northEastPosition_)
{
    m_northEastPosition_ = northEastPosition_;
}

void BoundingBox2D::setNorthEastPosition(::nds::core::geometry::Position2D&& northEastPosition_)
{
    m_northEastPosition_ = ::std::move(northEastPosition_);
}

void BoundingBox2D::initPackingContext(BoundingBox2D::ZserioPackingContext& context) const
{
    m_southWestPosition_.initPackingContext(context.getSouthWestPosition());
    m_northEastPosition_.initPackingContext(context.getNorthEastPosition());
}

size_t BoundingBox2D::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_southWestPosition_.bitSizeOf(endBitPosition);
    endBitPosition += m_northEastPosition_.bitSizeOf(endBitPosition);

    return endBitPosition - bitPosition;
}

size_t BoundingBox2D::bitSizeOf(BoundingBox2D::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_southWestPosition_.bitSizeOf(context.getSouthWestPosition(), endBitPosition);
    endBitPosition += m_northEastPosition_.bitSizeOf(context.getNorthEastPosition(), endBitPosition);

    return endBitPosition - bitPosition;
}

size_t BoundingBox2D::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_southWestPosition_.initializeOffsets(endBitPosition);
    endBitPosition = m_northEastPosition_.initializeOffsets(endBitPosition);

    return endBitPosition;
}

size_t BoundingBox2D::initializeOffsets(BoundingBox2D::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_southWestPosition_.initializeOffsets(context.getSouthWestPosition(), endBitPosition);
    endBitPosition = m_northEastPosition_.initializeOffsets(context.getNorthEastPosition(), endBitPosition);

    return endBitPosition;
}

bool BoundingBox2D::operator==(const BoundingBox2D& other) const
{
    if (this != &other)
    {
        return
                (m_southWestPosition_ == other.m_southWestPosition_) &&
                (m_northEastPosition_ == other.m_northEastPosition_);
    }

    return true;
}

uint32_t BoundingBox2D::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_southWestPosition_);
    result = ::zserio::calcHashCode(result, m_northEastPosition_);

    return result;
}

void BoundingBox2D::write(::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_southWestPosition_.getShift() != static_cast<::nds::core::geometry::CoordShift>(0))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field BoundingBox2D.southWestPosition: ") <<
                m_southWestPosition_.getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(0) << "!";
    }
    m_southWestPosition_.write(out);

    // check parameters
    if (m_northEastPosition_.getShift() != static_cast<::nds::core::geometry::CoordShift>(0))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field BoundingBox2D.northEastPosition: ") <<
                m_northEastPosition_.getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(0) << "!";
    }
    m_northEastPosition_.write(out);
}

void BoundingBox2D::write(BoundingBox2D::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_southWestPosition_.getShift() != static_cast<::nds::core::geometry::CoordShift>(0))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field BoundingBox2D.southWestPosition: ") <<
                m_southWestPosition_.getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(0) << "!";
    }
    m_southWestPosition_.write(context.getSouthWestPosition(), out);

    // check parameters
    if (m_northEastPosition_.getShift() != static_cast<::nds::core::geometry::CoordShift>(0))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field BoundingBox2D.northEastPosition: ") <<
                m_northEastPosition_.getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(0) << "!";
    }
    m_northEastPosition_.write(context.getNorthEastPosition(), out);
}

::nds::core::geometry::Position2D BoundingBox2D::readSouthWestPosition(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::geometry::Position2D(in, static_cast<::nds::core::geometry::CoordShift>(0), allocator);
}

::nds::core::geometry::Position2D BoundingBox2D::readSouthWestPosition(BoundingBox2D::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::geometry::Position2D(context.getSouthWestPosition(), in, static_cast<::nds::core::geometry::CoordShift>(0), allocator);
}
::nds::core::geometry::Position2D BoundingBox2D::readNorthEastPosition(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::geometry::Position2D(in, static_cast<::nds::core::geometry::CoordShift>(0), allocator);
}

::nds::core::geometry::Position2D BoundingBox2D::readNorthEastPosition(BoundingBox2D::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::geometry::Position2D(context.getNorthEastPosition(), in, static_cast<::nds::core::geometry::CoordShift>(0), allocator);
}

} // namespace geometry
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/core/geometry/BoundingPolygon2D.h>

namespace nds
{
namespace core
{
namespace geometry
{

BoundingPolygon2D::BoundingPolygon2D(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_outline_(allocator),
        m_hasHoles_(bool()),
        m_holes_(::zserio::NullOpt)
{
}

BoundingPolygon2D::BoundingPolygon2D(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift shift_, const allocator_type& allocator) :
        m_shift_(shift_),
        m_isInitialized(true),
        m_outline_(readOutline(in, allocator)),
        m_hasHoles_(readHasHoles(in)),
        m_holes_(readHoles(in, allocator))
{
}

BoundingPolygon2D::BoundingPolygon2D(BoundingPolygon2D::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift shift_, const allocator_type& allocator) :
        m_shift_(shift_),
        m_isInitialized(true),
        m_outline_(readOutline(context, in, allocator)),
        m_hasHoles_(readHasHoles(in)),
        m_holes_(readHoles(context, in, allocator))
{
}

BoundingPolygon2D::BoundingPolygon2D(const BoundingPolygon2D& other) :
        m_outline_(other.m_outline_),
        m_hasHoles_(other.m_hasHoles_),
        m_holes_(other.m_holes_)
{
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;
}

BoundingPolygon2D& BoundingPolygon2D::operator=(const BoundingPolygon2D& other)
{
    m_outline_ = other.m_outline_;
    m_hasHoles_ = other.m_hasHoles_;
    m_holes_ = other.m_holes_;
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;

    return *this;
}

BoundingPolygon2D::BoundingPolygon2D(BoundingPolygon2D&& other) :
        m_outline_(::std::move(other.m_outline_)),
        m_hasHoles_(::std::move(other.m_hasHoles_)),
        m_holes_(::std::move(other.m_holes_))
{
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;
}

BoundingPolygon2D& BoundingPolygon2D::operator=(BoundingPolygon2D&& other)
{
    m_outline_ = ::std::move(other.m_outline_);
    m_hasHoles_ = ::std::move(other.m_hasHoles_);
    m_holes_ = ::std::move(other.m_holes_);
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;

    return *this;
}

BoundingPolygon2D::BoundingPolygon2D(::zserio::PropagateAllocatorT,
        const BoundingPolygon2D& other, const allocator_type& allocator) :
        m_outline_(::zserio::allocatorPropagatingCopy(other.m_outline_, allocator)),
        m_hasHoles_(::zserio::allocatorPropagatingCopy(other.m_hasHoles_, allocator)),
        m_holes_(::zserio::allocatorPropagatingCopy(other.m_holes_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;
}

void BoundingPolygon2D::initialize(
        ::nds::core::geometry::CoordShift shift_)
{
    m_shift_ = shift_;
    m_isInitialized = true;

    initializeChildren();
}

bool BoundingPolygon2D::isInitialized() const
{
    return m_isInitialized;
}

void BoundingPolygon2D::initializeChildren()
{
    m_outline_.initialize(static_cast<::nds::core::geometry::CoordShift>(getShift()));
    if (getHasHoles())
        m_holes_.value().initializeElements(*this);
}

::nds::core::geometry::CoordShift BoundingPolygon2D::getShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'shift' of compound 'BoundingPolygon2D' is not initialized!");

    return m_shift_;
}

::nds::core::geometry::Ring2D& BoundingPolygon2D::getOutline()
{
    return m_outline_;
}

const ::nds::core::geometry::Ring2D& BoundingPolygon2D::getOutline() const
{
    return m_outline_;
}

void BoundingPolygon2D::setOutline(const ::nds::core::geometry::Ring2D& outline_)
{
    m_outline_ = outline_;
}

void BoundingPolygon2D::setOutline(::nds::core::geometry::Ring2D&& outline_)
{
    m_outline_ = ::std::move(outline_);
}

bool BoundingPolygon2D::getHasHoles() const
{
    return m_hasHoles_;
}

void BoundingPolygon2D::setHasHoles(bool hasHoles_)
{
    m_hasHoles_ = hasHoles_;
}

::zserio::vector<::nds::core::geometry::Ring2D>& BoundingPolygon2D::getHoles()
{
    return m_holes_.value().getRawArray();
}

const ::zserio::vector<::nds::core::geometry::Ring2D>& BoundingPolygon2D::getHoles() const
{
    return m_holes_.value().getRawArray();
}

void BoundingPolygon2D::setHoles(const ::zserio::vector<::nds::core::geometry::Ring2D>& holes_)
{
    m_holes_ = ZserioArrayType_holes(holes_);
}

void BoundingPolygon2D::setHoles(::zserio::vector<::nds::core::geometry::Ring2D>&& holes_)
{
    m_holes_ = ZserioArrayType_holes(std::move(holes_));
}

bool BoundingPolygon2D::isHolesUsed() const
{
    return (getHasHoles());
}

bool BoundingPolygon2D::isHolesSet() const
{
    return m_holes_.hasValue();
}

void BoundingPolygon2D::resetHoles()
{
    m_holes_.reset();
}

void BoundingPolygon2D::initPackingContext(BoundingPolygon2D::ZserioPackingContext& context) const
{
    m_outline_.initPackingContext(context.getOutline());
}

size_t BoundingPolygon2D::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_outline_.bitSizeOf(endBitPosition);
    endBitPosition += UINT8_C(1);
    if (getHasHoles())
    {
        endBitPosition += m_holes_.value().bitSizeOf(*this, endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t BoundingPolygon2D::bitSizeOf(BoundingPolygon2D::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_outline_.bitSizeOf(context.getOutline(), endBitPosition);
    endBitPosition += UINT8_C(1);
    if (getHasHoles())
    {
        endBitPosition += m_holes_.value().bitSizeOfPacked(*this, endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t BoundingPolygon2D::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_outline_.initializeOffsets(endBitPosition);
    endBitPosition += UINT8_C(1);
    if (getHasHoles())
    {
        endBitPosition = m_holes_.value().initializeOffsets(*this, endBitPosition);
    }

    return endBitPosition;
}

size_t BoundingPolygon2D::initializeOffsets(BoundingPolygon2D::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_outline_.initializeOffsets(context.getOutline(), endBitPosition);
    endBitPosition += UINT8_C(1);
    if (getHasHoles())
    {
        endBitPosition = m_holes_.value().initializeOffsetsPacked(*this, endBitPosition);
    }

    return endBitPosition;
}

bool BoundingPolygon2D::operator==(const BoundingPolygon2D& other) const
{
    if (this != &other)
    {
        return
                (getShift() == other.getShift()) &&
                (m_outline_ == other.m_outline_) &&
                (m_hasHoles_ == other.m_hasHoles_) &&
                (!isHolesUsed() ? !other.isHolesUsed() : (m_holes_ == other.m_holes_));
    }

    return true;
}

uint32_t BoundingPolygon2D::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getShift());
    result = ::zserio::calcHashCode(result, m_outline_);
    result = ::zserio::calcHashCode(result, m_hasHoles_);
    if (isHolesUsed())
        result = ::zserio::calcHashCode(result, m_holes_);

    return result;
}

void BoundingPolygon2D::write(::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_outline_.getShift() != static_cast<::nds::core::geometry::CoordShift>(getShift()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field BoundingPolygon2D.outline: ") <<
                m_outline_.getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShift()) << "!";
    }
    m_outline_.write(out);

    out.writeBool(m_hasHoles_);

    if (getHasHoles())
    {
        m_holes_.value().write(*this, out);
    }
}

void BoundingPolygon2D::write(BoundingPolygon2D::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_outline_.getShift() != static_cast<::nds::core::geometry::CoordShift>(getShift()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field BoundingPolygon2D.outline: ") <<
                m_outline_.getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShift()) << "!";
    }
    m_outline_.write(context.getOutline(), out);

    out.writeBool(m_hasHoles_);

    if (getHasHoles())
    {
        m_holes_.value().writePacked(*this, out);
    }
}

void BoundingPolygon2D::ZserioArrayExpressions_holes::initializeElement(BoundingPolygon2D& owner,
        ::nds::core::geometry::Ring2D& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getShift()));
}

void BoundingPolygon2D::ZserioElementFactory_holes::create(BoundingPolygon2D&         owner,
        ::zserio::vector<::nds::core::geometry::Ring2D>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getShift()), array.get_allocator());
}

void BoundingPolygon2D::ZserioElementFactory_holes::create(BoundingPolygon2D&         owner,
        ::zserio::vector<::nds::core::geometry::Ring2D>& array,
        ::nds::core::geometry::Ring2D::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getShift()), array.get_allocator());
}

::nds::core::geometry::Ring2D BoundingPolygon2D::readOutline(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::geometry::Ring2D(in, static_cast<::nds::core::geometry::CoordShift>(getShift()), allocator);
}

::nds::core::geometry::Ring2D BoundingPolygon2D::readOutline(BoundingPolygon2D::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::geometry::Ring2D(context.getOutline(), in, static_cast<::nds::core::geometry::CoordShift>(getShift()), allocator);
}
bool BoundingPolygon2D::readHasHoles(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
::zserio::InplaceOptionalHolder<BoundingPolygon2D::ZserioArrayType_holes> BoundingPolygon2D::readHoles(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getHasHoles())
    {
        ZserioArrayType_holes readField(allocator);
        readField.read(*this, in);

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_holes>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_holes>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<BoundingPolygon2D::ZserioArrayType_holes> BoundingPolygon2D::readHoles(BoundingPolygon2D::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getHasHoles())
    {
        ZserioArrayType_holes readField(allocator);
        readField.readPacked(*this, in);

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_holes>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_holes>(::zserio::NullOpt);
}

} // namespace geometry
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/core/geometry/BoundingPolygon3D.h>

namespace nds
{
namespace core
{
namespace geometry
{

BoundingPolygon3D::BoundingPolygon3D(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_outline_(allocator),
        m_hasHoles_(bool()),
        m_holes_(::zserio::NullOpt)
{
}

BoundingPolygon3D::BoundingPolygon3D(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift xyShift_,
        ::nds::core::geometry::CoordShift zShift_, const allocator_type& allocator) :
        m_xyShift_(xyShift_),
        m_zShift_(zShift_),
        m_isInitialized(true),
        m_outline_(readOutline(in, allocator)),
        m_hasHoles_(readHasHoles(in)),
        m_holes_(readHoles(in, allocator))
{
}

BoundingPolygon3D::BoundingPolygon3D(BoundingPolygon3D::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift xyShift_,
        ::nds::core::geometry::CoordShift zShift_, const allocator_type& allocator) :
        m_xyShift_(xyShift_),
        m_zShift_(zShift_),
        m_isInitialized(true),
        m_outline_(readOutline(context, in, allocator)),
        m_hasHoles_(readHasHoles(in)),
        m_holes_(readHoles(context, in, allocator))
{
}

BoundingPolygon3D::BoundingPolygon3D(const BoundingPolygon3D& other) :
        m_outline_(other.m_outline_),
        m_hasHoles_(other.m_hasHoles_),
        m_holes_(other.m_holes_)
{
    if (other.m_isInitialized)
        initialize(other.m_xyShift_, other.m_zShift_);
    else
        m_isInitialized = false;
}

BoundingPolygon3D& BoundingPolygon3D::operator=(const BoundingPolygon3D& other)
{
    m_outline_ = other.m_outline_;
    m_hasHoles_ = other.m_hasHoles_;
    m_holes_ = other.m_holes_;
    if (other.m_isInitialized)
        initialize(other.m_xyShift_, other.m_zShift_);
    else
        m_isInitialized = false;

    return *this;
}

BoundingPolygon3D::BoundingPolygon3D(BoundingPolygon3D&& other) :
        m_outline_(::std::move(other.m_outline_)),
        m_hasHoles_(::std::move(other.m_hasHoles_)),
        m_holes_(::std::move(other.m_holes_))
{
    if (other.m_isInitialized)
        initialize(other.m_xyShift_, other.m_zShift_);
    else
        m_isInitialized = false;
}

BoundingPolygon3D& BoundingPolygon3D::operator=(BoundingPolygon3D&& other)
{
    m_outline_ = ::std::move(other.m_outline_);
    m_hasHoles_ = ::std::move(other.m_hasHoles_);
    m_holes_ = ::std::move(other.m_holes_);
    if (other.m_isInitialized)
        initialize(other.m_xyShift_, other.m_zShift_);
    else
        m_isInitialized = false;

    return *this;
}

BoundingPolygon3D::BoundingPolygon3D(::zserio::PropagateAllocatorT,
        const BoundingPolygon3D& other, const allocator_type& allocator) :
        m_outline_(::zserio::allocatorPropagatingCopy(other.m_outline_, allocator)),
        m_hasHoles_(::zserio::allocatorPropagatingCopy(other.m_hasHoles_, allocator)),
        m_holes_(::zserio::allocatorPropagatingCopy(other.m_holes_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_xyShift_, other.m_zShift_);
    else
        m_isInitialized = false;
}

void BoundingPolygon3D::initialize(
        ::nds::core::geometry::CoordShift xyShift_,
        ::nds::core::geometry::CoordShift zShift_)
{
    m_xyShift_ = xyShift_;
    m_zShift_ = zShift_;
    m_isInitialized = true;

    initializeChildren();
}

bool BoundingPolygon3D::isInitialized() const
{
    return m_isInitialized;
}

void BoundingPolygon3D::initializeChildren()
{
    m_outline_.initialize(static_cast<::nds::core::geometry::CoordShift>(getXyShift()), static_cast<::nds::core::geometry::CoordShift>(getZShift()));
    if (getHasHoles())
        m_holes_.value().initializeElements(*this);
}

::nds::core::geometry::CoordShift BoundingPolygon3D::getXyShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'xyShift' of compound 'BoundingPolygon3D' is not initialized!");

    return m_xyShift_;
}

::nds::core::geometry::CoordShift BoundingPolygon3D::getZShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'zShift' of compound 'BoundingPolygon3D' is not initialized!");

    return m_zShift_;
}

::nds::core::geometry::Ring3D& BoundingPolygon3D::getOutline()
{
    return m_outline_;
}

const ::nds::core::geometry::Ring3D& BoundingPolygon3D::getOutline() const
{
    return m_outline_;
}

void BoundingPolygon3D::setOutline(const ::nds::core::geometry::Ring3D& outline_)
{
    m_outline_ = outline_;
}

void BoundingPolygon3D::setOutline(::nds::core::geometry::Ring3D&& outline_)
{
    m_outline_ = ::std::move(outline_);
}

bool BoundingPolygon3D::getHasHoles() const
{
    return m_hasHoles_;
}

void BoundingPolygon3D::setHasHoles(bool hasHoles_)
{
    m_hasHoles_ = hasHoles_;
}

::zserio::vector<::nds::core::geometry::Ring3D>& BoundingPolygon3D::getHoles()
{
    return m_holes_.value().getRawArray();
}

const ::zserio::vector<::nds::core::geometry::Ring3D>& BoundingPolygon3D::getHoles() const
{
    return m_holes_.value().getRawArray();
}

void BoundingPolygon3D::setHoles(const ::zserio::vector<::nds::core::geometry::Ring3D>& holes_)
{
    m_holes_ = ZserioArrayType_holes(holes_);
}

void BoundingPolygon3D::setHoles(::zserio::vector<::nds::core::geometry::Ring3D>&& holes_)
{
    m_holes_ = ZserioArrayType_holes(std::move(holes_));
}

bool BoundingPolygon3D::isHolesUsed() const
{
    return (getHasHoles());
}

bool BoundingPolygon3D::isHolesSet() const
{
    return m_holes_.hasValue();
}

void BoundingPolygon3D::resetHoles()
{
    m_holes_.reset();
}

void BoundingPolygon3D::initPackingContext(BoundingPolygon3D::ZserioPackingContext& context) const
{
    m_outline_.initPackingContext(context.getOutline());
}

size_t BoundingPolygon3D::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_outline_.bitSizeOf(endBitPosition);
    endBitPosition += UINT8_C(1);
    if (getHasHoles())
    {
        endBitPosition += m_holes_.value().bitSizeOf(*this, endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t BoundingPolygon3D::bitSizeOf(BoundingPolygon3D::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_outline_.bitSizeOf(context.getOutline(), endBitPosition);
    endBitPosition += UINT8_C(1);
    if (getHasHoles())
    {
        endBitPosition += m_holes_.value().bitSizeOfPacked(*this, endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t BoundingPolygon3D::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_outline_.initializeOffsets(endBitPosition);
    endBitPosition += UINT8_C(1);
    if (getHasHoles())
    {
        endBitPosition = m_holes_.value().initializeOffsets(*this, endBitPosition);
    }

    return endBitPosition;
}

size_t BoundingPolygon3D::initializeOffsets(BoundingPolygon3D::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_outline_.initializeOffsets(context.getOutline(), endBitPosition);
    endBitPosition += UINT8_C(1);
    if (getHasHoles())
    {
        endBitPosition = m_holes_.value().initializeOffsetsPacked(*this, endBitPosition);
    }

    return endBitPosition;
}

bool BoundingPolygon3D::operator==(const BoundingPolygon3D& other) const
{
    if (this != &other)
    {
        return
                (getXyShift() == other.getXyShift()) &&
                (getZShift() == other.getZShift()) &&
                (m_outline_ == other.m_outline_) &&
                (m_hasHoles_ == other.m_hasHoles_) &&
                (!isHolesUsed() ? !other.isHolesUsed() : (m_holes_ == other.m_holes_));
    }

    return true;
}

uint32_t BoundingPolygon3D::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getXyShift());
    result = ::zserio::calcHashCode(result, getZShift());
    result = ::zserio::calcHashCode(result, m_outline_);
    result = ::zserio::calcHashCode(result, m_hasHoles_);
    if (isHolesUsed())
        result = ::zserio::calcHashCode(result, m_holes_);

    return result;
}

void BoundingPolygon3D::write(::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_outline_.getShiftXY() != static_cast<::nds::core::geometry::CoordShift>(getXyShift()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shiftXY for field BoundingPolygon3D.outline: ") <<
                m_outline_.getShiftXY() << " != " << static_cast<::nds::core::geometry::CoordShift>(getXyShift()) << "!";
    }
    if (m_outline_.getShiftZ() != static_cast<::nds::core::geometry::CoordShift>(getZShift()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shiftZ for field BoundingPolygon3D.outline: ") <<
                m_outline_.getShiftZ() << " != " << static_cast<::nds::core::geometry::CoordShift>(getZShift()) << "!";
    }
    m_outline_.write(out);

    out.writeBool(m_hasHoles_);

    if (getHasHoles())
    {
        m_holes_.value().write(*this, out);
    }
}

void BoundingPolygon3D::write(BoundingPolygon3D::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    // check parameters
    if (m_outline_.getShiftXY() != static_cast<::nds::core::geometry::CoordShift>(getXyShift()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shiftXY for field BoundingPolygon3D.outline: ") <<
                m_outline_.getShiftXY() << " != " << static_cast<::nds::core::geometry::CoordShift>(getXyShift()) << "!";
    }
    if (m_outline_.getShiftZ() != static_cast<::nds::core::geometry::CoordShift>(getZShift()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter shiftZ for field BoundingPolygon3D.outline: ") <<
                m_outline_.getShiftZ() << " != " << static_cast<::nds::core::geometry::CoordShift>(getZShift()) << "!";
    }
    m_outline_.write(context.getOutline(), out);

    out.writeBool(m_hasHoles_);

    if (getHasHoles())
    {
        m_holes_.value().writePacked(*this, out);
    }
}

void BoundingPolygon3D::ZserioArrayExpressions_holes::initializeElement(BoundingPolygon3D& owner,
        ::nds::core::geometry::Ring3D& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getXyShift()), static_cast<::nds::core::geometry::CoordShift>(owner.getZShift()));
}

void BoundingPolygon3D::ZserioElementFactory_holes::create(BoundingPolygon3D&         owner,
        ::zserio::vector<::nds::core::geometry::Ring3D>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getXyShift()), static_cast<::nds::core::geometry::CoordShift>(owner.getZShift()), array.get_allocator());
}

void BoundingPolygon3D::ZserioElementFactory_holes::create(BoundingPolygon3D&         owner,
        ::zserio::vector<::nds::core::geometry::Ring3D>& array,
        ::nds::core::geometry::Ring3D::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getXyShift()), static_cast<::nds::core::geometry::CoordShift>(owner.getZShift()), array.get_allocator());
}

::nds::core::geometry::Ring3D BoundingPolygon3D::readOutline(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::geometry::Ring3D(in, static_cast<::nds::core::geometry::CoordShift>(getXyShift()), static_cast<::nds::core::geometry::CoordShift>(getZShift()), allocator);
}

::nds::core::geometry::Ring3D BoundingPolygon3D::readOutline(BoundingPolygon3D::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::geometry::Ring3D(context.getOutline(), in, static_cast<::nds::core::geometry::CoordShift>(getXyShift()), static_cast<::nds::core::geometry::CoordShift>(getZShift()), allocator);
}
bool BoundingPolygon3D::readHasHoles(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
::zserio::InplaceOptionalHolder<BoundingPolygon3D::ZserioArrayType_holes> BoundingPolygon3D::readHoles(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getHasHoles())
    {
        ZserioArrayType_holes readField(allocator);
        readField.read(*this, in);

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_holes>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_holes>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<BoundingPolygon3D::ZserioArrayType_holes> BoundingPolygon3D::readHoles(BoundingPolygon3D::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getHasHoles())
    {
        ZserioArrayType_holes readField(allocator);
        readField.readPacked(*this, in);

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_holes>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_holes>(::zserio::NullOpt);
}

} // namespace geometry
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/core/geometry/Polygon2DBuffers.h>

namespace nds
{
namespace core
{
namespace geometry
{

Polygon2DBuffers::Polygon2DBuffers(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numPositions_(uint32_t()),
        m_positions_(allocator),
        m_indexBuffer_(allocator),
        m_polygons_(allocator)
{
}

Polygon2DBuffers::Polygon2DBuffers(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift shift_,
        uint32_t numElements_, const allocator_type& allocator) :
        m_shift_(shift_),
        m_numElements_(numElements_),
        m_isInitialized(true),
        m_numPositions_(readNumPositions(in)),
        m_positions_(readPositions(in, allocator)),
        m_indexBuffer_(readIndexBuffer(in, allocator)),
        m_polygons_(readPolygons(in, allocator))
{
}

Polygon2DBuffers::Polygon2DBuffers(Polygon2DBuffers::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift shift_,
        uint32_t numElements_, const allocator_type& allocator) :
        m_shift_(shift_),
        m_numElements_(numElements_),
        m_isInitialized(true),
        m_numPositions_(readNumPositions(context, in)),
        m_positions_(readPositions(context, in, allocator)),
        m_indexBuffer_(readIndexBuffer(context, in, allocator)),
        m_polygons_(readPolygons(context, in, allocator))
{
}

Polygon2DBuffers::Polygon2DBuffers(const Polygon2DBuffers& other) :
        m_numPositions_(other.m_numPositions_),
        m_positions_(other.m_positions_),
        m_indexBuffer_(other.m_indexBuffer_),
        m_polygons_(other.m_polygons_)
{
    if (other.m_isInitialized)
        initialize(other.m_shift_, other.m_numElements_);
    else
        m_isInitialized = false;
}

Polygon2DBuffers& Polygon2DBuffers::operator=(const Polygon2DBuffers& other)
{
    m_numPositions_ = other.m_numPositions_;
    m_positions_ = other.m_positions_;
    m_indexBuffer_ = other.m_indexBuffer_;
    m_polygons_ = other.m_polygons_;
    if (other.m_isInitialized)
        initialize(other.m_shift_, other.m_numElements_);
    else
        m_isInitialized = false;

    return *this;
}

Polygon2DBuffers::Polygon2DBuffers(Polygon2DBuffers&& other) :
        m_numPositions_(::std::move(other.m_numPositions_)),
        m_positions_(::std::move(other.m_positions_)),
        m_indexBuffer_(::std::move(other.m_indexBuffer_)),
        m_polygons_(::std::move(other.m_polygons_))
{
    if (other.m_isInitialized)
        initialize(other.m_shift_, other.m_numElements_);
    else
        m_isInitialized = false;
}

Polygon2DBuffers& Polygon2DBuffers::operator=(Polygon2DBuffers&& other)
{
    m_numPositions_ = ::std::move(other.m_numPositions_);
    m_positions_ = ::std::move(other.m_positions_);
    m_indexBuffer_ = ::std::move(other.m_indexBuffer_);
    m_polygons_ = ::std::move(other.m_polygons_);
    if (other.m_isInitialized)
        initialize(other.m_shift_, other.m_numElements_);
    else
        m_isInitialized = false;

    return *this;
}

Polygon2DBuffers::Polygon2DBuffers(::zserio::PropagateAllocatorT,
        const Polygon2DBuffers& other, const allocator_type& allocator) :
        m_numPositions_(::zserio::allocatorPropagatingCopy(other.m_numPositions_, allocator)),
        m_positions_(::zserio::allocatorPropagatingCopy(other.m_positions_, allocator)),
        m_indexBuffer_(::zserio::allocatorPropagatingCopy(other.m_indexBuffer_, allocator)),
        m_polygons_(::zserio::allocatorPropagatingCopy(other.m_polygons_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_shift_, other.m_numElements_);
    else
        m_isInitialized = false;
}

void Polygon2DBuffers::initialize(
        ::nds::core::geometry::CoordShift shift_,
        uint32_t numElements_)
{
    m_shift_ = shift_;
    m_numElements_ = numElements_;
    m_isInitialized = true;

    initializeChildren();
}

bool Polygon2DBuffers::isInitialized() const
{
    return m_isInitialized;
}

void Polygon2DBuffers::initializeChildren()
{
    m_positions_.initializeElements(*this);
    m_indexBuffer_.initialize(static_cast<uint32_t>(getNumPositions()));
    m_polygons_.initializeElements(*this);
}

::nds::core::geometry::CoordShift Polygon2DBuffers::getShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'shift' of compound 'Polygon2DBuffers' is not initialized!");

    return m_shift_;
}

uint32_t Polygon2DBuffers::getNumElements() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'numElements' of compound 'Polygon2DBuffers' is not initialized!");

    return m_numElements_;
}

uint32_t Polygon2DBuffers::getNumPositions() const
{
    return m_numPositions_;
}

void Polygon2DBuffers::setNumPositions(uint32_t numPositions_)
{
    m_numPositions_ = numPositions_;
}

::zserio::vector<::nds::core::geometry::Position2D>& Polygon2DBuffers::getPositions()
{
    return m_positions_.getRawArray();
}

const ::zserio::vector<::nds::core::geometry::Position2D>& Polygon2DBuffers::getPositions() const
{
    return m_positions_.getRawArray();
}

void Polygon2DBuffers::setPositions(const ::zserio::vector<::nds::core::geometry::Position2D>& positions_)
{
    m_positions_ = ZserioArrayType_positions(positions_);
}

void Polygon2DBuffers::setPositions(::zserio::vector<::nds::core::geometry::Position2D>&& positions_)
{
    m_positions_ = ZserioArrayType_positions(std::move(positions_));
}

::nds::core::geometry::IndexBuffer& Polygon2DBuffers::getIndexBuffer()
{
    return m_indexBuffer_;
}

const ::nds::core::geometry::IndexBuffer& Polygon2DBuffers::getIndexBuffer() const
{
    return m_indexBuffer_;
}

void Polygon2DBuffers::setIndexBuffer(const ::nds::core::geometry::IndexBuffer& indexBuffer_)
{
    m_indexBuffer_ = indexBuffer_;
}

void Polygon2DBuffers::setIndexBuffer(::nds::core::geometry::IndexBuffer&& indexBuffer_)
{
    m_indexBuffer_ = ::std::move(indexBuffer_);
}

::zserio::vector<::nds::core::geometry::Polygon2D>& Polygon2DBuffers::getPolygons()
{
    return m_polygons_.getRawArray();
}

const ::zserio::vector<::nds::core::geometry::Polygon2D>& Polygon2DBuffers::getPolygons() const
{
    return m_polygons_.getRawArray();
}

void Polygon2DBuffers::setPolygons(const ::zserio::vector<::nds::core::geometry::Polygon2D>& polygons_)
{
    m_polygons_ = ZserioArrayType_polygons(polygons_);
}

void Polygon2DBuffers::setPolygons(::zserio::vector<::nds::core::geometry::Polygon2D>&& polygons_)
{
    m_polygons_ = ZserioArrayType_polygons(std::move(polygons_));
}

void Polygon2DBuffers::initPackingContext(Polygon2DBuffers::ZserioPackingContext& context) const
{
    context.getNumPositions().init<::zserio::VarSizeArrayTraits>(m_numPositions_);
    m_indexBuffer_.initPackingContext(context.getIndexBuffer());
}

size_t Polygon2DBuffers::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numPositions_);
    endBitPosition += m_positions_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_indexBuffer_.bitSizeOf(endBitPosition);
    endBitPosition += m_polygons_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t Polygon2DBuffers::bitSizeOf(Polygon2DBuffers::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumPositions().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numPositions_);
    endBitPosition += m_positions_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_indexBuffer_.bitSizeOf(context.getIndexBuffer(), endBitPosition);
    endBitPosition += m_polygons_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t Polygon2DBuffers::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numPositions_);
    endBitPosition = m_positions_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_indexBuffer_.initializeOffsets(endBitPosition);
    endBitPosition = m_polygons_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t Polygon2DBuffers::initializeOffsets(Polygon2DBuffers::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumPositions().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numPositions_);
    endBitPosition = m_positions_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_indexBuffer_.initializeOffsets(context.getIndexBuffer(), endBitPosition);
    endBitPosition = m_polygons_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool Polygon2DBuffers::operator==(const Polygon2DBuffers& other) const
{
    if (this != &other)
    {
        return
                (getShift() == other.getShift()) &&
                (getNumElements() == other.getNumElements()) &&
                (m_numPositions_ == other.m_numPositions_) &&
                (m_positions_ == other.m_positions_) &&
                (m_indexBuffer_ == other.m_indexBuffer_) &&
                (m_polygons_ == other.m_polygons_);
    }

    return true;
}

uint32_t Polygon2DBuffers::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getShift());
    result = ::zserio::calcHashCode(result, getNumElements());
    result = ::zserio::calcHashCode(result, m_numPositions_);
    result = ::zserio::calcHashCode(result, m_positions_);
    result = ::zserio::calcHashCode(result, m_indexBuffer_);
    result = ::zserio::calcHashCode(result, m_polygons_);

    return result;
}

void Polygon2DBuffers::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numPositions_);

    // check array length
    if (m_positions_.getRawArray().size() != static_cast<size_t>(getNumPositions()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field Polygon2DBuffers.positions: ") <<
                m_positions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumPositions()) << "!";
    }
    m_positions_.writePacked(*this, out);

    // check parameters
    if (m_indexBuffer_.getPositionBufferSize() != static_cast<uint32_t>(getNumPositions()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter positionBufferSize for field Polygon2DBuffers.indexBuffer: ") <<
                m_indexBuffer_.getPositionBufferSize() << " != " << static_cast<uint32_t>(getNumPositions()) << "!";
    }
    m_indexBuffer_.write(out);

    // check array length
    if (m_polygons_.getRawArray().size() != static_cast<size_t>(getNumElements()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field Polygon2DBuffers.polygons: ") <<
                m_polygons_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumElements()) << "!";
    }
    m_polygons_.writePacked(*this, out);
}

void Polygon2DBuffers::write(Polygon2DBuffers::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumPositions().write<::zserio::VarSizeArrayTraits>(out, m_numPositions_);

    // check array length
    if (m_positions_.getRawArray().size() != static_cast<size_t>(getNumPositions()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field Polygon2DBuffers.positions: ") <<
                m_positions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumPositions()) << "!";
    }
    m_positions_.writePacked(*this, out);

    // check parameters
    if (m_indexBuffer_.getPositionBufferSize() != static_cast<uint32_t>(getNumPositions()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter positionBufferSize for field Polygon2DBuffers.indexBuffer: ") <<
                m_indexBuffer_.getPositionBufferSize() << " != " << static_cast<uint32_t>(getNumPositions()) << "!";
    }
    m_indexBuffer_.write(context.getIndexBuffer(), out);

    // check array length
    if (m_polygons_.getRawArray().size() != static_cast<size_t>(getNumElements()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field Polygon2DBuffers.polygons: ") <<
                m_polygons_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumElements()) << "!";
    }
    m_polygons_.writePacked(*this, out);
}

void Polygon2DBuffers::ZserioArrayExpressions_positions::initializeElement(Polygon2DBuffers& owner,
        ::nds::core::geometry::Position2D& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getShift()));
}

void Polygon2DBuffers::ZserioElementFactory_positions::create(Polygon2DBuffers&         owner,
        ::zserio::vector<::nds::core::geometry::Position2D>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getShift()), array.get_allocator());
}

void Polygon2DBuffers::ZserioElementFactory_positions::create(Polygon2DBuffers&         owner,
        ::zserio::vector<::nds::core::geometry::Position2D>& array,
        ::nds::core::geometry::Position2D::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getShift()), array.get_allocator());
}

void Polygon2DBuffers::ZserioArrayExpressions_polygons::initializeElement(Polygon2DBuffers& owner,
        ::nds::core::geometry::Polygon2D& element, size_t)
{
    element.initialize(owner.getIndexBuffer());
}

void Polygon2DBuffers::ZserioElementFactory_polygons::create(Polygon2DBuffers&         owner,
        ::zserio::vector<::nds::core::geometry::Polygon2D>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, owner.getIndexBuffer(), array.get_allocator());
}

void Polygon2DBuffers::ZserioElementFactory_polygons::create(Polygon2DBuffers&         owner,
        ::zserio::vector<::nds::core::geometry::Polygon2D>& array,
        ::nds::core::geometry::Polygon2D::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, owner.getIndexBuffer(), array.get_allocator());
}

uint32_t Polygon2DBuffers::readNumPositions(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t Polygon2DBuffers::readNumPositions(Polygon2DBuffers::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumPositions().read<::zserio::VarSizeArrayTraits>(in);
}
Polygon2DBuffers::ZserioArrayType_positions Polygon2DBuffers::readPositions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_positions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumPositions()));

    return readField;
}

Polygon2DBuffers::ZserioArrayType_positions Polygon2DBuffers::readPositions(Polygon2DBuffers::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_positions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumPositions()));

    return readField;
}
::nds::core::geometry::IndexBuffer Polygon2DBuffers::readIndexBuffer(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::geometry::IndexBuffer(in, static_cast<uint32_t>(getNumPositions()), allocator);
}

::nds::core::geometry::IndexBuffer Polygon2DBuffers::readIndexBuffer(Polygon2DBuffers::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::geometry::IndexBuffer(context.getIndexBuffer(), in, static_cast<uint32_t>(getNumPositions()), allocator);
}
Polygon2DBuffers::ZserioArrayType_polygons Polygon2DBuffers::readPolygons(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_polygons readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumElements()));

    return readField;
}

Polygon2DBuffers::ZserioArrayType_polygons Polygon2DBuffers::readPolygons(Polygon2DBuffers::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_polygons readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumElements()));

    return readField;
}

} // namespace geometry
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/core/geometry/PolyMesh3DBuffers.h>

namespace nds
{
namespace core
{
namespace geometry
{

PolyMesh3DBuffers::PolyMesh3DBuffers(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numPositions_(uint32_t()),
        m_positions_(allocator),
        m_indexBuffer_(allocator),
        m_polymeshes_(allocator)
{
}

PolyMesh3DBuffers::PolyMesh3DBuffers(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift shiftXY_,
        ::nds::core::geometry::CoordShift shiftZ_,
        uint32_t numElements_,
        ::nds::core::geometry::PolyMesh3DType type_, const allocator_type& allocator) :
        m_shiftXY_(shiftXY_),
        m_shiftZ_(shiftZ_),
        m_numElements_(numElements_),
        m_type_(type_),
        m_isInitialized(true),
        m_numPositions_(readNumPositions(in)),
        m_positions_(readPositions(in, allocator)),
        m_indexBuffer_(readIndexBuffer(in, allocator)),
        m_polymeshes_(readPolymeshes(in, allocator))
{
}

PolyMesh3DBuffers::PolyMesh3DBuffers(PolyMesh3DBuffers::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift shiftXY_,
        ::nds::core::geometry::CoordShift shiftZ_,
        uint32_t numElements_,
        ::nds::core::geometry::PolyMesh3DType type_, const allocator_type& allocator) :
        m_shiftXY_(shiftXY_),
        m_shiftZ_(shiftZ_),
        m_numElements_(numElements_),
        m_type_(type_),
        m_isInitialized(true),
        m_numPositions_(readNumPositions(context, in)),
        m_positions_(readPositions(context, in, allocator)),
        m_indexBuffer_(readIndexBuffer(context, in, allocator)),
        m_polymeshes_(readPolymeshes(context, in, allocator))
{
}

PolyMesh3DBuffers::PolyMesh3DBuffers(const PolyMesh3DBuffers& other) :
        m_numPositions_(other.m_numPositions_),
        m_positions_(other.m_positions_),
        m_indexBuffer_(other.m_indexBuffer_),
        m_polymeshes_(other.m_polymeshes_)
{
    if (other.m_isInitialized)
        initialize(other.m_shiftXY_, other.m_shiftZ_, other.m_numElements_, other.m_type_);
    else
        m_isInitialized = false;
}

PolyMesh3DBuffers& PolyMesh3DBuffers::operator=(const PolyMesh3DBuffers& other)
{
    m_numPositions_ = other.m_numPositions_;
    m_positions_ = other.m_positions_;
    m_indexBuffer_ = other.m_indexBuffer_;
    m_polymeshes_ = other.m_polymeshes_;
    if (other.m_isInitialized)
        initialize(other.m_shiftXY_, other.m_shiftZ_, other.m_numElements_, other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

PolyMesh3DBuffers::PolyMesh3DBuffers(PolyMesh3DBuffers&& other) :
        m_numPositions_(::std::move(other.m_numPositions_)),
        m_positions_(::std::move(other.m_positions_)),
        m_indexBuffer_(::std::move(other.m_indexBuffer_)),
        m_polymeshes_(::std::move(other.m_polymeshes_))
{
    if (other.m_isInitialized)
        initialize(other.m_shiftXY_, other.m_shiftZ_, other.m_numElements_, other.m_type_);
    else
        m_isInitialized = false;
}

PolyMesh3DBuffers& PolyMesh3DBuffers::operator=(PolyMesh3DBuffers&& other)
{
    m_numPositions_ = ::std::move(other.m_numPositions_);
    m_positions_ = ::std::move(other.m_positions_);
    m_indexBuffer_ = ::std::move(other.m_indexBuffer_);
    m_polymeshes_ = ::std::move(other.m_polymeshes_);
    if (other.m_isInitialized)
        initialize(other.m_shiftXY_, other.m_shiftZ_, other.m_numElements_, other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

PolyMesh3DBuffers::PolyMesh3DBuffers(::zserio::PropagateAllocatorT,
        const PolyMesh3DBuffers& other, const allocator_type& allocator) :
        m_numPositions_(::zserio::allocatorPropagatingCopy(other.m_numPositions_, allocator)),
        m_positions_(::zserio::allocatorPropagatingCopy(other.m_positions_, allocator)),
        m_indexBuffer_(::zserio::allocatorPropagatingCopy(other.m_indexBuffer_, allocator)),
        m_polymeshes_(::zserio::allocatorPropagatingCopy(other.m_polymeshes_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_shiftXY_, other.m_shiftZ_, other.m_numElements_, other.m_type_);
    else
        m_isInitialized = false;
}

void PolyMesh3DBuffers::initialize(
        ::nds::core::geometry::CoordShift shiftXY_,
        ::nds::core::geometry::CoordShift shiftZ_,
        uint32_t numElements_,
        ::nds::core::geometry::PolyMesh3DType type_)
{
    m_shiftXY_ = shiftXY_;
    m_shiftZ_ = shiftZ_;
    m_numElements_ = numElements_;
    m_type_ = type_;
    m_isInitialized = true;

    initializeChildren();
}

bool PolyMesh3DBuffers::isInitialized() const
{
    return m_isInitialized;
}

void PolyMesh3DBuffers::initializeChildren()
{
    m_positions_.initializeElements(*this);
    m_indexBuffer_.initialize(static_cast<uint32_t>(getNumPositions()));
    m_polymeshes_.initializeElements(*this);
}

::nds::core::geometry::CoordShift PolyMesh3DBuffers::getShiftXY() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'shiftXY' of compound 'PolyMesh3DBuffers' is not initialized!");

    return m_shiftXY_;
}

::nds::core::geometry::CoordShift PolyMesh3DBuffers::getShiftZ() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'shiftZ' of compound 'PolyMesh3DBuffers' is not initialized!");

    return m_shiftZ_;
}

uint32_t PolyMesh3DBuffers::getNumElements() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'numElements' of compound 'PolyMesh3DBuffers' is not initialized!");

    return m_numElements_;
}

::nds::core::geometry::PolyMesh3DType PolyMesh3DBuffers::getType() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'type' of compound 'PolyMesh3DBuffers' is not initialized!");

    return m_type_;
}

uint32_t PolyMesh3DBuffers::getNumPositions() const
{
    return m_numPositions_;
}

void PolyMesh3DBuffers::setNumPositions(uint32_t numPositions_)
{
    m_numPositions_ = numPositions_;
}

::zserio::vector<::nds::core::geometry::Position3D>& PolyMesh3DBuffers::getPositions()
{
    return m_positions_.getRawArray();
}

const ::zserio::vector<::nds::core::geometry::Position3D>& PolyMesh3DBuffers::getPositions() const
{
    return m_positions_.getRawArray();
}

void PolyMesh3DBuffers::setPositions(const ::zserio::vector<::nds::core::geometry::Position3D>& positions_)
{
    m_positions_ = ZserioArrayType_positions(positions_);
}

void PolyMesh3DBuffers::setPositions(::zserio::vector<::nds::core::geometry::Position3D>&& positions_)
{
    m_positions_ = ZserioArrayType_positions(std::move(positions_));
}

::nds::core::geometry::IndexBuffer& PolyMesh3DBuffers::getIndexBuffer()
{
    return m_indexBuffer_;
}

const ::nds::core::geometry::IndexBuffer& PolyMesh3DBuffers::getIndexBuffer() const
{
    return m_indexBuffer_;
}

void PolyMesh3DBuffers::setIndexBuffer(const ::nds::core::geometry::IndexBuffer& indexBuffer_)
{
    m_indexBuffer_ = indexBuffer_;
}

void PolyMesh3DBuffers::setIndexBuffer(::nds::core::geometry::IndexBuffer&& indexBuffer_)
{
    m_indexBuffer_ = ::std::move(indexBuffer_);
}

::zserio::vector<::nds::core::geometry::PolyMesh3D>& PolyMesh3DBuffers::getPolymeshes()
{
    return m_polymeshes_.getRawArray();
}

const ::zserio::vector<::nds::core::geometry::PolyMesh3D>& PolyMesh3DBuffers::getPolymeshes() const
{
    return m_polymeshes_.getRawArray();
}

void PolyMesh3DBuffers::setPolymeshes(const ::zserio::vector<::nds::core::geometry::PolyMesh3D>& polymeshes_)
{
    m_polymeshes_ = ZserioArrayType_polymeshes(polymeshes_);
}

void PolyMesh3DBuffers::setPolymeshes(::zserio::vector<::nds::core::geometry::PolyMesh3D>&& polymeshes_)
{
    m_polymeshes_ = ZserioArrayType_polymeshes(std::move(polymeshes_));
}

void PolyMesh3DBuffers::initPackingContext(PolyMesh3DBuffers::ZserioPackingContext& context) const
{
    context.getNumPositions().init<::zserio::VarSizeArrayTraits>(m_numPositions_);
    m_indexBuffer_.initPackingContext(context.getIndexBuffer());
}

size_t PolyMesh3DBuffers::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numPositions_);
    endBitPosition += m_positions_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_indexBuffer_.bitSizeOf(endBitPosition);
    endBitPosition += m_polymeshes_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t PolyMesh3DBuffers::bitSizeOf(PolyMesh3DBuffers::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumPositions().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numPositions_);
    endBitPosition += m_positions_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += m_indexBuffer_.bitSizeOf(context.getIndexBuffer(), endBitPosition);
    endBitPosition += m_polymeshes_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t PolyMesh3DBuffers::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numPositions_);
    endBitPosition = m_positions_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_indexBuffer_.initializeOffsets(endBitPosition);
    endBitPosition = m_polymeshes_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t PolyMesh3DBuffers::initializeOffsets(PolyMesh3DBuffers::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumPositions().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numPositions_);
    endBitPosition = m_positions_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition = m_indexBuffer_.initializeOffsets(context.getIndexBuffer(), endBitPosition);
    endBitPosition = m_polymeshes_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool PolyMesh3DBuffers::operator==(const PolyMesh3DBuffers& other) const
{
    if (this != &other)
    {
        return
                (getShiftXY() == other.getShiftXY()) &&
                (getShiftZ() == other.getShiftZ()) &&
                (getNumElements() == other.getNumElements()) &&
                (getType() == other.getType()) &&
                (m_numPositions_ == other.m_numPositions_) &&
                (m_positions_ == other.m_positions_) &&
                (m_indexBuffer_ == other.m_indexBuffer_) &&
                (m_polymeshes_ == other.m_polymeshes_);
    }

    return true;
}

uint32_t PolyMesh3DBuffers::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getShiftXY());
    result = ::zserio::calcHashCode(result, getShiftZ());
    result = ::zserio::calcHashCode(result, getNumElements());
    result = ::zserio::calcHashCode(result, getType());
    result = ::zserio::calcHashCode(result, m_numPositions_);
    result = ::zserio::calcHashCode(result, m_positions_);
    result = ::zserio::calcHashCode(result, m_indexBuffer_);
    result = ::zserio::calcHashCode(result, m_polymeshes_);

    return result;
}

void PolyMesh3DBuffers::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numPositions_);

    // check array length
    if (m_positions_.getRawArray().size() != static_cast<size_t>(getNumPositions()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field PolyMesh3DBuffers.positions: ") <<
                m_positions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumPositions()) << "!";
    }
    m_positions_.writePacked(*this, out);

    // check parameters
    if (m_indexBuffer_.getPositionBufferSize() != static_cast<uint32_t>(getNumPositions()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter positionBufferSize for field PolyMesh3DBuffers.indexBuffer: ") <<
                m_indexBuffer_.getPositionBufferSize() << " != " << static_cast<uint32_t>(getNumPositions()) << "!";
    }
    m_indexBuffer_.write(out);

    // check array length
    if (m_polymeshes_.getRawArray().size() != static_cast<size_t>(getNumElements()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field PolyMesh3DBuffers.polymeshes: ") <<
                m_polymeshes_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumElements()) << "!";
    }
    m_polymeshes_.writePacked(*this, out);
}

void PolyMesh3DBuffers::write(PolyMesh3DBuffers::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumPositions().write<::zserio::VarSizeArrayTraits>(out, m_numPositions_);

    // check array length
    if (m_positions_.getRawArray().size() != static_cast<size_t>(getNumPositions()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field PolyMesh3DBuffers.positions: ") <<
                m_positions_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumPositions()) << "!";
    }
    m_positions_.writePacked(*this, out);

    // check parameters
    if (m_indexBuffer_.getPositionBufferSize() != static_cast<uint32_t>(getNumPositions()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong parameter positionBufferSize for field PolyMesh3DBuffers.indexBuffer: ") <<
                m_indexBuffer_.getPositionBufferSize() << " != " << static_cast<uint32_t>(getNumPositions()) << "!";
    }
    m_indexBuffer_.write(context.getIndexBuffer(), out);

    // check array length
    if (m_polymeshes_.getRawArray().size() != static_cast<size_t>(getNumElements()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field PolyMesh3DBuffers.polymeshes: ") <<
                m_polymeshes_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumElements()) << "!";
    }
    m_polymeshes_.writePacked(*this, out);
}

void PolyMesh3DBuffers::ZserioArrayExpressions_positions::initializeElement(PolyMesh3DBuffers& owner,
        ::nds::core::geometry::Position3D& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getShiftXY()), static_cast<::nds::core::geometry::CoordShift>(owner.getShiftZ()));
}

void PolyMesh3DBuffers::ZserioElementFactory_positions::create(PolyMesh3DBuffers&         owner,
        ::zserio::vector<::nds::core::geometry::Position3D>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getShiftXY()), static_cast<::nds::core::geometry::CoordShift>(owner.getShiftZ()), array.get_allocator());
}

void PolyMesh3DBuffers::ZserioElementFactory_positions::create(PolyMesh3DBuffers&         owner,
        ::zserio::vector<::nds::core::geometry::Position3D>& array,
        ::nds::core::geometry::Position3D::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getShiftXY()), static_cast<::nds::core::geometry::CoordShift>(owner.getShiftZ()), array.get_allocator());
}

void PolyMesh3DBuffers::ZserioArrayExpressions_polymeshes::initializeElement(PolyMesh3DBuffers& owner,
        ::nds::core::geometry::PolyMesh3D& element, size_t)
{
    element.initialize(owner.getIndexBuffer(), static_cast<::nds::core::geometry::PolyMesh3DType>(owner.getType()));
}

void PolyMesh3DBuffers::ZserioElementFactory_polymeshes::create(PolyMesh3DBuffers&         owner,
        ::zserio::vector<::nds::core::geometry::PolyMesh3D>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, owner.getIndexBuffer(), static_cast<::nds::core::geometry::PolyMesh3DType>(owner.getType()), array.get_allocator());
}

void PolyMesh3DBuffers::ZserioElementFactory_polymeshes::create(PolyMesh3DBuffers&         owner,
        ::zserio::vector<::nds::core::geometry::PolyMesh3D>& array,
        ::nds::core::geometry::PolyMesh3D::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, owner.getIndexBuffer(), static_cast<::nds::core::geometry::PolyMesh3DType>(owner.getType()), array.get_allocator());
}

uint32_t PolyMesh3DBuffers::readNumPositions(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t PolyMesh3DBuffers::readNumPositions(PolyMesh3DBuffers::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumPositions().read<::zserio::VarSizeArrayTraits>(in);
}
PolyMesh3DBuffers::ZserioArrayType_positions PolyMesh3DBuffers::readPositions(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_positions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumPositions()));

    return readField;
}

PolyMesh3DBuffers::ZserioArrayType_positions PolyMesh3DBuffers::readPositions(PolyMesh3DBuffers::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_positions readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumPositions()));

    return readField;
}
::nds::core::geometry::IndexBuffer PolyMesh3DBuffers::readIndexBuffer(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    return ::nds::core::geometry::IndexBuffer(in, static_cast<uint32_t>(getNumPositions()), allocator);
}

::nds::core::geometry::IndexBuffer PolyMesh3DBuffers::readIndexBuffer(PolyMesh3DBuffers::ZserioPackingContext& context, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    return ::nds::core::geometry::IndexBuffer(context.getIndexBuffer(), in, static_cast<uint32_t>(getNumPositions()), allocator);
}
PolyMesh3DBuffers::ZserioArrayType_polymeshes PolyMesh3DBuffers::readPolymeshes(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_polymeshes readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumElements()));

    return readField;
}

PolyMesh3DBuffers::ZserioArrayType_polymeshes PolyMesh3DBuffers::readPolymeshes(PolyMesh3DBuffers::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_polymeshes readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumElements()));

    return readField;
}

} // namespace geometry
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ConstraintException.h>

#include <nds/core/geometry/Polygon2D.h>

namespace nds
{
namespace core
{
namespace geometry
{

Polygon2D::Polygon2D(const allocator_type&) noexcept :
        m_isInitialized(false),
        m_indexType_(::nds::core::geometry::IndexType()),
        m_startIndex_(uint32_t()),
        m_numPositions_(uint32_t())
{
}

Polygon2D::Polygon2D(::zserio::BitStreamReader& in,
        ::nds::core::geometry::IndexBuffer& ib_, const allocator_type&) :
        m_ib_(&ib_),
        m_isInitialized(true),
        m_indexType_(readIndexType(in)),
        m_startIndex_(readStartIndex(in)),
        m_numPositions_(readNumPositions(in))
{
}

Polygon2D::Polygon2D(Polygon2D::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::IndexBuffer& ib_, const allocator_type&) :
        m_ib_(&ib_),
        m_isInitialized(true),
        m_indexType_(readIndexType(context, in)),
        m_startIndex_(readStartIndex(context, in)),
        m_numPositions_(readNumPositions(context, in))
{
}

Polygon2D::Polygon2D(const Polygon2D& other) :
        m_indexType_(other.m_indexType_),
        m_startIndex_(other.m_startIndex_),
        m_numPositions_(other.m_numPositions_)
{
    if (other.m_isInitialized)
        initialize(*(other.m_ib_));
    else
        m_isInitialized = false;
}

Polygon2D& Polygon2D::operator=(const Polygon2D& other)
{
    m_indexType_ = other.m_indexType_;
    m_startIndex_ = other.m_startIndex_;
    m_numPositions_ = other.m_numPositions_;
    if (other.m_isInitialized)
        initialize(*(other.m_ib_));
    else
        m_isInitialized = false;

    return *this;
}

Polygon2D::Polygon2D(Polygon2D&& other) :
        m_indexType_(::std::move(other.m_indexType_)),
        m_startIndex_(::std::move(other.m_startIndex_)),
        m_numPositions_(::std::move(other.m_numPositions_))
{
    if (other.m_isInitialized)
        initialize(*(other.m_ib_));
    else
        m_isInitialized = false;
}

Polygon2D& Polygon2D::operator=(Polygon2D&& other)
{
    m_indexType_ = ::std::move(other.m_indexType_);
    m_startIndex_ = ::std::move(other.m_startIndex_);
    m_numPositions_ = ::std::move(other.m_numPositions_);
    if (other.m_isInitialized)
        initialize(*(other.m_ib_));
    else
        m_isInitialized = false;

    return *this;
}

Polygon2D::Polygon2D(::zserio::PropagateAllocatorT,
        const Polygon2D& other, const allocator_type& allocator) :
        m_indexType_(::zserio::allocatorPropagatingCopy(other.m_indexType_, allocator)),
        m_startIndex_(::zserio::allocatorPropagatingCopy(other.m_startIndex_, allocator)),
        m_numPositions_(::zserio::allocatorPropagatingCopy(other.m_numPositions_, allocator))
{
    if (other.m_isInitialized)
        initialize(*(other.m_ib_));
    else
        m_isInitialized = false;
}

void Polygon2D::initialize(
        ::nds::core::geometry::IndexBuffer& ib_)
{
    m_ib_ = &ib_;
    m_isInitialized = true;
}

bool Polygon2D::isInitialized() const
{
    return m_isInitialized;
}

::nds::core::geometry::IndexBuffer& Polygon2D::getIb()
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'ib' of compound 'Polygon2D' is not initialized!");

    return *m_ib_;
}

const ::nds::core::geometry::IndexBuffer& Polygon2D::getIb() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'ib' of compound 'Polygon2D' is not initialized!");

    return *m_ib_;
}

::nds::core::geometry::IndexType Polygon2D::getIndexType() const
{
    return m_indexType_;
}

void Polygon2D::setIndexType(::nds::core::geometry::IndexType indexType_)
{
    m_indexType_ = indexType_;
}

uint32_t Polygon2D::getStartIndex() const
{
    return m_startIndex_;
}

void Polygon2D::setStartIndex(uint32_t startIndex_)
{
    m_startIndex_ = startIndex_;
}

uint32_t Polygon2D::getNumPositions() const
{
    return m_numPositions_;
}

void Polygon2D::setNumPositions(uint32_t numPositions_)
{
    m_numPositions_ = numPositions_;
}

void Polygon2D::initPackingContext(Polygon2D::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getIndexType(), m_indexType_);
    context.getStartIndex().init<::zserio::VarSizeArrayTraits>(m_startIndex_);
    context.getNumPositions().init<::zserio::VarSizeArrayTraits>(m_numPositions_);
}

size_t Polygon2D::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_indexType_);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_startIndex_);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_numPositions_);

    return endBitPosition - bitPosition;
}

size_t Polygon2D::bitSizeOf(Polygon2D::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getIndexType(), m_indexType_);
    endBitPosition += context.getStartIndex().bitSizeOf<::zserio::VarSizeArrayTraits>(m_startIndex_);
    endBitPosition += context.getNumPositions().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numPositions_);

    return endBitPosition - bitPosition;
}

size_t Polygon2D::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_indexType_);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_startIndex_);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_numPositions_);

    return endBitPosition;
}

size_t Polygon2D::initializeOffsets(Polygon2D::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getIndexType(), endBitPosition,
        m_indexType_);
    endBitPosition += context.getStartIndex().bitSizeOf<::zserio::VarSizeArrayTraits>(m_startIndex_);
    endBitPosition += context.getNumPositions().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numPositions_);

    return endBitPosition;
}

bool Polygon2D::operator==(const Polygon2D& other) const
{
    if (this != &other)
    {
        return
                (getIb() == other.getIb()) &&
                (m_indexType_ == other.m_indexType_) &&
                (m_startIndex_ == other.m_startIndex_) &&
                (m_numPositions_ == other.m_numPositions_);
    }

    return true;
}

uint32_t Polygon2D::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getIb());
    result = ::zserio::calcHashCode(result, m_indexType_);
    result = ::zserio::calcHashCode(result, m_startIndex_);
    result = ::zserio::calcHashCode(result, m_numPositions_);

    return result;
}

void Polygon2D::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_indexType_);

    out.writeVarSize(m_startIndex_);

    // check constraint
    if (!((getStartIndex() + getNumPositions()) <= getIb().getNumEntries()))
        throw ::zserio::ConstraintException("Write: Constraint violated at Polygon2D.numPositions!");
    out.writeVarSize(m_numPositions_);
}

void Polygon2D::write(Polygon2D::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getIndexType(), out, m_indexType_);

    context.getStartIndex().write<::zserio::VarSizeArrayTraits>(out, m_startIndex_);

    // check constraint
    if (!((getStartIndex() + getNumPositions()) <= getIb().getNumEntries()))
        throw ::zserio::ConstraintException("Write: Constraint violated at Polygon2D.numPositions!");
    context.getNumPositions().write<::zserio::VarSizeArrayTraits>(out, m_numPositions_);
}

::nds::core::geometry::IndexType Polygon2D::readIndexType(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::core::geometry::IndexType>(in);
}

::nds::core::geometry::IndexType Polygon2D::readIndexType(Polygon2D::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::core::geometry::IndexType>(context.getIndexType(), in);
}
uint32_t Polygon2D::readStartIndex(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t Polygon2D::readStartIndex(Polygon2D::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getStartIndex().read<::zserio::VarSizeArrayTraits>(in);
}
uint32_t Polygon2D::readNumPositions(::zserio::BitStreamReader& in)
{
    uint32_t readField = static_cast<uint32_t>(in.readVarSize());
    // check constraint
    if (!((getStartIndex() + readField) <= getIb().getNumEntries()))
        throw ::zserio::ConstraintException("Read: Constraint violated at Polygon2D.numPositions!");

    return readField;
}

uint32_t Polygon2D::readNumPositions(Polygon2D::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    uint32_t readField = context.getNumPositions().read<::zserio::VarSizeArrayTraits>(in);
    // check constraint
    if (!((getStartIndex() + readField) <= getIb().getNumEntries()))
        throw ::zserio::ConstraintException("Read: Constraint violated at Polygon2D.numPositions!");

    return readField;
}

} // namespace geometry
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ConstraintException.h>
#include <zserio/ArrayTraits.h>

#include <nds/core/geometry/PolyMesh3D.h>
#include <nds/core/geometry/PolyMesh3DType.h>

namespace nds
{
namespace core
{
namespace geometry
{

PolyMesh3D::PolyMesh3D(const allocator_type&) noexcept :
        m_isInitialized(false),
        m_indexType_(::nds::core::geometry::IndexType()),
        m_startIndex_(uint32_t()),
        m_numPositions_(uint32_t())
{
}

PolyMesh3D::PolyMesh3D(::zserio::BitStreamReader& in,
        ::nds::core::geometry::IndexBuffer& ib_,
        ::nds::core::geometry::PolyMesh3DType type_, const allocator_type&) :
        m_ib_(&ib_),
        m_type_(type_),
        m_isInitialized(true),
        m_indexType_(readIndexType(in)),
        m_startIndex_(readStartIndex(in)),
        m_numPositions_(readNumPositions(in))
{
}

PolyMesh3D::PolyMesh3D(PolyMesh3D::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::IndexBuffer& ib_,
        ::nds::core::geometry::PolyMesh3DType type_, const allocator_type&) :
        m_ib_(&ib_),
        m_type_(type_),
        m_isInitialized(true),
        m_indexType_(readIndexType(context, in)),
        m_startIndex_(readStartIndex(context, in)),
        m_numPositions_(readNumPositions(context, in))
{
}

PolyMesh3D::PolyMesh3D(const PolyMesh3D& other) :
        m_indexType_(other.m_indexType_),
        m_startIndex_(other.m_startIndex_),
        m_numPositions_(other.m_numPositions_)
{
    if (other.m_isInitialized)
        initialize(*(other.m_ib_), other.m_type_);
    else
        m_isInitialized = false;
}

PolyMesh3D& PolyMesh3D::operator=(const PolyMesh3D& other)
{
    m_indexType_ = other.m_indexType_;
    m_startIndex_ = other.m_startIndex_;
    m_numPositions_ = other.m_numPositions_;
    if (other.m_isInitialized)
        initialize(*(other.m_ib_), other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

PolyMesh3D::PolyMesh3D(PolyMesh3D&& other) :
        m_indexType_(::std::move(other.m_indexType_)),
        m_startIndex_(::std::move(other.m_startIndex_)),
        m_numPositions_(::std::move(other.m_numPositions_))
{
    if (other.m_isInitialized)
        initialize(*(other.m_ib_), other.m_type_);
    else
        m_isInitialized = false;
}

PolyMesh3D& PolyMesh3D::operator=(PolyMesh3D&& other)
{
    m_indexType_ = ::std::move(other.m_indexType_);
    m_startIndex_ = ::std::move(other.m_startIndex_);
    m_numPositions_ = ::std::move(other.m_numPositions_);
    if (other.m_isInitialized)
        initialize(*(other.m_ib_), other.m_type_);
    else
        m_isInitialized = false;

    return *this;
}

PolyMesh3D::PolyMesh3D(::zserio::PropagateAllocatorT,
        const PolyMesh3D& other, const allocator_type& allocator) :
        m_indexType_(::zserio::allocatorPropagatingCopy(other.m_indexType_, allocator)),
        m_startIndex_(::zserio::allocatorPropagatingCopy(other.m_startIndex_, allocator)),
        m_numPositions_(::zserio::allocatorPropagatingCopy(other.m_numPositions_, allocator))
{
    if (other.m_isInitialized)
        initialize(*(other.m_ib_), other.m_type_);
    else
        m_isInitialized = false;
}

void PolyMesh3D::initialize(
        ::nds::core::geometry::IndexBuffer& ib_,
        ::nds::core::geometry::PolyMesh3DType type_)
{
    m_ib_ = &ib_;
    m_type_ = type_;
    m_isInitialized = true;
}

bool PolyMesh3D::isInitialized() const
{
    return m_isInitialized;
}

::nds::core::geometry::IndexBuffer& PolyMesh3D::getIb()
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'ib' of compound 'PolyMesh3D' is not initialized!");

    return *m_ib_;
}

const ::nds::core::geometry::IndexBuffer& PolyMesh3D::getIb() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'ib' of compound 'PolyMesh3D' is not initialized!");

    return *m_ib_;
}

::nds::core::geometry::PolyMesh3DType PolyMesh3D::getType() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'type' of compound 'PolyMesh3D' is not initialized!");

    return m_type_;
}

::nds::core::geometry::IndexType PolyMesh3D::getIndexType() const
{
    return m_indexType_;
}

void PolyMesh3D::setIndexType(::nds::core::geometry::IndexType indexType_)
{
    m_indexType_ = indexType_;
}

uint32_t PolyMesh3D::getStartIndex() const
{
    return m_startIndex_;
}

void PolyMesh3D::setStartIndex(uint32_t startIndex_)
{
    m_startIndex_ = startIndex_;
}

uint32_t PolyMesh3D::getNumPositions() const
{
    return m_numPositions_;
}

void PolyMesh3D::setNumPositions(uint32_t numPositions_)
{
    m_numPositions_ = numPositions_;
}

bool PolyMesh3D::funcIsPlanar() const
{
    return static_cast<bool>(((getType() == ::nds::core::geometry::PolyMesh3DType::POLYGON)) ? true : false);
}

void PolyMesh3D::initPackingContext(PolyMesh3D::ZserioPackingContext& context) const
{
    ::zserio::initPackingContext(context.getIndexType(), m_indexType_);
    context.getStartIndex().init<::zserio::VarSizeArrayTraits>(m_startIndex_);
    context.getNumPositions().init<::zserio::VarSizeArrayTraits>(m_numPositions_);
}

size_t PolyMesh3D::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(m_indexType_);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_startIndex_);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_numPositions_);

    return endBitPosition - bitPosition;
}

size_t PolyMesh3D::bitSizeOf(PolyMesh3D::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOf(context.getIndexType(), m_indexType_);
    endBitPosition += context.getStartIndex().bitSizeOf<::zserio::VarSizeArrayTraits>(m_startIndex_);
    endBitPosition += context.getNumPositions().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numPositions_);

    return endBitPosition - bitPosition;
}

size_t PolyMesh3D::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(endBitPosition, m_indexType_);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_startIndex_);
    endBitPosition += ::zserio::bitSizeOfVarSize(m_numPositions_);

    return endBitPosition;
}

size_t PolyMesh3D::initializeOffsets(PolyMesh3D::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = ::zserio::initializeOffsets(context.getIndexType(), endBitPosition,
        m_indexType_);
    endBitPosition += context.getStartIndex().bitSizeOf<::zserio::VarSizeArrayTraits>(m_startIndex_);
    endBitPosition += context.getNumPositions().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numPositions_);

    return endBitPosition;
}

bool PolyMesh3D::operator==(const PolyMesh3D& other) const
{
    if (this != &other)
    {
        return
                (getIb() == other.getIb()) &&
                (getType() == other.getType()) &&
                (m_indexType_ == other.m_indexType_) &&
                (m_startIndex_ == other.m_startIndex_) &&
                (m_numPositions_ == other.m_numPositions_);
    }

    return true;
}

uint32_t PolyMesh3D::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getIb());
    result = ::zserio::calcHashCode(result, getType());
    result = ::zserio::calcHashCode(result, m_indexType_);
    result = ::zserio::calcHashCode(result, m_startIndex_);
    result = ::zserio::calcHashCode(result, m_numPositions_);

    return result;
}

void PolyMesh3D::write(::zserio::BitStreamWriter& out) const
{
    ::zserio::write(out, m_indexType_);

    out.writeVarSize(m_startIndex_);

    // check constraint
    if (!((getStartIndex() + getNumPositions()) <= getIb().getNumEntries()))
        throw ::zserio::ConstraintException("Write: Constraint violated at PolyMesh3D.numPositions!");
    out.writeVarSize(m_numPositions_);
}

void PolyMesh3D::write(PolyMesh3D::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    ::zserio::write(context.getIndexType(), out, m_indexType_);

    context.getStartIndex().write<::zserio::VarSizeArrayTraits>(out, m_startIndex_);

    // check constraint
    if (!((getStartIndex() + getNumPositions()) <= getIb().getNumEntries()))
        throw ::zserio::ConstraintException("Write: Constraint violated at PolyMesh3D.numPositions!");
    context.getNumPositions().write<::zserio::VarSizeArrayTraits>(out, m_numPositions_);
}

::nds::core::geometry::IndexType PolyMesh3D::readIndexType(::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::core::geometry::IndexType>(in);
}

::nds::core::geometry::IndexType PolyMesh3D::readIndexType(PolyMesh3D::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return ::zserio::read<::nds::core::geometry::IndexType>(context.getIndexType(), in);
}
uint32_t PolyMesh3D::readStartIndex(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t PolyMesh3D::readStartIndex(PolyMesh3D::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getStartIndex().read<::zserio::VarSizeArrayTraits>(in);
}
uint32_t PolyMesh3D::readNumPositions(::zserio::BitStreamReader& in)
{
    uint32_t readField = static_cast<uint32_t>(in.readVarSize());
    // check constraint
    if (!((getStartIndex() + readField) <= getIb().getNumEntries()))
        throw ::zserio::ConstraintException("Read: Constraint violated at PolyMesh3D.numPositions!");

    return readField;
}

uint32_t PolyMesh3D::readNumPositions(PolyMesh3D::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    uint32_t readField = context.getNumPositions().read<::zserio::VarSizeArrayTraits>(in);
    // check constraint
    if (!((getStartIndex() + readField) <= getIb().getNumEntries()))
        throw ::zserio::ConstraintException("Read: Constraint violated at PolyMesh3D.numPositions!");

    return readField;
}

} // namespace geometry
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/core/geometry/IndexBuffer.h>

namespace nds
{
namespace core
{
namespace geometry
{

IndexBuffer::IndexBuffer(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_numEntries_(uint32_t()),
        m_indices_(allocator)
{
}

IndexBuffer::IndexBuffer(::zserio::BitStreamReader& in,
        uint32_t positionBufferSize_, const allocator_type& allocator) :
        m_positionBufferSize_(positionBufferSize_),
        m_isInitialized(true),
        m_numEntries_(readNumEntries(in)),
        m_indices_(readIndices(in, allocator))
{
}

IndexBuffer::IndexBuffer(IndexBuffer::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        uint32_t positionBufferSize_, const allocator_type& allocator) :
        m_positionBufferSize_(positionBufferSize_),
        m_isInitialized(true),
        m_numEntries_(readNumEntries(context, in)),
        m_indices_(readIndices(context, in, allocator))
{
}

IndexBuffer::IndexBuffer(const IndexBuffer& other) :
        m_numEntries_(other.m_numEntries_),
        m_indices_(other.m_indices_)
{
    if (other.m_isInitialized)
        initialize(other.m_positionBufferSize_);
    else
        m_isInitialized = false;
}

IndexBuffer& IndexBuffer::operator=(const IndexBuffer& other)
{
    m_numEntries_ = other.m_numEntries_;
    m_indices_ = other.m_indices_;
    if (other.m_isInitialized)
        initialize(other.m_positionBufferSize_);
    else
        m_isInitialized = false;

    return *this;
}

IndexBuffer::IndexBuffer(IndexBuffer&& other) :
        m_numEntries_(::std::move(other.m_numEntries_)),
        m_indices_(::std::move(other.m_indices_))
{
    if (other.m_isInitialized)
        initialize(other.m_positionBufferSize_);
    else
        m_isInitialized = false;
}

IndexBuffer& IndexBuffer::operator=(IndexBuffer&& other)
{
    m_numEntries_ = ::std::move(other.m_numEntries_);
    m_indices_ = ::std::move(other.m_indices_);
    if (other.m_isInitialized)
        initialize(other.m_positionBufferSize_);
    else
        m_isInitialized = false;

    return *this;
}

IndexBuffer::IndexBuffer(::zserio::PropagateAllocatorT,
        const IndexBuffer& other, const allocator_type& allocator) :
        m_numEntries_(::zserio::allocatorPropagatingCopy(other.m_numEntries_, allocator)),
        m_indices_(::zserio::allocatorPropagatingCopy(other.m_indices_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_positionBufferSize_);
    else
        m_isInitialized = false;
}

void IndexBuffer::initialize(
        uint32_t positionBufferSize_)
{
    m_positionBufferSize_ = positionBufferSize_;
    m_isInitialized = true;

    initializeChildren();
}

bool IndexBuffer::isInitialized() const
{
    return m_isInitialized;
}

void IndexBuffer::initializeChildren()
{
    m_indices_.initializeElements(*this);
}

uint32_t IndexBuffer::getPositionBufferSize() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'positionBufferSize' of compound 'IndexBuffer' is not initialized!");

    return m_positionBufferSize_;
}

uint32_t IndexBuffer::getNumEntries() const
{
    return m_numEntries_;
}

void IndexBuffer::setNumEntries(uint32_t numEntries_)
{
    m_numEntries_ = numEntries_;
}

::zserio::vector<::nds::core::geometry::IndexBufferEntry>& IndexBuffer::getIndices()
{
    return m_indices_.getRawArray();
}

const ::zserio::vector<::nds::core::geometry::IndexBufferEntry>& IndexBuffer::getIndices() const
{
    return m_indices_.getRawArray();
}

void IndexBuffer::setIndices(const ::zserio::vector<::nds::core::geometry::IndexBufferEntry>& indices_)
{
    m_indices_ = ZserioArrayType_indices(indices_);
}

void IndexBuffer::setIndices(::zserio::vector<::nds::core::geometry::IndexBufferEntry>&& indices_)
{
    m_indices_ = ZserioArrayType_indices(std::move(indices_));
}

void IndexBuffer::initPackingContext(IndexBuffer::ZserioPackingContext& context) const
{
    context.getNumEntries().init<::zserio::VarSizeArrayTraits>(m_numEntries_);
}

size_t IndexBuffer::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numEntries_);
    endBitPosition += m_indices_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t IndexBuffer::bitSizeOf(IndexBuffer::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumEntries().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numEntries_);
    endBitPosition += m_indices_.bitSizeOfPacked(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t IndexBuffer::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += ::zserio::bitSizeOfVarSize(m_numEntries_);
    endBitPosition = m_indices_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

size_t IndexBuffer::initializeOffsets(IndexBuffer::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getNumEntries().bitSizeOf<::zserio::VarSizeArrayTraits>(m_numEntries_);
    endBitPosition = m_indices_.initializeOffsetsPacked(*this, endBitPosition);

    return endBitPosition;
}

bool IndexBuffer::operator==(const IndexBuffer& other) const
{
    if (this != &other)
    {
        return
                (getPositionBufferSize() == other.getPositionBufferSize()) &&
                (m_numEntries_ == other.m_numEntries_) &&
                (m_indices_ == other.m_indices_);
    }

    return true;
}

uint32_t IndexBuffer::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getPositionBufferSize());
    result = ::zserio::calcHashCode(result, m_numEntries_);
    result = ::zserio::calcHashCode(result, m_indices_);

    return result;
}

void IndexBuffer::write(::zserio::BitStreamWriter& out) const
{
    out.writeVarSize(m_numEntries_);

    // check array length
    if (m_indices_.getRawArray().size() != static_cast<size_t>(getNumEntries()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field IndexBuffer.indices: ") <<
                m_indices_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumEntries()) << "!";
    }
    m_indices_.writePacked(*this, out);
}

void IndexBuffer::write(IndexBuffer::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    context.getNumEntries().write<::zserio::VarSizeArrayTraits>(out, m_numEntries_);

    // check array length
    if (m_indices_.getRawArray().size() != static_cast<size_t>(getNumEntries()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field IndexBuffer.indices: ") <<
                m_indices_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumEntries()) << "!";
    }
    m_indices_.writePacked(*this, out);
}

void IndexBuffer::ZserioArrayExpressions_indices::initializeElement(IndexBuffer& owner,
        ::nds::core::geometry::IndexBufferEntry& element, size_t)
{
    element.initialize(static_cast<uint32_t>(owner.getPositionBufferSize()));
}

void IndexBuffer::ZserioElementFactory_indices::create(IndexBuffer&         owner,
        ::zserio::vector<::nds::core::geometry::IndexBufferEntry>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<uint32_t>(owner.getPositionBufferSize()), array.get_allocator());
}

void IndexBuffer::ZserioElementFactory_indices::create(IndexBuffer&         owner,
        ::zserio::vector<::nds::core::geometry::IndexBufferEntry>& array,
        ::nds::core::geometry::IndexBufferEntry::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<uint32_t>(owner.getPositionBufferSize()), array.get_allocator());
}

uint32_t IndexBuffer::readNumEntries(::zserio::BitStreamReader& in)
{
    return static_cast<uint32_t>(in.readVarSize());
}

uint32_t IndexBuffer::readNumEntries(IndexBuffer::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    return context.getNumEntries().read<::zserio::VarSizeArrayTraits>(in);
}
IndexBuffer::ZserioArrayType_indices IndexBuffer::readIndices(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_indices readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumEntries()));

    return readField;
}

IndexBuffer::ZserioArrayType_indices IndexBuffer::readIndices(IndexBuffer::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_indices readField(allocator);
    readField.readPacked(*this, in, static_cast<size_t>(getNumEntries()));

    return readField;
}

} // namespace geometry
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ConstraintException.h>
#include <zserio/BuiltInOperators.h>

#include <nds/core/geometry/IndexBufferEntry.h>

namespace nds
{
namespace core
{
namespace geometry
{

IndexBufferEntry::IndexBufferEntry(const allocator_type&) noexcept :
        m_isInitialized(false),
        m_index_(uint32_t())
{
}

IndexBufferEntry::IndexBufferEntry(::zserio::BitStreamReader& in,
        uint32_t positionBufferSize_, const allocator_type&) :
        m_positionBufferSize_(positionBufferSize_),
        m_isInitialized(true),
        m_index_(readIndex(in))
{
}

IndexBufferEntry::IndexBufferEntry(IndexBufferEntry::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        uint32_t positionBufferSize_, const allocator_type&) :
        m_positionBufferSize_(positionBufferSize_),
        m_isInitialized(true),
        m_index_(readIndex(context, in))
{
}

IndexBufferEntry::IndexBufferEntry(const IndexBufferEntry& other) :
        m_index_(other.m_index_)
{
    if (other.m_isInitialized)
        initialize(other.m_positionBufferSize_);
    else
        m_isInitialized = false;
}

IndexBufferEntry& IndexBufferEntry::operator=(const IndexBufferEntry& other)
{
    m_index_ = other.m_index_;
    if (other.m_isInitialized)
        initialize(other.m_positionBufferSize_);
    else
        m_isInitialized = false;

    return *this;
}

IndexBufferEntry::IndexBufferEntry(IndexBufferEntry&& other) :
        m_index_(::std::move(other.m_index_))
{
    if (other.m_isInitialized)
        initialize(other.m_positionBufferSize_);
    else
        m_isInitialized = false;
}

IndexBufferEntry& IndexBufferEntry::operator=(IndexBufferEntry&& other)
{
    m_index_ = ::std::move(other.m_index_);
    if (other.m_isInitialized)
        initialize(other.m_positionBufferSize_);
    else
        m_isInitialized = false;

    return *this;
}

IndexBufferEntry::IndexBufferEntry(::zserio::PropagateAllocatorT,
        const IndexBufferEntry& other, const allocator_type& allocator) :
        m_index_(::zserio::allocatorPropagatingCopy(other.m_index_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_positionBufferSize_);
    else
        m_isInitialized = false;
}

void IndexBufferEntry::initialize(
        uint32_t positionBufferSize_)
{
    m_positionBufferSize_ = positionBufferSize_;
    m_isInitialized = true;
}

bool IndexBufferEntry::isInitialized() const
{
    return m_isInitialized;
}

uint32_t IndexBufferEntry::getPositionBufferSize() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'positionBufferSize' of compound 'IndexBufferEntry' is not initialized!");

    return m_positionBufferSize_;
}

uint32_t IndexBufferEntry::getIndex() const
{
    return m_index_;
}

void IndexBufferEntry::setIndex(uint32_t index_)
{
    m_index_ = index_;
}

void IndexBufferEntry::initPackingContext(IndexBufferEntry::ZserioPackingContext& context) const
{
    context.getIndex().init<::zserio::DynamicBitFieldArrayTraits<uint32_t, ZserioElementBitSize_index>>(*this, m_index_);
}

size_t IndexBufferEntry::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += static_cast<uint8_t>(::zserio::builtin::numBits(getPositionBufferSize()));

    return endBitPosition - bitPosition;
}

size_t IndexBufferEntry::bitSizeOf(IndexBufferEntry::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getIndex().bitSizeOf<::zserio::DynamicBitFieldArrayTraits<uint32_t, ZserioElementBitSize_index>>(*this, m_index_);

    return endBitPosition - bitPosition;
}

size_t IndexBufferEntry::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += static_cast<uint8_t>(::zserio::builtin::numBits(getPositionBufferSize()));

    return endBitPosition;
}

size_t IndexBufferEntry::initializeOffsets(IndexBufferEntry::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += context.getIndex().bitSizeOf<::zserio::DynamicBitFieldArrayTraits<uint32_t, ZserioElementBitSize_index>>(*this, m_index_);

    return endBitPosition;
}

bool IndexBufferEntry::operator==(const IndexBufferEntry& other) const
{
    if (this != &other)
    {
        return
                (getPositionBufferSize() == other.getPositionBufferSize()) &&
                (m_index_ == other.m_index_);
    }

    return true;
}

uint32_t IndexBufferEntry::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getPositionBufferSize());
    result = ::zserio::calcHashCode(result, m_index_);

    return result;
}

void IndexBufferEntry::write(::zserio::BitStreamWriter& out) const
{
    // check constraint
    if (!(getIndex() < getPositionBufferSize()))
        throw ::zserio::ConstraintException("Write: Constraint violated at IndexBufferEntry.index!");
    out.writeBits(m_index_, static_cast<uint8_t>(::zserio::builtin::numBits(getPositionBufferSize())));
}

void IndexBufferEntry::write(IndexBufferEntry::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    // check constraint
    if (!(getIndex() < getPositionBufferSize()))
        throw ::zserio::ConstraintException("Write: Constraint violated at IndexBufferEntry.index!");
    context.getIndex().write<::zserio::DynamicBitFieldArrayTraits<uint32_t, ZserioElementBitSize_index>>(*this, out, m_index_);
}

uint8_t IndexBufferEntry::ZserioElementBitSize_index::get(const IndexBufferEntry& owner)
{
    return static_cast<uint8_t>(::zserio::builtin::numBits(owner.getPositionBufferSize()));
}

uint32_t IndexBufferEntry::readIndex(::zserio::BitStreamReader& in)
{
    uint32_t readField = static_cast<uint32_t>(in.readBits(static_cast<uint8_t>(::zserio::builtin::numBits(getPositionBufferSize()))));
    // check constraint
    if (!(readField < getPositionBufferSize()))
        throw ::zserio::ConstraintException("Read: Constraint violated at IndexBufferEntry.index!");

    return readField;
}

uint32_t IndexBufferEntry::readIndex(IndexBufferEntry::ZserioPackingContext& context, ::zserio::BitStreamReader& in)
{
    uint32_t readField = context.getIndex().read<::zserio::DynamicBitFieldArrayTraits<uint32_t, ZserioElementBitSize_index>>(*this, in);
    // check constraint
    if (!(readField < getPositionBufferSize()))
        throw ::zserio::ConstraintException("Read: Constraint violated at IndexBufferEntry.index!");

    return readField;
}

} // namespace geometry
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <nds/core/geometry/SimplePolygonSet2D.h>

namespace nds
{
namespace core
{
namespace geometry
{

SimplePolygonSet2D::SimplePolygonSet2D(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_outlines_(allocator),
        m_hasHoles_(bool()),
        m_holes_(::zserio::NullOpt)
{
}

SimplePolygonSet2D::SimplePolygonSet2D(::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift shift_, const allocator_type& allocator) :
        m_shift_(shift_),
        m_isInitialized(true),
        m_outlines_(readOutlines(in, allocator)),
        m_hasHoles_(readHasHoles(in)),
        m_holes_(readHoles(in, allocator))
{
}

SimplePolygonSet2D::SimplePolygonSet2D(SimplePolygonSet2D::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::CoordShift shift_, const allocator_type& allocator) :
        m_shift_(shift_),
        m_isInitialized(true),
        m_outlines_(readOutlines(context, in, allocator)),
        m_hasHoles_(readHasHoles(in)),
        m_holes_(readHoles(context, in, allocator))
{
}

SimplePolygonSet2D::SimplePolygonSet2D(const SimplePolygonSet2D& other) :
        m_outlines_(other.m_outlines_),
        m_hasHoles_(other.m_hasHoles_),
        m_holes_(other.m_holes_)
{
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;
}

SimplePolygonSet2D& SimplePolygonSet2D::operator=(const SimplePolygonSet2D& other)
{
    m_outlines_ = other.m_outlines_;
    m_hasHoles_ = other.m_hasHoles_;
    m_holes_ = other.m_holes_;
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;

    return *this;
}

SimplePolygonSet2D::SimplePolygonSet2D(SimplePolygonSet2D&& other) :
        m_outlines_(::std::move(other.m_outlines_)),
        m_hasHoles_(::std::move(other.m_hasHoles_)),
        m_holes_(::std::move(other.m_holes_))
{
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;
}

SimplePolygonSet2D& SimplePolygonSet2D::operator=(SimplePolygonSet2D&& other)
{
    m_outlines_ = ::std::move(other.m_outlines_);
    m_hasHoles_ = ::std::move(other.m_hasHoles_);
    m_holes_ = ::std::move(other.m_holes_);
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;

    return *this;
}

SimplePolygonSet2D::SimplePolygonSet2D(::zserio::PropagateAllocatorT,
        const SimplePolygonSet2D& other, const allocator_type& allocator) :
        m_outlines_(::zserio::allocatorPropagatingCopy(other.m_outlines_, allocator)),
        m_hasHoles_(::zserio::allocatorPropagatingCopy(other.m_hasHoles_, allocator)),
        m_holes_(::zserio::allocatorPropagatingCopy(other.m_holes_, allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_shift_);
    else
        m_isInitialized = false;
}

void SimplePolygonSet2D::initialize(
        ::nds::core::geometry::CoordShift shift_)
{
    m_shift_ = shift_;
    m_isInitialized = true;

    initializeChildren();
}

bool SimplePolygonSet2D::isInitialized() const
{
    return m_isInitialized;
}

void SimplePolygonSet2D::initializeChildren()
{
    m_outlines_.initializeElements(*this);
    if (getHasHoles())
        m_holes_.value().initializeElements(*this);
}

::nds::core::geometry::CoordShift SimplePolygonSet2D::getShift() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'shift' of compound 'SimplePolygonSet2D' is not initialized!");

    return m_shift_;
}

::zserio::vector<::nds::core::geometry::Ring2D>& SimplePolygonSet2D::getOutlines()
{
    return m_outlines_.getRawArray();
}

const ::zserio::vector<::nds::core::geometry::Ring2D>& SimplePolygonSet2D::getOutlines() const
{
    return m_outlines_.getRawArray();
}

void SimplePolygonSet2D::setOutlines(const ::zserio::vector<::nds::core::geometry::Ring2D>& outlines_)
{
    m_outlines_ = ZserioArrayType_outlines(outlines_);
}

void SimplePolygonSet2D::setOutlines(::zserio::vector<::nds::core::geometry::Ring2D>&& outlines_)
{
    m_outlines_ = ZserioArrayType_outlines(std::move(outlines_));
}

bool SimplePolygonSet2D::getHasHoles() const
{
    return m_hasHoles_;
}

void SimplePolygonSet2D::setHasHoles(bool hasHoles_)
{
    m_hasHoles_ = hasHoles_;
}

::zserio::vector<::nds::core::geometry::Ring2D>& SimplePolygonSet2D::getHoles()
{
    return m_holes_.value().getRawArray();
}

const ::zserio::vector<::nds::core::geometry::Ring2D>& SimplePolygonSet2D::getHoles() const
{
    return m_holes_.value().getRawArray();
}

void SimplePolygonSet2D::setHoles(const ::zserio::vector<::nds::core::geometry::Ring2D>& holes_)
{
    m_holes_ = ZserioArrayType_holes(holes_);
}

void SimplePolygonSet2D::setHoles(::zserio::vector<::nds::core::geometry::Ring2D>&& holes_)
{
    m_holes_ = ZserioArrayType_holes(std::move(holes_));
}

bool SimplePolygonSet2D::isHolesUsed() const
{
    return (getHasHoles());
}

bool SimplePolygonSet2D::isHolesSet() const
{
    return m_holes_.hasValue();
}

void SimplePolygonSet2D::resetHoles()
{
    m_holes_.reset();
}

void SimplePolygonSet2D::initPackingContext(SimplePolygonSet2D::ZserioPackingContext&) const
{
}

size_t SimplePolygonSet2D::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_outlines_.bitSizeOf(*this, endBitPosition);
    endBitPosition += UINT8_C(1);
    if (getHasHoles())
    {
        endBitPosition += m_holes_.value().bitSizeOf(*this, endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t SimplePolygonSet2D::bitSizeOf(SimplePolygonSet2D::ZserioPackingContext&, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_outlines_.bitSizeOfPacked(*this, endBitPosition);
    endBitPosition += UINT8_C(1);
    if (getHasHoles())
    {
        endBitPosition += m_holes_.value().bitSizeOfPacked(*this, endBitPosition);
    }

    return endBitPosition - bitPosition;
}

size_t SimplePolygonSet2D::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_outlines_.initializeOffsets(*this, endBitPosition);
    endBitPosition += UINT8_C(1);
    if (getHasHoles())
    {
        endBitPosition = m_holes_.value().initializeOffsets(*this, endBitPosition);
    }

    return endBitPosition;
}

size_t SimplePolygonSet2D::initializeOffsets(SimplePolygonSet2D::ZserioPackingContext&, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_outlines_.initializeOffsetsPacked(*this, endBitPosition);
    endBitPosition += UINT8_C(1);
    if (getHasHoles())
    {
        endBitPosition = m_holes_.value().initializeOffsetsPacked(*this, endBitPosition);
    }

    return endBitPosition;
}

bool SimplePolygonSet2D::operator==(const SimplePolygonSet2D& other) const
{
    if (this != &other)
    {
        return
                (getShift() == other.getShift()) &&
                (m_outlines_ == other.m_outlines_) &&
                (m_hasHoles_ == other.m_hasHoles_) &&
                (!isHolesUsed() ? !other.isHolesUsed() : (m_holes_ == other.m_holes_));
    }

    return true;
}

uint32_t SimplePolygonSet2D::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getShift());
    result = ::zserio::calcHashCode(result, m_outlines_);
    result = ::zserio::calcHashCode(result, m_hasHoles_);
    if (isHolesUsed())
        result = ::zserio::calcHashCode(result, m_holes_);

    return result;
}

void SimplePolygonSet2D::write(::zserio::BitStreamWriter& out) const
{
    m_outlines_.write(*this, out);
    out.writeBool(m_hasHoles_);
    if (getHasHoles())
    {
        m_holes_.value().write(*this, out);
    }
}

void SimplePolygonSet2D::write(SimplePolygonSet2D::ZserioPackingContext&, ::zserio::BitStreamWriter& out) const
{
    m_outlines_.writePacked(*this, out);
    out.writeBool(m_hasHoles_);
    if (getHasHoles())
    {
        m_holes_.value().writePacked(*this, out);
    }
}

void SimplePolygonSet2D::ZserioArrayExpressions_outlines::initializeElement(SimplePolygonSet2D& owner,
        ::nds::core::geometry::Ring2D& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getShift()));
}

void SimplePolygonSet2D::ZserioElementFactory_outlines::create(SimplePolygonSet2D&         owner,
        ::zserio::vector<::nds::core::geometry::Ring2D>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getShift()), array.get_allocator());
}

void SimplePolygonSet2D::ZserioElementFactory_outlines::create(SimplePolygonSet2D&         owner,
        ::zserio::vector<::nds::core::geometry::Ring2D>& array,
        ::nds::core::geometry::Ring2D::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getShift()), array.get_allocator());
}

void SimplePolygonSet2D::ZserioArrayExpressions_holes::initializeElement(SimplePolygonSet2D& owner,
        ::nds::core::geometry::Ring2D& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getShift()));
}

void SimplePolygonSet2D::ZserioElementFactory_holes::create(SimplePolygonSet2D&         owner,
        ::zserio::vector<::nds::core::geometry::Ring2D>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getShift()), array.get_allocator());
}

void SimplePolygonSet2D::ZserioElementFactory_holes::create(SimplePolygonSet2D&         owner,
        ::zserio::vector<::nds::core::geometry::Ring2D>& array,
        ::nds::core::geometry::Ring2D::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getShift()), array.get_allocator());
}

SimplePolygonSet2D::ZserioArrayType_outlines SimplePolygonSet2D::readOutlines(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_outlines readField(allocator);
    readField.read(*this, in);

    return readField;
}

SimplePolygonSet2D::ZserioArrayType_outlines SimplePolygonSet2D::readOutlines(SimplePolygonSet2D::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    ZserioArrayType_outlines readField(allocator);
    readField.readPacked(*this, in);

    return readField;
}
bool SimplePolygonSet2D::readHasHoles(::zserio::BitStreamReader& in)
{
    return static_cast<bool>(in.readBool());
}
::zserio::InplaceOptionalHolder<SimplePolygonSet2D::ZserioArrayType_holes> SimplePolygonSet2D::readHoles(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    if (getHasHoles())
    {
        ZserioArrayType_holes readField(allocator);
        readField.read(*this, in);

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_holes>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_holes>(::zserio::NullOpt);
}

::zserio::InplaceOptionalHolder<SimplePolygonSet2D::ZserioArrayType_holes> SimplePolygonSet2D::readHoles(SimplePolygonSet2D::ZserioPackingContext&, ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    if (getHasHoles())
    {
        ZserioArrayType_holes readField(allocator);
        readField.readPacked(*this, in);

        return ::zserio::InplaceOptionalHolder<ZserioArrayType_holes>(::std::move(readField));
    }

    return ::zserio::InplaceOptionalHolder<ZserioArrayType_holes>(::zserio::NullOpt);
}

} // namespace geometry
} // namespace core
} // namespace nds

/**
 * Automatically generated by Zserio C++ extension version 2.12.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, sourcesAmalgamation, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/ArrayTraits.h>

#include <nds/core/geometry/Buffers.h>
#include <nds/core/geometry/PolyMesh3DType.h>

namespace nds
{
namespace core
{
namespace geometry
{

Buffers::Buffers(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_objectChoice(allocator)
{
}

Buffers::Buffers(::zserio::BitStreamReader& in,
        ::nds::core::geometry::GeometryLayerType type_,
        ::nds::core::geometry::CoordShift shiftXY_,
        ::nds::core::geometry::CoordShift shiftZ_,
        uint32_t numElements_, const allocator_type& allocator) :
        m_type_(type_),
        m_shiftXY_(shiftXY_),
        m_shiftZ_(shiftZ_),
        m_numElements_(numElements_),
        m_isInitialized(true),
        m_objectChoice(readObject(in, allocator), allocator)
{
}

Buffers::Buffers(Buffers::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        ::nds::core::geometry::GeometryLayerType type_,
        ::nds::core::geometry::CoordShift shiftXY_,
        ::nds::core::geometry::CoordShift shiftZ_,
        uint32_t numElements_, const allocator_type& allocator) :
        m_type_(type_),
        m_shiftXY_(shiftXY_),
        m_shiftZ_(shiftZ_),
        m_numElements_(numElements_),
        m_isInitialized(true),
        m_objectChoice(readObject(context, in, allocator), allocator)
{
}

Buffers::Buffers(const Buffers& other) :
        m_objectChoice(other.m_objectChoice)
{
    if (other.m_isInitialized)
        initialize(other.m_type_, other.m_shiftXY_, other.m_shiftZ_, other.m_numElements_);
    else
        m_isInitialized = false;
}

Buffers& Buffers::operator=(const Buffers& other)
{
    m_objectChoice = other.m_objectChoice;
    if (other.m_isInitialized)
        initialize(other.m_type_, other.m_shiftXY_, other.m_shiftZ_, other.m_numElements_);
    else
        m_isInitialized = false;

    return *this;
}

Buffers::Buffers(Buffers&& other) :
        m_objectChoice(::std::move(other.m_objectChoice))
{
    if (other.m_isInitialized)
        initialize(other.m_type_, other.m_shiftXY_, other.m_shiftZ_, other.m_numElements_);
    else
        m_isInitialized = false;
}

Buffers& Buffers::operator=(Buffers&& other)
{
    m_objectChoice = ::std::move(other.m_objectChoice);
    if (other.m_isInitialized)
        initialize(other.m_type_, other.m_shiftXY_, other.m_shiftZ_, other.m_numElements_);
    else
        m_isInitialized = false;

    return *this;
}

Buffers::Buffers(::zserio::PropagateAllocatorT,
        const Buffers& other, const allocator_type& allocator) :
        m_objectChoice(other.copyObject(allocator))
{
    if (other.m_isInitialized)
        initialize(other.m_type_, other.m_shiftXY_, other.m_shiftZ_, other.m_numElements_);
    else
        m_isInitialized = false;
}

void Buffers::initialize(
        ::nds::core::geometry::GeometryLayerType type_,
        ::nds::core::geometry::CoordShift shiftXY_,
        ::nds::core::geometry::CoordShift shiftZ_,
        uint32_t numElements_)
{
    m_type_ = type_;
    m_shiftXY_ = shiftXY_;
    m_shiftZ_ = shiftZ_;
    m_numElements_ = numElements_;
    m_isInitialized = true;

    initializeChildren();
}

bool Buffers::isInitialized() const
{
    return m_isInitialized;
}

void Buffers::initializeChildren()
{
    switch (getType())
    {
    case ::nds::core::geometry::GeometryLayerType::POSITION_2D:
        m_objectChoice.get<ZserioArrayType_positions2D>().initializeElements(*this);
        break;
    case ::nds::core::geometry::GeometryLayerType::POSITION_3D:
        m_objectChoice.get<ZserioArrayType_positions3D>().initializeElements(*this);
        break;
    case ::nds::core::geometry::GeometryLayerType::LINE_2D:
        m_objectChoice.get<ZserioArrayType_lines2D>().initializeElements(*this);
        break;
    case ::nds::core::geometry::GeometryLayerType::LINE_3D:
        m_objectChoice.get<ZserioArrayType_lines3D>().initializeElements(*this);
        break;
    case ::nds::core::geometry::GeometryLayerType::POLYGON_2D:
        m_objectChoice.get<::nds::core::geometry::Polygon2DBuffers>().initialize(static_cast<::nds::core::geometry::CoordShift>(getShiftXY()), static_cast<uint32_t>(getNumElements()));
        break;
    case ::nds::core::geometry::GeometryLayerType::POLYGON_3D:
        m_objectChoice.get<::nds::core::geometry::PolyMesh3DBuffers>().initialize(static_cast<::nds::core::geometry::CoordShift>(getShiftXY()), static_cast<::nds::core::geometry::CoordShift>(getShiftZ()), static_cast<uint32_t>(getNumElements()), static_cast<::nds::core::geometry::PolyMesh3DType>(::nds::core::geometry::PolyMesh3DType::POLYGON));
        break;
    case ::nds::core::geometry::GeometryLayerType::MESH_3D:
        m_objectChoice.get<::nds::core::geometry::PolyMesh3DBuffers>().initialize(static_cast<::nds::core::geometry::CoordShift>(getShiftXY()), static_cast<::nds::core::geometry::CoordShift>(getShiftZ()), static_cast<uint32_t>(getNumElements()), static_cast<::nds::core::geometry::PolyMesh3DType>(::nds::core::geometry::PolyMesh3DType::MESH));
        break;
    case ::nds::core::geometry::GeometryLayerType::SIMPLE_POLYGON_2D:
        m_objectChoice.get<ZserioArrayType_simplePolygons2D>().initializeElements(*this);
        break;
    case ::nds::core::geometry::GeometryLayerType::SIMPLE_POLYGON_SET_2D:
        m_objectChoice.get<ZserioArrayType_simplePolygonSets2D>().initializeElements(*this);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice Buffers!");
    }
}

::nds::core::geometry::GeometryLayerType Buffers::getType() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'type' of compound 'Buffers' is not initialized!");

    return m_type_;
}

::nds::core::geometry::CoordShift Buffers::getShiftXY() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'shiftXY' of compound 'Buffers' is not initialized!");

    return m_shiftXY_;
}

::nds::core::geometry::CoordShift Buffers::getShiftZ() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'shiftZ' of compound 'Buffers' is not initialized!");

    return m_shiftZ_;
}

uint32_t Buffers::getNumElements() const
{
    if (!m_isInitialized)
        throw ::zserio::CppRuntimeException("Parameter 'numElements' of compound 'Buffers' is not initialized!");

    return m_numElements_;
}

::zserio::vector<::nds::core::geometry::Position2D>& Buffers::getPositions2D()
{
    return m_objectChoice.get<ZserioArrayType_positions2D>().getRawArray();
}

const ::zserio::vector<::nds::core::geometry::Position2D>& Buffers::getPositions2D() const
{
    return m_objectChoice.get<ZserioArrayType_positions2D>().getRawArray();
}

void Buffers::setPositions2D(const ::zserio::vector<::nds::core::geometry::Position2D>& positions2D_)
{
    m_objectChoice = ZserioArrayType_positions2D(positions2D_);
}

void Buffers::setPositions2D(::zserio::vector<::nds::core::geometry::Position2D>&& positions2D_)
{
    m_objectChoice = ZserioArrayType_positions2D(std::move(positions2D_));
}

::zserio::vector<::nds::core::geometry::Position3D>& Buffers::getPositions3D()
{
    return m_objectChoice.get<ZserioArrayType_positions3D>().getRawArray();
}

const ::zserio::vector<::nds::core::geometry::Position3D>& Buffers::getPositions3D() const
{
    return m_objectChoice.get<ZserioArrayType_positions3D>().getRawArray();
}

void Buffers::setPositions3D(const ::zserio::vector<::nds::core::geometry::Position3D>& positions3D_)
{
    m_objectChoice = ZserioArrayType_positions3D(positions3D_);
}

void Buffers::setPositions3D(::zserio::vector<::nds::core::geometry::Position3D>&& positions3D_)
{
    m_objectChoice = ZserioArrayType_positions3D(std::move(positions3D_));
}

::zserio::vector<::nds::core::geometry::Line2D>& Buffers::getLines2D()
{
    return m_objectChoice.get<ZserioArrayType_lines2D>().getRawArray();
}

const ::zserio::vector<::nds::core::geometry::Line2D>& Buffers::getLines2D() const
{
    return m_objectChoice.get<ZserioArrayType_lines2D>().getRawArray();
}

void Buffers::setLines2D(const ::zserio::vector<::nds::core::geometry::Line2D>& lines2D_)
{
    m_objectChoice = ZserioArrayType_lines2D(lines2D_);
}

void Buffers::setLines2D(::zserio::vector<::nds::core::geometry::Line2D>&& lines2D_)
{
    m_objectChoice = ZserioArrayType_lines2D(std::move(lines2D_));
}

::zserio::vector<::nds::core::geometry::Line3D>& Buffers::getLines3D()
{
    return m_objectChoice.get<ZserioArrayType_lines3D>().getRawArray();
}

const ::zserio::vector<::nds::core::geometry::Line3D>& Buffers::getLines3D() const
{
    return m_objectChoice.get<ZserioArrayType_lines3D>().getRawArray();
}

void Buffers::setLines3D(const ::zserio::vector<::nds::core::geometry::Line3D>& lines3D_)
{
    m_objectChoice = ZserioArrayType_lines3D(lines3D_);
}

void Buffers::setLines3D(::zserio::vector<::nds::core::geometry::Line3D>&& lines3D_)
{
    m_objectChoice = ZserioArrayType_lines3D(std::move(lines3D_));
}

::nds::core::geometry::Polygon2DBuffers& Buffers::getPolygons2D()
{
    return m_objectChoice.get<::nds::core::geometry::Polygon2DBuffers>();
}

const ::nds::core::geometry::Polygon2DBuffers& Buffers::getPolygons2D() const
{
    return m_objectChoice.get<::nds::core::geometry::Polygon2DBuffers>();
}

void Buffers::setPolygons2D(const ::nds::core::geometry::Polygon2DBuffers& polygons2D_)
{
    m_objectChoice = polygons2D_;
}

void Buffers::setPolygons2D(::nds::core::geometry::Polygon2DBuffers&& polygons2D_)
{
    m_objectChoice = ::std::move(polygons2D_);
}

::nds::core::geometry::PolyMesh3DBuffers& Buffers::getPolygons3D()
{
    return m_objectChoice.get<::nds::core::geometry::PolyMesh3DBuffers>();
}

const ::nds::core::geometry::PolyMesh3DBuffers& Buffers::getPolygons3D() const
{
    return m_objectChoice.get<::nds::core::geometry::PolyMesh3DBuffers>();
}

void Buffers::setPolygons3D(const ::nds::core::geometry::PolyMesh3DBuffers& polygons3D_)
{
    m_objectChoice = polygons3D_;
}

void Buffers::setPolygons3D(::nds::core::geometry::PolyMesh3DBuffers&& polygons3D_)
{
    m_objectChoice = ::std::move(polygons3D_);
}

::nds::core::geometry::PolyMesh3DBuffers& Buffers::getMeshes3D()
{
    return m_objectChoice.get<::nds::core::geometry::PolyMesh3DBuffers>();
}

const ::nds::core::geometry::PolyMesh3DBuffers& Buffers::getMeshes3D() const
{
    return m_objectChoice.get<::nds::core::geometry::PolyMesh3DBuffers>();
}

void Buffers::setMeshes3D(const ::nds::core::geometry::PolyMesh3DBuffers& meshes3D_)
{
    m_objectChoice = meshes3D_;
}

void Buffers::setMeshes3D(::nds::core::geometry::PolyMesh3DBuffers&& meshes3D_)
{
    m_objectChoice = ::std::move(meshes3D_);
}

::zserio::vector<::nds::core::geometry::SimplePolygon2D>& Buffers::getSimplePolygons2D()
{
    return m_objectChoice.get<ZserioArrayType_simplePolygons2D>().getRawArray();
}

const ::zserio::vector<::nds::core::geometry::SimplePolygon2D>& Buffers::getSimplePolygons2D() const
{
    return m_objectChoice.get<ZserioArrayType_simplePolygons2D>().getRawArray();
}

void Buffers::setSimplePolygons2D(const ::zserio::vector<::nds::core::geometry::SimplePolygon2D>& simplePolygons2D_)
{
    m_objectChoice = ZserioArrayType_simplePolygons2D(simplePolygons2D_);
}

void Buffers::setSimplePolygons2D(::zserio::vector<::nds::core::geometry::SimplePolygon2D>&& simplePolygons2D_)
{
    m_objectChoice = ZserioArrayType_simplePolygons2D(std::move(simplePolygons2D_));
}

::zserio::vector<::nds::core::geometry::SimplePolygonSet2D>& Buffers::getSimplePolygonSets2D()
{
    return m_objectChoice.get<ZserioArrayType_simplePolygonSets2D>().getRawArray();
}

const ::zserio::vector<::nds::core::geometry::SimplePolygonSet2D>& Buffers::getSimplePolygonSets2D() const
{
    return m_objectChoice.get<ZserioArrayType_simplePolygonSets2D>().getRawArray();
}

void Buffers::setSimplePolygonSets2D(const ::zserio::vector<::nds::core::geometry::SimplePolygonSet2D>& simplePolygonSets2D_)
{
    m_objectChoice = ZserioArrayType_simplePolygonSets2D(simplePolygonSets2D_);
}

void Buffers::setSimplePolygonSets2D(::zserio::vector<::nds::core::geometry::SimplePolygonSet2D>&& simplePolygonSets2D_)
{
    m_objectChoice = ZserioArrayType_simplePolygonSets2D(std::move(simplePolygonSets2D_));
}

Buffers::ChoiceTag Buffers::choiceTag() const
{
    switch (getType())
    {
    case ::nds::core::geometry::GeometryLayerType::POSITION_2D:
        return CHOICE_positions2D;
    case ::nds::core::geometry::GeometryLayerType::POSITION_3D:
        return CHOICE_positions3D;
    case ::nds::core::geometry::GeometryLayerType::LINE_2D:
        return CHOICE_lines2D;
    case ::nds::core::geometry::GeometryLayerType::LINE_3D:
        return CHOICE_lines3D;
    case ::nds::core::geometry::GeometryLayerType::POLYGON_2D:
        return CHOICE_polygons2D;
    case ::nds::core::geometry::GeometryLayerType::POLYGON_3D:
        return CHOICE_polygons3D;
    case ::nds::core::geometry::GeometryLayerType::MESH_3D:
        return CHOICE_meshes3D;
    case ::nds::core::geometry::GeometryLayerType::SIMPLE_POLYGON_2D:
        return CHOICE_simplePolygons2D;
    case ::nds::core::geometry::GeometryLayerType::SIMPLE_POLYGON_SET_2D:
        return CHOICE_simplePolygonSets2D;
    default:
        return UNDEFINED_CHOICE;
    }
}

void Buffers::initPackingContext(Buffers::ZserioPackingContext& context) const
{
    switch (getType())
    {
    case ::nds::core::geometry::GeometryLayerType::POSITION_2D:
        break;
    case ::nds::core::geometry::GeometryLayerType::POSITION_3D:
        break;
    case ::nds::core::geometry::GeometryLayerType::LINE_2D:
        break;
    case ::nds::core::geometry::GeometryLayerType::LINE_3D:
        break;
    case ::nds::core::geometry::GeometryLayerType::POLYGON_2D:
        m_objectChoice.get<::nds::core::geometry::Polygon2DBuffers>().initPackingContext(context.getPolygons2D());
        break;
    case ::nds::core::geometry::GeometryLayerType::POLYGON_3D:
        m_objectChoice.get<::nds::core::geometry::PolyMesh3DBuffers>().initPackingContext(context.getPolygons3D());
        break;
    case ::nds::core::geometry::GeometryLayerType::MESH_3D:
        m_objectChoice.get<::nds::core::geometry::PolyMesh3DBuffers>().initPackingContext(context.getMeshes3D());
        break;
    case ::nds::core::geometry::GeometryLayerType::SIMPLE_POLYGON_2D:
        break;
    case ::nds::core::geometry::GeometryLayerType::SIMPLE_POLYGON_SET_2D:
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice Buffers!");
    }
}

size_t Buffers::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::core::geometry::GeometryLayerType::POSITION_2D:
        endBitPosition += m_objectChoice.get<ZserioArrayType_positions2D>().bitSizeOfPacked(*this, endBitPosition);
        break;
    case ::nds::core::geometry::GeometryLayerType::POSITION_3D:
        endBitPosition += m_objectChoice.get<ZserioArrayType_positions3D>().bitSizeOfPacked(*this, endBitPosition);
        break;
    case ::nds::core::geometry::GeometryLayerType::LINE_2D:
        endBitPosition += m_objectChoice.get<ZserioArrayType_lines2D>().bitSizeOf(*this, endBitPosition);
        break;
    case ::nds::core::geometry::GeometryLayerType::LINE_3D:
        endBitPosition += m_objectChoice.get<ZserioArrayType_lines3D>().bitSizeOf(*this, endBitPosition);
        break;
    case ::nds::core::geometry::GeometryLayerType::POLYGON_2D:
        endBitPosition += m_objectChoice.get<::nds::core::geometry::Polygon2DBuffers>().bitSizeOf(endBitPosition);
        break;
    case ::nds::core::geometry::GeometryLayerType::POLYGON_3D:
        endBitPosition += m_objectChoice.get<::nds::core::geometry::PolyMesh3DBuffers>().bitSizeOf(endBitPosition);
        break;
    case ::nds::core::geometry::GeometryLayerType::MESH_3D:
        endBitPosition += m_objectChoice.get<::nds::core::geometry::PolyMesh3DBuffers>().bitSizeOf(endBitPosition);
        break;
    case ::nds::core::geometry::GeometryLayerType::SIMPLE_POLYGON_2D:
        endBitPosition += m_objectChoice.get<ZserioArrayType_simplePolygons2D>().bitSizeOf(*this, endBitPosition);
        break;
    case ::nds::core::geometry::GeometryLayerType::SIMPLE_POLYGON_SET_2D:
        endBitPosition += m_objectChoice.get<ZserioArrayType_simplePolygonSets2D>().bitSizeOf(*this, endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice Buffers!");
    }

    return endBitPosition - bitPosition;
}

size_t Buffers::bitSizeOf(Buffers::ZserioPackingContext& context, size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::core::geometry::GeometryLayerType::POSITION_2D:
        endBitPosition += m_objectChoice.get<ZserioArrayType_positions2D>().bitSizeOfPacked(*this, endBitPosition);
        break;
    case ::nds::core::geometry::GeometryLayerType::POSITION_3D:
        endBitPosition += m_objectChoice.get<ZserioArrayType_positions3D>().bitSizeOfPacked(*this, endBitPosition);
        break;
    case ::nds::core::geometry::GeometryLayerType::LINE_2D:
        endBitPosition += m_objectChoice.get<ZserioArrayType_lines2D>().bitSizeOfPacked(*this, endBitPosition);
        break;
    case ::nds::core::geometry::GeometryLayerType::LINE_3D:
        endBitPosition += m_objectChoice.get<ZserioArrayType_lines3D>().bitSizeOfPacked(*this, endBitPosition);
        break;
    case ::nds::core::geometry::GeometryLayerType::POLYGON_2D:
        endBitPosition += m_objectChoice.get<::nds::core::geometry::Polygon2DBuffers>().bitSizeOf(context.getPolygons2D(), endBitPosition);
        break;
    case ::nds::core::geometry::GeometryLayerType::POLYGON_3D:
        endBitPosition += m_objectChoice.get<::nds::core::geometry::PolyMesh3DBuffers>().bitSizeOf(context.getPolygons3D(), endBitPosition);
        break;
    case ::nds::core::geometry::GeometryLayerType::MESH_3D:
        endBitPosition += m_objectChoice.get<::nds::core::geometry::PolyMesh3DBuffers>().bitSizeOf(context.getMeshes3D(), endBitPosition);
        break;
    case ::nds::core::geometry::GeometryLayerType::SIMPLE_POLYGON_2D:
        endBitPosition += m_objectChoice.get<ZserioArrayType_simplePolygons2D>().bitSizeOfPacked(*this, endBitPosition);
        break;
    case ::nds::core::geometry::GeometryLayerType::SIMPLE_POLYGON_SET_2D:
        endBitPosition += m_objectChoice.get<ZserioArrayType_simplePolygonSets2D>().bitSizeOfPacked(*this, endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice Buffers!");
    }

    return endBitPosition - bitPosition;
}

size_t Buffers::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::core::geometry::GeometryLayerType::POSITION_2D:
        endBitPosition = m_objectChoice.get<ZserioArrayType_positions2D>().initializeOffsetsPacked(*this, endBitPosition);
        break;
    case ::nds::core::geometry::GeometryLayerType::POSITION_3D:
        endBitPosition = m_objectChoice.get<ZserioArrayType_positions3D>().initializeOffsetsPacked(*this, endBitPosition);
        break;
    case ::nds::core::geometry::GeometryLayerType::LINE_2D:
        endBitPosition = m_objectChoice.get<ZserioArrayType_lines2D>().initializeOffsets(*this, endBitPosition);
        break;
    case ::nds::core::geometry::GeometryLayerType::LINE_3D:
        endBitPosition = m_objectChoice.get<ZserioArrayType_lines3D>().initializeOffsets(*this, endBitPosition);
        break;
    case ::nds::core::geometry::GeometryLayerType::POLYGON_2D:
        endBitPosition = m_objectChoice.get<::nds::core::geometry::Polygon2DBuffers>().initializeOffsets(endBitPosition);
        break;
    case ::nds::core::geometry::GeometryLayerType::POLYGON_3D:
        endBitPosition = m_objectChoice.get<::nds::core::geometry::PolyMesh3DBuffers>().initializeOffsets(endBitPosition);
        break;
    case ::nds::core::geometry::GeometryLayerType::MESH_3D:
        endBitPosition = m_objectChoice.get<::nds::core::geometry::PolyMesh3DBuffers>().initializeOffsets(endBitPosition);
        break;
    case ::nds::core::geometry::GeometryLayerType::SIMPLE_POLYGON_2D:
        endBitPosition = m_objectChoice.get<ZserioArrayType_simplePolygons2D>().initializeOffsets(*this, endBitPosition);
        break;
    case ::nds::core::geometry::GeometryLayerType::SIMPLE_POLYGON_SET_2D:
        endBitPosition = m_objectChoice.get<ZserioArrayType_simplePolygonSets2D>().initializeOffsets(*this, endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice Buffers!");
    }

    return endBitPosition;
}

size_t Buffers::initializeOffsets(Buffers::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (getType())
    {
    case ::nds::core::geometry::GeometryLayerType::POSITION_2D:
        endBitPosition = m_objectChoice.get<ZserioArrayType_positions2D>().initializeOffsetsPacked(*this, endBitPosition);
        break;
    case ::nds::core::geometry::GeometryLayerType::POSITION_3D:
        endBitPosition = m_objectChoice.get<ZserioArrayType_positions3D>().initializeOffsetsPacked(*this, endBitPosition);
        break;
    case ::nds::core::geometry::GeometryLayerType::LINE_2D:
        endBitPosition = m_objectChoice.get<ZserioArrayType_lines2D>().initializeOffsetsPacked(*this, endBitPosition);
        break;
    case ::nds::core::geometry::GeometryLayerType::LINE_3D:
        endBitPosition = m_objectChoice.get<ZserioArrayType_lines3D>().initializeOffsetsPacked(*this, endBitPosition);
        break;
    case ::nds::core::geometry::GeometryLayerType::POLYGON_2D:
        endBitPosition = m_objectChoice.get<::nds::core::geometry::Polygon2DBuffers>().initializeOffsets(context.getPolygons2D(), endBitPosition);
        break;
    case ::nds::core::geometry::GeometryLayerType::POLYGON_3D:
        endBitPosition = m_objectChoice.get<::nds::core::geometry::PolyMesh3DBuffers>().initializeOffsets(context.getPolygons3D(), endBitPosition);
        break;
    case ::nds::core::geometry::GeometryLayerType::MESH_3D:
        endBitPosition = m_objectChoice.get<::nds::core::geometry::PolyMesh3DBuffers>().initializeOffsets(context.getMeshes3D(), endBitPosition);
        break;
    case ::nds::core::geometry::GeometryLayerType::SIMPLE_POLYGON_2D:
        endBitPosition = m_objectChoice.get<ZserioArrayType_simplePolygons2D>().initializeOffsetsPacked(*this, endBitPosition);
        break;
    case ::nds::core::geometry::GeometryLayerType::SIMPLE_POLYGON_SET_2D:
        endBitPosition = m_objectChoice.get<ZserioArrayType_simplePolygonSets2D>().initializeOffsetsPacked(*this, endBitPosition);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice Buffers!");
    }

    return endBitPosition;
}

bool Buffers::operator==(const Buffers& other) const
{
    if (this == &other)
        return true;

    if (!(getType() == other.getType())||
            !(getShiftXY() == other.getShiftXY())||
            !(getShiftZ() == other.getShiftZ())||
            !(getNumElements() == other.getNumElements()))
        return false;

    switch (getType())
    {
    case ::nds::core::geometry::GeometryLayerType::POSITION_2D:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<ZserioArrayType_positions2D>() == other.m_objectChoice.get<ZserioArrayType_positions2D>());
    case ::nds::core::geometry::GeometryLayerType::POSITION_3D:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<ZserioArrayType_positions3D>() == other.m_objectChoice.get<ZserioArrayType_positions3D>());
    case ::nds::core::geometry::GeometryLayerType::LINE_2D:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<ZserioArrayType_lines2D>() == other.m_objectChoice.get<ZserioArrayType_lines2D>());
    case ::nds::core::geometry::GeometryLayerType::LINE_3D:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<ZserioArrayType_lines3D>() == other.m_objectChoice.get<ZserioArrayType_lines3D>());
    case ::nds::core::geometry::GeometryLayerType::POLYGON_2D:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::core::geometry::Polygon2DBuffers>() == other.m_objectChoice.get<::nds::core::geometry::Polygon2DBuffers>());
    case ::nds::core::geometry::GeometryLayerType::POLYGON_3D:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::core::geometry::PolyMesh3DBuffers>() == other.m_objectChoice.get<::nds::core::geometry::PolyMesh3DBuffers>());
    case ::nds::core::geometry::GeometryLayerType::MESH_3D:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<::nds::core::geometry::PolyMesh3DBuffers>() == other.m_objectChoice.get<::nds::core::geometry::PolyMesh3DBuffers>());
    case ::nds::core::geometry::GeometryLayerType::SIMPLE_POLYGON_2D:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<ZserioArrayType_simplePolygons2D>() == other.m_objectChoice.get<ZserioArrayType_simplePolygons2D>());
    case ::nds::core::geometry::GeometryLayerType::SIMPLE_POLYGON_SET_2D:
        return (!m_objectChoice.hasValue() && !other.m_objectChoice.hasValue()) ||
                (m_objectChoice.hasValue() && other.m_objectChoice.hasValue() &&
                m_objectChoice.get<ZserioArrayType_simplePolygonSets2D>() == other.m_objectChoice.get<ZserioArrayType_simplePolygonSets2D>());
    default:
        throw ::zserio::CppRuntimeException("No match in choice Buffers!");
    }
}

uint32_t Buffers::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getType());
    result = ::zserio::calcHashCode(result, getShiftXY());
    result = ::zserio::calcHashCode(result, getShiftZ());
    result = ::zserio::calcHashCode(result, getNumElements());
    if (m_objectChoice.hasValue())
    {
        switch (getType())
        {
        case ::nds::core::geometry::GeometryLayerType::POSITION_2D:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<ZserioArrayType_positions2D>());
            break;
        case ::nds::core::geometry::GeometryLayerType::POSITION_3D:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<ZserioArrayType_positions3D>());
            break;
        case ::nds::core::geometry::GeometryLayerType::LINE_2D:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<ZserioArrayType_lines2D>());
            break;
        case ::nds::core::geometry::GeometryLayerType::LINE_3D:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<ZserioArrayType_lines3D>());
            break;
        case ::nds::core::geometry::GeometryLayerType::POLYGON_2D:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::core::geometry::Polygon2DBuffers>());
            break;
        case ::nds::core::geometry::GeometryLayerType::POLYGON_3D:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::core::geometry::PolyMesh3DBuffers>());
            break;
        case ::nds::core::geometry::GeometryLayerType::MESH_3D:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<::nds::core::geometry::PolyMesh3DBuffers>());
            break;
        case ::nds::core::geometry::GeometryLayerType::SIMPLE_POLYGON_2D:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<ZserioArrayType_simplePolygons2D>());
            break;
        case ::nds::core::geometry::GeometryLayerType::SIMPLE_POLYGON_SET_2D:
            result = ::zserio::calcHashCode(result, m_objectChoice.get<ZserioArrayType_simplePolygonSets2D>());
            break;
        default:
            break;
        }
    }

    return result;
}

void Buffers::write(::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::core::geometry::GeometryLayerType::POSITION_2D:
        // check array length
        if (m_objectChoice.get<ZserioArrayType_positions2D>().getRawArray().size() != static_cast<size_t>(getNumElements()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field Buffers.positions2D: ") <<
                    m_objectChoice.get<ZserioArrayType_positions2D>().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumElements()) << "!";
        }
        m_objectChoice.get<ZserioArrayType_positions2D>().writePacked(*this, out);
        break;
    case ::nds::core::geometry::GeometryLayerType::POSITION_3D:
        // check array length
        if (m_objectChoice.get<ZserioArrayType_positions3D>().getRawArray().size() != static_cast<size_t>(getNumElements()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field Buffers.positions3D: ") <<
                    m_objectChoice.get<ZserioArrayType_positions3D>().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumElements()) << "!";
        }
        m_objectChoice.get<ZserioArrayType_positions3D>().writePacked(*this, out);
        break;
    case ::nds::core::geometry::GeometryLayerType::LINE_2D:
        // check array length
        if (m_objectChoice.get<ZserioArrayType_lines2D>().getRawArray().size() != static_cast<size_t>(getNumElements()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field Buffers.lines2D: ") <<
                    m_objectChoice.get<ZserioArrayType_lines2D>().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumElements()) << "!";
        }
        m_objectChoice.get<ZserioArrayType_lines2D>().write(*this, out);
        break;
    case ::nds::core::geometry::GeometryLayerType::LINE_3D:
        // check array length
        if (m_objectChoice.get<ZserioArrayType_lines3D>().getRawArray().size() != static_cast<size_t>(getNumElements()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field Buffers.lines3D: ") <<
                    m_objectChoice.get<ZserioArrayType_lines3D>().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumElements()) << "!";
        }
        m_objectChoice.get<ZserioArrayType_lines3D>().write(*this, out);
        break;
    case ::nds::core::geometry::GeometryLayerType::POLYGON_2D:
        // check parameters
        if (m_objectChoice.get<::nds::core::geometry::Polygon2DBuffers>().getShift() != static_cast<::nds::core::geometry::CoordShift>(getShiftXY()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field Buffers.polygons2D: ") <<
                    m_objectChoice.get<::nds::core::geometry::Polygon2DBuffers>().getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShiftXY()) << "!";
        }
        if (m_objectChoice.get<::nds::core::geometry::Polygon2DBuffers>().getNumElements() != static_cast<uint32_t>(getNumElements()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter numElements for field Buffers.polygons2D: ") <<
                    m_objectChoice.get<::nds::core::geometry::Polygon2DBuffers>().getNumElements() << " != " << static_cast<uint32_t>(getNumElements()) << "!";
        }
        m_objectChoice.get<::nds::core::geometry::Polygon2DBuffers>().write(out);
        break;
    case ::nds::core::geometry::GeometryLayerType::POLYGON_3D:
        // check parameters
        if (m_objectChoice.get<::nds::core::geometry::PolyMesh3DBuffers>().getShiftXY() != static_cast<::nds::core::geometry::CoordShift>(getShiftXY()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter shiftXY for field Buffers.polygons3D: ") <<
                    m_objectChoice.get<::nds::core::geometry::PolyMesh3DBuffers>().getShiftXY() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShiftXY()) << "!";
        }
        if (m_objectChoice.get<::nds::core::geometry::PolyMesh3DBuffers>().getShiftZ() != static_cast<::nds::core::geometry::CoordShift>(getShiftZ()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter shiftZ for field Buffers.polygons3D: ") <<
                    m_objectChoice.get<::nds::core::geometry::PolyMesh3DBuffers>().getShiftZ() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShiftZ()) << "!";
        }
        if (m_objectChoice.get<::nds::core::geometry::PolyMesh3DBuffers>().getNumElements() != static_cast<uint32_t>(getNumElements()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter numElements for field Buffers.polygons3D: ") <<
                    m_objectChoice.get<::nds::core::geometry::PolyMesh3DBuffers>().getNumElements() << " != " << static_cast<uint32_t>(getNumElements()) << "!";
        }
        if (m_objectChoice.get<::nds::core::geometry::PolyMesh3DBuffers>().getType() != static_cast<::nds::core::geometry::PolyMesh3DType>(::nds::core::geometry::PolyMesh3DType::POLYGON))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field Buffers.polygons3D: ") <<
                    m_objectChoice.get<::nds::core::geometry::PolyMesh3DBuffers>().getType() << " != " << static_cast<::nds::core::geometry::PolyMesh3DType>(::nds::core::geometry::PolyMesh3DType::POLYGON) << "!";
        }
        m_objectChoice.get<::nds::core::geometry::PolyMesh3DBuffers>().write(out);
        break;
    case ::nds::core::geometry::GeometryLayerType::MESH_3D:
        // check parameters
        if (m_objectChoice.get<::nds::core::geometry::PolyMesh3DBuffers>().getShiftXY() != static_cast<::nds::core::geometry::CoordShift>(getShiftXY()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter shiftXY for field Buffers.meshes3D: ") <<
                    m_objectChoice.get<::nds::core::geometry::PolyMesh3DBuffers>().getShiftXY() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShiftXY()) << "!";
        }
        if (m_objectChoice.get<::nds::core::geometry::PolyMesh3DBuffers>().getShiftZ() != static_cast<::nds::core::geometry::CoordShift>(getShiftZ()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter shiftZ for field Buffers.meshes3D: ") <<
                    m_objectChoice.get<::nds::core::geometry::PolyMesh3DBuffers>().getShiftZ() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShiftZ()) << "!";
        }
        if (m_objectChoice.get<::nds::core::geometry::PolyMesh3DBuffers>().getNumElements() != static_cast<uint32_t>(getNumElements()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter numElements for field Buffers.meshes3D: ") <<
                    m_objectChoice.get<::nds::core::geometry::PolyMesh3DBuffers>().getNumElements() << " != " << static_cast<uint32_t>(getNumElements()) << "!";
        }
        if (m_objectChoice.get<::nds::core::geometry::PolyMesh3DBuffers>().getType() != static_cast<::nds::core::geometry::PolyMesh3DType>(::nds::core::geometry::PolyMesh3DType::MESH))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field Buffers.meshes3D: ") <<
                    m_objectChoice.get<::nds::core::geometry::PolyMesh3DBuffers>().getType() << " != " << static_cast<::nds::core::geometry::PolyMesh3DType>(::nds::core::geometry::PolyMesh3DType::MESH) << "!";
        }
        m_objectChoice.get<::nds::core::geometry::PolyMesh3DBuffers>().write(out);
        break;
    case ::nds::core::geometry::GeometryLayerType::SIMPLE_POLYGON_2D:
        // check array length
        if (m_objectChoice.get<ZserioArrayType_simplePolygons2D>().getRawArray().size() != static_cast<size_t>(getNumElements()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field Buffers.simplePolygons2D: ") <<
                    m_objectChoice.get<ZserioArrayType_simplePolygons2D>().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumElements()) << "!";
        }
        m_objectChoice.get<ZserioArrayType_simplePolygons2D>().write(*this, out);
        break;
    case ::nds::core::geometry::GeometryLayerType::SIMPLE_POLYGON_SET_2D:
        // check array length
        if (m_objectChoice.get<ZserioArrayType_simplePolygonSets2D>().getRawArray().size() != static_cast<size_t>(getNumElements()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field Buffers.simplePolygonSets2D: ") <<
                    m_objectChoice.get<ZserioArrayType_simplePolygonSets2D>().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumElements()) << "!";
        }
        m_objectChoice.get<ZserioArrayType_simplePolygonSets2D>().write(*this, out);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice Buffers!");
    }
}

void Buffers::write(Buffers::ZserioPackingContext& context, ::zserio::BitStreamWriter& out) const
{
    switch (getType())
    {
    case ::nds::core::geometry::GeometryLayerType::POSITION_2D:
        // check array length
        if (m_objectChoice.get<ZserioArrayType_positions2D>().getRawArray().size() != static_cast<size_t>(getNumElements()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field Buffers.positions2D: ") <<
                    m_objectChoice.get<ZserioArrayType_positions2D>().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumElements()) << "!";
        }
        m_objectChoice.get<ZserioArrayType_positions2D>().writePacked(*this, out);
        break;
    case ::nds::core::geometry::GeometryLayerType::POSITION_3D:
        // check array length
        if (m_objectChoice.get<ZserioArrayType_positions3D>().getRawArray().size() != static_cast<size_t>(getNumElements()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field Buffers.positions3D: ") <<
                    m_objectChoice.get<ZserioArrayType_positions3D>().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumElements()) << "!";
        }
        m_objectChoice.get<ZserioArrayType_positions3D>().writePacked(*this, out);
        break;
    case ::nds::core::geometry::GeometryLayerType::LINE_2D:
        // check array length
        if (m_objectChoice.get<ZserioArrayType_lines2D>().getRawArray().size() != static_cast<size_t>(getNumElements()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field Buffers.lines2D: ") <<
                    m_objectChoice.get<ZserioArrayType_lines2D>().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumElements()) << "!";
        }
        m_objectChoice.get<ZserioArrayType_lines2D>().writePacked(*this, out);
        break;
    case ::nds::core::geometry::GeometryLayerType::LINE_3D:
        // check array length
        if (m_objectChoice.get<ZserioArrayType_lines3D>().getRawArray().size() != static_cast<size_t>(getNumElements()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field Buffers.lines3D: ") <<
                    m_objectChoice.get<ZserioArrayType_lines3D>().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumElements()) << "!";
        }
        m_objectChoice.get<ZserioArrayType_lines3D>().writePacked(*this, out);
        break;
    case ::nds::core::geometry::GeometryLayerType::POLYGON_2D:
        // check parameters
        if (m_objectChoice.get<::nds::core::geometry::Polygon2DBuffers>().getShift() != static_cast<::nds::core::geometry::CoordShift>(getShiftXY()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter shift for field Buffers.polygons2D: ") <<
                    m_objectChoice.get<::nds::core::geometry::Polygon2DBuffers>().getShift() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShiftXY()) << "!";
        }
        if (m_objectChoice.get<::nds::core::geometry::Polygon2DBuffers>().getNumElements() != static_cast<uint32_t>(getNumElements()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter numElements for field Buffers.polygons2D: ") <<
                    m_objectChoice.get<::nds::core::geometry::Polygon2DBuffers>().getNumElements() << " != " << static_cast<uint32_t>(getNumElements()) << "!";
        }
        m_objectChoice.get<::nds::core::geometry::Polygon2DBuffers>().write(context.getPolygons2D(), out);
        break;
    case ::nds::core::geometry::GeometryLayerType::POLYGON_3D:
        // check parameters
        if (m_objectChoice.get<::nds::core::geometry::PolyMesh3DBuffers>().getShiftXY() != static_cast<::nds::core::geometry::CoordShift>(getShiftXY()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter shiftXY for field Buffers.polygons3D: ") <<
                    m_objectChoice.get<::nds::core::geometry::PolyMesh3DBuffers>().getShiftXY() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShiftXY()) << "!";
        }
        if (m_objectChoice.get<::nds::core::geometry::PolyMesh3DBuffers>().getShiftZ() != static_cast<::nds::core::geometry::CoordShift>(getShiftZ()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter shiftZ for field Buffers.polygons3D: ") <<
                    m_objectChoice.get<::nds::core::geometry::PolyMesh3DBuffers>().getShiftZ() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShiftZ()) << "!";
        }
        if (m_objectChoice.get<::nds::core::geometry::PolyMesh3DBuffers>().getNumElements() != static_cast<uint32_t>(getNumElements()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter numElements for field Buffers.polygons3D: ") <<
                    m_objectChoice.get<::nds::core::geometry::PolyMesh3DBuffers>().getNumElements() << " != " << static_cast<uint32_t>(getNumElements()) << "!";
        }
        if (m_objectChoice.get<::nds::core::geometry::PolyMesh3DBuffers>().getType() != static_cast<::nds::core::geometry::PolyMesh3DType>(::nds::core::geometry::PolyMesh3DType::POLYGON))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field Buffers.polygons3D: ") <<
                    m_objectChoice.get<::nds::core::geometry::PolyMesh3DBuffers>().getType() << " != " << static_cast<::nds::core::geometry::PolyMesh3DType>(::nds::core::geometry::PolyMesh3DType::POLYGON) << "!";
        }
        m_objectChoice.get<::nds::core::geometry::PolyMesh3DBuffers>().write(context.getPolygons3D(), out);
        break;
    case ::nds::core::geometry::GeometryLayerType::MESH_3D:
        // check parameters
        if (m_objectChoice.get<::nds::core::geometry::PolyMesh3DBuffers>().getShiftXY() != static_cast<::nds::core::geometry::CoordShift>(getShiftXY()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter shiftXY for field Buffers.meshes3D: ") <<
                    m_objectChoice.get<::nds::core::geometry::PolyMesh3DBuffers>().getShiftXY() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShiftXY()) << "!";
        }
        if (m_objectChoice.get<::nds::core::geometry::PolyMesh3DBuffers>().getShiftZ() != static_cast<::nds::core::geometry::CoordShift>(getShiftZ()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter shiftZ for field Buffers.meshes3D: ") <<
                    m_objectChoice.get<::nds::core::geometry::PolyMesh3DBuffers>().getShiftZ() << " != " << static_cast<::nds::core::geometry::CoordShift>(getShiftZ()) << "!";
        }
        if (m_objectChoice.get<::nds::core::geometry::PolyMesh3DBuffers>().getNumElements() != static_cast<uint32_t>(getNumElements()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter numElements for field Buffers.meshes3D: ") <<
                    m_objectChoice.get<::nds::core::geometry::PolyMesh3DBuffers>().getNumElements() << " != " << static_cast<uint32_t>(getNumElements()) << "!";
        }
        if (m_objectChoice.get<::nds::core::geometry::PolyMesh3DBuffers>().getType() != static_cast<::nds::core::geometry::PolyMesh3DType>(::nds::core::geometry::PolyMesh3DType::MESH))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong parameter type for field Buffers.meshes3D: ") <<
                    m_objectChoice.get<::nds::core::geometry::PolyMesh3DBuffers>().getType() << " != " << static_cast<::nds::core::geometry::PolyMesh3DType>(::nds::core::geometry::PolyMesh3DType::MESH) << "!";
        }
        m_objectChoice.get<::nds::core::geometry::PolyMesh3DBuffers>().write(context.getMeshes3D(), out);
        break;
    case ::nds::core::geometry::GeometryLayerType::SIMPLE_POLYGON_2D:
        // check array length
        if (m_objectChoice.get<ZserioArrayType_simplePolygons2D>().getRawArray().size() != static_cast<size_t>(getNumElements()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field Buffers.simplePolygons2D: ") <<
                    m_objectChoice.get<ZserioArrayType_simplePolygons2D>().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumElements()) << "!";
        }
        m_objectChoice.get<ZserioArrayType_simplePolygons2D>().writePacked(*this, out);
        break;
    case ::nds::core::geometry::GeometryLayerType::SIMPLE_POLYGON_SET_2D:
        // check array length
        if (m_objectChoice.get<ZserioArrayType_simplePolygonSets2D>().getRawArray().size() != static_cast<size_t>(getNumElements()))
        {
            throw ::zserio::CppRuntimeException("Write: Wrong array length for field Buffers.simplePolygonSets2D: ") <<
                    m_objectChoice.get<ZserioArrayType_simplePolygonSets2D>().getRawArray().size() << " != " <<
                    static_cast<size_t>(getNumElements()) << "!";
        }
        m_objectChoice.get<ZserioArrayType_simplePolygonSets2D>().writePacked(*this, out);
        break;
    default:
        throw ::zserio::CppRuntimeException("No match in choice Buffers!");
    }
}

void Buffers::ZserioArrayExpressions_positions2D::initializeElement(Buffers& owner,
        ::nds::core::geometry::Position2D& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getShiftXY()));
}

void Buffers::ZserioElementFactory_positions2D::create(Buffers&         owner,
        ::zserio::vector<::nds::core::geometry::Position2D>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getShiftXY()), array.get_allocator());
}

void Buffers::ZserioElementFactory_positions2D::create(Buffers&         owner,
        ::zserio::vector<::nds::core::geometry::Position2D>& array,
        ::nds::core::geometry::Position2D::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getShiftXY()), array.get_allocator());
}

void Buffers::ZserioArrayExpressions_positions3D::initializeElement(Buffers& owner,
        ::nds::core::geometry::Position3D& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getShiftXY()), static_cast<::nds::core::geometry::CoordShift>(owner.getShiftZ()));
}

void Buffers::ZserioElementFactory_positions3D::create(Buffers&         owner,
        ::zserio::vector<::nds::core::geometry::Position3D>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getShiftXY()), static_cast<::nds::core::geometry::CoordShift>(owner.getShiftZ()), array.get_allocator());
}

void Buffers::ZserioElementFactory_positions3D::create(Buffers&         owner,
        ::zserio::vector<::nds::core::geometry::Position3D>& array,
        ::nds::core::geometry::Position3D::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getShiftXY()), static_cast<::nds::core::geometry::CoordShift>(owner.getShiftZ()), array.get_allocator());
}

void Buffers::ZserioArrayExpressions_lines2D::initializeElement(Buffers& owner,
        ::nds::core::geometry::Line2D& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getShiftXY()));
}

void Buffers::ZserioElementFactory_lines2D::create(Buffers&         owner,
        ::zserio::vector<::nds::core::geometry::Line2D>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getShiftXY()), array.get_allocator());
}

void Buffers::ZserioElementFactory_lines2D::create(Buffers&         owner,
        ::zserio::vector<::nds::core::geometry::Line2D>& array,
        ::nds::core::geometry::Line2D::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getShiftXY()), array.get_allocator());
}

void Buffers::ZserioArrayExpressions_lines3D::initializeElement(Buffers& owner,
        ::nds::core::geometry::Line3D& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getShiftXY()), static_cast<::nds::core::geometry::CoordShift>(owner.getShiftZ()));
}

void Buffers::ZserioElementFactory_lines3D::create(Buffers&         owner,
        ::zserio::vector<::nds::core::geometry::Line3D>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getShiftXY()), static_cast<::nds::core::geometry::CoordShift>(owner.getShiftZ()), array.get_allocator());
}

void Buffers::ZserioElementFactory_lines3D::create(Buffers&         owner,
        ::zserio::vector<::nds::core::geometry::Line3D>& array,
        ::nds::core::geometry::Line3D::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getShiftXY()), static_cast<::nds::core::geometry::CoordShift>(owner.getShiftZ()), array.get_allocator());
}

void Buffers::ZserioArrayExpressions_simplePolygons2D::initializeElement(Buffers& owner,
        ::nds::core::geometry::SimplePolygon2D& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getShiftXY()));
}

void Buffers::ZserioElementFactory_simplePolygons2D::create(Buffers&         owner,
        ::zserio::vector<::nds::core::geometry::SimplePolygon2D>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getShiftXY()), array.get_allocator());
}

void Buffers::ZserioElementFactory_simplePolygons2D::create(Buffers&         owner,
        ::zserio::vector<::nds::core::geometry::SimplePolygon2D>& array,
        ::nds::core::geometry::SimplePolygon2D::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getShiftXY()), array.get_allocator());
}

void Buffers::ZserioArrayExpressions_simplePolygonSets2D::initializeElement(Buffers& owner,
        ::nds::core::geometry::SimplePolygonSet2D& element, size_t)
{
    element.initialize(static_cast<::nds::core::geometry::CoordShift>(owner.getShiftXY()));
}

void Buffers::ZserioElementFactory_simplePolygonSets2D::create(Buffers&         owner,
        ::zserio::vector<::nds::core::geometry::SimplePolygonSet2D>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    array.emplace_back(in, static_cast<::nds::core::geometry::CoordShift>(owner.getShiftXY()), array.get_allocator());
}

void Buffers::ZserioElementFactory_simplePolygonSets2D::create(Buffers&         owner,
        ::zserio::vector<::nds::core::geometry::SimplePolygonSet2D>& array,
        ::nds::core::geometry::SimplePolygonSet2D::ZserioPackingContext& context, ::zserio::BitStreamReader& in,
        size_t)
{
    array.emplace_back(context, in, static_cast<::nds::core::geometry::CoordShift>(owner.getShiftXY()), array.get_allocator());
}

::zserio::AnyHolder<> Buffers::readObject(::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::core::geometry::GeometryLayerType::POSITION_2D:
        {
            ZserioArrayType_positions2D readField(allocator);
            readField.readPacked(*this, in, static_cast<size_t>(getNumElements()));

            return ::zserio::AnyHolder<>(::std::move(readField), allocator);
        }
    case ::nds::core::geometry::GeometryLayerType::POSITION_3D:
        {
            ZserioArrayType_positions3D readField(allocator);
            readField.readPacked(*this, in, static_cast<size_t>(getNumElements()));

            return ::zserio::AnyHolder<>(::std::move(readField), allocator);
        }
    case ::nds::core::geometry::GeometryLayerType::LINE_2D:
        {
            ZserioArrayType_lines2D readField(allocator);
            readField.read(*this, in, static_cast<size_t>(getNumElements()));

            return ::zserio::AnyHolder<>(::std::move(readField), allocator);
        }
    case ::nds::core::geometry::GeometryLayerType::LINE_3D:
        {
            ZserioArrayType_lines3D readField(allocator);
            readField.read(*this, in, static_cast<size_t>(getNumElements()));

            return ::zserio::AnyHolder<>(::std::move(readField), allocator);
        }
    case ::nds::core::geometry::GeometryLayerType::POLYGON_2D:
        return ::zserio::AnyHolder<>(::nds::core::geometry::Polygon2DBuffers(in, static_cast<::nds::core::geometry::CoordShift>(getShiftXY()), static_cast<uint32_t>(getNumElements()), allocator), allocator);
    case ::nds::core::geometry::GeometryLayerType::POLYGON_3D:
        return ::zserio::AnyHolder<>(::nds::core::geometry::PolyMesh3DBuffers(in, static_cast<::nds::core::geometry::CoordShift>(getShiftXY()), static_cast<::nds::core::geometry::CoordShift>(getShiftZ()), static_cast<uint32_t>(getNumElements()), static_cast<::nds::core::geometry::PolyMesh3DType>(::nds::core::geometry::PolyMesh3DType::POLYGON), allocator), allocator);
    case ::nds::core::geometry::GeometryLayerType::MESH_3D:
        return ::zserio::AnyHolder<>(::nds::core::geometry::PolyMesh3DBuffers(in, static_cast<::nds::core::geometry::CoordShift>(getShiftXY()), static_cast<::nds::core::geometry::CoordShift>(getShiftZ()), static_cast<uint32_t>(getNumElements()), static_cast<::nds::core::geometry::PolyMesh3DType>(::nds::core::geometry::PolyMesh3DType::MESH), allocator), allocator);
    case ::nds::core::geometry::GeometryLayerType::SIMPLE_POLYGON_2D:
        {
            ZserioArrayType_simplePolygons2D readField(allocator);
            readField.read(*this, in, static_cast<size_t>(getNumElements()));

            return ::zserio::AnyHolder<>(::std::move(readField), allocator);
        }
    case ::nds::core::geometry::GeometryLayerType::SIMPLE_POLYGON_SET_2D:
        {
            ZserioArrayType_simplePolygonSets2D readField(allocator);
            readField.read(*this, in, static_cast<size_t>(getNumElements()));

            return ::zserio::AnyHolder<>(::std::move(readField), allocator);
        }
    default:
        throw ::zserio::CppRuntimeException("No match in choice Buffers!");
    }
}

::zserio::AnyHolder<> Buffers::readObject(Buffers::ZserioPackingContext& context,
        ::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    switch (getType())
    {
    case ::nds::core::geometry::GeometryLayerType::POSITION_2D:
        {
            ZserioArrayType_positions2D readField(allocator);
            readField.readPacked(*this, in, static_cast<size_t>(getNumElements()));

            return ::zserio::AnyHolder<>(::std::move(readField), allocator);
        }
    case ::nds::core::geometry::GeometryLayerType::POSITION_3D:
        {
            ZserioArrayType_positions3D readField(allocator);
            readField.readPacked(*this, in, static_cast<size_t>(getNumElements()));

            return ::zserio::AnyHolder<>(::std::move(readField), allocator);
        }
    case ::nds::core::geometry::GeometryLayerType::LINE_2D:
        {
            ZserioArrayType_lines2D readField(allocator);
            readField.readPacked(*this, in, static_cast<size_t>(getNumElements()));

            return ::zserio::AnyHolder<>(::std::move(readField), allocator);
        }
    case ::nds::core::geometry::GeometryLayerType::LINE_3D:
        {
            ZserioArrayType_lines3D readField(allocator);
            readField.readPacked(*this, in, static_cast<size_t>(getNumElements()));

            return ::zserio::AnyHolder<>(::std::move(readField), allocator);
        }
    case ::nds::core::geometry::GeometryLayerType::POLYGON_2D:
        return ::zserio::AnyHolder<>(::nds::core::geometry::Polygon2DBuffers(context.getPolygons2D(), in, static_cast<::nds::core::geometry::CoordShift>(getShiftXY()), static_cast<uint32_t>(getNumElements()), allocator), allocator);
    case ::nds::core::geometry::GeometryLayerType::POLYGON_3D:
        return ::zserio::AnyHolder<>(::nds::core::geometry::PolyMesh3DBuffers(context.getPolygons3D(), in, static_cast<::nds::core::geometry::CoordShift>(getShiftXY()), static_cast<::nds::core::geometry::CoordShift>(getShiftZ()), static_cast<uint32_t>(getNumElements()), static_cast<::nds::core::geometry::PolyMesh3DType>(::nds::core::geometry::PolyMesh3DType::POLYGON), allocator), allocator);
    case ::nds::core::geometry::GeometryLayerType::MESH_3D:
        return ::zserio::AnyHolder<>(::nds::core::geometry::PolyMesh3DBuffers(context.getMeshes3D(), in, static_cast<::nds::core::geometry::CoordShift>(getShiftXY()), static_cast<::nds::core::geometry::CoordShift>(getShiftZ()), static_cast<uint32_t>(getNumElements()), static_cast<::nds::core::geometry::PolyMesh3DType>(::nds::core::geometry::PolyMesh3DType::MESH), allocator), allocator);
    case ::nds::core::geometry::GeometryLayerType::SIMPLE_POLYGON_2D:
        {
            ZserioArrayType_simplePolygons2D readField(allocator);
            readField.readPacked(*this, in, static_cast<size_t>(getNumElements()));

            return ::zserio::AnyHolder<>(::std::move(readField), allocator);
        }
    case ::nds::core::geometry::GeometryLayerType::SIMPLE_POLYGON_SET_2D:
        {
            ZserioArrayType_simplePolygonSets2D readField(allocator);
            readField.readPacked(*this, in, static_cast<size_t>(getNumElements()));

            return ::zserio::AnyHolder<>(::std::move(readField), allocator);
        }
    default:
        throw ::zserio::CppRuntimeException("No match in choice Buffers!");
    }
}

::zserio::AnyHolder<> Buffers::copyObject(const allocator_type& allocator) const
{
    switch (getType())
    {
    case ::nds::core::geometry::GeometryLayerType::POSITION_2D:
        return ::zserio::allocatorPropagatingCopy<ZserioArrayType_positions2D>(m_objectChoice, allocator);
    case ::nds::core::geometry::GeometryLayerType::POSITION_3D:
        return ::zserio::allocatorPropagatingCopy<ZserioArrayType_positions3D>(m_objectChoice, allocator);
    case ::nds::core::geometry::GeometryLayerType::LINE_2D:
        return ::zserio::allocatorPropagatingCopy<ZserioArrayType_lines2D>(m_objectChoice, allocator);
    case ::nds::core::geometry::GeometryLayerType::LINE_3D:
        return ::zserio::allocatorPropagatingCopy<ZserioArrayType_lines3D>(m_objectChoice, allocator);
    case ::nds::core::geometry::GeometryLayerType::POLYGON_2D:
        return ::zserio::allocatorPropagatingCopy<::nds::core::geometry::Polygon2DBuffers>(m_objectChoice, allocator);
    case ::nds::core::geometry::GeometryLayerType::POLYGON_3D:
        return ::zserio::allocatorPropagatingCopy<::nds::core::geometry::PolyMesh3DBuffers>(m_objectChoice, allocator);
    case ::nds::core::geometry::GeometryLayerType::MESH_3D:
        return ::zserio::allocatorPropagatingCopy<::nds::core::geometry::PolyMesh3DBuffers>(m_objectChoice, allocator);
    case ::nds::core::geometry::GeometryLayerType::SIMPLE_POLYGON_2D:
        return ::zserio::allocatorPropagatingCopy<ZserioArrayType_simplePolygons2D>(m_objectChoice, allocator);
    case ::nds::core::geometry::GeometryLayerType::SIMPLE_POLYGON_SET_2D:
        return ::zserio::allocatorPropagatingCopy<ZserioArrayType_simplePolygonSets2D>(m_objectChoice, allocator);
    default:
        throw ::zserio::CppRuntimeException("No match in choice Buffers!");
    }
}

} // namespace geometry
} // namespace core
} // namespace nds
