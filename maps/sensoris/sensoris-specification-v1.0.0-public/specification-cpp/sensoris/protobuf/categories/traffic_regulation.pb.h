// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sensoris/protobuf/categories/traffic_regulation.proto
// Protobuf C++ Version: 4.25.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_sensoris_2fprotobuf_2fcategories_2ftraffic_5fregulation_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_sensoris_2fprotobuf_2fcategories_2ftraffic_5fregulation_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "google/protobuf/wrappers.pb.h"
#include "sensoris/protobuf/types/base.pb.h"
#include "sensoris/protobuf/types/spatial.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_sensoris_2fprotobuf_2fcategories_2ftraffic_5fregulation_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_sensoris_2fprotobuf_2fcategories_2ftraffic_5fregulation_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_sensoris_2fprotobuf_2fcategories_2ftraffic_5fregulation_2eproto;
namespace sensoris {
namespace protobuf {
namespace categories {
namespace trafficregulation {
class TrafficRegulationCategory;
struct TrafficRegulationCategoryDefaultTypeInternal;
extern TrafficRegulationCategoryDefaultTypeInternal _TrafficRegulationCategory_default_instance_;
class TrafficSign;
struct TrafficSignDefaultTypeInternal;
extern TrafficSignDefaultTypeInternal _TrafficSign_default_instance_;
class TrafficSign_DominantBackgroundColorAndConfidence;
struct TrafficSign_DominantBackgroundColorAndConfidenceDefaultTypeInternal;
extern TrafficSign_DominantBackgroundColorAndConfidenceDefaultTypeInternal _TrafficSign_DominantBackgroundColorAndConfidence_default_instance_;
class TrafficSign_PermanencyAndConfidence;
struct TrafficSign_PermanencyAndConfidenceDefaultTypeInternal;
extern TrafficSign_PermanencyAndConfidenceDefaultTypeInternal _TrafficSign_PermanencyAndConfidence_default_instance_;
class TrafficSign_ShapeAndConfidence;
struct TrafficSign_ShapeAndConfidenceDefaultTypeInternal;
extern TrafficSign_ShapeAndConfidenceDefaultTypeInternal _TrafficSign_ShapeAndConfidence_default_instance_;
class TrafficSign_SupplementarySignAndConfidence;
struct TrafficSign_SupplementarySignAndConfidenceDefaultTypeInternal;
extern TrafficSign_SupplementarySignAndConfidenceDefaultTypeInternal _TrafficSign_SupplementarySignAndConfidence_default_instance_;
class TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence;
struct TrafficSign_SupplementarySignAndConfidence_TypeAndConfidenceDefaultTypeInternal;
extern TrafficSign_SupplementarySignAndConfidence_TypeAndConfidenceDefaultTypeInternal _TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_default_instance_;
class TrafficSign_TypeAndConfidence;
struct TrafficSign_TypeAndConfidenceDefaultTypeInternal;
extern TrafficSign_TypeAndConfidenceDefaultTypeInternal _TrafficSign_TypeAndConfidence_default_instance_;
class TrafficSign_ValidationAndConfidence;
struct TrafficSign_ValidationAndConfidenceDefaultTypeInternal;
extern TrafficSign_ValidationAndConfidenceDefaultTypeInternal _TrafficSign_ValidationAndConfidence_default_instance_;
class TrafficSign_ValueAndConfidence;
struct TrafficSign_ValueAndConfidenceDefaultTypeInternal;
extern TrafficSign_ValueAndConfidenceDefaultTypeInternal _TrafficSign_ValueAndConfidence_default_instance_;
}  // namespace trafficregulation
}  // namespace categories
}  // namespace protobuf
}  // namespace sensoris
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace sensoris {
namespace protobuf {
namespace categories {
namespace trafficregulation {
enum TrafficSign_ShapeAndConfidence_Type : int {
  TrafficSign_ShapeAndConfidence_Type_UNKNOWN_TYPE = 0,
  TrafficSign_ShapeAndConfidence_Type_OTHER = 1,
  TrafficSign_ShapeAndConfidence_Type_RECTANGLE = 2,
  TrafficSign_ShapeAndConfidence_Type_SQUARE = 3,
  TrafficSign_ShapeAndConfidence_Type_TRIANGLE_UP = 4,
  TrafficSign_ShapeAndConfidence_Type_TRIANGLE_DOWN = 5,
  TrafficSign_ShapeAndConfidence_Type_DIAMOND = 6,
  TrafficSign_ShapeAndConfidence_Type_HEXAGON = 7,
  TrafficSign_ShapeAndConfidence_Type_ROUND = 8,
  TrafficSign_ShapeAndConfidence_Type_CROSS_BUCK = 9,
  TrafficSign_ShapeAndConfidence_Type_OCTAGON = 10,
  TrafficSign_ShapeAndConfidence_Type_ELLIPSE = 11,
  TrafficSign_ShapeAndConfidence_Type_PENTAGON = 12,
  TrafficSign_ShapeAndConfidence_Type_TrafficSign_ShapeAndConfidence_Type_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  TrafficSign_ShapeAndConfidence_Type_TrafficSign_ShapeAndConfidence_Type_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool TrafficSign_ShapeAndConfidence_Type_IsValid(int value);
extern const uint32_t TrafficSign_ShapeAndConfidence_Type_internal_data_[];
constexpr TrafficSign_ShapeAndConfidence_Type TrafficSign_ShapeAndConfidence_Type_Type_MIN = static_cast<TrafficSign_ShapeAndConfidence_Type>(0);
constexpr TrafficSign_ShapeAndConfidence_Type TrafficSign_ShapeAndConfidence_Type_Type_MAX = static_cast<TrafficSign_ShapeAndConfidence_Type>(12);
constexpr int TrafficSign_ShapeAndConfidence_Type_Type_ARRAYSIZE = 12 + 1;
const ::google::protobuf::EnumDescriptor*
TrafficSign_ShapeAndConfidence_Type_descriptor();
template <typename T>
const std::string& TrafficSign_ShapeAndConfidence_Type_Name(T value) {
  static_assert(std::is_same<T, TrafficSign_ShapeAndConfidence_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return TrafficSign_ShapeAndConfidence_Type_Name(static_cast<TrafficSign_ShapeAndConfidence_Type>(value));
}
template <>
inline const std::string& TrafficSign_ShapeAndConfidence_Type_Name(TrafficSign_ShapeAndConfidence_Type value) {
  return ::google::protobuf::internal::NameOfDenseEnum<TrafficSign_ShapeAndConfidence_Type_descriptor,
                                                 0, 12>(
      static_cast<int>(value));
}
inline bool TrafficSign_ShapeAndConfidence_Type_Parse(absl::string_view name, TrafficSign_ShapeAndConfidence_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrafficSign_ShapeAndConfidence_Type>(
      TrafficSign_ShapeAndConfidence_Type_descriptor(), name, value);
}
enum TrafficSign_TypeAndConfidence_Type : int {
  TrafficSign_TypeAndConfidence_Type_UNKNOWN_TYPE = 0,
  TrafficSign_TypeAndConfidence_Type_OTHER_AS_TEXT = 1,
  TrafficSign_TypeAndConfidence_Type_SPEED_LIMIT = 2,
  TrafficSign_TypeAndConfidence_Type_SPEED_LIMIT_END = 3,
  TrafficSign_TypeAndConfidence_Type_SPEED_LIMIT_CHANGE_UPCOMING = 4,
  TrafficSign_TypeAndConfidence_Type_ADVISORY_SPEED_LIMIT = 5,
  TrafficSign_TypeAndConfidence_Type_ADVISORY_SPEED_LIMIT_END = 6,
  TrafficSign_TypeAndConfidence_Type_NO_OVERTAKING = 7,
  TrafficSign_TypeAndConfidence_Type_NO_OVERTAKING_END = 8,
  TrafficSign_TypeAndConfidence_Type_PROTECTED_PASSING_START = 9,
  TrafficSign_TypeAndConfidence_Type_PROTECTED_PASSING_END = 10,
  TrafficSign_TypeAndConfidence_Type_PROTECTED_PASSING_LEFT_START = 11,
  TrafficSign_TypeAndConfidence_Type_PROTECTED_PASSING_RIGHT_START = 12,
  TrafficSign_TypeAndConfidence_Type_PROTECTED_PASSING_LEFT_END = 13,
  TrafficSign_TypeAndConfidence_Type_PROTECTED_PASSING_RIGHT_END = 14,
  TrafficSign_TypeAndConfidence_Type_NO_OVERTAKING_TRUCK = 15,
  TrafficSign_TypeAndConfidence_Type_NO_OVERTAKING_TRUCK_END = 16,
  TrafficSign_TypeAndConfidence_Type_ALL_RESTRICTIONS_END = 17,
  TrafficSign_TypeAndConfidence_Type_CITY_START = 18,
  TrafficSign_TypeAndConfidence_Type_CITY_END = 19,
  TrafficSign_TypeAndConfidence_Type_HIGHWAY = 20,
  TrafficSign_TypeAndConfidence_Type_HIGHWAY_END = 21,
  TrafficSign_TypeAndConfidence_Type_MOTORWAY = 22,
  TrafficSign_TypeAndConfidence_Type_MOTORWAY_END = 23,
  TrafficSign_TypeAndConfidence_Type_CONSTRUCTION = 24,
  TrafficSign_TypeAndConfidence_Type_CONSTRUCTION_END = 25,
  TrafficSign_TypeAndConfidence_Type_LANE_MERGE = 26,
  TrafficSign_TypeAndConfidence_Type_LANE_MERGE_ON_RIGHT = 27,
  TrafficSign_TypeAndConfidence_Type_LANE_MERGE_ON_LEFT = 28,
  TrafficSign_TypeAndConfidence_Type_LANE_MERGE_CENTER = 29,
  TrafficSign_TypeAndConfidence_Type_RAILWAY_CROSSING_GENERAL = 30,
  TrafficSign_TypeAndConfidence_Type_RAILWAY_CROSSING_PROTECTED = 31,
  TrafficSign_TypeAndConfidence_Type_RAILWAY_CROSSING_UNPROTECTED = 32,
  TrafficSign_TypeAndConfidence_Type_ROAD_NARROWS = 33,
  TrafficSign_TypeAndConfidence_Type_ROAD_NARROWS_LEFT = 34,
  TrafficSign_TypeAndConfidence_Type_ROAD_NARROWS_RIGHT = 35,
  TrafficSign_TypeAndConfidence_Type_ROAD_NARROWS_CENTER = 36,
  TrafficSign_TypeAndConfidence_Type_SHARP_CURVE = 37,
  TrafficSign_TypeAndConfidence_Type_SHARP_CURVE_LEFT = 38,
  TrafficSign_TypeAndConfidence_Type_SHARP_CURVE_RIGHT = 39,
  TrafficSign_TypeAndConfidence_Type_WINDING_ROAD = 40,
  TrafficSign_TypeAndConfidence_Type_WINDING_ROAD_STARTING_LEFT = 41,
  TrafficSign_TypeAndConfidence_Type_WINDING_ROAD_STARTING_RIGHT = 42,
  TrafficSign_TypeAndConfidence_Type_STEEP_HILL = 43,
  TrafficSign_TypeAndConfidence_Type_STEEP_HILL_UPWARDS = 44,
  TrafficSign_TypeAndConfidence_Type_STEEP_HILL_DOWNWARDS = 45,
  TrafficSign_TypeAndConfidence_Type_STOP_SIGN = 46,
  TrafficSign_TypeAndConfidence_Type_LATERAL_WIND = 47,
  TrafficSign_TypeAndConfidence_Type_LATERAL_WIND_FROM_RIGHT = 48,
  TrafficSign_TypeAndConfidence_Type_LATERAL_WIND_FROM_LEFT = 49,
  TrafficSign_TypeAndConfidence_Type_GENERAL_WARNING = 50,
  TrafficSign_TypeAndConfidence_Type_RISK_OF_GROUNDING = 51,
  TrafficSign_TypeAndConfidence_Type_ANIMAL = 52,
  TrafficSign_TypeAndConfidence_Type_ICY_CONDITIONS = 53,
  TrafficSign_TypeAndConfidence_Type_SLIPPERY_ROAD = 54,
  TrafficSign_TypeAndConfidence_Type_UNEVEN_ROAD = 55,
  TrafficSign_TypeAndConfidence_Type_SCHOOL_ZONE = 56,
  TrafficSign_TypeAndConfidence_Type_TRAMWAY_CROSSING = 57,
  TrafficSign_TypeAndConfidence_Type_CONGESTION_HAZARD = 58,
  TrafficSign_TypeAndConfidence_Type_ACCIDENT_HAZARD = 59,
  TrafficSign_TypeAndConfidence_Type_BICYCLE_CROSSING = 60,
  TrafficSign_TypeAndConfidence_Type_PRIORITY_OVER_ONCOMING_TRAFFIC = 61,
  TrafficSign_TypeAndConfidence_Type_YIELD = 62,
  TrafficSign_TypeAndConfidence_Type_PRIORITY_ROAD = 63,
  TrafficSign_TypeAndConfidence_Type_PRIORITY_ROAD_END = 64,
  TrafficSign_TypeAndConfidence_Type_TRAFFIC_CALMING = 65,
  TrafficSign_TypeAndConfidence_Type_TRAFFIC_CALMING_END = 66,
  TrafficSign_TypeAndConfidence_Type_ENVIRONMENTAL_AREA = 67,
  TrafficSign_TypeAndConfidence_Type_ENVIRONMENTAL_AREA_END = 68,
  TrafficSign_TypeAndConfidence_Type_INTERSECTION = 69,
  TrafficSign_TypeAndConfidence_Type_ROUNDABOUT = 70,
  TrafficSign_TypeAndConfidence_Type_PASSING_ON_LEFT = 71,
  TrafficSign_TypeAndConfidence_Type_PASSING_ON_RIGHT = 72,
  TrafficSign_TypeAndConfidence_Type_PASSING_ON_LEFT_OR_RIGHT = 73,
  TrafficSign_TypeAndConfidence_Type_MANDATORY_TURN_RIGHT_ONLY = 74,
  TrafficSign_TypeAndConfidence_Type_MANDATORY_TURN_LEFT_ONLY = 75,
  TrafficSign_TypeAndConfidence_Type_MANDATORY_STRAIGHT_ONLY = 76,
  TrafficSign_TypeAndConfidence_Type_MANDATORY_TURN_LEFT_OR_RIGHT = 77,
  TrafficSign_TypeAndConfidence_Type_MANDATORY_TURN_RESTRICTION = 78,
  TrafficSign_TypeAndConfidence_Type_MANDATORY_STRAIGHT_OR_LEFT = 79,
  TrafficSign_TypeAndConfidence_Type_MANDATORY_STRAIGHT_OR_RIGHT = 80,
  TrafficSign_TypeAndConfidence_Type_NO_LEFT_TURN = 81,
  TrafficSign_TypeAndConfidence_Type_NO_RIGHT_TURN = 82,
  TrafficSign_TypeAndConfidence_Type_NO_U_TURN = 83,
  TrafficSign_TypeAndConfidence_Type_NO_U_OR_LEFT_TURN = 84,
  TrafficSign_TypeAndConfidence_Type_U_TURN_ALLOWED = 85,
  TrafficSign_TypeAndConfidence_Type_MANDATORY_LEFT_TRUCK = 86,
  TrafficSign_TypeAndConfidence_Type_MANDATORY_RIGHT_TRUCK = 87,
  TrafficSign_TypeAndConfidence_Type_MANDATORY_STRAIGHT_TRUCK = 88,
  TrafficSign_TypeAndConfidence_Type_NO_ENTRY = 89,
  TrafficSign_TypeAndConfidence_Type_DEAD_END = 90,
  TrafficSign_TypeAndConfidence_Type_HIGH_OCCUPANCY_VEHICLE_LANE = 91,
  TrafficSign_TypeAndConfidence_Type_TOLL = 92,
  TrafficSign_TypeAndConfidence_Type_TOLL_CAR = 93,
  TrafficSign_TypeAndConfidence_Type_TOLL_LANE = 94,
  TrafficSign_TypeAndConfidence_Type_EXPRESS_LANE = 95,
  TrafficSign_TypeAndConfidence_Type_SHOULDER_OPEN_FOR_TRAFFIC = 96,
  TrafficSign_TypeAndConfidence_Type_SHOULDER_CLOSED_FOR_TRAFFIC = 97,
  TrafficSign_TypeAndConfidence_Type_LANE_CLOSED = 98,
  TrafficSign_TypeAndConfidence_Type_LANE_CLOSED_RIGHT_MOST_LANE = 99,
  TrafficSign_TypeAndConfidence_Type_LANE_CLOSED_LEFT_MOST_LANE = 100,
  TrafficSign_TypeAndConfidence_Type_WARNING_PEDESTRIAN = 101,
  TrafficSign_TypeAndConfidence_Type_WARNING_CHILDREN = 102,
  TrafficSign_TypeAndConfidence_Type_WARNING_BICYCLE = 103,
  TrafficSign_TypeAndConfidence_Type_WARNING_BUS = 104,
  TrafficSign_TypeAndConfidence_Type_PUBLIC_TRANSPORTATION_STOP = 105,
  TrafficSign_TypeAndConfidence_Type_PEDESTRIAN_CROSSING = 106,
  TrafficSign_TypeAndConfidence_Type_WEIGHT_RESTRICTION = 107,
  TrafficSign_TypeAndConfidence_Type_HEIGHT_RESTRICTION = 108,
  TrafficSign_TypeAndConfidence_Type_LENGTH_RESTRICTION = 109,
  TrafficSign_TypeAndConfidence_Type_WIDTH_RESTRICTION = 110,
  TrafficSign_TypeAndConfidence_Type_WARNING_TRUCK_ROLLOVER = 111,
  TrafficSign_TypeAndConfidence_Type_SIGNAL_AHEAD = 112,
  TrafficSign_TypeAndConfidence_Type_SKI_CROSSING = 113,
  TrafficSign_TypeAndConfidence_Type_NO_AGRICULTUR_VEHICLE = 114,
  TrafficSign_TypeAndConfidence_Type_NO_BICYCLE = 115,
  TrafficSign_TypeAndConfidence_Type_NO_BUS = 116,
  TrafficSign_TypeAndConfidence_Type_NO_HAUL_EXPLOSIVES = 117,
  TrafficSign_TypeAndConfidence_Type_NO_HAUL_HARMFUL_TO_WATER = 118,
  TrafficSign_TypeAndConfidence_Type_NO_HAUL_HAZARDOUS_MATERIAL = 119,
  TrafficSign_TypeAndConfidence_Type_NO_MOTORCYCLE = 120,
  TrafficSign_TypeAndConfidence_Type_NO_TRAILER = 121,
  TrafficSign_TypeAndConfidence_Type_NO_TRUCK_WITH_TRAILER = 122,
  TrafficSign_TypeAndConfidence_Type_PARK_AND_RIDE = 123,
  TrafficSign_TypeAndConfidence_Type_ROAD_DISTANCE = 124,
  TrafficSign_TypeAndConfidence_Type_EMERGENCY_PHONE = 125,
  TrafficSign_TypeAndConfidence_Type_SPEED_LIMIT_ENFORCEMENT = 126,
  TrafficSign_TypeAndConfidence_Type_TRAFFIC_LIGHT_ENFORCEMENT = 127,
  TrafficSign_TypeAndConfidence_Type_BOARD_DIRECTION = 128,
  TrafficSign_TypeAndConfidence_Type_STREET_NAME = 129,
  TrafficSign_TypeAndConfidence_Type_TRUCK_SPEED_LIMIT = 130,
  TrafficSign_TypeAndConfidence_Type_TRUCK_SPEED_LIMIT_END = 131,
  TrafficSign_TypeAndConfidence_Type_SPEED_LIMIT_NIGHT = 132,
  TrafficSign_TypeAndConfidence_Type_SPEED_LIMIT_NIGHT_END = 133,
  TrafficSign_TypeAndConfidence_Type_MINIMUM_SPEED = 134,
  TrafficSign_TypeAndConfidence_Type_MINIMUM_SPEED_END = 135,
  TrafficSign_TypeAndConfidence_Type_PEDESTRIAN_ZONE = 136,
  TrafficSign_TypeAndConfidence_Type_PEDESTRIAN_ZONE_END = 137,
  TrafficSign_TypeAndConfidence_Type_PEDESTRIAN_PATH = 138,
  TrafficSign_TypeAndConfidence_Type_PEDESTRIAN_PATH_END = 139,
  TrafficSign_TypeAndConfidence_Type_PEDESTRIAN_BICYCLE_PATH = 140,
  TrafficSign_TypeAndConfidence_Type_PEDESTRIAN_BICYCLE_PATH_END = 141,
  TrafficSign_TypeAndConfidence_Type_BICYCLE_PATH = 142,
  TrafficSign_TypeAndConfidence_Type_BICYCLE_PATH_END = 143,
  TrafficSign_TypeAndConfidence_Type_BICYCLE_STREET = 144,
  TrafficSign_TypeAndConfidence_Type_BICYCLE_STREET_END = 145,
  TrafficSign_TypeAndConfidence_Type_CURVE_LEFT_THEN_RIGHT = 146,
  TrafficSign_TypeAndConfidence_Type_CURVE_RIGHT_THEN_LEFT = 147,
  TrafficSign_TypeAndConfidence_Type_CURVE_TRIPLE_HAIRPIN = 148,
  TrafficSign_TypeAndConfidence_Type_STEEP_DROP = 149,
  TrafficSign_TypeAndConfidence_Type_STEEP_DROP_ON_LEFT = 150,
  TrafficSign_TypeAndConfidence_Type_STEEP_DROP_ON_RIGHT = 151,
  TrafficSign_TypeAndConfidence_Type_NO_ANIMAL_CATTLE = 152,
  TrafficSign_TypeAndConfidence_Type_ANIMAL_DEER = 153,
  TrafficSign_TypeAndConfidence_Type_ANIMAL_MOOSE = 154,
  TrafficSign_TypeAndConfidence_Type_NO_HORSE_RIDING = 155,
  TrafficSign_TypeAndConfidence_Type_FALLING_ROCKS = 156,
  TrafficSign_TypeAndConfidence_Type_FALLING_ROCKS_LEFT = 157,
  TrafficSign_TypeAndConfidence_Type_FALLING_ROCKS_RIGHT = 158,
  TrafficSign_TypeAndConfidence_Type_YIELD_TO_ONCOMING_TRAFFIC = 159,
  TrafficSign_TypeAndConfidence_Type_UNPROTECTED_LEFT_TURN = 160,
  TrafficSign_TypeAndConfidence_Type_ONEWAY_TRAFFIC = 161,
  TrafficSign_TypeAndConfidence_Type_ONEWAY_TRAFFIC_TO_LEFT = 162,
  TrafficSign_TypeAndConfidence_Type_ONEWAY_TRAFFIC_TO_RIGHT = 163,
  TrafficSign_TypeAndConfidence_Type_ONEWAY_TRAFFIC_TO_STRAIGHT = 164,
  TrafficSign_TypeAndConfidence_Type_NO_VEHICLE = 165,
  TrafficSign_TypeAndConfidence_Type_NO_MOTOR_VEHICLE = 166,
  TrafficSign_TypeAndConfidence_Type_NO_TRUCK = 167,
  TrafficSign_TypeAndConfidence_Type_NO_PEDESTRIAN = 168,
  TrafficSign_TypeAndConfidence_Type_LANE_USED_IN_BOTH_DIRECTIONS = 169,
  TrafficSign_TypeAndConfidence_Type_FOG_AREA = 170,
  TrafficSign_TypeAndConfidence_Type_TIRE_CHAINS_MANDATORY = 171,
  TrafficSign_TypeAndConfidence_Type_HIJACKING_HOTSPOT = 172,
  TrafficSign_TypeAndConfidence_Type_OVERPASS_AHEAD = 173,
  TrafficSign_TypeAndConfidence_Type_TUNNEL = 174,
  TrafficSign_TypeAndConfidence_Type_FERRY_TERMINAL = 175,
  TrafficSign_TypeAndConfidence_Type_NARROW_BRIDGE = 176,
  TrafficSign_TypeAndConfidence_Type_NO_IDLING = 177,
  TrafficSign_TypeAndConfidence_Type_HUMPBACK_BRIDGE = 178,
  TrafficSign_TypeAndConfidence_Type_EMBANKMENT = 179,
  TrafficSign_TypeAndConfidence_Type_EMBANKMENT_ON_THE_LEFT = 180,
  TrafficSign_TypeAndConfidence_Type_EMBANKMENT_ON_THE_RIGHT = 181,
  TrafficSign_TypeAndConfidence_Type_CROSSING_WITH_PRIORITY_OVER_MINOR_ROAD = 182,
  TrafficSign_TypeAndConfidence_Type_CROSSING_WITH_PRIORITY_TO_THE_RIGHT = 183,
  TrafficSign_TypeAndConfidence_Type_BRANCH_TO_THE_LEFT = 184,
  TrafficSign_TypeAndConfidence_Type_BRANCH_TO_THE_RIGHT = 185,
  TrafficSign_TypeAndConfidence_Type_TWO_WAY_TRAFFIC = 186,
  TrafficSign_TypeAndConfidence_Type_BUMP = 187,
  TrafficSign_TypeAndConfidence_Type_DIP = 188,
  TrafficSign_TypeAndConfidence_Type_ROAD_FLOODED = 189,
  TrafficSign_TypeAndConfidence_Type_AUDIBLE_WARNING = 190,
  TrafficSign_TypeAndConfidence_Type_VILLAGE_AHEAD = 191,
  TrafficSign_TypeAndConfidence_Type_MOVABLE_BRIDGE = 192,
  TrafficSign_TypeAndConfidence_Type_SLOW_DOWN = 193,
  TrafficSign_TypeAndConfidence_Type_INTERSECTION_T = 194,
  TrafficSign_TypeAndConfidence_Type_INTERSECTION_T_LEFT = 195,
  TrafficSign_TypeAndConfidence_Type_INTERSECTION_T_RIGHT = 196,
  TrafficSign_TypeAndConfidence_Type_INTERSECTION_T_LEFT_RIGHT = 197,
  TrafficSign_TypeAndConfidence_Type_INTERSECTION_Y = 198,
  TrafficSign_TypeAndConfidence_Type_USE_LOW_GEAR = 199,
  TrafficSign_TypeAndConfidence_Type_USE_LOW_GEAR_END = 200,
  TrafficSign_TypeAndConfidence_Type_NO_COMPRESSION_BRAKING = 201,
  TrafficSign_TypeAndConfidence_Type_NO_COMPRESSION_BRAKING_END = 202,
  TrafficSign_TypeAndConfidence_Type_WAITING_LINE = 203,
  TrafficSign_TypeAndConfidence_Type_DONT_STOP_ZONE = 204,
  TrafficSign_TypeAndConfidence_Type_HONKING_PROHIBITED = 205,
  TrafficSign_TypeAndConfidence_Type_FASTEN_SEAT_BELT = 206,
  TrafficSign_TypeAndConfidence_Type_HAMLET_ENTRY = 207,
  TrafficSign_TypeAndConfidence_Type_HAMLET_EXIT = 208,
  TrafficSign_TypeAndConfidence_Type_HIGHWAY_MARKER_1_STRIPE = 209,
  TrafficSign_TypeAndConfidence_Type_HIGHWAY_MARKER_2_STRIPES = 210,
  TrafficSign_TypeAndConfidence_Type_HIGHWAY_MARKER_3_STRIPES = 211,
  TrafficSign_TypeAndConfidence_Type_GUIDING_BEACON = 212,
  TrafficSign_TypeAndConfidence_Type_COUNTDOWN_MARKER_1_STRIPE = 213,
  TrafficSign_TypeAndConfidence_Type_COUNTDOWN_MARKER_2_STRIPES = 214,
  TrafficSign_TypeAndConfidence_Type_COUNTDOWN_MARKER_3_STRIPES = 215,
  TrafficSign_TypeAndConfidence_Type_DIVERSION_ROUTE = 216,
  TrafficSign_TypeAndConfidence_Type_DIVERSION_ROUTE_END = 217,
  TrafficSign_TypeAndConfidence_Type_NO_STOPPING_EXCEPT_TAXI = 218,
  TrafficSign_TypeAndConfidence_Type_NO_STOPPING = 219,
  TrafficSign_TypeAndConfidence_Type_NO_STOPPING_LEFT = 220,
  TrafficSign_TypeAndConfidence_Type_NO_STOPPING_RIGHT = 221,
  TrafficSign_TypeAndConfidence_Type_NO_STOPPING_LEFT_AND_RIGHT = 222,
  TrafficSign_TypeAndConfidence_Type_NO_PARKING = 223,
  TrafficSign_TypeAndConfidence_Type_NO_PARKING_LEFT = 224,
  TrafficSign_TypeAndConfidence_Type_NO_PARKING_RIGHT = 225,
  TrafficSign_TypeAndConfidence_Type_NO_PARKING_LEFT_AND_RIGHT = 226,
  TrafficSign_TypeAndConfidence_Type_RUNNAWAY_TRUCK_RAMP = 227,
  TrafficSign_TypeAndConfidence_Type_TURN_ON_GREEN = 228,
  TrafficSign_TypeAndConfidence_Type_NO_TURN_ON_RED = 229,
  TrafficSign_TypeAndConfidence_Type_MOTORWAY_ROAD_NUMBER = 230,
  TrafficSign_TypeAndConfidence_Type_HIGHWAY_ROAD_NUMBER = 231,
  TrafficSign_TypeAndConfidence_Type_HIGHWAY_INTERCHANGE_NUMBER = 232,
  TrafficSign_TypeAndConfidence_Type_EUROPEAN_ROAD_NUMBER = 233,
  TrafficSign_TypeAndConfidence_Type_SPEED_LIMIT_ZONE = 234,
  TrafficSign_TypeAndConfidence_Type_SPEED_LIMIT_ZONE_END = 235,
  TrafficSign_TypeAndConfidence_Type_NO_PARKING_ZONE = 236,
  TrafficSign_TypeAndConfidence_Type_NO_PARKING_ZONE_END = 237,
  TrafficSign_TypeAndConfidence_Type_PARKING_ZONE = 238,
  TrafficSign_TypeAndConfidence_Type_PARKING_ZONE_END = 239,
  TrafficSign_TypeAndConfidence_Type_PARKING = 240,
  TrafficSign_TypeAndConfidence_Type_PARKING_TO_LEFT = 241,
  TrafficSign_TypeAndConfidence_Type_PARKING_TO_RIGHT = 242,
  TrafficSign_TypeAndConfidence_Type_PARKING_GARAGE = 243,
  TrafficSign_TypeAndConfidence_Type_PARKING_ON_SIDEWAY = 244,
  TrafficSign_TypeAndConfidence_Type_SAFETY_DISTANCE = 245,
  TrafficSign_TypeAndConfidence_Type_SAFETY_DISTANCE_VEHICLE = 246,
  TrafficSign_TypeAndConfidence_Type_SAFETY_DISTANCE_TRUCK = 247,
  TrafficSign_TypeAndConfidence_Type_DETOUR = 248,
  TrafficSign_TypeAndConfidence_Type_DETOUR_END = 249,
  TrafficSign_TypeAndConfidence_Type_DETOUR_LEFT = 250,
  TrafficSign_TypeAndConfidence_Type_DETOUR_RIGHT = 251,
  TrafficSign_TypeAndConfidence_Type_STATION_GAS = 252,
  TrafficSign_TypeAndConfidence_Type_STATION_LPG = 253,
  TrafficSign_TypeAndConfidence_Type_STATION_CNG = 254,
  TrafficSign_TypeAndConfidence_Type_STATION_H2 = 255,
  TrafficSign_TypeAndConfidence_Type_STATION_ELECTRO = 256,
  TrafficSign_TypeAndConfidence_Type_STATION_POLICE = 257,
  TrafficSign_TypeAndConfidence_Type_CAMPING_SPOT = 258,
  TrafficSign_TypeAndConfidence_Type_RESTROOMS = 259,
  TrafficSign_TypeAndConfidence_Type_INFO_POINT = 260,
  TrafficSign_TypeAndConfidence_Type_MOTORWAY_EXIT_AHEAD = 261,
  TrafficSign_TypeAndConfidence_Type_HIGHWAY_EXIT_AHEAD = 262,
  TrafficSign_TypeAndConfidence_Type_MOTORWAY_EXIT = 263,
  TrafficSign_TypeAndConfidence_Type_HIGHWAY_EXIT = 264,
  TrafficSign_TypeAndConfidence_Type_FIRST_AID = 265,
  TrafficSign_TypeAndConfidence_Type_LOW_FLYING = 266,
  TrafficSign_TypeAndConfidence_Type_LANE_SHIFT = 267,
  TrafficSign_TypeAndConfidence_Type_LANE_SHIFT_TO_LEFT = 268,
  TrafficSign_TypeAndConfidence_Type_LANE_SHIFT_TO_RIGHT = 269,
  TrafficSign_TypeAndConfidence_Type_PEDESTRIAN_UNDERPASS = 270,
  TrafficSign_TypeAndConfidence_Type_PEDESTRIAN_OVERPASS = 271,
  TrafficSign_TypeAndConfidence_Type_BREAKDOWN_BAY = 272,
  TrafficSign_TypeAndConfidence_Type_BUS_LANE = 273,
  TrafficSign_TypeAndConfidence_Type_DOUBLE_HAIRPIN = 274,
  TrafficSign_TypeAndConfidence_Type_COUNTRY_SPECIFIC_INFORMATION = 275,
  TrafficSign_TypeAndConfidence_Type_PEDESTRIAN_BICYCLE_SHARED_PATH = 276,
  TrafficSign_TypeAndConfidence_Type_OVERHEAD_LANE_CONTROL_CLOSED = 277,
  TrafficSign_TypeAndConfidence_Type_OVERHEAD_LANE_CONTROL_OPEN = 278,
  TrafficSign_TypeAndConfidence_Type_OVERHEAD_LANE_CONTROL_CLOSING_LEFT = 279,
  TrafficSign_TypeAndConfidence_Type_OVERHEAD_LANE_CONTROL_CLOSING_RIGHT = 280,
  TrafficSign_TypeAndConfidence_Type_OVERHEAD_LANE_CONTROL_FLASH_ARROW_LEFT = 281,
  TrafficSign_TypeAndConfidence_Type_OVERHEAD_LANE_CONTROL_FLASH_ARROW_RIGHT = 282,
  TrafficSign_TypeAndConfidence_Type_TRINATURE = 283,
  TrafficSign_TypeAndConfidence_Type_ANIMAL_FROG = 284,
  TrafficSign_TypeAndConfidence_Type_GRAVEL = 285,
  TrafficSign_TypeAndConfidence_Type_WARNING_PEDESTRIAN_CROSSING = 286,
  TrafficSign_TypeAndConfidence_Type_LOW_TREE = 287,
  TrafficSign_TypeAndConfidence_Type_WARNING_RIDER = 288,
  TrafficSign_TypeAndConfidence_Type_STOP_AHEAD = 289,
  TrafficSign_TypeAndConfidence_Type_YIELD_AHEAD = 290,
  TrafficSign_TypeAndConfidence_Type_WATER_PROTECTION_AREA = 291,
  TrafficSign_TypeAndConfidence_Type_TOLL_DOUANE = 292,
  TrafficSign_TypeAndConfidence_Type_NO_CAR_OR_BIKE = 293,
  TrafficSign_TypeAndConfidence_Type_DRIVING_DIRECTION_ONLY_UP = 294,
  TrafficSign_TypeAndConfidence_Type_DRIVING_DIRECTION_UP_AND_DOWN = 295,
  TrafficSign_TypeAndConfidence_Type_MILITARY_SIGN = 296,
  TrafficSign_TypeAndConfidence_Type_SMOG = 297,
  TrafficSign_TypeAndConfidence_Type_ROUNDABOUT_AHEAD = 298,
  TrafficSign_TypeAndConfidence_Type_MANDATORY_LEFT_OR_STRAIGHT_OR_RIGHT = 299,
  TrafficSign_TypeAndConfidence_Type_DEAD_END_RIGHT = 300,
  TrafficSign_TypeAndConfidence_Type_DEAD_END_LEFT = 301,
  TrafficSign_TypeAndConfidence_Type_TOLL_TRUCK = 302,
  TrafficSign_TypeAndConfidence_Type_TOLL_TRUCK_END = 303,
  TrafficSign_TypeAndConfidence_Type_STAGGERED_JUNCTION = 304,
  TrafficSign_TypeAndConfidence_Type_AXLE_WEIGHT_RESTRICTION = 305,
  TrafficSign_TypeAndConfidence_Type_TOLL_END = 306,
  TrafficSign_TypeAndConfidence_Type_TOLL_CAR_END = 307,
  TrafficSign_TypeAndConfidence_Type_TOLL_LANE_END = 308,
  TrafficSign_TypeAndConfidence_Type_TrafficSign_TypeAndConfidence_Type_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  TrafficSign_TypeAndConfidence_Type_TrafficSign_TypeAndConfidence_Type_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool TrafficSign_TypeAndConfidence_Type_IsValid(int value);
extern const uint32_t TrafficSign_TypeAndConfidence_Type_internal_data_[];
constexpr TrafficSign_TypeAndConfidence_Type TrafficSign_TypeAndConfidence_Type_Type_MIN = static_cast<TrafficSign_TypeAndConfidence_Type>(0);
constexpr TrafficSign_TypeAndConfidence_Type TrafficSign_TypeAndConfidence_Type_Type_MAX = static_cast<TrafficSign_TypeAndConfidence_Type>(308);
constexpr int TrafficSign_TypeAndConfidence_Type_Type_ARRAYSIZE = 308 + 1;
const ::google::protobuf::EnumDescriptor*
TrafficSign_TypeAndConfidence_Type_descriptor();
template <typename T>
const std::string& TrafficSign_TypeAndConfidence_Type_Name(T value) {
  static_assert(std::is_same<T, TrafficSign_TypeAndConfidence_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return TrafficSign_TypeAndConfidence_Type_Name(static_cast<TrafficSign_TypeAndConfidence_Type>(value));
}
template <>
inline const std::string& TrafficSign_TypeAndConfidence_Type_Name(TrafficSign_TypeAndConfidence_Type value) {
  return ::google::protobuf::internal::NameOfDenseEnum<TrafficSign_TypeAndConfidence_Type_descriptor,
                                                 0, 308>(
      static_cast<int>(value));
}
inline bool TrafficSign_TypeAndConfidence_Type_Parse(absl::string_view name, TrafficSign_TypeAndConfidence_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrafficSign_TypeAndConfidence_Type>(
      TrafficSign_TypeAndConfidence_Type_descriptor(), name, value);
}
enum TrafficSign_PermanencyAndConfidence_Type : int {
  TrafficSign_PermanencyAndConfidence_Type_UNKNOWN_TYPE = 0,
  TrafficSign_PermanencyAndConfidence_Type_STATIC = 1,
  TrafficSign_PermanencyAndConfidence_Type_VARIABLE = 2,
  TrafficSign_PermanencyAndConfidence_Type_VARIABLE_ELECTRONICALLY = 3,
  TrafficSign_PermanencyAndConfidence_Type_VARIABLE_MECHANICALLY = 4,
  TrafficSign_PermanencyAndConfidence_Type_VARIABLE_DEACTIVATED = 5,
  TrafficSign_PermanencyAndConfidence_Type_TrafficSign_PermanencyAndConfidence_Type_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  TrafficSign_PermanencyAndConfidence_Type_TrafficSign_PermanencyAndConfidence_Type_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool TrafficSign_PermanencyAndConfidence_Type_IsValid(int value);
extern const uint32_t TrafficSign_PermanencyAndConfidence_Type_internal_data_[];
constexpr TrafficSign_PermanencyAndConfidence_Type TrafficSign_PermanencyAndConfidence_Type_Type_MIN = static_cast<TrafficSign_PermanencyAndConfidence_Type>(0);
constexpr TrafficSign_PermanencyAndConfidence_Type TrafficSign_PermanencyAndConfidence_Type_Type_MAX = static_cast<TrafficSign_PermanencyAndConfidence_Type>(5);
constexpr int TrafficSign_PermanencyAndConfidence_Type_Type_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor*
TrafficSign_PermanencyAndConfidence_Type_descriptor();
template <typename T>
const std::string& TrafficSign_PermanencyAndConfidence_Type_Name(T value) {
  static_assert(std::is_same<T, TrafficSign_PermanencyAndConfidence_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return TrafficSign_PermanencyAndConfidence_Type_Name(static_cast<TrafficSign_PermanencyAndConfidence_Type>(value));
}
template <>
inline const std::string& TrafficSign_PermanencyAndConfidence_Type_Name(TrafficSign_PermanencyAndConfidence_Type value) {
  return ::google::protobuf::internal::NameOfDenseEnum<TrafficSign_PermanencyAndConfidence_Type_descriptor,
                                                 0, 5>(
      static_cast<int>(value));
}
inline bool TrafficSign_PermanencyAndConfidence_Type_Parse(absl::string_view name, TrafficSign_PermanencyAndConfidence_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrafficSign_PermanencyAndConfidence_Type>(
      TrafficSign_PermanencyAndConfidence_Type_descriptor(), name, value);
}
enum TrafficSign_ValidationAndConfidence_Type : int {
  TrafficSign_ValidationAndConfidence_Type_UNKNOWN_TYPE = 0,
  TrafficSign_ValidationAndConfidence_Type_VALID = 1,
  TrafficSign_ValidationAndConfidence_Type_INVALID = 2,
  TrafficSign_ValidationAndConfidence_Type_TrafficSign_ValidationAndConfidence_Type_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  TrafficSign_ValidationAndConfidence_Type_TrafficSign_ValidationAndConfidence_Type_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool TrafficSign_ValidationAndConfidence_Type_IsValid(int value);
extern const uint32_t TrafficSign_ValidationAndConfidence_Type_internal_data_[];
constexpr TrafficSign_ValidationAndConfidence_Type TrafficSign_ValidationAndConfidence_Type_Type_MIN = static_cast<TrafficSign_ValidationAndConfidence_Type>(0);
constexpr TrafficSign_ValidationAndConfidence_Type TrafficSign_ValidationAndConfidence_Type_Type_MAX = static_cast<TrafficSign_ValidationAndConfidence_Type>(2);
constexpr int TrafficSign_ValidationAndConfidence_Type_Type_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
TrafficSign_ValidationAndConfidence_Type_descriptor();
template <typename T>
const std::string& TrafficSign_ValidationAndConfidence_Type_Name(T value) {
  static_assert(std::is_same<T, TrafficSign_ValidationAndConfidence_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return TrafficSign_ValidationAndConfidence_Type_Name(static_cast<TrafficSign_ValidationAndConfidence_Type>(value));
}
template <>
inline const std::string& TrafficSign_ValidationAndConfidence_Type_Name(TrafficSign_ValidationAndConfidence_Type value) {
  return ::google::protobuf::internal::NameOfDenseEnum<TrafficSign_ValidationAndConfidence_Type_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool TrafficSign_ValidationAndConfidence_Type_Parse(absl::string_view name, TrafficSign_ValidationAndConfidence_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrafficSign_ValidationAndConfidence_Type>(
      TrafficSign_ValidationAndConfidence_Type_descriptor(), name, value);
}
enum TrafficSign_DominantBackgroundColorAndConfidence_Type : int {
  TrafficSign_DominantBackgroundColorAndConfidence_Type_UNKNOWN_TYPE = 0,
  TrafficSign_DominantBackgroundColorAndConfidence_Type_OTHER = 1,
  TrafficSign_DominantBackgroundColorAndConfidence_Type_WHITE = 2,
  TrafficSign_DominantBackgroundColorAndConfidence_Type_RED = 3,
  TrafficSign_DominantBackgroundColorAndConfidence_Type_GREEN = 4,
  TrafficSign_DominantBackgroundColorAndConfidence_Type_BLUE = 5,
  TrafficSign_DominantBackgroundColorAndConfidence_Type_YELLOW = 6,
  TrafficSign_DominantBackgroundColorAndConfidence_Type_BLACK = 7,
  TrafficSign_DominantBackgroundColorAndConfidence_Type_BROWN = 8,
  TrafficSign_DominantBackgroundColorAndConfidence_Type_TrafficSign_DominantBackgroundColorAndConfidence_Type_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  TrafficSign_DominantBackgroundColorAndConfidence_Type_TrafficSign_DominantBackgroundColorAndConfidence_Type_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool TrafficSign_DominantBackgroundColorAndConfidence_Type_IsValid(int value);
extern const uint32_t TrafficSign_DominantBackgroundColorAndConfidence_Type_internal_data_[];
constexpr TrafficSign_DominantBackgroundColorAndConfidence_Type TrafficSign_DominantBackgroundColorAndConfidence_Type_Type_MIN = static_cast<TrafficSign_DominantBackgroundColorAndConfidence_Type>(0);
constexpr TrafficSign_DominantBackgroundColorAndConfidence_Type TrafficSign_DominantBackgroundColorAndConfidence_Type_Type_MAX = static_cast<TrafficSign_DominantBackgroundColorAndConfidence_Type>(8);
constexpr int TrafficSign_DominantBackgroundColorAndConfidence_Type_Type_ARRAYSIZE = 8 + 1;
const ::google::protobuf::EnumDescriptor*
TrafficSign_DominantBackgroundColorAndConfidence_Type_descriptor();
template <typename T>
const std::string& TrafficSign_DominantBackgroundColorAndConfidence_Type_Name(T value) {
  static_assert(std::is_same<T, TrafficSign_DominantBackgroundColorAndConfidence_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return TrafficSign_DominantBackgroundColorAndConfidence_Type_Name(static_cast<TrafficSign_DominantBackgroundColorAndConfidence_Type>(value));
}
template <>
inline const std::string& TrafficSign_DominantBackgroundColorAndConfidence_Type_Name(TrafficSign_DominantBackgroundColorAndConfidence_Type value) {
  return ::google::protobuf::internal::NameOfDenseEnum<TrafficSign_DominantBackgroundColorAndConfidence_Type_descriptor,
                                                 0, 8>(
      static_cast<int>(value));
}
inline bool TrafficSign_DominantBackgroundColorAndConfidence_Type_Parse(absl::string_view name, TrafficSign_DominantBackgroundColorAndConfidence_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrafficSign_DominantBackgroundColorAndConfidence_Type>(
      TrafficSign_DominantBackgroundColorAndConfidence_Type_descriptor(), name, value);
}
enum TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type : int {
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_UNKNOWN_TYPE = 0,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_OTHER_AS_TEXT = 1,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_WET = 2,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_RAIN = 3,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_SNOW = 4,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_SNOW_OR_RAIN = 5,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_FOG = 6,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_TIME = 7,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_DAY_AND_TIME = 8,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_NIGHT = 9,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_SEASON = 10,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_WORKDAYS = 11,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_WORKDAYS_AND_TIME = 12,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_SCHOOL = 13,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_RAMP = 14,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_TRUCK = 15,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_TRUCK_WITH_TRAILER = 16,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_PASSENGER_CAR = 17,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_PASSENGER_CAR_WITH_TAILER = 18,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_TRACTOR_EXCEPT = 19,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_BUS = 20,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_TRUCKS_AND_BUS = 21,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_CARS_TRUCKS_BUS = 22,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_TAXI = 23,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_TANK = 24,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_ROADSIDE = 25,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_WEIGHT = 26,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_STARTING_IN = 27,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_VALID_FOR = 28,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_IN_RIGHT_DIRECTION = 29,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_IN_LEFT_DIRECTION = 30,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_ZONE = 31,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_ZONE_START = 32,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_ZONE_END = 33,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_BEGIN_OF_VALIDITY = 34,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_END_OF_VALIDITY = 35,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_FROG = 36,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_ALL_WAY = 37,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_BIKE = 38,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_BIKE_EXCEPT = 39,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_BUS_EXCEPT = 40,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_CAMPER = 41,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_CARAVAN = 42,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_CONSTRUCTION_GATEWAY = 43,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_CROSS_WAY = 44,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_DELIVERY_EXCEPT = 45,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_ELECTRONIC_CAR = 46,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_GATEWAY = 47,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_GIVE_WAY_LEFT = 48,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_GIVE_WAY_RIGHT = 49,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_GRAVEL = 50,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_HAZMAT = 51,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_HAZ_WATER = 52,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_KIDS = 53,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_LOCAL_EXCEP = 54,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_LOW_TREE = 55,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_MOTORCYCLE = 56,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_MOTORCYCLE_EXCEPT = 57,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_NEW_ROAD_BED = 58,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_NO_STOP_SHOULDER = 59,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_OIL_TRAIL = 60,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_PASSENGER_CAR_EXCEPT = 61,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_PASSENGER_CAR_WITH_TAILER_EXCEPT = 62,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_PEDESTRIAN = 63,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_PRIORITY_TURN_LEFT = 64,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_PRIORITY_TURN_RIGHT = 65,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_ROAD_DAMAGE = 66,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_RUTS = 67,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_TRACTOR = 68,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_TRACTOR_MAY_BE_OVERTAKEN = 69,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_TRAFFIC_JAM = 70,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_TRAIN = 71,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_TRAM = 72,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_TRUCK_EXCEPT = 73,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_TRUCK_WITH_TRAILER_EXCEPT = 74,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_GET_IN_PROPER_LANE = 75,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_ROADSIDE_TRUCK = 76,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_RAPPEL = 77,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_RADAR_ENFORCED = 78,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_STOP_IN_DISTANCE = 79,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_IsValid(int value);
extern const uint32_t TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_internal_data_[];
constexpr TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_Type_MIN = static_cast<TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type>(0);
constexpr TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_Type_MAX = static_cast<TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type>(79);
constexpr int TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_Type_ARRAYSIZE = 79 + 1;
const ::google::protobuf::EnumDescriptor*
TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_descriptor();
template <typename T>
const std::string& TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_Name(T value) {
  static_assert(std::is_same<T, TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_Name(static_cast<TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type>(value));
}
template <>
inline const std::string& TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_Name(TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type value) {
  return ::google::protobuf::internal::NameOfDenseEnum<TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_descriptor,
                                                 0, 79>(
      static_cast<int>(value));
}
inline bool TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_Parse(absl::string_view name, TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type>(
      TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class TrafficSign_ValueAndConfidence final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.trafficregulation.TrafficSign.ValueAndConfidence) */ {
 public:
  inline TrafficSign_ValueAndConfidence() : TrafficSign_ValueAndConfidence(nullptr) {}
  ~TrafficSign_ValueAndConfidence() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TrafficSign_ValueAndConfidence(::google::protobuf::internal::ConstantInitialized);

  inline TrafficSign_ValueAndConfidence(const TrafficSign_ValueAndConfidence& from)
      : TrafficSign_ValueAndConfidence(nullptr, from) {}
  TrafficSign_ValueAndConfidence(TrafficSign_ValueAndConfidence&& from) noexcept
    : TrafficSign_ValueAndConfidence() {
    *this = ::std::move(from);
  }

  inline TrafficSign_ValueAndConfidence& operator=(const TrafficSign_ValueAndConfidence& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrafficSign_ValueAndConfidence& operator=(TrafficSign_ValueAndConfidence&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrafficSign_ValueAndConfidence& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrafficSign_ValueAndConfidence* internal_default_instance() {
    return reinterpret_cast<const TrafficSign_ValueAndConfidence*>(
               &_TrafficSign_ValueAndConfidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(TrafficSign_ValueAndConfidence& a, TrafficSign_ValueAndConfidence& b) {
    a.Swap(&b);
  }
  inline void Swap(TrafficSign_ValueAndConfidence* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrafficSign_ValueAndConfidence* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrafficSign_ValueAndConfidence* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrafficSign_ValueAndConfidence>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TrafficSign_ValueAndConfidence& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TrafficSign_ValueAndConfidence& from) {
    TrafficSign_ValueAndConfidence::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TrafficSign_ValueAndConfidence* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.categories.trafficregulation.TrafficSign.ValueAndConfidence";
  }
  protected:
  explicit TrafficSign_ValueAndConfidence(::google::protobuf::Arena* arena);
  TrafficSign_ValueAndConfidence(::google::protobuf::Arena* arena, const TrafficSign_ValueAndConfidence& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
    kConfidenceFieldNumber = 2,
  };
  // .google.protobuf.StringValue value = 1;
  bool has_value() const;
  void clear_value() ;
  const ::google::protobuf::StringValue& value() const;
  PROTOBUF_NODISCARD ::google::protobuf::StringValue* release_value();
  ::google::protobuf::StringValue* mutable_value();
  void set_allocated_value(::google::protobuf::StringValue* value);
  void unsafe_arena_set_allocated_value(::google::protobuf::StringValue* value);
  ::google::protobuf::StringValue* unsafe_arena_release_value();

  private:
  const ::google::protobuf::StringValue& _internal_value() const;
  ::google::protobuf::StringValue* _internal_mutable_value();

  public:
  // .sensoris.protobuf.types.base.Confidence confidence = 2;
  bool has_confidence() const;
  void clear_confidence() ;
  const ::sensoris::protobuf::types::base::Confidence& confidence() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::Confidence* release_confidence();
  ::sensoris::protobuf::types::base::Confidence* mutable_confidence();
  void set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value);
  void unsafe_arena_set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value);
  ::sensoris::protobuf::types::base::Confidence* unsafe_arena_release_confidence();

  private:
  const ::sensoris::protobuf::types::base::Confidence& _internal_confidence() const;
  ::sensoris::protobuf::types::base::Confidence* _internal_mutable_confidence();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.trafficregulation.TrafficSign.ValueAndConfidence)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::StringValue* value_;
    ::sensoris::protobuf::types::base::Confidence* confidence_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2ftraffic_5fregulation_2eproto;
};// -------------------------------------------------------------------

class TrafficSign_ValidationAndConfidence final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.trafficregulation.TrafficSign.ValidationAndConfidence) */ {
 public:
  inline TrafficSign_ValidationAndConfidence() : TrafficSign_ValidationAndConfidence(nullptr) {}
  ~TrafficSign_ValidationAndConfidence() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TrafficSign_ValidationAndConfidence(::google::protobuf::internal::ConstantInitialized);

  inline TrafficSign_ValidationAndConfidence(const TrafficSign_ValidationAndConfidence& from)
      : TrafficSign_ValidationAndConfidence(nullptr, from) {}
  TrafficSign_ValidationAndConfidence(TrafficSign_ValidationAndConfidence&& from) noexcept
    : TrafficSign_ValidationAndConfidence() {
    *this = ::std::move(from);
  }

  inline TrafficSign_ValidationAndConfidence& operator=(const TrafficSign_ValidationAndConfidence& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrafficSign_ValidationAndConfidence& operator=(TrafficSign_ValidationAndConfidence&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrafficSign_ValidationAndConfidence& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrafficSign_ValidationAndConfidence* internal_default_instance() {
    return reinterpret_cast<const TrafficSign_ValidationAndConfidence*>(
               &_TrafficSign_ValidationAndConfidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(TrafficSign_ValidationAndConfidence& a, TrafficSign_ValidationAndConfidence& b) {
    a.Swap(&b);
  }
  inline void Swap(TrafficSign_ValidationAndConfidence* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrafficSign_ValidationAndConfidence* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrafficSign_ValidationAndConfidence* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrafficSign_ValidationAndConfidence>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TrafficSign_ValidationAndConfidence& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TrafficSign_ValidationAndConfidence& from) {
    TrafficSign_ValidationAndConfidence::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TrafficSign_ValidationAndConfidence* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.categories.trafficregulation.TrafficSign.ValidationAndConfidence";
  }
  protected:
  explicit TrafficSign_ValidationAndConfidence(::google::protobuf::Arena* arena);
  TrafficSign_ValidationAndConfidence(::google::protobuf::Arena* arena, const TrafficSign_ValidationAndConfidence& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Type = TrafficSign_ValidationAndConfidence_Type;
  static constexpr Type UNKNOWN_TYPE = TrafficSign_ValidationAndConfidence_Type_UNKNOWN_TYPE;
  static constexpr Type VALID = TrafficSign_ValidationAndConfidence_Type_VALID;
  static constexpr Type INVALID = TrafficSign_ValidationAndConfidence_Type_INVALID;
  static inline bool Type_IsValid(int value) {
    return TrafficSign_ValidationAndConfidence_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = TrafficSign_ValidationAndConfidence_Type_Type_MIN;
  static constexpr Type Type_MAX = TrafficSign_ValidationAndConfidence_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = TrafficSign_ValidationAndConfidence_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Type_descriptor() {
    return TrafficSign_ValidationAndConfidence_Type_descriptor();
  }
  template <typename T>
  static inline const std::string& Type_Name(T value) {
    return TrafficSign_ValidationAndConfidence_Type_Name(value);
  }
  static inline bool Type_Parse(absl::string_view name, Type* value) {
    return TrafficSign_ValidationAndConfidence_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kConfidenceFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // .sensoris.protobuf.types.base.Confidence confidence = 2;
  bool has_confidence() const;
  void clear_confidence() ;
  const ::sensoris::protobuf::types::base::Confidence& confidence() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::Confidence* release_confidence();
  ::sensoris::protobuf::types::base::Confidence* mutable_confidence();
  void set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value);
  void unsafe_arena_set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value);
  ::sensoris::protobuf::types::base::Confidence* unsafe_arena_release_confidence();

  private:
  const ::sensoris::protobuf::types::base::Confidence& _internal_confidence() const;
  ::sensoris::protobuf::types::base::Confidence* _internal_mutable_confidence();

  public:
  // .sensoris.protobuf.categories.trafficregulation.TrafficSign.ValidationAndConfidence.Type type = 1;
  void clear_type() ;
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValidationAndConfidence_Type type() const;
  void set_type(::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValidationAndConfidence_Type value);

  private:
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValidationAndConfidence_Type _internal_type() const;
  void _internal_set_type(::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValidationAndConfidence_Type value);

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.trafficregulation.TrafficSign.ValidationAndConfidence)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::Confidence* confidence_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2ftraffic_5fregulation_2eproto;
};// -------------------------------------------------------------------

class TrafficSign_TypeAndConfidence final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.trafficregulation.TrafficSign.TypeAndConfidence) */ {
 public:
  inline TrafficSign_TypeAndConfidence() : TrafficSign_TypeAndConfidence(nullptr) {}
  ~TrafficSign_TypeAndConfidence() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TrafficSign_TypeAndConfidence(::google::protobuf::internal::ConstantInitialized);

  inline TrafficSign_TypeAndConfidence(const TrafficSign_TypeAndConfidence& from)
      : TrafficSign_TypeAndConfidence(nullptr, from) {}
  TrafficSign_TypeAndConfidence(TrafficSign_TypeAndConfidence&& from) noexcept
    : TrafficSign_TypeAndConfidence() {
    *this = ::std::move(from);
  }

  inline TrafficSign_TypeAndConfidence& operator=(const TrafficSign_TypeAndConfidence& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrafficSign_TypeAndConfidence& operator=(TrafficSign_TypeAndConfidence&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrafficSign_TypeAndConfidence& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrafficSign_TypeAndConfidence* internal_default_instance() {
    return reinterpret_cast<const TrafficSign_TypeAndConfidence*>(
               &_TrafficSign_TypeAndConfidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(TrafficSign_TypeAndConfidence& a, TrafficSign_TypeAndConfidence& b) {
    a.Swap(&b);
  }
  inline void Swap(TrafficSign_TypeAndConfidence* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrafficSign_TypeAndConfidence* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrafficSign_TypeAndConfidence* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrafficSign_TypeAndConfidence>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TrafficSign_TypeAndConfidence& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TrafficSign_TypeAndConfidence& from) {
    TrafficSign_TypeAndConfidence::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TrafficSign_TypeAndConfidence* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.categories.trafficregulation.TrafficSign.TypeAndConfidence";
  }
  protected:
  explicit TrafficSign_TypeAndConfidence(::google::protobuf::Arena* arena);
  TrafficSign_TypeAndConfidence(::google::protobuf::Arena* arena, const TrafficSign_TypeAndConfidence& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Type = TrafficSign_TypeAndConfidence_Type;
  static constexpr Type UNKNOWN_TYPE = TrafficSign_TypeAndConfidence_Type_UNKNOWN_TYPE;
  static constexpr Type OTHER_AS_TEXT = TrafficSign_TypeAndConfidence_Type_OTHER_AS_TEXT;
  static constexpr Type SPEED_LIMIT = TrafficSign_TypeAndConfidence_Type_SPEED_LIMIT;
  static constexpr Type SPEED_LIMIT_END = TrafficSign_TypeAndConfidence_Type_SPEED_LIMIT_END;
  static constexpr Type SPEED_LIMIT_CHANGE_UPCOMING = TrafficSign_TypeAndConfidence_Type_SPEED_LIMIT_CHANGE_UPCOMING;
  static constexpr Type ADVISORY_SPEED_LIMIT = TrafficSign_TypeAndConfidence_Type_ADVISORY_SPEED_LIMIT;
  static constexpr Type ADVISORY_SPEED_LIMIT_END = TrafficSign_TypeAndConfidence_Type_ADVISORY_SPEED_LIMIT_END;
  static constexpr Type NO_OVERTAKING = TrafficSign_TypeAndConfidence_Type_NO_OVERTAKING;
  static constexpr Type NO_OVERTAKING_END = TrafficSign_TypeAndConfidence_Type_NO_OVERTAKING_END;
  static constexpr Type PROTECTED_PASSING_START = TrafficSign_TypeAndConfidence_Type_PROTECTED_PASSING_START;
  static constexpr Type PROTECTED_PASSING_END = TrafficSign_TypeAndConfidence_Type_PROTECTED_PASSING_END;
  static constexpr Type PROTECTED_PASSING_LEFT_START = TrafficSign_TypeAndConfidence_Type_PROTECTED_PASSING_LEFT_START;
  static constexpr Type PROTECTED_PASSING_RIGHT_START = TrafficSign_TypeAndConfidence_Type_PROTECTED_PASSING_RIGHT_START;
  static constexpr Type PROTECTED_PASSING_LEFT_END = TrafficSign_TypeAndConfidence_Type_PROTECTED_PASSING_LEFT_END;
  static constexpr Type PROTECTED_PASSING_RIGHT_END = TrafficSign_TypeAndConfidence_Type_PROTECTED_PASSING_RIGHT_END;
  static constexpr Type NO_OVERTAKING_TRUCK = TrafficSign_TypeAndConfidence_Type_NO_OVERTAKING_TRUCK;
  static constexpr Type NO_OVERTAKING_TRUCK_END = TrafficSign_TypeAndConfidence_Type_NO_OVERTAKING_TRUCK_END;
  static constexpr Type ALL_RESTRICTIONS_END = TrafficSign_TypeAndConfidence_Type_ALL_RESTRICTIONS_END;
  static constexpr Type CITY_START = TrafficSign_TypeAndConfidence_Type_CITY_START;
  static constexpr Type CITY_END = TrafficSign_TypeAndConfidence_Type_CITY_END;
  static constexpr Type HIGHWAY = TrafficSign_TypeAndConfidence_Type_HIGHWAY;
  static constexpr Type HIGHWAY_END = TrafficSign_TypeAndConfidence_Type_HIGHWAY_END;
  static constexpr Type MOTORWAY = TrafficSign_TypeAndConfidence_Type_MOTORWAY;
  static constexpr Type MOTORWAY_END = TrafficSign_TypeAndConfidence_Type_MOTORWAY_END;
  static constexpr Type CONSTRUCTION = TrafficSign_TypeAndConfidence_Type_CONSTRUCTION;
  static constexpr Type CONSTRUCTION_END = TrafficSign_TypeAndConfidence_Type_CONSTRUCTION_END;
  static constexpr Type LANE_MERGE = TrafficSign_TypeAndConfidence_Type_LANE_MERGE;
  static constexpr Type LANE_MERGE_ON_RIGHT = TrafficSign_TypeAndConfidence_Type_LANE_MERGE_ON_RIGHT;
  static constexpr Type LANE_MERGE_ON_LEFT = TrafficSign_TypeAndConfidence_Type_LANE_MERGE_ON_LEFT;
  static constexpr Type LANE_MERGE_CENTER = TrafficSign_TypeAndConfidence_Type_LANE_MERGE_CENTER;
  static constexpr Type RAILWAY_CROSSING_GENERAL = TrafficSign_TypeAndConfidence_Type_RAILWAY_CROSSING_GENERAL;
  static constexpr Type RAILWAY_CROSSING_PROTECTED = TrafficSign_TypeAndConfidence_Type_RAILWAY_CROSSING_PROTECTED;
  static constexpr Type RAILWAY_CROSSING_UNPROTECTED = TrafficSign_TypeAndConfidence_Type_RAILWAY_CROSSING_UNPROTECTED;
  static constexpr Type ROAD_NARROWS = TrafficSign_TypeAndConfidence_Type_ROAD_NARROWS;
  static constexpr Type ROAD_NARROWS_LEFT = TrafficSign_TypeAndConfidence_Type_ROAD_NARROWS_LEFT;
  static constexpr Type ROAD_NARROWS_RIGHT = TrafficSign_TypeAndConfidence_Type_ROAD_NARROWS_RIGHT;
  static constexpr Type ROAD_NARROWS_CENTER = TrafficSign_TypeAndConfidence_Type_ROAD_NARROWS_CENTER;
  static constexpr Type SHARP_CURVE = TrafficSign_TypeAndConfidence_Type_SHARP_CURVE;
  static constexpr Type SHARP_CURVE_LEFT = TrafficSign_TypeAndConfidence_Type_SHARP_CURVE_LEFT;
  static constexpr Type SHARP_CURVE_RIGHT = TrafficSign_TypeAndConfidence_Type_SHARP_CURVE_RIGHT;
  static constexpr Type WINDING_ROAD = TrafficSign_TypeAndConfidence_Type_WINDING_ROAD;
  static constexpr Type WINDING_ROAD_STARTING_LEFT = TrafficSign_TypeAndConfidence_Type_WINDING_ROAD_STARTING_LEFT;
  static constexpr Type WINDING_ROAD_STARTING_RIGHT = TrafficSign_TypeAndConfidence_Type_WINDING_ROAD_STARTING_RIGHT;
  static constexpr Type STEEP_HILL = TrafficSign_TypeAndConfidence_Type_STEEP_HILL;
  static constexpr Type STEEP_HILL_UPWARDS = TrafficSign_TypeAndConfidence_Type_STEEP_HILL_UPWARDS;
  static constexpr Type STEEP_HILL_DOWNWARDS = TrafficSign_TypeAndConfidence_Type_STEEP_HILL_DOWNWARDS;
  static constexpr Type STOP_SIGN = TrafficSign_TypeAndConfidence_Type_STOP_SIGN;
  static constexpr Type LATERAL_WIND = TrafficSign_TypeAndConfidence_Type_LATERAL_WIND;
  static constexpr Type LATERAL_WIND_FROM_RIGHT = TrafficSign_TypeAndConfidence_Type_LATERAL_WIND_FROM_RIGHT;
  static constexpr Type LATERAL_WIND_FROM_LEFT = TrafficSign_TypeAndConfidence_Type_LATERAL_WIND_FROM_LEFT;
  static constexpr Type GENERAL_WARNING = TrafficSign_TypeAndConfidence_Type_GENERAL_WARNING;
  static constexpr Type RISK_OF_GROUNDING = TrafficSign_TypeAndConfidence_Type_RISK_OF_GROUNDING;
  static constexpr Type ANIMAL = TrafficSign_TypeAndConfidence_Type_ANIMAL;
  static constexpr Type ICY_CONDITIONS = TrafficSign_TypeAndConfidence_Type_ICY_CONDITIONS;
  static constexpr Type SLIPPERY_ROAD = TrafficSign_TypeAndConfidence_Type_SLIPPERY_ROAD;
  static constexpr Type UNEVEN_ROAD = TrafficSign_TypeAndConfidence_Type_UNEVEN_ROAD;
  static constexpr Type SCHOOL_ZONE = TrafficSign_TypeAndConfidence_Type_SCHOOL_ZONE;
  static constexpr Type TRAMWAY_CROSSING = TrafficSign_TypeAndConfidence_Type_TRAMWAY_CROSSING;
  static constexpr Type CONGESTION_HAZARD = TrafficSign_TypeAndConfidence_Type_CONGESTION_HAZARD;
  static constexpr Type ACCIDENT_HAZARD = TrafficSign_TypeAndConfidence_Type_ACCIDENT_HAZARD;
  static constexpr Type BICYCLE_CROSSING = TrafficSign_TypeAndConfidence_Type_BICYCLE_CROSSING;
  static constexpr Type PRIORITY_OVER_ONCOMING_TRAFFIC = TrafficSign_TypeAndConfidence_Type_PRIORITY_OVER_ONCOMING_TRAFFIC;
  static constexpr Type YIELD = TrafficSign_TypeAndConfidence_Type_YIELD;
  static constexpr Type PRIORITY_ROAD = TrafficSign_TypeAndConfidence_Type_PRIORITY_ROAD;
  static constexpr Type PRIORITY_ROAD_END = TrafficSign_TypeAndConfidence_Type_PRIORITY_ROAD_END;
  static constexpr Type TRAFFIC_CALMING = TrafficSign_TypeAndConfidence_Type_TRAFFIC_CALMING;
  static constexpr Type TRAFFIC_CALMING_END = TrafficSign_TypeAndConfidence_Type_TRAFFIC_CALMING_END;
  static constexpr Type ENVIRONMENTAL_AREA = TrafficSign_TypeAndConfidence_Type_ENVIRONMENTAL_AREA;
  static constexpr Type ENVIRONMENTAL_AREA_END = TrafficSign_TypeAndConfidence_Type_ENVIRONMENTAL_AREA_END;
  static constexpr Type INTERSECTION = TrafficSign_TypeAndConfidence_Type_INTERSECTION;
  static constexpr Type ROUNDABOUT = TrafficSign_TypeAndConfidence_Type_ROUNDABOUT;
  static constexpr Type PASSING_ON_LEFT = TrafficSign_TypeAndConfidence_Type_PASSING_ON_LEFT;
  static constexpr Type PASSING_ON_RIGHT = TrafficSign_TypeAndConfidence_Type_PASSING_ON_RIGHT;
  static constexpr Type PASSING_ON_LEFT_OR_RIGHT = TrafficSign_TypeAndConfidence_Type_PASSING_ON_LEFT_OR_RIGHT;
  static constexpr Type MANDATORY_TURN_RIGHT_ONLY = TrafficSign_TypeAndConfidence_Type_MANDATORY_TURN_RIGHT_ONLY;
  static constexpr Type MANDATORY_TURN_LEFT_ONLY = TrafficSign_TypeAndConfidence_Type_MANDATORY_TURN_LEFT_ONLY;
  static constexpr Type MANDATORY_STRAIGHT_ONLY = TrafficSign_TypeAndConfidence_Type_MANDATORY_STRAIGHT_ONLY;
  static constexpr Type MANDATORY_TURN_LEFT_OR_RIGHT = TrafficSign_TypeAndConfidence_Type_MANDATORY_TURN_LEFT_OR_RIGHT;
  static constexpr Type MANDATORY_TURN_RESTRICTION = TrafficSign_TypeAndConfidence_Type_MANDATORY_TURN_RESTRICTION;
  static constexpr Type MANDATORY_STRAIGHT_OR_LEFT = TrafficSign_TypeAndConfidence_Type_MANDATORY_STRAIGHT_OR_LEFT;
  static constexpr Type MANDATORY_STRAIGHT_OR_RIGHT = TrafficSign_TypeAndConfidence_Type_MANDATORY_STRAIGHT_OR_RIGHT;
  static constexpr Type NO_LEFT_TURN = TrafficSign_TypeAndConfidence_Type_NO_LEFT_TURN;
  static constexpr Type NO_RIGHT_TURN = TrafficSign_TypeAndConfidence_Type_NO_RIGHT_TURN;
  static constexpr Type NO_U_TURN = TrafficSign_TypeAndConfidence_Type_NO_U_TURN;
  static constexpr Type NO_U_OR_LEFT_TURN = TrafficSign_TypeAndConfidence_Type_NO_U_OR_LEFT_TURN;
  static constexpr Type U_TURN_ALLOWED = TrafficSign_TypeAndConfidence_Type_U_TURN_ALLOWED;
  static constexpr Type MANDATORY_LEFT_TRUCK = TrafficSign_TypeAndConfidence_Type_MANDATORY_LEFT_TRUCK;
  static constexpr Type MANDATORY_RIGHT_TRUCK = TrafficSign_TypeAndConfidence_Type_MANDATORY_RIGHT_TRUCK;
  static constexpr Type MANDATORY_STRAIGHT_TRUCK = TrafficSign_TypeAndConfidence_Type_MANDATORY_STRAIGHT_TRUCK;
  static constexpr Type NO_ENTRY = TrafficSign_TypeAndConfidence_Type_NO_ENTRY;
  static constexpr Type DEAD_END = TrafficSign_TypeAndConfidence_Type_DEAD_END;
  static constexpr Type HIGH_OCCUPANCY_VEHICLE_LANE = TrafficSign_TypeAndConfidence_Type_HIGH_OCCUPANCY_VEHICLE_LANE;
  static constexpr Type TOLL = TrafficSign_TypeAndConfidence_Type_TOLL;
  static constexpr Type TOLL_CAR = TrafficSign_TypeAndConfidence_Type_TOLL_CAR;
  static constexpr Type TOLL_LANE = TrafficSign_TypeAndConfidence_Type_TOLL_LANE;
  static constexpr Type EXPRESS_LANE = TrafficSign_TypeAndConfidence_Type_EXPRESS_LANE;
  static constexpr Type SHOULDER_OPEN_FOR_TRAFFIC = TrafficSign_TypeAndConfidence_Type_SHOULDER_OPEN_FOR_TRAFFIC;
  static constexpr Type SHOULDER_CLOSED_FOR_TRAFFIC = TrafficSign_TypeAndConfidence_Type_SHOULDER_CLOSED_FOR_TRAFFIC;
  static constexpr Type LANE_CLOSED = TrafficSign_TypeAndConfidence_Type_LANE_CLOSED;
  static constexpr Type LANE_CLOSED_RIGHT_MOST_LANE = TrafficSign_TypeAndConfidence_Type_LANE_CLOSED_RIGHT_MOST_LANE;
  static constexpr Type LANE_CLOSED_LEFT_MOST_LANE = TrafficSign_TypeAndConfidence_Type_LANE_CLOSED_LEFT_MOST_LANE;
  static constexpr Type WARNING_PEDESTRIAN = TrafficSign_TypeAndConfidence_Type_WARNING_PEDESTRIAN;
  static constexpr Type WARNING_CHILDREN = TrafficSign_TypeAndConfidence_Type_WARNING_CHILDREN;
  static constexpr Type WARNING_BICYCLE = TrafficSign_TypeAndConfidence_Type_WARNING_BICYCLE;
  static constexpr Type WARNING_BUS = TrafficSign_TypeAndConfidence_Type_WARNING_BUS;
  static constexpr Type PUBLIC_TRANSPORTATION_STOP = TrafficSign_TypeAndConfidence_Type_PUBLIC_TRANSPORTATION_STOP;
  static constexpr Type PEDESTRIAN_CROSSING = TrafficSign_TypeAndConfidence_Type_PEDESTRIAN_CROSSING;
  static constexpr Type WEIGHT_RESTRICTION = TrafficSign_TypeAndConfidence_Type_WEIGHT_RESTRICTION;
  static constexpr Type HEIGHT_RESTRICTION = TrafficSign_TypeAndConfidence_Type_HEIGHT_RESTRICTION;
  static constexpr Type LENGTH_RESTRICTION = TrafficSign_TypeAndConfidence_Type_LENGTH_RESTRICTION;
  static constexpr Type WIDTH_RESTRICTION = TrafficSign_TypeAndConfidence_Type_WIDTH_RESTRICTION;
  static constexpr Type WARNING_TRUCK_ROLLOVER = TrafficSign_TypeAndConfidence_Type_WARNING_TRUCK_ROLLOVER;
  static constexpr Type SIGNAL_AHEAD = TrafficSign_TypeAndConfidence_Type_SIGNAL_AHEAD;
  static constexpr Type SKI_CROSSING = TrafficSign_TypeAndConfidence_Type_SKI_CROSSING;
  static constexpr Type NO_AGRICULTUR_VEHICLE = TrafficSign_TypeAndConfidence_Type_NO_AGRICULTUR_VEHICLE;
  static constexpr Type NO_BICYCLE = TrafficSign_TypeAndConfidence_Type_NO_BICYCLE;
  static constexpr Type NO_BUS = TrafficSign_TypeAndConfidence_Type_NO_BUS;
  static constexpr Type NO_HAUL_EXPLOSIVES = TrafficSign_TypeAndConfidence_Type_NO_HAUL_EXPLOSIVES;
  static constexpr Type NO_HAUL_HARMFUL_TO_WATER = TrafficSign_TypeAndConfidence_Type_NO_HAUL_HARMFUL_TO_WATER;
  static constexpr Type NO_HAUL_HAZARDOUS_MATERIAL = TrafficSign_TypeAndConfidence_Type_NO_HAUL_HAZARDOUS_MATERIAL;
  static constexpr Type NO_MOTORCYCLE = TrafficSign_TypeAndConfidence_Type_NO_MOTORCYCLE;
  static constexpr Type NO_TRAILER = TrafficSign_TypeAndConfidence_Type_NO_TRAILER;
  static constexpr Type NO_TRUCK_WITH_TRAILER = TrafficSign_TypeAndConfidence_Type_NO_TRUCK_WITH_TRAILER;
  static constexpr Type PARK_AND_RIDE = TrafficSign_TypeAndConfidence_Type_PARK_AND_RIDE;
  static constexpr Type ROAD_DISTANCE = TrafficSign_TypeAndConfidence_Type_ROAD_DISTANCE;
  static constexpr Type EMERGENCY_PHONE = TrafficSign_TypeAndConfidence_Type_EMERGENCY_PHONE;
  static constexpr Type SPEED_LIMIT_ENFORCEMENT = TrafficSign_TypeAndConfidence_Type_SPEED_LIMIT_ENFORCEMENT;
  static constexpr Type TRAFFIC_LIGHT_ENFORCEMENT = TrafficSign_TypeAndConfidence_Type_TRAFFIC_LIGHT_ENFORCEMENT;
  static constexpr Type BOARD_DIRECTION = TrafficSign_TypeAndConfidence_Type_BOARD_DIRECTION;
  static constexpr Type STREET_NAME = TrafficSign_TypeAndConfidence_Type_STREET_NAME;
  static constexpr Type TRUCK_SPEED_LIMIT = TrafficSign_TypeAndConfidence_Type_TRUCK_SPEED_LIMIT;
  static constexpr Type TRUCK_SPEED_LIMIT_END = TrafficSign_TypeAndConfidence_Type_TRUCK_SPEED_LIMIT_END;
  static constexpr Type SPEED_LIMIT_NIGHT = TrafficSign_TypeAndConfidence_Type_SPEED_LIMIT_NIGHT;
  static constexpr Type SPEED_LIMIT_NIGHT_END = TrafficSign_TypeAndConfidence_Type_SPEED_LIMIT_NIGHT_END;
  static constexpr Type MINIMUM_SPEED = TrafficSign_TypeAndConfidence_Type_MINIMUM_SPEED;
  static constexpr Type MINIMUM_SPEED_END = TrafficSign_TypeAndConfidence_Type_MINIMUM_SPEED_END;
  static constexpr Type PEDESTRIAN_ZONE = TrafficSign_TypeAndConfidence_Type_PEDESTRIAN_ZONE;
  static constexpr Type PEDESTRIAN_ZONE_END = TrafficSign_TypeAndConfidence_Type_PEDESTRIAN_ZONE_END;
  static constexpr Type PEDESTRIAN_PATH = TrafficSign_TypeAndConfidence_Type_PEDESTRIAN_PATH;
  static constexpr Type PEDESTRIAN_PATH_END = TrafficSign_TypeAndConfidence_Type_PEDESTRIAN_PATH_END;
  static constexpr Type PEDESTRIAN_BICYCLE_PATH = TrafficSign_TypeAndConfidence_Type_PEDESTRIAN_BICYCLE_PATH;
  static constexpr Type PEDESTRIAN_BICYCLE_PATH_END = TrafficSign_TypeAndConfidence_Type_PEDESTRIAN_BICYCLE_PATH_END;
  static constexpr Type BICYCLE_PATH = TrafficSign_TypeAndConfidence_Type_BICYCLE_PATH;
  static constexpr Type BICYCLE_PATH_END = TrafficSign_TypeAndConfidence_Type_BICYCLE_PATH_END;
  static constexpr Type BICYCLE_STREET = TrafficSign_TypeAndConfidence_Type_BICYCLE_STREET;
  static constexpr Type BICYCLE_STREET_END = TrafficSign_TypeAndConfidence_Type_BICYCLE_STREET_END;
  static constexpr Type CURVE_LEFT_THEN_RIGHT = TrafficSign_TypeAndConfidence_Type_CURVE_LEFT_THEN_RIGHT;
  static constexpr Type CURVE_RIGHT_THEN_LEFT = TrafficSign_TypeAndConfidence_Type_CURVE_RIGHT_THEN_LEFT;
  static constexpr Type CURVE_TRIPLE_HAIRPIN = TrafficSign_TypeAndConfidence_Type_CURVE_TRIPLE_HAIRPIN;
  static constexpr Type STEEP_DROP = TrafficSign_TypeAndConfidence_Type_STEEP_DROP;
  static constexpr Type STEEP_DROP_ON_LEFT = TrafficSign_TypeAndConfidence_Type_STEEP_DROP_ON_LEFT;
  static constexpr Type STEEP_DROP_ON_RIGHT = TrafficSign_TypeAndConfidence_Type_STEEP_DROP_ON_RIGHT;
  static constexpr Type NO_ANIMAL_CATTLE = TrafficSign_TypeAndConfidence_Type_NO_ANIMAL_CATTLE;
  static constexpr Type ANIMAL_DEER = TrafficSign_TypeAndConfidence_Type_ANIMAL_DEER;
  static constexpr Type ANIMAL_MOOSE = TrafficSign_TypeAndConfidence_Type_ANIMAL_MOOSE;
  static constexpr Type NO_HORSE_RIDING = TrafficSign_TypeAndConfidence_Type_NO_HORSE_RIDING;
  static constexpr Type FALLING_ROCKS = TrafficSign_TypeAndConfidence_Type_FALLING_ROCKS;
  static constexpr Type FALLING_ROCKS_LEFT = TrafficSign_TypeAndConfidence_Type_FALLING_ROCKS_LEFT;
  static constexpr Type FALLING_ROCKS_RIGHT = TrafficSign_TypeAndConfidence_Type_FALLING_ROCKS_RIGHT;
  static constexpr Type YIELD_TO_ONCOMING_TRAFFIC = TrafficSign_TypeAndConfidence_Type_YIELD_TO_ONCOMING_TRAFFIC;
  static constexpr Type UNPROTECTED_LEFT_TURN = TrafficSign_TypeAndConfidence_Type_UNPROTECTED_LEFT_TURN;
  static constexpr Type ONEWAY_TRAFFIC = TrafficSign_TypeAndConfidence_Type_ONEWAY_TRAFFIC;
  static constexpr Type ONEWAY_TRAFFIC_TO_LEFT = TrafficSign_TypeAndConfidence_Type_ONEWAY_TRAFFIC_TO_LEFT;
  static constexpr Type ONEWAY_TRAFFIC_TO_RIGHT = TrafficSign_TypeAndConfidence_Type_ONEWAY_TRAFFIC_TO_RIGHT;
  static constexpr Type ONEWAY_TRAFFIC_TO_STRAIGHT = TrafficSign_TypeAndConfidence_Type_ONEWAY_TRAFFIC_TO_STRAIGHT;
  static constexpr Type NO_VEHICLE = TrafficSign_TypeAndConfidence_Type_NO_VEHICLE;
  static constexpr Type NO_MOTOR_VEHICLE = TrafficSign_TypeAndConfidence_Type_NO_MOTOR_VEHICLE;
  static constexpr Type NO_TRUCK = TrafficSign_TypeAndConfidence_Type_NO_TRUCK;
  static constexpr Type NO_PEDESTRIAN = TrafficSign_TypeAndConfidence_Type_NO_PEDESTRIAN;
  static constexpr Type LANE_USED_IN_BOTH_DIRECTIONS = TrafficSign_TypeAndConfidence_Type_LANE_USED_IN_BOTH_DIRECTIONS;
  static constexpr Type FOG_AREA = TrafficSign_TypeAndConfidence_Type_FOG_AREA;
  static constexpr Type TIRE_CHAINS_MANDATORY = TrafficSign_TypeAndConfidence_Type_TIRE_CHAINS_MANDATORY;
  static constexpr Type HIJACKING_HOTSPOT = TrafficSign_TypeAndConfidence_Type_HIJACKING_HOTSPOT;
  static constexpr Type OVERPASS_AHEAD = TrafficSign_TypeAndConfidence_Type_OVERPASS_AHEAD;
  static constexpr Type TUNNEL = TrafficSign_TypeAndConfidence_Type_TUNNEL;
  static constexpr Type FERRY_TERMINAL = TrafficSign_TypeAndConfidence_Type_FERRY_TERMINAL;
  static constexpr Type NARROW_BRIDGE = TrafficSign_TypeAndConfidence_Type_NARROW_BRIDGE;
  static constexpr Type NO_IDLING = TrafficSign_TypeAndConfidence_Type_NO_IDLING;
  static constexpr Type HUMPBACK_BRIDGE = TrafficSign_TypeAndConfidence_Type_HUMPBACK_BRIDGE;
  static constexpr Type EMBANKMENT = TrafficSign_TypeAndConfidence_Type_EMBANKMENT;
  static constexpr Type EMBANKMENT_ON_THE_LEFT = TrafficSign_TypeAndConfidence_Type_EMBANKMENT_ON_THE_LEFT;
  static constexpr Type EMBANKMENT_ON_THE_RIGHT = TrafficSign_TypeAndConfidence_Type_EMBANKMENT_ON_THE_RIGHT;
  static constexpr Type CROSSING_WITH_PRIORITY_OVER_MINOR_ROAD = TrafficSign_TypeAndConfidence_Type_CROSSING_WITH_PRIORITY_OVER_MINOR_ROAD;
  static constexpr Type CROSSING_WITH_PRIORITY_TO_THE_RIGHT = TrafficSign_TypeAndConfidence_Type_CROSSING_WITH_PRIORITY_TO_THE_RIGHT;
  static constexpr Type BRANCH_TO_THE_LEFT = TrafficSign_TypeAndConfidence_Type_BRANCH_TO_THE_LEFT;
  static constexpr Type BRANCH_TO_THE_RIGHT = TrafficSign_TypeAndConfidence_Type_BRANCH_TO_THE_RIGHT;
  static constexpr Type TWO_WAY_TRAFFIC = TrafficSign_TypeAndConfidence_Type_TWO_WAY_TRAFFIC;
  static constexpr Type BUMP = TrafficSign_TypeAndConfidence_Type_BUMP;
  static constexpr Type DIP = TrafficSign_TypeAndConfidence_Type_DIP;
  static constexpr Type ROAD_FLOODED = TrafficSign_TypeAndConfidence_Type_ROAD_FLOODED;
  static constexpr Type AUDIBLE_WARNING = TrafficSign_TypeAndConfidence_Type_AUDIBLE_WARNING;
  static constexpr Type VILLAGE_AHEAD = TrafficSign_TypeAndConfidence_Type_VILLAGE_AHEAD;
  static constexpr Type MOVABLE_BRIDGE = TrafficSign_TypeAndConfidence_Type_MOVABLE_BRIDGE;
  static constexpr Type SLOW_DOWN = TrafficSign_TypeAndConfidence_Type_SLOW_DOWN;
  static constexpr Type INTERSECTION_T = TrafficSign_TypeAndConfidence_Type_INTERSECTION_T;
  static constexpr Type INTERSECTION_T_LEFT = TrafficSign_TypeAndConfidence_Type_INTERSECTION_T_LEFT;
  static constexpr Type INTERSECTION_T_RIGHT = TrafficSign_TypeAndConfidence_Type_INTERSECTION_T_RIGHT;
  static constexpr Type INTERSECTION_T_LEFT_RIGHT = TrafficSign_TypeAndConfidence_Type_INTERSECTION_T_LEFT_RIGHT;
  static constexpr Type INTERSECTION_Y = TrafficSign_TypeAndConfidence_Type_INTERSECTION_Y;
  static constexpr Type USE_LOW_GEAR = TrafficSign_TypeAndConfidence_Type_USE_LOW_GEAR;
  static constexpr Type USE_LOW_GEAR_END = TrafficSign_TypeAndConfidence_Type_USE_LOW_GEAR_END;
  static constexpr Type NO_COMPRESSION_BRAKING = TrafficSign_TypeAndConfidence_Type_NO_COMPRESSION_BRAKING;
  static constexpr Type NO_COMPRESSION_BRAKING_END = TrafficSign_TypeAndConfidence_Type_NO_COMPRESSION_BRAKING_END;
  static constexpr Type WAITING_LINE = TrafficSign_TypeAndConfidence_Type_WAITING_LINE;
  static constexpr Type DONT_STOP_ZONE = TrafficSign_TypeAndConfidence_Type_DONT_STOP_ZONE;
  static constexpr Type HONKING_PROHIBITED = TrafficSign_TypeAndConfidence_Type_HONKING_PROHIBITED;
  static constexpr Type FASTEN_SEAT_BELT = TrafficSign_TypeAndConfidence_Type_FASTEN_SEAT_BELT;
  static constexpr Type HAMLET_ENTRY = TrafficSign_TypeAndConfidence_Type_HAMLET_ENTRY;
  static constexpr Type HAMLET_EXIT = TrafficSign_TypeAndConfidence_Type_HAMLET_EXIT;
  static constexpr Type HIGHWAY_MARKER_1_STRIPE = TrafficSign_TypeAndConfidence_Type_HIGHWAY_MARKER_1_STRIPE;
  static constexpr Type HIGHWAY_MARKER_2_STRIPES = TrafficSign_TypeAndConfidence_Type_HIGHWAY_MARKER_2_STRIPES;
  static constexpr Type HIGHWAY_MARKER_3_STRIPES = TrafficSign_TypeAndConfidence_Type_HIGHWAY_MARKER_3_STRIPES;
  static constexpr Type GUIDING_BEACON = TrafficSign_TypeAndConfidence_Type_GUIDING_BEACON;
  static constexpr Type COUNTDOWN_MARKER_1_STRIPE = TrafficSign_TypeAndConfidence_Type_COUNTDOWN_MARKER_1_STRIPE;
  static constexpr Type COUNTDOWN_MARKER_2_STRIPES = TrafficSign_TypeAndConfidence_Type_COUNTDOWN_MARKER_2_STRIPES;
  static constexpr Type COUNTDOWN_MARKER_3_STRIPES = TrafficSign_TypeAndConfidence_Type_COUNTDOWN_MARKER_3_STRIPES;
  static constexpr Type DIVERSION_ROUTE = TrafficSign_TypeAndConfidence_Type_DIVERSION_ROUTE;
  static constexpr Type DIVERSION_ROUTE_END = TrafficSign_TypeAndConfidence_Type_DIVERSION_ROUTE_END;
  static constexpr Type NO_STOPPING_EXCEPT_TAXI = TrafficSign_TypeAndConfidence_Type_NO_STOPPING_EXCEPT_TAXI;
  static constexpr Type NO_STOPPING = TrafficSign_TypeAndConfidence_Type_NO_STOPPING;
  static constexpr Type NO_STOPPING_LEFT = TrafficSign_TypeAndConfidence_Type_NO_STOPPING_LEFT;
  static constexpr Type NO_STOPPING_RIGHT = TrafficSign_TypeAndConfidence_Type_NO_STOPPING_RIGHT;
  static constexpr Type NO_STOPPING_LEFT_AND_RIGHT = TrafficSign_TypeAndConfidence_Type_NO_STOPPING_LEFT_AND_RIGHT;
  static constexpr Type NO_PARKING = TrafficSign_TypeAndConfidence_Type_NO_PARKING;
  static constexpr Type NO_PARKING_LEFT = TrafficSign_TypeAndConfidence_Type_NO_PARKING_LEFT;
  static constexpr Type NO_PARKING_RIGHT = TrafficSign_TypeAndConfidence_Type_NO_PARKING_RIGHT;
  static constexpr Type NO_PARKING_LEFT_AND_RIGHT = TrafficSign_TypeAndConfidence_Type_NO_PARKING_LEFT_AND_RIGHT;
  static constexpr Type RUNNAWAY_TRUCK_RAMP = TrafficSign_TypeAndConfidence_Type_RUNNAWAY_TRUCK_RAMP;
  static constexpr Type TURN_ON_GREEN = TrafficSign_TypeAndConfidence_Type_TURN_ON_GREEN;
  static constexpr Type NO_TURN_ON_RED = TrafficSign_TypeAndConfidence_Type_NO_TURN_ON_RED;
  static constexpr Type MOTORWAY_ROAD_NUMBER = TrafficSign_TypeAndConfidence_Type_MOTORWAY_ROAD_NUMBER;
  static constexpr Type HIGHWAY_ROAD_NUMBER = TrafficSign_TypeAndConfidence_Type_HIGHWAY_ROAD_NUMBER;
  static constexpr Type HIGHWAY_INTERCHANGE_NUMBER = TrafficSign_TypeAndConfidence_Type_HIGHWAY_INTERCHANGE_NUMBER;
  static constexpr Type EUROPEAN_ROAD_NUMBER = TrafficSign_TypeAndConfidence_Type_EUROPEAN_ROAD_NUMBER;
  static constexpr Type SPEED_LIMIT_ZONE = TrafficSign_TypeAndConfidence_Type_SPEED_LIMIT_ZONE;
  static constexpr Type SPEED_LIMIT_ZONE_END = TrafficSign_TypeAndConfidence_Type_SPEED_LIMIT_ZONE_END;
  static constexpr Type NO_PARKING_ZONE = TrafficSign_TypeAndConfidence_Type_NO_PARKING_ZONE;
  static constexpr Type NO_PARKING_ZONE_END = TrafficSign_TypeAndConfidence_Type_NO_PARKING_ZONE_END;
  static constexpr Type PARKING_ZONE = TrafficSign_TypeAndConfidence_Type_PARKING_ZONE;
  static constexpr Type PARKING_ZONE_END = TrafficSign_TypeAndConfidence_Type_PARKING_ZONE_END;
  static constexpr Type PARKING = TrafficSign_TypeAndConfidence_Type_PARKING;
  static constexpr Type PARKING_TO_LEFT = TrafficSign_TypeAndConfidence_Type_PARKING_TO_LEFT;
  static constexpr Type PARKING_TO_RIGHT = TrafficSign_TypeAndConfidence_Type_PARKING_TO_RIGHT;
  static constexpr Type PARKING_GARAGE = TrafficSign_TypeAndConfidence_Type_PARKING_GARAGE;
  static constexpr Type PARKING_ON_SIDEWAY = TrafficSign_TypeAndConfidence_Type_PARKING_ON_SIDEWAY;
  static constexpr Type SAFETY_DISTANCE = TrafficSign_TypeAndConfidence_Type_SAFETY_DISTANCE;
  static constexpr Type SAFETY_DISTANCE_VEHICLE = TrafficSign_TypeAndConfidence_Type_SAFETY_DISTANCE_VEHICLE;
  static constexpr Type SAFETY_DISTANCE_TRUCK = TrafficSign_TypeAndConfidence_Type_SAFETY_DISTANCE_TRUCK;
  static constexpr Type DETOUR = TrafficSign_TypeAndConfidence_Type_DETOUR;
  static constexpr Type DETOUR_END = TrafficSign_TypeAndConfidence_Type_DETOUR_END;
  static constexpr Type DETOUR_LEFT = TrafficSign_TypeAndConfidence_Type_DETOUR_LEFT;
  static constexpr Type DETOUR_RIGHT = TrafficSign_TypeAndConfidence_Type_DETOUR_RIGHT;
  static constexpr Type STATION_GAS = TrafficSign_TypeAndConfidence_Type_STATION_GAS;
  static constexpr Type STATION_LPG = TrafficSign_TypeAndConfidence_Type_STATION_LPG;
  static constexpr Type STATION_CNG = TrafficSign_TypeAndConfidence_Type_STATION_CNG;
  static constexpr Type STATION_H2 = TrafficSign_TypeAndConfidence_Type_STATION_H2;
  static constexpr Type STATION_ELECTRO = TrafficSign_TypeAndConfidence_Type_STATION_ELECTRO;
  static constexpr Type STATION_POLICE = TrafficSign_TypeAndConfidence_Type_STATION_POLICE;
  static constexpr Type CAMPING_SPOT = TrafficSign_TypeAndConfidence_Type_CAMPING_SPOT;
  static constexpr Type RESTROOMS = TrafficSign_TypeAndConfidence_Type_RESTROOMS;
  static constexpr Type INFO_POINT = TrafficSign_TypeAndConfidence_Type_INFO_POINT;
  static constexpr Type MOTORWAY_EXIT_AHEAD = TrafficSign_TypeAndConfidence_Type_MOTORWAY_EXIT_AHEAD;
  static constexpr Type HIGHWAY_EXIT_AHEAD = TrafficSign_TypeAndConfidence_Type_HIGHWAY_EXIT_AHEAD;
  static constexpr Type MOTORWAY_EXIT = TrafficSign_TypeAndConfidence_Type_MOTORWAY_EXIT;
  static constexpr Type HIGHWAY_EXIT = TrafficSign_TypeAndConfidence_Type_HIGHWAY_EXIT;
  static constexpr Type FIRST_AID = TrafficSign_TypeAndConfidence_Type_FIRST_AID;
  static constexpr Type LOW_FLYING = TrafficSign_TypeAndConfidence_Type_LOW_FLYING;
  static constexpr Type LANE_SHIFT = TrafficSign_TypeAndConfidence_Type_LANE_SHIFT;
  static constexpr Type LANE_SHIFT_TO_LEFT = TrafficSign_TypeAndConfidence_Type_LANE_SHIFT_TO_LEFT;
  static constexpr Type LANE_SHIFT_TO_RIGHT = TrafficSign_TypeAndConfidence_Type_LANE_SHIFT_TO_RIGHT;
  static constexpr Type PEDESTRIAN_UNDERPASS = TrafficSign_TypeAndConfidence_Type_PEDESTRIAN_UNDERPASS;
  static constexpr Type PEDESTRIAN_OVERPASS = TrafficSign_TypeAndConfidence_Type_PEDESTRIAN_OVERPASS;
  static constexpr Type BREAKDOWN_BAY = TrafficSign_TypeAndConfidence_Type_BREAKDOWN_BAY;
  static constexpr Type BUS_LANE = TrafficSign_TypeAndConfidence_Type_BUS_LANE;
  static constexpr Type DOUBLE_HAIRPIN = TrafficSign_TypeAndConfidence_Type_DOUBLE_HAIRPIN;
  static constexpr Type COUNTRY_SPECIFIC_INFORMATION = TrafficSign_TypeAndConfidence_Type_COUNTRY_SPECIFIC_INFORMATION;
  static constexpr Type PEDESTRIAN_BICYCLE_SHARED_PATH = TrafficSign_TypeAndConfidence_Type_PEDESTRIAN_BICYCLE_SHARED_PATH;
  static constexpr Type OVERHEAD_LANE_CONTROL_CLOSED = TrafficSign_TypeAndConfidence_Type_OVERHEAD_LANE_CONTROL_CLOSED;
  static constexpr Type OVERHEAD_LANE_CONTROL_OPEN = TrafficSign_TypeAndConfidence_Type_OVERHEAD_LANE_CONTROL_OPEN;
  static constexpr Type OVERHEAD_LANE_CONTROL_CLOSING_LEFT = TrafficSign_TypeAndConfidence_Type_OVERHEAD_LANE_CONTROL_CLOSING_LEFT;
  static constexpr Type OVERHEAD_LANE_CONTROL_CLOSING_RIGHT = TrafficSign_TypeAndConfidence_Type_OVERHEAD_LANE_CONTROL_CLOSING_RIGHT;
  static constexpr Type OVERHEAD_LANE_CONTROL_FLASH_ARROW_LEFT = TrafficSign_TypeAndConfidence_Type_OVERHEAD_LANE_CONTROL_FLASH_ARROW_LEFT;
  static constexpr Type OVERHEAD_LANE_CONTROL_FLASH_ARROW_RIGHT = TrafficSign_TypeAndConfidence_Type_OVERHEAD_LANE_CONTROL_FLASH_ARROW_RIGHT;
  static constexpr Type TRINATURE = TrafficSign_TypeAndConfidence_Type_TRINATURE;
  static constexpr Type ANIMAL_FROG = TrafficSign_TypeAndConfidence_Type_ANIMAL_FROG;
  static constexpr Type GRAVEL = TrafficSign_TypeAndConfidence_Type_GRAVEL;
  static constexpr Type WARNING_PEDESTRIAN_CROSSING = TrafficSign_TypeAndConfidence_Type_WARNING_PEDESTRIAN_CROSSING;
  static constexpr Type LOW_TREE = TrafficSign_TypeAndConfidence_Type_LOW_TREE;
  static constexpr Type WARNING_RIDER = TrafficSign_TypeAndConfidence_Type_WARNING_RIDER;
  static constexpr Type STOP_AHEAD = TrafficSign_TypeAndConfidence_Type_STOP_AHEAD;
  static constexpr Type YIELD_AHEAD = TrafficSign_TypeAndConfidence_Type_YIELD_AHEAD;
  static constexpr Type WATER_PROTECTION_AREA = TrafficSign_TypeAndConfidence_Type_WATER_PROTECTION_AREA;
  static constexpr Type TOLL_DOUANE = TrafficSign_TypeAndConfidence_Type_TOLL_DOUANE;
  static constexpr Type NO_CAR_OR_BIKE = TrafficSign_TypeAndConfidence_Type_NO_CAR_OR_BIKE;
  static constexpr Type DRIVING_DIRECTION_ONLY_UP = TrafficSign_TypeAndConfidence_Type_DRIVING_DIRECTION_ONLY_UP;
  static constexpr Type DRIVING_DIRECTION_UP_AND_DOWN = TrafficSign_TypeAndConfidence_Type_DRIVING_DIRECTION_UP_AND_DOWN;
  static constexpr Type MILITARY_SIGN = TrafficSign_TypeAndConfidence_Type_MILITARY_SIGN;
  static constexpr Type SMOG = TrafficSign_TypeAndConfidence_Type_SMOG;
  static constexpr Type ROUNDABOUT_AHEAD = TrafficSign_TypeAndConfidence_Type_ROUNDABOUT_AHEAD;
  static constexpr Type MANDATORY_LEFT_OR_STRAIGHT_OR_RIGHT = TrafficSign_TypeAndConfidence_Type_MANDATORY_LEFT_OR_STRAIGHT_OR_RIGHT;
  static constexpr Type DEAD_END_RIGHT = TrafficSign_TypeAndConfidence_Type_DEAD_END_RIGHT;
  static constexpr Type DEAD_END_LEFT = TrafficSign_TypeAndConfidence_Type_DEAD_END_LEFT;
  static constexpr Type TOLL_TRUCK = TrafficSign_TypeAndConfidence_Type_TOLL_TRUCK;
  static constexpr Type TOLL_TRUCK_END = TrafficSign_TypeAndConfidence_Type_TOLL_TRUCK_END;
  static constexpr Type STAGGERED_JUNCTION = TrafficSign_TypeAndConfidence_Type_STAGGERED_JUNCTION;
  static constexpr Type AXLE_WEIGHT_RESTRICTION = TrafficSign_TypeAndConfidence_Type_AXLE_WEIGHT_RESTRICTION;
  static constexpr Type TOLL_END = TrafficSign_TypeAndConfidence_Type_TOLL_END;
  static constexpr Type TOLL_CAR_END = TrafficSign_TypeAndConfidence_Type_TOLL_CAR_END;
  static constexpr Type TOLL_LANE_END = TrafficSign_TypeAndConfidence_Type_TOLL_LANE_END;
  static inline bool Type_IsValid(int value) {
    return TrafficSign_TypeAndConfidence_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = TrafficSign_TypeAndConfidence_Type_Type_MIN;
  static constexpr Type Type_MAX = TrafficSign_TypeAndConfidence_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = TrafficSign_TypeAndConfidence_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Type_descriptor() {
    return TrafficSign_TypeAndConfidence_Type_descriptor();
  }
  template <typename T>
  static inline const std::string& Type_Name(T value) {
    return TrafficSign_TypeAndConfidence_Type_Name(value);
  }
  static inline bool Type_Parse(absl::string_view name, Type* value) {
    return TrafficSign_TypeAndConfidence_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kConfidenceFieldNumber = 2,
    kOtherTextFieldNumber = 3,
    kTypeFieldNumber = 1,
  };
  // .sensoris.protobuf.types.base.Confidence confidence = 2;
  bool has_confidence() const;
  void clear_confidence() ;
  const ::sensoris::protobuf::types::base::Confidence& confidence() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::Confidence* release_confidence();
  ::sensoris::protobuf::types::base::Confidence* mutable_confidence();
  void set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value);
  void unsafe_arena_set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value);
  ::sensoris::protobuf::types::base::Confidence* unsafe_arena_release_confidence();

  private:
  const ::sensoris::protobuf::types::base::Confidence& _internal_confidence() const;
  ::sensoris::protobuf::types::base::Confidence* _internal_mutable_confidence();

  public:
  // .google.protobuf.StringValue other_text = 3;
  bool has_other_text() const;
  void clear_other_text() ;
  const ::google::protobuf::StringValue& other_text() const;
  PROTOBUF_NODISCARD ::google::protobuf::StringValue* release_other_text();
  ::google::protobuf::StringValue* mutable_other_text();
  void set_allocated_other_text(::google::protobuf::StringValue* value);
  void unsafe_arena_set_allocated_other_text(::google::protobuf::StringValue* value);
  ::google::protobuf::StringValue* unsafe_arena_release_other_text();

  private:
  const ::google::protobuf::StringValue& _internal_other_text() const;
  ::google::protobuf::StringValue* _internal_mutable_other_text();

  public:
  // .sensoris.protobuf.categories.trafficregulation.TrafficSign.TypeAndConfidence.Type type = 1;
  void clear_type() ;
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_TypeAndConfidence_Type type() const;
  void set_type(::sensoris::protobuf::categories::trafficregulation::TrafficSign_TypeAndConfidence_Type value);

  private:
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_TypeAndConfidence_Type _internal_type() const;
  void _internal_set_type(::sensoris::protobuf::categories::trafficregulation::TrafficSign_TypeAndConfidence_Type value);

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.trafficregulation.TrafficSign.TypeAndConfidence)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::Confidence* confidence_;
    ::google::protobuf::StringValue* other_text_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2ftraffic_5fregulation_2eproto;
};// -------------------------------------------------------------------

class TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence.TypeAndConfidence) */ {
 public:
  inline TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence() : TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence(nullptr) {}
  ~TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence(::google::protobuf::internal::ConstantInitialized);

  inline TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence(const TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence& from)
      : TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence(nullptr, from) {}
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence(TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence&& from) noexcept
    : TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence() {
    *this = ::std::move(from);
  }

  inline TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence& operator=(const TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence& operator=(TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence* internal_default_instance() {
    return reinterpret_cast<const TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence*>(
               &_TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence& a, TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence& b) {
    a.Swap(&b);
  }
  inline void Swap(TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence& from) {
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence.TypeAndConfidence";
  }
  protected:
  explicit TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence(::google::protobuf::Arena* arena);
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence(::google::protobuf::Arena* arena, const TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Type = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type;
  static constexpr Type UNKNOWN_TYPE = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_UNKNOWN_TYPE;
  static constexpr Type SUP_OTHER_AS_TEXT = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_OTHER_AS_TEXT;
  static constexpr Type SUP_WET = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_WET;
  static constexpr Type SUP_RAIN = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_RAIN;
  static constexpr Type SUP_SNOW = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_SNOW;
  static constexpr Type SUP_SNOW_OR_RAIN = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_SNOW_OR_RAIN;
  static constexpr Type SUP_FOG = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_FOG;
  static constexpr Type SUP_TIME = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_TIME;
  static constexpr Type SUP_DAY_AND_TIME = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_DAY_AND_TIME;
  static constexpr Type SUP_NIGHT = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_NIGHT;
  static constexpr Type SUP_SEASON = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_SEASON;
  static constexpr Type SUP_WORKDAYS = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_WORKDAYS;
  static constexpr Type SUP_WORKDAYS_AND_TIME = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_WORKDAYS_AND_TIME;
  static constexpr Type SUP_SCHOOL = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_SCHOOL;
  static constexpr Type SUP_RAMP = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_RAMP;
  static constexpr Type SUP_TRUCK = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_TRUCK;
  static constexpr Type SUP_TRUCK_WITH_TRAILER = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_TRUCK_WITH_TRAILER;
  static constexpr Type SUP_PASSENGER_CAR = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_PASSENGER_CAR;
  static constexpr Type SUP_PASSENGER_CAR_WITH_TAILER = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_PASSENGER_CAR_WITH_TAILER;
  static constexpr Type SUP_TRACTOR_EXCEPT = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_TRACTOR_EXCEPT;
  static constexpr Type SUP_BUS = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_BUS;
  static constexpr Type SUP_TRUCKS_AND_BUS = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_TRUCKS_AND_BUS;
  static constexpr Type SUP_CARS_TRUCKS_BUS = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_CARS_TRUCKS_BUS;
  static constexpr Type SUP_TAXI = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_TAXI;
  static constexpr Type SUP_TANK = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_TANK;
  static constexpr Type SUP_ROADSIDE = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_ROADSIDE;
  static constexpr Type SUP_WEIGHT = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_WEIGHT;
  static constexpr Type SUP_STARTING_IN = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_STARTING_IN;
  static constexpr Type SUP_VALID_FOR = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_VALID_FOR;
  static constexpr Type SUP_IN_RIGHT_DIRECTION = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_IN_RIGHT_DIRECTION;
  static constexpr Type SUP_IN_LEFT_DIRECTION = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_IN_LEFT_DIRECTION;
  static constexpr Type SUP_ZONE = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_ZONE;
  static constexpr Type SUP_ZONE_START = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_ZONE_START;
  static constexpr Type SUP_ZONE_END = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_ZONE_END;
  static constexpr Type SUP_BEGIN_OF_VALIDITY = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_BEGIN_OF_VALIDITY;
  static constexpr Type SUP_END_OF_VALIDITY = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_END_OF_VALIDITY;
  static constexpr Type SUP_FROG = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_FROG;
  static constexpr Type SUP_ALL_WAY = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_ALL_WAY;
  static constexpr Type SUP_BIKE = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_BIKE;
  static constexpr Type SUP_BIKE_EXCEPT = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_BIKE_EXCEPT;
  static constexpr Type SUP_BUS_EXCEPT = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_BUS_EXCEPT;
  static constexpr Type SUP_CAMPER = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_CAMPER;
  static constexpr Type SUP_CARAVAN = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_CARAVAN;
  static constexpr Type SUP_CONSTRUCTION_GATEWAY = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_CONSTRUCTION_GATEWAY;
  static constexpr Type SUP_CROSS_WAY = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_CROSS_WAY;
  static constexpr Type SUP_DELIVERY_EXCEPT = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_DELIVERY_EXCEPT;
  static constexpr Type SUP_ELECTRONIC_CAR = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_ELECTRONIC_CAR;
  static constexpr Type SUP_GATEWAY = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_GATEWAY;
  static constexpr Type SUP_GIVE_WAY_LEFT = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_GIVE_WAY_LEFT;
  static constexpr Type SUP_GIVE_WAY_RIGHT = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_GIVE_WAY_RIGHT;
  static constexpr Type SUP_GRAVEL = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_GRAVEL;
  static constexpr Type SUP_HAZMAT = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_HAZMAT;
  static constexpr Type SUP_HAZ_WATER = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_HAZ_WATER;
  static constexpr Type SUP_KIDS = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_KIDS;
  static constexpr Type SUP_LOCAL_EXCEP = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_LOCAL_EXCEP;
  static constexpr Type SUP_LOW_TREE = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_LOW_TREE;
  static constexpr Type SUP_MOTORCYCLE = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_MOTORCYCLE;
  static constexpr Type SUP_MOTORCYCLE_EXCEPT = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_MOTORCYCLE_EXCEPT;
  static constexpr Type SUP_NEW_ROAD_BED = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_NEW_ROAD_BED;
  static constexpr Type SUP_NO_STOP_SHOULDER = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_NO_STOP_SHOULDER;
  static constexpr Type SUP_OIL_TRAIL = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_OIL_TRAIL;
  static constexpr Type SUP_PASSENGER_CAR_EXCEPT = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_PASSENGER_CAR_EXCEPT;
  static constexpr Type SUP_PASSENGER_CAR_WITH_TAILER_EXCEPT = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_PASSENGER_CAR_WITH_TAILER_EXCEPT;
  static constexpr Type SUP_PEDESTRIAN = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_PEDESTRIAN;
  static constexpr Type SUP_PRIORITY_TURN_LEFT = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_PRIORITY_TURN_LEFT;
  static constexpr Type SUP_PRIORITY_TURN_RIGHT = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_PRIORITY_TURN_RIGHT;
  static constexpr Type SUP_ROAD_DAMAGE = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_ROAD_DAMAGE;
  static constexpr Type SUP_RUTS = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_RUTS;
  static constexpr Type SUP_TRACTOR = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_TRACTOR;
  static constexpr Type SUP_TRACTOR_MAY_BE_OVERTAKEN = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_TRACTOR_MAY_BE_OVERTAKEN;
  static constexpr Type SUP_TRAFFIC_JAM = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_TRAFFIC_JAM;
  static constexpr Type SUP_TRAIN = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_TRAIN;
  static constexpr Type SUP_TRAM = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_TRAM;
  static constexpr Type SUP_TRUCK_EXCEPT = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_TRUCK_EXCEPT;
  static constexpr Type SUP_TRUCK_WITH_TRAILER_EXCEPT = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_TRUCK_WITH_TRAILER_EXCEPT;
  static constexpr Type SUP_GET_IN_PROPER_LANE = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_GET_IN_PROPER_LANE;
  static constexpr Type SUP_ROADSIDE_TRUCK = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_ROADSIDE_TRUCK;
  static constexpr Type SUP_RAPPEL = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_RAPPEL;
  static constexpr Type SUP_RADAR_ENFORCED = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_RADAR_ENFORCED;
  static constexpr Type SUP_STOP_IN_DISTANCE = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_STOP_IN_DISTANCE;
  static inline bool Type_IsValid(int value) {
    return TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_Type_MIN;
  static constexpr Type Type_MAX = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Type_descriptor() {
    return TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_descriptor();
  }
  template <typename T>
  static inline const std::string& Type_Name(T value) {
    return TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_Name(value);
  }
  static inline bool Type_Parse(absl::string_view name, Type* value) {
    return TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kConfidenceFieldNumber = 2,
    kOtherTextFieldNumber = 3,
    kTypeFieldNumber = 1,
  };
  // .sensoris.protobuf.types.base.Confidence confidence = 2;
  bool has_confidence() const;
  void clear_confidence() ;
  const ::sensoris::protobuf::types::base::Confidence& confidence() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::Confidence* release_confidence();
  ::sensoris::protobuf::types::base::Confidence* mutable_confidence();
  void set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value);
  void unsafe_arena_set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value);
  ::sensoris::protobuf::types::base::Confidence* unsafe_arena_release_confidence();

  private:
  const ::sensoris::protobuf::types::base::Confidence& _internal_confidence() const;
  ::sensoris::protobuf::types::base::Confidence* _internal_mutable_confidence();

  public:
  // .google.protobuf.StringValue other_text = 3;
  bool has_other_text() const;
  void clear_other_text() ;
  const ::google::protobuf::StringValue& other_text() const;
  PROTOBUF_NODISCARD ::google::protobuf::StringValue* release_other_text();
  ::google::protobuf::StringValue* mutable_other_text();
  void set_allocated_other_text(::google::protobuf::StringValue* value);
  void unsafe_arena_set_allocated_other_text(::google::protobuf::StringValue* value);
  ::google::protobuf::StringValue* unsafe_arena_release_other_text();

  private:
  const ::google::protobuf::StringValue& _internal_other_text() const;
  ::google::protobuf::StringValue* _internal_mutable_other_text();

  public:
  // .sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence.TypeAndConfidence.Type type = 1;
  void clear_type() ;
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type type() const;
  void set_type(::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type value);

  private:
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type _internal_type() const;
  void _internal_set_type(::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type value);

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence.TypeAndConfidence)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::Confidence* confidence_;
    ::google::protobuf::StringValue* other_text_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2ftraffic_5fregulation_2eproto;
};// -------------------------------------------------------------------

class TrafficSign_ShapeAndConfidence final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.trafficregulation.TrafficSign.ShapeAndConfidence) */ {
 public:
  inline TrafficSign_ShapeAndConfidence() : TrafficSign_ShapeAndConfidence(nullptr) {}
  ~TrafficSign_ShapeAndConfidence() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TrafficSign_ShapeAndConfidence(::google::protobuf::internal::ConstantInitialized);

  inline TrafficSign_ShapeAndConfidence(const TrafficSign_ShapeAndConfidence& from)
      : TrafficSign_ShapeAndConfidence(nullptr, from) {}
  TrafficSign_ShapeAndConfidence(TrafficSign_ShapeAndConfidence&& from) noexcept
    : TrafficSign_ShapeAndConfidence() {
    *this = ::std::move(from);
  }

  inline TrafficSign_ShapeAndConfidence& operator=(const TrafficSign_ShapeAndConfidence& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrafficSign_ShapeAndConfidence& operator=(TrafficSign_ShapeAndConfidence&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrafficSign_ShapeAndConfidence& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrafficSign_ShapeAndConfidence* internal_default_instance() {
    return reinterpret_cast<const TrafficSign_ShapeAndConfidence*>(
               &_TrafficSign_ShapeAndConfidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(TrafficSign_ShapeAndConfidence& a, TrafficSign_ShapeAndConfidence& b) {
    a.Swap(&b);
  }
  inline void Swap(TrafficSign_ShapeAndConfidence* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrafficSign_ShapeAndConfidence* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrafficSign_ShapeAndConfidence* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrafficSign_ShapeAndConfidence>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TrafficSign_ShapeAndConfidence& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TrafficSign_ShapeAndConfidence& from) {
    TrafficSign_ShapeAndConfidence::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TrafficSign_ShapeAndConfidence* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.categories.trafficregulation.TrafficSign.ShapeAndConfidence";
  }
  protected:
  explicit TrafficSign_ShapeAndConfidence(::google::protobuf::Arena* arena);
  TrafficSign_ShapeAndConfidence(::google::protobuf::Arena* arena, const TrafficSign_ShapeAndConfidence& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Type = TrafficSign_ShapeAndConfidence_Type;
  static constexpr Type UNKNOWN_TYPE = TrafficSign_ShapeAndConfidence_Type_UNKNOWN_TYPE;
  static constexpr Type OTHER = TrafficSign_ShapeAndConfidence_Type_OTHER;
  static constexpr Type RECTANGLE = TrafficSign_ShapeAndConfidence_Type_RECTANGLE;
  static constexpr Type SQUARE = TrafficSign_ShapeAndConfidence_Type_SQUARE;
  static constexpr Type TRIANGLE_UP = TrafficSign_ShapeAndConfidence_Type_TRIANGLE_UP;
  static constexpr Type TRIANGLE_DOWN = TrafficSign_ShapeAndConfidence_Type_TRIANGLE_DOWN;
  static constexpr Type DIAMOND = TrafficSign_ShapeAndConfidence_Type_DIAMOND;
  static constexpr Type HEXAGON = TrafficSign_ShapeAndConfidence_Type_HEXAGON;
  static constexpr Type ROUND = TrafficSign_ShapeAndConfidence_Type_ROUND;
  static constexpr Type CROSS_BUCK = TrafficSign_ShapeAndConfidence_Type_CROSS_BUCK;
  static constexpr Type OCTAGON = TrafficSign_ShapeAndConfidence_Type_OCTAGON;
  static constexpr Type ELLIPSE = TrafficSign_ShapeAndConfidence_Type_ELLIPSE;
  static constexpr Type PENTAGON = TrafficSign_ShapeAndConfidence_Type_PENTAGON;
  static inline bool Type_IsValid(int value) {
    return TrafficSign_ShapeAndConfidence_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = TrafficSign_ShapeAndConfidence_Type_Type_MIN;
  static constexpr Type Type_MAX = TrafficSign_ShapeAndConfidence_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = TrafficSign_ShapeAndConfidence_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Type_descriptor() {
    return TrafficSign_ShapeAndConfidence_Type_descriptor();
  }
  template <typename T>
  static inline const std::string& Type_Name(T value) {
    return TrafficSign_ShapeAndConfidence_Type_Name(value);
  }
  static inline bool Type_Parse(absl::string_view name, Type* value) {
    return TrafficSign_ShapeAndConfidence_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kConfidenceFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // .sensoris.protobuf.types.base.Confidence confidence = 2;
  bool has_confidence() const;
  void clear_confidence() ;
  const ::sensoris::protobuf::types::base::Confidence& confidence() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::Confidence* release_confidence();
  ::sensoris::protobuf::types::base::Confidence* mutable_confidence();
  void set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value);
  void unsafe_arena_set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value);
  ::sensoris::protobuf::types::base::Confidence* unsafe_arena_release_confidence();

  private:
  const ::sensoris::protobuf::types::base::Confidence& _internal_confidence() const;
  ::sensoris::protobuf::types::base::Confidence* _internal_mutable_confidence();

  public:
  // .sensoris.protobuf.categories.trafficregulation.TrafficSign.ShapeAndConfidence.Type type = 1;
  void clear_type() ;
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ShapeAndConfidence_Type type() const;
  void set_type(::sensoris::protobuf::categories::trafficregulation::TrafficSign_ShapeAndConfidence_Type value);

  private:
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ShapeAndConfidence_Type _internal_type() const;
  void _internal_set_type(::sensoris::protobuf::categories::trafficregulation::TrafficSign_ShapeAndConfidence_Type value);

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.trafficregulation.TrafficSign.ShapeAndConfidence)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::Confidence* confidence_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2ftraffic_5fregulation_2eproto;
};// -------------------------------------------------------------------

class TrafficSign_PermanencyAndConfidence final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.trafficregulation.TrafficSign.PermanencyAndConfidence) */ {
 public:
  inline TrafficSign_PermanencyAndConfidence() : TrafficSign_PermanencyAndConfidence(nullptr) {}
  ~TrafficSign_PermanencyAndConfidence() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TrafficSign_PermanencyAndConfidence(::google::protobuf::internal::ConstantInitialized);

  inline TrafficSign_PermanencyAndConfidence(const TrafficSign_PermanencyAndConfidence& from)
      : TrafficSign_PermanencyAndConfidence(nullptr, from) {}
  TrafficSign_PermanencyAndConfidence(TrafficSign_PermanencyAndConfidence&& from) noexcept
    : TrafficSign_PermanencyAndConfidence() {
    *this = ::std::move(from);
  }

  inline TrafficSign_PermanencyAndConfidence& operator=(const TrafficSign_PermanencyAndConfidence& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrafficSign_PermanencyAndConfidence& operator=(TrafficSign_PermanencyAndConfidence&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrafficSign_PermanencyAndConfidence& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrafficSign_PermanencyAndConfidence* internal_default_instance() {
    return reinterpret_cast<const TrafficSign_PermanencyAndConfidence*>(
               &_TrafficSign_PermanencyAndConfidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(TrafficSign_PermanencyAndConfidence& a, TrafficSign_PermanencyAndConfidence& b) {
    a.Swap(&b);
  }
  inline void Swap(TrafficSign_PermanencyAndConfidence* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrafficSign_PermanencyAndConfidence* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrafficSign_PermanencyAndConfidence* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrafficSign_PermanencyAndConfidence>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TrafficSign_PermanencyAndConfidence& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TrafficSign_PermanencyAndConfidence& from) {
    TrafficSign_PermanencyAndConfidence::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TrafficSign_PermanencyAndConfidence* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.categories.trafficregulation.TrafficSign.PermanencyAndConfidence";
  }
  protected:
  explicit TrafficSign_PermanencyAndConfidence(::google::protobuf::Arena* arena);
  TrafficSign_PermanencyAndConfidence(::google::protobuf::Arena* arena, const TrafficSign_PermanencyAndConfidence& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Type = TrafficSign_PermanencyAndConfidence_Type;
  static constexpr Type UNKNOWN_TYPE = TrafficSign_PermanencyAndConfidence_Type_UNKNOWN_TYPE;
  static constexpr Type STATIC = TrafficSign_PermanencyAndConfidence_Type_STATIC;
  static constexpr Type VARIABLE = TrafficSign_PermanencyAndConfidence_Type_VARIABLE;
  static constexpr Type VARIABLE_ELECTRONICALLY = TrafficSign_PermanencyAndConfidence_Type_VARIABLE_ELECTRONICALLY;
  static constexpr Type VARIABLE_MECHANICALLY = TrafficSign_PermanencyAndConfidence_Type_VARIABLE_MECHANICALLY;
  static constexpr Type VARIABLE_DEACTIVATED = TrafficSign_PermanencyAndConfidence_Type_VARIABLE_DEACTIVATED;
  static inline bool Type_IsValid(int value) {
    return TrafficSign_PermanencyAndConfidence_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = TrafficSign_PermanencyAndConfidence_Type_Type_MIN;
  static constexpr Type Type_MAX = TrafficSign_PermanencyAndConfidence_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = TrafficSign_PermanencyAndConfidence_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Type_descriptor() {
    return TrafficSign_PermanencyAndConfidence_Type_descriptor();
  }
  template <typename T>
  static inline const std::string& Type_Name(T value) {
    return TrafficSign_PermanencyAndConfidence_Type_Name(value);
  }
  static inline bool Type_Parse(absl::string_view name, Type* value) {
    return TrafficSign_PermanencyAndConfidence_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kConfidenceFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // .sensoris.protobuf.types.base.Confidence confidence = 2;
  bool has_confidence() const;
  void clear_confidence() ;
  const ::sensoris::protobuf::types::base::Confidence& confidence() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::Confidence* release_confidence();
  ::sensoris::protobuf::types::base::Confidence* mutable_confidence();
  void set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value);
  void unsafe_arena_set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value);
  ::sensoris::protobuf::types::base::Confidence* unsafe_arena_release_confidence();

  private:
  const ::sensoris::protobuf::types::base::Confidence& _internal_confidence() const;
  ::sensoris::protobuf::types::base::Confidence* _internal_mutable_confidence();

  public:
  // .sensoris.protobuf.categories.trafficregulation.TrafficSign.PermanencyAndConfidence.Type type = 1;
  void clear_type() ;
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_PermanencyAndConfidence_Type type() const;
  void set_type(::sensoris::protobuf::categories::trafficregulation::TrafficSign_PermanencyAndConfidence_Type value);

  private:
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_PermanencyAndConfidence_Type _internal_type() const;
  void _internal_set_type(::sensoris::protobuf::categories::trafficregulation::TrafficSign_PermanencyAndConfidence_Type value);

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.trafficregulation.TrafficSign.PermanencyAndConfidence)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::Confidence* confidence_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2ftraffic_5fregulation_2eproto;
};// -------------------------------------------------------------------

class TrafficSign_DominantBackgroundColorAndConfidence final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.trafficregulation.TrafficSign.DominantBackgroundColorAndConfidence) */ {
 public:
  inline TrafficSign_DominantBackgroundColorAndConfidence() : TrafficSign_DominantBackgroundColorAndConfidence(nullptr) {}
  ~TrafficSign_DominantBackgroundColorAndConfidence() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TrafficSign_DominantBackgroundColorAndConfidence(::google::protobuf::internal::ConstantInitialized);

  inline TrafficSign_DominantBackgroundColorAndConfidence(const TrafficSign_DominantBackgroundColorAndConfidence& from)
      : TrafficSign_DominantBackgroundColorAndConfidence(nullptr, from) {}
  TrafficSign_DominantBackgroundColorAndConfidence(TrafficSign_DominantBackgroundColorAndConfidence&& from) noexcept
    : TrafficSign_DominantBackgroundColorAndConfidence() {
    *this = ::std::move(from);
  }

  inline TrafficSign_DominantBackgroundColorAndConfidence& operator=(const TrafficSign_DominantBackgroundColorAndConfidence& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrafficSign_DominantBackgroundColorAndConfidence& operator=(TrafficSign_DominantBackgroundColorAndConfidence&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrafficSign_DominantBackgroundColorAndConfidence& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrafficSign_DominantBackgroundColorAndConfidence* internal_default_instance() {
    return reinterpret_cast<const TrafficSign_DominantBackgroundColorAndConfidence*>(
               &_TrafficSign_DominantBackgroundColorAndConfidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(TrafficSign_DominantBackgroundColorAndConfidence& a, TrafficSign_DominantBackgroundColorAndConfidence& b) {
    a.Swap(&b);
  }
  inline void Swap(TrafficSign_DominantBackgroundColorAndConfidence* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrafficSign_DominantBackgroundColorAndConfidence* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrafficSign_DominantBackgroundColorAndConfidence* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrafficSign_DominantBackgroundColorAndConfidence>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TrafficSign_DominantBackgroundColorAndConfidence& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TrafficSign_DominantBackgroundColorAndConfidence& from) {
    TrafficSign_DominantBackgroundColorAndConfidence::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TrafficSign_DominantBackgroundColorAndConfidence* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.categories.trafficregulation.TrafficSign.DominantBackgroundColorAndConfidence";
  }
  protected:
  explicit TrafficSign_DominantBackgroundColorAndConfidence(::google::protobuf::Arena* arena);
  TrafficSign_DominantBackgroundColorAndConfidence(::google::protobuf::Arena* arena, const TrafficSign_DominantBackgroundColorAndConfidence& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Type = TrafficSign_DominantBackgroundColorAndConfidence_Type;
  static constexpr Type UNKNOWN_TYPE = TrafficSign_DominantBackgroundColorAndConfidence_Type_UNKNOWN_TYPE;
  static constexpr Type OTHER = TrafficSign_DominantBackgroundColorAndConfidence_Type_OTHER;
  static constexpr Type WHITE = TrafficSign_DominantBackgroundColorAndConfidence_Type_WHITE;
  static constexpr Type RED = TrafficSign_DominantBackgroundColorAndConfidence_Type_RED;
  static constexpr Type GREEN = TrafficSign_DominantBackgroundColorAndConfidence_Type_GREEN;
  static constexpr Type BLUE = TrafficSign_DominantBackgroundColorAndConfidence_Type_BLUE;
  static constexpr Type YELLOW = TrafficSign_DominantBackgroundColorAndConfidence_Type_YELLOW;
  static constexpr Type BLACK = TrafficSign_DominantBackgroundColorAndConfidence_Type_BLACK;
  static constexpr Type BROWN = TrafficSign_DominantBackgroundColorAndConfidence_Type_BROWN;
  static inline bool Type_IsValid(int value) {
    return TrafficSign_DominantBackgroundColorAndConfidence_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = TrafficSign_DominantBackgroundColorAndConfidence_Type_Type_MIN;
  static constexpr Type Type_MAX = TrafficSign_DominantBackgroundColorAndConfidence_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = TrafficSign_DominantBackgroundColorAndConfidence_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Type_descriptor() {
    return TrafficSign_DominantBackgroundColorAndConfidence_Type_descriptor();
  }
  template <typename T>
  static inline const std::string& Type_Name(T value) {
    return TrafficSign_DominantBackgroundColorAndConfidence_Type_Name(value);
  }
  static inline bool Type_Parse(absl::string_view name, Type* value) {
    return TrafficSign_DominantBackgroundColorAndConfidence_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kConfidenceFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // .sensoris.protobuf.types.base.Confidence confidence = 2;
  bool has_confidence() const;
  void clear_confidence() ;
  const ::sensoris::protobuf::types::base::Confidence& confidence() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::Confidence* release_confidence();
  ::sensoris::protobuf::types::base::Confidence* mutable_confidence();
  void set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value);
  void unsafe_arena_set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value);
  ::sensoris::protobuf::types::base::Confidence* unsafe_arena_release_confidence();

  private:
  const ::sensoris::protobuf::types::base::Confidence& _internal_confidence() const;
  ::sensoris::protobuf::types::base::Confidence* _internal_mutable_confidence();

  public:
  // .sensoris.protobuf.categories.trafficregulation.TrafficSign.DominantBackgroundColorAndConfidence.Type type = 1;
  void clear_type() ;
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_DominantBackgroundColorAndConfidence_Type type() const;
  void set_type(::sensoris::protobuf::categories::trafficregulation::TrafficSign_DominantBackgroundColorAndConfidence_Type value);

  private:
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_DominantBackgroundColorAndConfidence_Type _internal_type() const;
  void _internal_set_type(::sensoris::protobuf::categories::trafficregulation::TrafficSign_DominantBackgroundColorAndConfidence_Type value);

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.trafficregulation.TrafficSign.DominantBackgroundColorAndConfidence)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::Confidence* confidence_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2ftraffic_5fregulation_2eproto;
};// -------------------------------------------------------------------

class TrafficSign_SupplementarySignAndConfidence final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence) */ {
 public:
  inline TrafficSign_SupplementarySignAndConfidence() : TrafficSign_SupplementarySignAndConfidence(nullptr) {}
  ~TrafficSign_SupplementarySignAndConfidence() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TrafficSign_SupplementarySignAndConfidence(::google::protobuf::internal::ConstantInitialized);

  inline TrafficSign_SupplementarySignAndConfidence(const TrafficSign_SupplementarySignAndConfidence& from)
      : TrafficSign_SupplementarySignAndConfidence(nullptr, from) {}
  TrafficSign_SupplementarySignAndConfidence(TrafficSign_SupplementarySignAndConfidence&& from) noexcept
    : TrafficSign_SupplementarySignAndConfidence() {
    *this = ::std::move(from);
  }

  inline TrafficSign_SupplementarySignAndConfidence& operator=(const TrafficSign_SupplementarySignAndConfidence& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrafficSign_SupplementarySignAndConfidence& operator=(TrafficSign_SupplementarySignAndConfidence&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrafficSign_SupplementarySignAndConfidence& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrafficSign_SupplementarySignAndConfidence* internal_default_instance() {
    return reinterpret_cast<const TrafficSign_SupplementarySignAndConfidence*>(
               &_TrafficSign_SupplementarySignAndConfidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(TrafficSign_SupplementarySignAndConfidence& a, TrafficSign_SupplementarySignAndConfidence& b) {
    a.Swap(&b);
  }
  inline void Swap(TrafficSign_SupplementarySignAndConfidence* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrafficSign_SupplementarySignAndConfidence* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrafficSign_SupplementarySignAndConfidence* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrafficSign_SupplementarySignAndConfidence>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TrafficSign_SupplementarySignAndConfidence& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TrafficSign_SupplementarySignAndConfidence& from) {
    TrafficSign_SupplementarySignAndConfidence::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TrafficSign_SupplementarySignAndConfidence* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence";
  }
  protected:
  explicit TrafficSign_SupplementarySignAndConfidence(::google::protobuf::Arena* arena);
  TrafficSign_SupplementarySignAndConfidence(::google::protobuf::Arena* arena, const TrafficSign_SupplementarySignAndConfidence& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using TypeAndConfidence = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence;

  // accessors -------------------------------------------------------

  enum : int {
    kExistenceConfidenceFieldNumber = 1,
    kDetectionStatusFieldNumber = 2,
    kTypeAndConfidenceFieldNumber = 3,
    kValueAndConfidenceFieldNumber = 4,
  };
  // .sensoris.protobuf.types.base.Confidence existence_confidence = 1;
  bool has_existence_confidence() const;
  void clear_existence_confidence() ;
  const ::sensoris::protobuf::types::base::Confidence& existence_confidence() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::Confidence* release_existence_confidence();
  ::sensoris::protobuf::types::base::Confidence* mutable_existence_confidence();
  void set_allocated_existence_confidence(::sensoris::protobuf::types::base::Confidence* value);
  void unsafe_arena_set_allocated_existence_confidence(::sensoris::protobuf::types::base::Confidence* value);
  ::sensoris::protobuf::types::base::Confidence* unsafe_arena_release_existence_confidence();

  private:
  const ::sensoris::protobuf::types::base::Confidence& _internal_existence_confidence() const;
  ::sensoris::protobuf::types::base::Confidence* _internal_mutable_existence_confidence();

  public:
  // .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 2;
  bool has_detection_status() const;
  void clear_detection_status() ;
  const ::sensoris::protobuf::types::base::EventDetectionStatus& detection_status() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::EventDetectionStatus* release_detection_status();
  ::sensoris::protobuf::types::base::EventDetectionStatus* mutable_detection_status();
  void set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* value);
  void unsafe_arena_set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* value);
  ::sensoris::protobuf::types::base::EventDetectionStatus* unsafe_arena_release_detection_status();

  private:
  const ::sensoris::protobuf::types::base::EventDetectionStatus& _internal_detection_status() const;
  ::sensoris::protobuf::types::base::EventDetectionStatus* _internal_mutable_detection_status();

  public:
  // .sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence.TypeAndConfidence type_and_confidence = 3;
  bool has_type_and_confidence() const;
  void clear_type_and_confidence() ;
  const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence& type_and_confidence() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence* release_type_and_confidence();
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence* mutable_type_and_confidence();
  void set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence* value);
  void unsafe_arena_set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence* value);
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence* unsafe_arena_release_type_and_confidence();

  private:
  const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence& _internal_type_and_confidence() const;
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence* _internal_mutable_type_and_confidence();

  public:
  // .sensoris.protobuf.categories.trafficregulation.TrafficSign.ValueAndConfidence value_and_confidence = 4;
  bool has_value_and_confidence() const;
  void clear_value_and_confidence() ;
  const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence& value_and_confidence() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence* release_value_and_confidence();
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence* mutable_value_and_confidence();
  void set_allocated_value_and_confidence(::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence* value);
  void unsafe_arena_set_allocated_value_and_confidence(::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence* value);
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence* unsafe_arena_release_value_and_confidence();

  private:
  const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence& _internal_value_and_confidence() const;
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence* _internal_mutable_value_and_confidence();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 4,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::Confidence* existence_confidence_;
    ::sensoris::protobuf::types::base::EventDetectionStatus* detection_status_;
    ::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence* type_and_confidence_;
    ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence* value_and_confidence_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2ftraffic_5fregulation_2eproto;
};// -------------------------------------------------------------------

class TrafficSign final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.trafficregulation.TrafficSign) */ {
 public:
  inline TrafficSign() : TrafficSign(nullptr) {}
  ~TrafficSign() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TrafficSign(::google::protobuf::internal::ConstantInitialized);

  inline TrafficSign(const TrafficSign& from)
      : TrafficSign(nullptr, from) {}
  TrafficSign(TrafficSign&& from) noexcept
    : TrafficSign() {
    *this = ::std::move(from);
  }

  inline TrafficSign& operator=(const TrafficSign& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrafficSign& operator=(TrafficSign&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrafficSign& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrafficSign* internal_default_instance() {
    return reinterpret_cast<const TrafficSign*>(
               &_TrafficSign_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(TrafficSign& a, TrafficSign& b) {
    a.Swap(&b);
  }
  inline void Swap(TrafficSign* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrafficSign* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrafficSign* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrafficSign>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TrafficSign& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TrafficSign& from) {
    TrafficSign::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TrafficSign* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.categories.trafficregulation.TrafficSign";
  }
  protected:
  explicit TrafficSign(::google::protobuf::Arena* arena);
  TrafficSign(::google::protobuf::Arena* arena, const TrafficSign& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using ShapeAndConfidence = TrafficSign_ShapeAndConfidence;
  using TypeAndConfidence = TrafficSign_TypeAndConfidence;
  using ValueAndConfidence = TrafficSign_ValueAndConfidence;
  using PermanencyAndConfidence = TrafficSign_PermanencyAndConfidence;
  using ValidationAndConfidence = TrafficSign_ValidationAndConfidence;
  using DominantBackgroundColorAndConfidence = TrafficSign_DominantBackgroundColorAndConfidence;
  using SupplementarySignAndConfidence = TrafficSign_SupplementarySignAndConfidence;

  // accessors -------------------------------------------------------

  enum : int {
    kSupplementarySignAndConfidenceFieldNumber = 11,
    kEnvelopeFieldNumber = 1,
    kExistenceConfidenceFieldNumber = 2,
    kDetectionStatusFieldNumber = 3,
    kRectangularBoxAndAccuracyFieldNumber = 4,
    kShapeAndConfidenceFieldNumber = 5,
    kTypeAndConfidenceFieldNumber = 6,
    kValueAndConfidenceFieldNumber = 7,
    kPermanencyAndConfidenceFieldNumber = 8,
    kValidationAndConfidenceFieldNumber = 9,
    kBackgroundColorAndConfidenceFieldNumber = 10,
  };
  // repeated .sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence supplementary_sign_and_confidence = 11;
  int supplementary_sign_and_confidence_size() const;
  private:
  int _internal_supplementary_sign_and_confidence_size() const;

  public:
  void clear_supplementary_sign_and_confidence() ;
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence* mutable_supplementary_sign_and_confidence(int index);
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence >*
      mutable_supplementary_sign_and_confidence();
  private:
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence>& _internal_supplementary_sign_and_confidence() const;
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence>* _internal_mutable_supplementary_sign_and_confidence();
  public:
  const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence& supplementary_sign_and_confidence(int index) const;
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence* add_supplementary_sign_and_confidence();
  const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence >&
      supplementary_sign_and_confidence() const;
  // .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
  bool has_envelope() const;
  void clear_envelope() ;
  const ::sensoris::protobuf::types::base::EventEnvelope& envelope() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::EventEnvelope* release_envelope();
  ::sensoris::protobuf::types::base::EventEnvelope* mutable_envelope();
  void set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value);
  void unsafe_arena_set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value);
  ::sensoris::protobuf::types::base::EventEnvelope* unsafe_arena_release_envelope();

  private:
  const ::sensoris::protobuf::types::base::EventEnvelope& _internal_envelope() const;
  ::sensoris::protobuf::types::base::EventEnvelope* _internal_mutable_envelope();

  public:
  // .sensoris.protobuf.types.base.Confidence existence_confidence = 2;
  bool has_existence_confidence() const;
  void clear_existence_confidence() ;
  const ::sensoris::protobuf::types::base::Confidence& existence_confidence() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::Confidence* release_existence_confidence();
  ::sensoris::protobuf::types::base::Confidence* mutable_existence_confidence();
  void set_allocated_existence_confidence(::sensoris::protobuf::types::base::Confidence* value);
  void unsafe_arena_set_allocated_existence_confidence(::sensoris::protobuf::types::base::Confidence* value);
  ::sensoris::protobuf::types::base::Confidence* unsafe_arena_release_existence_confidence();

  private:
  const ::sensoris::protobuf::types::base::Confidence& _internal_existence_confidence() const;
  ::sensoris::protobuf::types::base::Confidence* _internal_mutable_existence_confidence();

  public:
  // .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 3;
  bool has_detection_status() const;
  void clear_detection_status() ;
  const ::sensoris::protobuf::types::base::EventDetectionStatus& detection_status() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::EventDetectionStatus* release_detection_status();
  ::sensoris::protobuf::types::base::EventDetectionStatus* mutable_detection_status();
  void set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* value);
  void unsafe_arena_set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* value);
  ::sensoris::protobuf::types::base::EventDetectionStatus* unsafe_arena_release_detection_status();

  private:
  const ::sensoris::protobuf::types::base::EventDetectionStatus& _internal_detection_status() const;
  ::sensoris::protobuf::types::base::EventDetectionStatus* _internal_mutable_detection_status();

  public:
  // .sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy rectangular_box_and_accuracy = 4;
  bool has_rectangular_box_and_accuracy() const;
  void clear_rectangular_box_and_accuracy() ;
  const ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy& rectangular_box_and_accuracy() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* release_rectangular_box_and_accuracy();
  ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* mutable_rectangular_box_and_accuracy();
  void set_allocated_rectangular_box_and_accuracy(::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* value);
  void unsafe_arena_set_allocated_rectangular_box_and_accuracy(::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* value);
  ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* unsafe_arena_release_rectangular_box_and_accuracy();

  private:
  const ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy& _internal_rectangular_box_and_accuracy() const;
  ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* _internal_mutable_rectangular_box_and_accuracy();

  public:
  // .sensoris.protobuf.categories.trafficregulation.TrafficSign.ShapeAndConfidence shape_and_confidence = 5;
  bool has_shape_and_confidence() const;
  void clear_shape_and_confidence() ;
  const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ShapeAndConfidence& shape_and_confidence() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ShapeAndConfidence* release_shape_and_confidence();
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ShapeAndConfidence* mutable_shape_and_confidence();
  void set_allocated_shape_and_confidence(::sensoris::protobuf::categories::trafficregulation::TrafficSign_ShapeAndConfidence* value);
  void unsafe_arena_set_allocated_shape_and_confidence(::sensoris::protobuf::categories::trafficregulation::TrafficSign_ShapeAndConfidence* value);
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ShapeAndConfidence* unsafe_arena_release_shape_and_confidence();

  private:
  const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ShapeAndConfidence& _internal_shape_and_confidence() const;
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ShapeAndConfidence* _internal_mutable_shape_and_confidence();

  public:
  // .sensoris.protobuf.categories.trafficregulation.TrafficSign.TypeAndConfidence type_and_confidence = 6;
  bool has_type_and_confidence() const;
  void clear_type_and_confidence() ;
  const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_TypeAndConfidence& type_and_confidence() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::categories::trafficregulation::TrafficSign_TypeAndConfidence* release_type_and_confidence();
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_TypeAndConfidence* mutable_type_and_confidence();
  void set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficregulation::TrafficSign_TypeAndConfidence* value);
  void unsafe_arena_set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficregulation::TrafficSign_TypeAndConfidence* value);
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_TypeAndConfidence* unsafe_arena_release_type_and_confidence();

  private:
  const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_TypeAndConfidence& _internal_type_and_confidence() const;
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_TypeAndConfidence* _internal_mutable_type_and_confidence();

  public:
  // .sensoris.protobuf.categories.trafficregulation.TrafficSign.ValueAndConfidence value_and_confidence = 7;
  bool has_value_and_confidence() const;
  void clear_value_and_confidence() ;
  const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence& value_and_confidence() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence* release_value_and_confidence();
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence* mutable_value_and_confidence();
  void set_allocated_value_and_confidence(::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence* value);
  void unsafe_arena_set_allocated_value_and_confidence(::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence* value);
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence* unsafe_arena_release_value_and_confidence();

  private:
  const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence& _internal_value_and_confidence() const;
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence* _internal_mutable_value_and_confidence();

  public:
  // .sensoris.protobuf.categories.trafficregulation.TrafficSign.PermanencyAndConfidence permanency_and_confidence = 8;
  bool has_permanency_and_confidence() const;
  void clear_permanency_and_confidence() ;
  const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_PermanencyAndConfidence& permanency_and_confidence() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::categories::trafficregulation::TrafficSign_PermanencyAndConfidence* release_permanency_and_confidence();
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_PermanencyAndConfidence* mutable_permanency_and_confidence();
  void set_allocated_permanency_and_confidence(::sensoris::protobuf::categories::trafficregulation::TrafficSign_PermanencyAndConfidence* value);
  void unsafe_arena_set_allocated_permanency_and_confidence(::sensoris::protobuf::categories::trafficregulation::TrafficSign_PermanencyAndConfidence* value);
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_PermanencyAndConfidence* unsafe_arena_release_permanency_and_confidence();

  private:
  const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_PermanencyAndConfidence& _internal_permanency_and_confidence() const;
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_PermanencyAndConfidence* _internal_mutable_permanency_and_confidence();

  public:
  // .sensoris.protobuf.categories.trafficregulation.TrafficSign.ValidationAndConfidence validation_and_confidence = 9;
  bool has_validation_and_confidence() const;
  void clear_validation_and_confidence() ;
  const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValidationAndConfidence& validation_and_confidence() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValidationAndConfidence* release_validation_and_confidence();
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValidationAndConfidence* mutable_validation_and_confidence();
  void set_allocated_validation_and_confidence(::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValidationAndConfidence* value);
  void unsafe_arena_set_allocated_validation_and_confidence(::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValidationAndConfidence* value);
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValidationAndConfidence* unsafe_arena_release_validation_and_confidence();

  private:
  const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValidationAndConfidence& _internal_validation_and_confidence() const;
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValidationAndConfidence* _internal_mutable_validation_and_confidence();

  public:
  // .sensoris.protobuf.categories.trafficregulation.TrafficSign.DominantBackgroundColorAndConfidence background_color_and_confidence = 10;
  bool has_background_color_and_confidence() const;
  void clear_background_color_and_confidence() ;
  const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_DominantBackgroundColorAndConfidence& background_color_and_confidence() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::categories::trafficregulation::TrafficSign_DominantBackgroundColorAndConfidence* release_background_color_and_confidence();
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_DominantBackgroundColorAndConfidence* mutable_background_color_and_confidence();
  void set_allocated_background_color_and_confidence(::sensoris::protobuf::categories::trafficregulation::TrafficSign_DominantBackgroundColorAndConfidence* value);
  void unsafe_arena_set_allocated_background_color_and_confidence(::sensoris::protobuf::categories::trafficregulation::TrafficSign_DominantBackgroundColorAndConfidence* value);
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_DominantBackgroundColorAndConfidence* unsafe_arena_release_background_color_and_confidence();

  private:
  const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_DominantBackgroundColorAndConfidence& _internal_background_color_and_confidence() const;
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_DominantBackgroundColorAndConfidence* _internal_mutable_background_color_and_confidence();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.trafficregulation.TrafficSign)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 11, 11,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence > supplementary_sign_and_confidence_;
    ::sensoris::protobuf::types::base::EventEnvelope* envelope_;
    ::sensoris::protobuf::types::base::Confidence* existence_confidence_;
    ::sensoris::protobuf::types::base::EventDetectionStatus* detection_status_;
    ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* rectangular_box_and_accuracy_;
    ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ShapeAndConfidence* shape_and_confidence_;
    ::sensoris::protobuf::categories::trafficregulation::TrafficSign_TypeAndConfidence* type_and_confidence_;
    ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence* value_and_confidence_;
    ::sensoris::protobuf::categories::trafficregulation::TrafficSign_PermanencyAndConfidence* permanency_and_confidence_;
    ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValidationAndConfidence* validation_and_confidence_;
    ::sensoris::protobuf::categories::trafficregulation::TrafficSign_DominantBackgroundColorAndConfidence* background_color_and_confidence_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2ftraffic_5fregulation_2eproto;
};// -------------------------------------------------------------------

class TrafficRegulationCategory final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.trafficregulation.TrafficRegulationCategory) */ {
 public:
  inline TrafficRegulationCategory() : TrafficRegulationCategory(nullptr) {}
  ~TrafficRegulationCategory() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TrafficRegulationCategory(::google::protobuf::internal::ConstantInitialized);

  inline TrafficRegulationCategory(const TrafficRegulationCategory& from)
      : TrafficRegulationCategory(nullptr, from) {}
  TrafficRegulationCategory(TrafficRegulationCategory&& from) noexcept
    : TrafficRegulationCategory() {
    *this = ::std::move(from);
  }

  inline TrafficRegulationCategory& operator=(const TrafficRegulationCategory& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrafficRegulationCategory& operator=(TrafficRegulationCategory&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrafficRegulationCategory& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrafficRegulationCategory* internal_default_instance() {
    return reinterpret_cast<const TrafficRegulationCategory*>(
               &_TrafficRegulationCategory_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(TrafficRegulationCategory& a, TrafficRegulationCategory& b) {
    a.Swap(&b);
  }
  inline void Swap(TrafficRegulationCategory* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrafficRegulationCategory* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrafficRegulationCategory* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrafficRegulationCategory>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TrafficRegulationCategory& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TrafficRegulationCategory& from) {
    TrafficRegulationCategory::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TrafficRegulationCategory* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.categories.trafficregulation.TrafficRegulationCategory";
  }
  protected:
  explicit TrafficRegulationCategory(::google::protobuf::Arena* arena);
  TrafficRegulationCategory(::google::protobuf::Arena* arena, const TrafficRegulationCategory& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrafficSignFieldNumber = 2,
    kEnvelopeFieldNumber = 1,
  };
  // repeated .sensoris.protobuf.categories.trafficregulation.TrafficSign traffic_sign = 2;
  int traffic_sign_size() const;
  private:
  int _internal_traffic_sign_size() const;

  public:
  void clear_traffic_sign() ;
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign* mutable_traffic_sign(int index);
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficregulation::TrafficSign >*
      mutable_traffic_sign();
  private:
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficregulation::TrafficSign>& _internal_traffic_sign() const;
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficregulation::TrafficSign>* _internal_mutable_traffic_sign();
  public:
  const ::sensoris::protobuf::categories::trafficregulation::TrafficSign& traffic_sign(int index) const;
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign* add_traffic_sign();
  const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficregulation::TrafficSign >&
      traffic_sign() const;
  // .sensoris.protobuf.types.base.CategoryEnvelope envelope = 1;
  bool has_envelope() const;
  void clear_envelope() ;
  const ::sensoris::protobuf::types::base::CategoryEnvelope& envelope() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::CategoryEnvelope* release_envelope();
  ::sensoris::protobuf::types::base::CategoryEnvelope* mutable_envelope();
  void set_allocated_envelope(::sensoris::protobuf::types::base::CategoryEnvelope* value);
  void unsafe_arena_set_allocated_envelope(::sensoris::protobuf::types::base::CategoryEnvelope* value);
  ::sensoris::protobuf::types::base::CategoryEnvelope* unsafe_arena_release_envelope();

  private:
  const ::sensoris::protobuf::types::base::CategoryEnvelope& _internal_envelope() const;
  ::sensoris::protobuf::types::base::CategoryEnvelope* _internal_mutable_envelope();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.trafficregulation.TrafficRegulationCategory)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficregulation::TrafficSign > traffic_sign_;
    ::sensoris::protobuf::types::base::CategoryEnvelope* envelope_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2ftraffic_5fregulation_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// TrafficSign_ShapeAndConfidence

// .sensoris.protobuf.categories.trafficregulation.TrafficSign.ShapeAndConfidence.Type type = 1;
inline void TrafficSign_ShapeAndConfidence::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ShapeAndConfidence_Type TrafficSign_ShapeAndConfidence::type() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficregulation.TrafficSign.ShapeAndConfidence.type)
  return _internal_type();
}
inline void TrafficSign_ShapeAndConfidence::set_type(::sensoris::protobuf::categories::trafficregulation::TrafficSign_ShapeAndConfidence_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.trafficregulation.TrafficSign.ShapeAndConfidence.type)
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ShapeAndConfidence_Type TrafficSign_ShapeAndConfidence::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::sensoris::protobuf::categories::trafficregulation::TrafficSign_ShapeAndConfidence_Type>(_impl_.type_);
}
inline void TrafficSign_ShapeAndConfidence::_internal_set_type(::sensoris::protobuf::categories::trafficregulation::TrafficSign_ShapeAndConfidence_Type value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// .sensoris.protobuf.types.base.Confidence confidence = 2;
inline bool TrafficSign_ShapeAndConfidence::has_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.confidence_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Confidence& TrafficSign_ShapeAndConfidence::_internal_confidence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::Confidence* p = _impl_.confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Confidence&>(::sensoris::protobuf::types::base::_Confidence_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Confidence& TrafficSign_ShapeAndConfidence::confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficregulation.TrafficSign.ShapeAndConfidence.confidence)
  return _internal_confidence();
}
inline void TrafficSign_ShapeAndConfidence::unsafe_arena_set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }
  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficregulation.TrafficSign.ShapeAndConfidence.confidence)
}
inline ::sensoris::protobuf::types::base::Confidence* TrafficSign_ShapeAndConfidence::release_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* released = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::Confidence* TrafficSign_ShapeAndConfidence::unsafe_arena_release_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficregulation.TrafficSign.ShapeAndConfidence.confidence)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* temp = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* TrafficSign_ShapeAndConfidence::_internal_mutable_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.confidence_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Confidence>(GetArena());
    _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(p);
  }
  return _impl_.confidence_;
}
inline ::sensoris::protobuf::types::base::Confidence* TrafficSign_ShapeAndConfidence::mutable_confidence() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::Confidence* _msg = _internal_mutable_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficregulation.TrafficSign.ShapeAndConfidence.confidence)
  return _msg;
}
inline void TrafficSign_ShapeAndConfidence::set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficregulation.TrafficSign.ShapeAndConfidence.confidence)
}

// -------------------------------------------------------------------

// TrafficSign_TypeAndConfidence

// .sensoris.protobuf.categories.trafficregulation.TrafficSign.TypeAndConfidence.Type type = 1;
inline void TrafficSign_TypeAndConfidence::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_TypeAndConfidence_Type TrafficSign_TypeAndConfidence::type() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficregulation.TrafficSign.TypeAndConfidence.type)
  return _internal_type();
}
inline void TrafficSign_TypeAndConfidence::set_type(::sensoris::protobuf::categories::trafficregulation::TrafficSign_TypeAndConfidence_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.trafficregulation.TrafficSign.TypeAndConfidence.type)
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_TypeAndConfidence_Type TrafficSign_TypeAndConfidence::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::sensoris::protobuf::categories::trafficregulation::TrafficSign_TypeAndConfidence_Type>(_impl_.type_);
}
inline void TrafficSign_TypeAndConfidence::_internal_set_type(::sensoris::protobuf::categories::trafficregulation::TrafficSign_TypeAndConfidence_Type value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// .sensoris.protobuf.types.base.Confidence confidence = 2;
inline bool TrafficSign_TypeAndConfidence::has_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.confidence_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Confidence& TrafficSign_TypeAndConfidence::_internal_confidence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::Confidence* p = _impl_.confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Confidence&>(::sensoris::protobuf::types::base::_Confidence_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Confidence& TrafficSign_TypeAndConfidence::confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficregulation.TrafficSign.TypeAndConfidence.confidence)
  return _internal_confidence();
}
inline void TrafficSign_TypeAndConfidence::unsafe_arena_set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }
  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficregulation.TrafficSign.TypeAndConfidence.confidence)
}
inline ::sensoris::protobuf::types::base::Confidence* TrafficSign_TypeAndConfidence::release_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* released = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::Confidence* TrafficSign_TypeAndConfidence::unsafe_arena_release_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficregulation.TrafficSign.TypeAndConfidence.confidence)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* temp = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* TrafficSign_TypeAndConfidence::_internal_mutable_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.confidence_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Confidence>(GetArena());
    _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(p);
  }
  return _impl_.confidence_;
}
inline ::sensoris::protobuf::types::base::Confidence* TrafficSign_TypeAndConfidence::mutable_confidence() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::Confidence* _msg = _internal_mutable_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficregulation.TrafficSign.TypeAndConfidence.confidence)
  return _msg;
}
inline void TrafficSign_TypeAndConfidence::set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficregulation.TrafficSign.TypeAndConfidence.confidence)
}

// .google.protobuf.StringValue other_text = 3;
inline bool TrafficSign_TypeAndConfidence::has_other_text() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.other_text_ != nullptr);
  return value;
}
inline const ::google::protobuf::StringValue& TrafficSign_TypeAndConfidence::_internal_other_text() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::StringValue* p = _impl_.other_text_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::StringValue&>(::google::protobuf::_StringValue_default_instance_);
}
inline const ::google::protobuf::StringValue& TrafficSign_TypeAndConfidence::other_text() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficregulation.TrafficSign.TypeAndConfidence.other_text)
  return _internal_other_text();
}
inline void TrafficSign_TypeAndConfidence::unsafe_arena_set_allocated_other_text(::google::protobuf::StringValue* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.other_text_);
  }
  _impl_.other_text_ = reinterpret_cast<::google::protobuf::StringValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficregulation.TrafficSign.TypeAndConfidence.other_text)
}
inline ::google::protobuf::StringValue* TrafficSign_TypeAndConfidence::release_other_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::StringValue* released = _impl_.other_text_;
  _impl_.other_text_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::StringValue* TrafficSign_TypeAndConfidence::unsafe_arena_release_other_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficregulation.TrafficSign.TypeAndConfidence.other_text)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::StringValue* temp = _impl_.other_text_;
  _impl_.other_text_ = nullptr;
  return temp;
}
inline ::google::protobuf::StringValue* TrafficSign_TypeAndConfidence::_internal_mutable_other_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.other_text_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::StringValue>(GetArena());
    _impl_.other_text_ = reinterpret_cast<::google::protobuf::StringValue*>(p);
  }
  return _impl_.other_text_;
}
inline ::google::protobuf::StringValue* TrafficSign_TypeAndConfidence::mutable_other_text() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::StringValue* _msg = _internal_mutable_other_text();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficregulation.TrafficSign.TypeAndConfidence.other_text)
  return _msg;
}
inline void TrafficSign_TypeAndConfidence::set_allocated_other_text(::google::protobuf::StringValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.other_text_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.other_text_ = reinterpret_cast<::google::protobuf::StringValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficregulation.TrafficSign.TypeAndConfidence.other_text)
}

// -------------------------------------------------------------------

// TrafficSign_ValueAndConfidence

// .google.protobuf.StringValue value = 1;
inline bool TrafficSign_ValueAndConfidence::has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.value_ != nullptr);
  return value;
}
inline const ::google::protobuf::StringValue& TrafficSign_ValueAndConfidence::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::StringValue* p = _impl_.value_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::StringValue&>(::google::protobuf::_StringValue_default_instance_);
}
inline const ::google::protobuf::StringValue& TrafficSign_ValueAndConfidence::value() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficregulation.TrafficSign.ValueAndConfidence.value)
  return _internal_value();
}
inline void TrafficSign_ValueAndConfidence::unsafe_arena_set_allocated_value(::google::protobuf::StringValue* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.value_);
  }
  _impl_.value_ = reinterpret_cast<::google::protobuf::StringValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficregulation.TrafficSign.ValueAndConfidence.value)
}
inline ::google::protobuf::StringValue* TrafficSign_ValueAndConfidence::release_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::StringValue* released = _impl_.value_;
  _impl_.value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::StringValue* TrafficSign_ValueAndConfidence::unsafe_arena_release_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficregulation.TrafficSign.ValueAndConfidence.value)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::StringValue* temp = _impl_.value_;
  _impl_.value_ = nullptr;
  return temp;
}
inline ::google::protobuf::StringValue* TrafficSign_ValueAndConfidence::_internal_mutable_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.value_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::StringValue>(GetArena());
    _impl_.value_ = reinterpret_cast<::google::protobuf::StringValue*>(p);
  }
  return _impl_.value_;
}
inline ::google::protobuf::StringValue* TrafficSign_ValueAndConfidence::mutable_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::StringValue* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficregulation.TrafficSign.ValueAndConfidence.value)
  return _msg;
}
inline void TrafficSign_ValueAndConfidence::set_allocated_value(::google::protobuf::StringValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.value_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.value_ = reinterpret_cast<::google::protobuf::StringValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficregulation.TrafficSign.ValueAndConfidence.value)
}

// .sensoris.protobuf.types.base.Confidence confidence = 2;
inline bool TrafficSign_ValueAndConfidence::has_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.confidence_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Confidence& TrafficSign_ValueAndConfidence::_internal_confidence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::Confidence* p = _impl_.confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Confidence&>(::sensoris::protobuf::types::base::_Confidence_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Confidence& TrafficSign_ValueAndConfidence::confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficregulation.TrafficSign.ValueAndConfidence.confidence)
  return _internal_confidence();
}
inline void TrafficSign_ValueAndConfidence::unsafe_arena_set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }
  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficregulation.TrafficSign.ValueAndConfidence.confidence)
}
inline ::sensoris::protobuf::types::base::Confidence* TrafficSign_ValueAndConfidence::release_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::Confidence* released = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::Confidence* TrafficSign_ValueAndConfidence::unsafe_arena_release_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficregulation.TrafficSign.ValueAndConfidence.confidence)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::Confidence* temp = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* TrafficSign_ValueAndConfidence::_internal_mutable_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.confidence_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Confidence>(GetArena());
    _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(p);
  }
  return _impl_.confidence_;
}
inline ::sensoris::protobuf::types::base::Confidence* TrafficSign_ValueAndConfidence::mutable_confidence() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::Confidence* _msg = _internal_mutable_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficregulation.TrafficSign.ValueAndConfidence.confidence)
  return _msg;
}
inline void TrafficSign_ValueAndConfidence::set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficregulation.TrafficSign.ValueAndConfidence.confidence)
}

// -------------------------------------------------------------------

// TrafficSign_PermanencyAndConfidence

// .sensoris.protobuf.categories.trafficregulation.TrafficSign.PermanencyAndConfidence.Type type = 1;
inline void TrafficSign_PermanencyAndConfidence::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_PermanencyAndConfidence_Type TrafficSign_PermanencyAndConfidence::type() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficregulation.TrafficSign.PermanencyAndConfidence.type)
  return _internal_type();
}
inline void TrafficSign_PermanencyAndConfidence::set_type(::sensoris::protobuf::categories::trafficregulation::TrafficSign_PermanencyAndConfidence_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.trafficregulation.TrafficSign.PermanencyAndConfidence.type)
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_PermanencyAndConfidence_Type TrafficSign_PermanencyAndConfidence::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::sensoris::protobuf::categories::trafficregulation::TrafficSign_PermanencyAndConfidence_Type>(_impl_.type_);
}
inline void TrafficSign_PermanencyAndConfidence::_internal_set_type(::sensoris::protobuf::categories::trafficregulation::TrafficSign_PermanencyAndConfidence_Type value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// .sensoris.protobuf.types.base.Confidence confidence = 2;
inline bool TrafficSign_PermanencyAndConfidence::has_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.confidence_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Confidence& TrafficSign_PermanencyAndConfidence::_internal_confidence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::Confidence* p = _impl_.confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Confidence&>(::sensoris::protobuf::types::base::_Confidence_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Confidence& TrafficSign_PermanencyAndConfidence::confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficregulation.TrafficSign.PermanencyAndConfidence.confidence)
  return _internal_confidence();
}
inline void TrafficSign_PermanencyAndConfidence::unsafe_arena_set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }
  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficregulation.TrafficSign.PermanencyAndConfidence.confidence)
}
inline ::sensoris::protobuf::types::base::Confidence* TrafficSign_PermanencyAndConfidence::release_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* released = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::Confidence* TrafficSign_PermanencyAndConfidence::unsafe_arena_release_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficregulation.TrafficSign.PermanencyAndConfidence.confidence)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* temp = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* TrafficSign_PermanencyAndConfidence::_internal_mutable_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.confidence_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Confidence>(GetArena());
    _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(p);
  }
  return _impl_.confidence_;
}
inline ::sensoris::protobuf::types::base::Confidence* TrafficSign_PermanencyAndConfidence::mutable_confidence() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::Confidence* _msg = _internal_mutable_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficregulation.TrafficSign.PermanencyAndConfidence.confidence)
  return _msg;
}
inline void TrafficSign_PermanencyAndConfidence::set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficregulation.TrafficSign.PermanencyAndConfidence.confidence)
}

// -------------------------------------------------------------------

// TrafficSign_ValidationAndConfidence

// .sensoris.protobuf.categories.trafficregulation.TrafficSign.ValidationAndConfidence.Type type = 1;
inline void TrafficSign_ValidationAndConfidence::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValidationAndConfidence_Type TrafficSign_ValidationAndConfidence::type() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficregulation.TrafficSign.ValidationAndConfidence.type)
  return _internal_type();
}
inline void TrafficSign_ValidationAndConfidence::set_type(::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValidationAndConfidence_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.trafficregulation.TrafficSign.ValidationAndConfidence.type)
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValidationAndConfidence_Type TrafficSign_ValidationAndConfidence::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValidationAndConfidence_Type>(_impl_.type_);
}
inline void TrafficSign_ValidationAndConfidence::_internal_set_type(::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValidationAndConfidence_Type value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// .sensoris.protobuf.types.base.Confidence confidence = 2;
inline bool TrafficSign_ValidationAndConfidence::has_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.confidence_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Confidence& TrafficSign_ValidationAndConfidence::_internal_confidence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::Confidence* p = _impl_.confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Confidence&>(::sensoris::protobuf::types::base::_Confidence_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Confidence& TrafficSign_ValidationAndConfidence::confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficregulation.TrafficSign.ValidationAndConfidence.confidence)
  return _internal_confidence();
}
inline void TrafficSign_ValidationAndConfidence::unsafe_arena_set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }
  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficregulation.TrafficSign.ValidationAndConfidence.confidence)
}
inline ::sensoris::protobuf::types::base::Confidence* TrafficSign_ValidationAndConfidence::release_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* released = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::Confidence* TrafficSign_ValidationAndConfidence::unsafe_arena_release_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficregulation.TrafficSign.ValidationAndConfidence.confidence)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* temp = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* TrafficSign_ValidationAndConfidence::_internal_mutable_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.confidence_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Confidence>(GetArena());
    _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(p);
  }
  return _impl_.confidence_;
}
inline ::sensoris::protobuf::types::base::Confidence* TrafficSign_ValidationAndConfidence::mutable_confidence() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::Confidence* _msg = _internal_mutable_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficregulation.TrafficSign.ValidationAndConfidence.confidence)
  return _msg;
}
inline void TrafficSign_ValidationAndConfidence::set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficregulation.TrafficSign.ValidationAndConfidence.confidence)
}

// -------------------------------------------------------------------

// TrafficSign_DominantBackgroundColorAndConfidence

// .sensoris.protobuf.categories.trafficregulation.TrafficSign.DominantBackgroundColorAndConfidence.Type type = 1;
inline void TrafficSign_DominantBackgroundColorAndConfidence::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_DominantBackgroundColorAndConfidence_Type TrafficSign_DominantBackgroundColorAndConfidence::type() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficregulation.TrafficSign.DominantBackgroundColorAndConfidence.type)
  return _internal_type();
}
inline void TrafficSign_DominantBackgroundColorAndConfidence::set_type(::sensoris::protobuf::categories::trafficregulation::TrafficSign_DominantBackgroundColorAndConfidence_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.trafficregulation.TrafficSign.DominantBackgroundColorAndConfidence.type)
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_DominantBackgroundColorAndConfidence_Type TrafficSign_DominantBackgroundColorAndConfidence::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::sensoris::protobuf::categories::trafficregulation::TrafficSign_DominantBackgroundColorAndConfidence_Type>(_impl_.type_);
}
inline void TrafficSign_DominantBackgroundColorAndConfidence::_internal_set_type(::sensoris::protobuf::categories::trafficregulation::TrafficSign_DominantBackgroundColorAndConfidence_Type value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// .sensoris.protobuf.types.base.Confidence confidence = 2;
inline bool TrafficSign_DominantBackgroundColorAndConfidence::has_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.confidence_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Confidence& TrafficSign_DominantBackgroundColorAndConfidence::_internal_confidence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::Confidence* p = _impl_.confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Confidence&>(::sensoris::protobuf::types::base::_Confidence_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Confidence& TrafficSign_DominantBackgroundColorAndConfidence::confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficregulation.TrafficSign.DominantBackgroundColorAndConfidence.confidence)
  return _internal_confidence();
}
inline void TrafficSign_DominantBackgroundColorAndConfidence::unsafe_arena_set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }
  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficregulation.TrafficSign.DominantBackgroundColorAndConfidence.confidence)
}
inline ::sensoris::protobuf::types::base::Confidence* TrafficSign_DominantBackgroundColorAndConfidence::release_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* released = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::Confidence* TrafficSign_DominantBackgroundColorAndConfidence::unsafe_arena_release_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficregulation.TrafficSign.DominantBackgroundColorAndConfidence.confidence)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* temp = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* TrafficSign_DominantBackgroundColorAndConfidence::_internal_mutable_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.confidence_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Confidence>(GetArena());
    _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(p);
  }
  return _impl_.confidence_;
}
inline ::sensoris::protobuf::types::base::Confidence* TrafficSign_DominantBackgroundColorAndConfidence::mutable_confidence() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::Confidence* _msg = _internal_mutable_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficregulation.TrafficSign.DominantBackgroundColorAndConfidence.confidence)
  return _msg;
}
inline void TrafficSign_DominantBackgroundColorAndConfidence::set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficregulation.TrafficSign.DominantBackgroundColorAndConfidence.confidence)
}

// -------------------------------------------------------------------

// TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence

// .sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence.TypeAndConfidence.Type type = 1;
inline void TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence::type() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence.TypeAndConfidence.type)
  return _internal_type();
}
inline void TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence::set_type(::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence.TypeAndConfidence.type)
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type>(_impl_.type_);
}
inline void TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence::_internal_set_type(::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// .sensoris.protobuf.types.base.Confidence confidence = 2;
inline bool TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence::has_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.confidence_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Confidence& TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence::_internal_confidence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::Confidence* p = _impl_.confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Confidence&>(::sensoris::protobuf::types::base::_Confidence_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Confidence& TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence::confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence.TypeAndConfidence.confidence)
  return _internal_confidence();
}
inline void TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence::unsafe_arena_set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }
  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence.TypeAndConfidence.confidence)
}
inline ::sensoris::protobuf::types::base::Confidence* TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence::release_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* released = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::Confidence* TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence::unsafe_arena_release_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence.TypeAndConfidence.confidence)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* temp = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence::_internal_mutable_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.confidence_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Confidence>(GetArena());
    _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(p);
  }
  return _impl_.confidence_;
}
inline ::sensoris::protobuf::types::base::Confidence* TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence::mutable_confidence() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::Confidence* _msg = _internal_mutable_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence.TypeAndConfidence.confidence)
  return _msg;
}
inline void TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence::set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence.TypeAndConfidence.confidence)
}

// .google.protobuf.StringValue other_text = 3;
inline bool TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence::has_other_text() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.other_text_ != nullptr);
  return value;
}
inline const ::google::protobuf::StringValue& TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence::_internal_other_text() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::StringValue* p = _impl_.other_text_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::StringValue&>(::google::protobuf::_StringValue_default_instance_);
}
inline const ::google::protobuf::StringValue& TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence::other_text() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence.TypeAndConfidence.other_text)
  return _internal_other_text();
}
inline void TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence::unsafe_arena_set_allocated_other_text(::google::protobuf::StringValue* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.other_text_);
  }
  _impl_.other_text_ = reinterpret_cast<::google::protobuf::StringValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence.TypeAndConfidence.other_text)
}
inline ::google::protobuf::StringValue* TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence::release_other_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::StringValue* released = _impl_.other_text_;
  _impl_.other_text_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::StringValue* TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence::unsafe_arena_release_other_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence.TypeAndConfidence.other_text)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::StringValue* temp = _impl_.other_text_;
  _impl_.other_text_ = nullptr;
  return temp;
}
inline ::google::protobuf::StringValue* TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence::_internal_mutable_other_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.other_text_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::StringValue>(GetArena());
    _impl_.other_text_ = reinterpret_cast<::google::protobuf::StringValue*>(p);
  }
  return _impl_.other_text_;
}
inline ::google::protobuf::StringValue* TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence::mutable_other_text() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::StringValue* _msg = _internal_mutable_other_text();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence.TypeAndConfidence.other_text)
  return _msg;
}
inline void TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence::set_allocated_other_text(::google::protobuf::StringValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.other_text_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.other_text_ = reinterpret_cast<::google::protobuf::StringValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence.TypeAndConfidence.other_text)
}

// -------------------------------------------------------------------

// TrafficSign_SupplementarySignAndConfidence

// .sensoris.protobuf.types.base.Confidence existence_confidence = 1;
inline bool TrafficSign_SupplementarySignAndConfidence::has_existence_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.existence_confidence_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Confidence& TrafficSign_SupplementarySignAndConfidence::_internal_existence_confidence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::Confidence* p = _impl_.existence_confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Confidence&>(::sensoris::protobuf::types::base::_Confidence_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Confidence& TrafficSign_SupplementarySignAndConfidence::existence_confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence.existence_confidence)
  return _internal_existence_confidence();
}
inline void TrafficSign_SupplementarySignAndConfidence::unsafe_arena_set_allocated_existence_confidence(::sensoris::protobuf::types::base::Confidence* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.existence_confidence_);
  }
  _impl_.existence_confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence.existence_confidence)
}
inline ::sensoris::protobuf::types::base::Confidence* TrafficSign_SupplementarySignAndConfidence::release_existence_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* released = _impl_.existence_confidence_;
  _impl_.existence_confidence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::Confidence* TrafficSign_SupplementarySignAndConfidence::unsafe_arena_release_existence_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence.existence_confidence)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* temp = _impl_.existence_confidence_;
  _impl_.existence_confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* TrafficSign_SupplementarySignAndConfidence::_internal_mutable_existence_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.existence_confidence_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Confidence>(GetArena());
    _impl_.existence_confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(p);
  }
  return _impl_.existence_confidence_;
}
inline ::sensoris::protobuf::types::base::Confidence* TrafficSign_SupplementarySignAndConfidence::mutable_existence_confidence() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::Confidence* _msg = _internal_mutable_existence_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence.existence_confidence)
  return _msg;
}
inline void TrafficSign_SupplementarySignAndConfidence::set_allocated_existence_confidence(::sensoris::protobuf::types::base::Confidence* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.existence_confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.existence_confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence.existence_confidence)
}

// .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 2;
inline bool TrafficSign_SupplementarySignAndConfidence::has_detection_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.detection_status_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::EventDetectionStatus& TrafficSign_SupplementarySignAndConfidence::_internal_detection_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::EventDetectionStatus* p = _impl_.detection_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::EventDetectionStatus&>(::sensoris::protobuf::types::base::_EventDetectionStatus_default_instance_);
}
inline const ::sensoris::protobuf::types::base::EventDetectionStatus& TrafficSign_SupplementarySignAndConfidence::detection_status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence.detection_status)
  return _internal_detection_status();
}
inline void TrafficSign_SupplementarySignAndConfidence::unsafe_arena_set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.detection_status_);
  }
  _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence.detection_status)
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* TrafficSign_SupplementarySignAndConfidence::release_detection_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::EventDetectionStatus* released = _impl_.detection_status_;
  _impl_.detection_status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* TrafficSign_SupplementarySignAndConfidence::unsafe_arena_release_detection_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence.detection_status)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::EventDetectionStatus* temp = _impl_.detection_status_;
  _impl_.detection_status_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* TrafficSign_SupplementarySignAndConfidence::_internal_mutable_detection_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.detection_status_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::EventDetectionStatus>(GetArena());
    _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(p);
  }
  return _impl_.detection_status_;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* TrafficSign_SupplementarySignAndConfidence::mutable_detection_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::EventDetectionStatus* _msg = _internal_mutable_detection_status();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence.detection_status)
  return _msg;
}
inline void TrafficSign_SupplementarySignAndConfidence::set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.detection_status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence.detection_status)
}

// .sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence.TypeAndConfidence type_and_confidence = 3;
inline bool TrafficSign_SupplementarySignAndConfidence::has_type_and_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.type_and_confidence_ != nullptr);
  return value;
}
inline void TrafficSign_SupplementarySignAndConfidence::clear_type_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.type_and_confidence_ != nullptr) _impl_.type_and_confidence_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence& TrafficSign_SupplementarySignAndConfidence::_internal_type_and_confidence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence* p = _impl_.type_and_confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence&>(::sensoris::protobuf::categories::trafficregulation::_TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_default_instance_);
}
inline const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence& TrafficSign_SupplementarySignAndConfidence::type_and_confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence.type_and_confidence)
  return _internal_type_and_confidence();
}
inline void TrafficSign_SupplementarySignAndConfidence::unsafe_arena_set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.type_and_confidence_);
  }
  _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence.type_and_confidence)
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence* TrafficSign_SupplementarySignAndConfidence::release_type_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence* released = _impl_.type_and_confidence_;
  _impl_.type_and_confidence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence* TrafficSign_SupplementarySignAndConfidence::unsafe_arena_release_type_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence.type_and_confidence)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence* temp = _impl_.type_and_confidence_;
  _impl_.type_and_confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence* TrafficSign_SupplementarySignAndConfidence::_internal_mutable_type_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.type_and_confidence_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence>(GetArena());
    _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence*>(p);
  }
  return _impl_.type_and_confidence_;
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence* TrafficSign_SupplementarySignAndConfidence::mutable_type_and_confidence() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence* _msg = _internal_mutable_type_and_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence.type_and_confidence)
  return _msg;
}
inline void TrafficSign_SupplementarySignAndConfidence::set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence*>(_impl_.type_and_confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence.type_and_confidence)
}

// .sensoris.protobuf.categories.trafficregulation.TrafficSign.ValueAndConfidence value_and_confidence = 4;
inline bool TrafficSign_SupplementarySignAndConfidence::has_value_and_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.value_and_confidence_ != nullptr);
  return value;
}
inline void TrafficSign_SupplementarySignAndConfidence::clear_value_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.value_and_confidence_ != nullptr) _impl_.value_and_confidence_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence& TrafficSign_SupplementarySignAndConfidence::_internal_value_and_confidence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence* p = _impl_.value_and_confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence&>(::sensoris::protobuf::categories::trafficregulation::_TrafficSign_ValueAndConfidence_default_instance_);
}
inline const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence& TrafficSign_SupplementarySignAndConfidence::value_and_confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence.value_and_confidence)
  return _internal_value_and_confidence();
}
inline void TrafficSign_SupplementarySignAndConfidence::unsafe_arena_set_allocated_value_and_confidence(::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.value_and_confidence_);
  }
  _impl_.value_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence.value_and_confidence)
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence* TrafficSign_SupplementarySignAndConfidence::release_value_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence* released = _impl_.value_and_confidence_;
  _impl_.value_and_confidence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence* TrafficSign_SupplementarySignAndConfidence::unsafe_arena_release_value_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence.value_and_confidence)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence* temp = _impl_.value_and_confidence_;
  _impl_.value_and_confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence* TrafficSign_SupplementarySignAndConfidence::_internal_mutable_value_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.value_and_confidence_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence>(GetArena());
    _impl_.value_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence*>(p);
  }
  return _impl_.value_and_confidence_;
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence* TrafficSign_SupplementarySignAndConfidence::mutable_value_and_confidence() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence* _msg = _internal_mutable_value_and_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence.value_and_confidence)
  return _msg;
}
inline void TrafficSign_SupplementarySignAndConfidence::set_allocated_value_and_confidence(::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence*>(_impl_.value_and_confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.value_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence.value_and_confidence)
}

// -------------------------------------------------------------------

// TrafficSign

// .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
inline bool TrafficSign::has_envelope() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.envelope_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& TrafficSign::_internal_envelope() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::EventEnvelope* p = _impl_.envelope_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::EventEnvelope&>(::sensoris::protobuf::types::base::_EventEnvelope_default_instance_);
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& TrafficSign::envelope() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficregulation.TrafficSign.envelope)
  return _internal_envelope();
}
inline void TrafficSign::unsafe_arena_set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }
  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficregulation.TrafficSign.envelope)
}
inline ::sensoris::protobuf::types::base::EventEnvelope* TrafficSign::release_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* released = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* TrafficSign::unsafe_arena_release_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficregulation.TrafficSign.envelope)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* temp = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* TrafficSign::_internal_mutable_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.envelope_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::EventEnvelope>(GetArena());
    _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(p);
  }
  return _impl_.envelope_;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* TrafficSign::mutable_envelope() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::EventEnvelope* _msg = _internal_mutable_envelope();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficregulation.TrafficSign.envelope)
  return _msg;
}
inline void TrafficSign::set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficregulation.TrafficSign.envelope)
}

// .sensoris.protobuf.types.base.Confidence existence_confidence = 2;
inline bool TrafficSign::has_existence_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.existence_confidence_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Confidence& TrafficSign::_internal_existence_confidence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::Confidence* p = _impl_.existence_confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Confidence&>(::sensoris::protobuf::types::base::_Confidence_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Confidence& TrafficSign::existence_confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficregulation.TrafficSign.existence_confidence)
  return _internal_existence_confidence();
}
inline void TrafficSign::unsafe_arena_set_allocated_existence_confidence(::sensoris::protobuf::types::base::Confidence* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.existence_confidence_);
  }
  _impl_.existence_confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficregulation.TrafficSign.existence_confidence)
}
inline ::sensoris::protobuf::types::base::Confidence* TrafficSign::release_existence_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::Confidence* released = _impl_.existence_confidence_;
  _impl_.existence_confidence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::Confidence* TrafficSign::unsafe_arena_release_existence_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficregulation.TrafficSign.existence_confidence)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::Confidence* temp = _impl_.existence_confidence_;
  _impl_.existence_confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* TrafficSign::_internal_mutable_existence_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.existence_confidence_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Confidence>(GetArena());
    _impl_.existence_confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(p);
  }
  return _impl_.existence_confidence_;
}
inline ::sensoris::protobuf::types::base::Confidence* TrafficSign::mutable_existence_confidence() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::Confidence* _msg = _internal_mutable_existence_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficregulation.TrafficSign.existence_confidence)
  return _msg;
}
inline void TrafficSign::set_allocated_existence_confidence(::sensoris::protobuf::types::base::Confidence* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.existence_confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.existence_confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficregulation.TrafficSign.existence_confidence)
}

// .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 3;
inline bool TrafficSign::has_detection_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.detection_status_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::EventDetectionStatus& TrafficSign::_internal_detection_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::EventDetectionStatus* p = _impl_.detection_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::EventDetectionStatus&>(::sensoris::protobuf::types::base::_EventDetectionStatus_default_instance_);
}
inline const ::sensoris::protobuf::types::base::EventDetectionStatus& TrafficSign::detection_status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficregulation.TrafficSign.detection_status)
  return _internal_detection_status();
}
inline void TrafficSign::unsafe_arena_set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.detection_status_);
  }
  _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficregulation.TrafficSign.detection_status)
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* TrafficSign::release_detection_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::types::base::EventDetectionStatus* released = _impl_.detection_status_;
  _impl_.detection_status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* TrafficSign::unsafe_arena_release_detection_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficregulation.TrafficSign.detection_status)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::types::base::EventDetectionStatus* temp = _impl_.detection_status_;
  _impl_.detection_status_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* TrafficSign::_internal_mutable_detection_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.detection_status_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::EventDetectionStatus>(GetArena());
    _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(p);
  }
  return _impl_.detection_status_;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* TrafficSign::mutable_detection_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::EventDetectionStatus* _msg = _internal_mutable_detection_status();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficregulation.TrafficSign.detection_status)
  return _msg;
}
inline void TrafficSign::set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.detection_status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficregulation.TrafficSign.detection_status)
}

// .sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy rectangular_box_and_accuracy = 4;
inline bool TrafficSign::has_rectangular_box_and_accuracy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rectangular_box_and_accuracy_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy& TrafficSign::_internal_rectangular_box_and_accuracy() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* p = _impl_.rectangular_box_and_accuracy_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy&>(::sensoris::protobuf::types::spatial::_RectangularBoxAndAccuracy_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy& TrafficSign::rectangular_box_and_accuracy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficregulation.TrafficSign.rectangular_box_and_accuracy)
  return _internal_rectangular_box_and_accuracy();
}
inline void TrafficSign::unsafe_arena_set_allocated_rectangular_box_and_accuracy(::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.rectangular_box_and_accuracy_);
  }
  _impl_.rectangular_box_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficregulation.TrafficSign.rectangular_box_and_accuracy)
}
inline ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* TrafficSign::release_rectangular_box_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* released = _impl_.rectangular_box_and_accuracy_;
  _impl_.rectangular_box_and_accuracy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* TrafficSign::unsafe_arena_release_rectangular_box_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficregulation.TrafficSign.rectangular_box_and_accuracy)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* temp = _impl_.rectangular_box_and_accuracy_;
  _impl_.rectangular_box_and_accuracy_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* TrafficSign::_internal_mutable_rectangular_box_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.rectangular_box_and_accuracy_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy>(GetArena());
    _impl_.rectangular_box_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy*>(p);
  }
  return _impl_.rectangular_box_and_accuracy_;
}
inline ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* TrafficSign::mutable_rectangular_box_and_accuracy() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* _msg = _internal_mutable_rectangular_box_and_accuracy();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficregulation.TrafficSign.rectangular_box_and_accuracy)
  return _msg;
}
inline void TrafficSign::set_allocated_rectangular_box_and_accuracy(::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.rectangular_box_and_accuracy_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.rectangular_box_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficregulation.TrafficSign.rectangular_box_and_accuracy)
}

// .sensoris.protobuf.categories.trafficregulation.TrafficSign.ShapeAndConfidence shape_and_confidence = 5;
inline bool TrafficSign::has_shape_and_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.shape_and_confidence_ != nullptr);
  return value;
}
inline void TrafficSign::clear_shape_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.shape_and_confidence_ != nullptr) _impl_.shape_and_confidence_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ShapeAndConfidence& TrafficSign::_internal_shape_and_confidence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ShapeAndConfidence* p = _impl_.shape_and_confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ShapeAndConfidence&>(::sensoris::protobuf::categories::trafficregulation::_TrafficSign_ShapeAndConfidence_default_instance_);
}
inline const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ShapeAndConfidence& TrafficSign::shape_and_confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficregulation.TrafficSign.shape_and_confidence)
  return _internal_shape_and_confidence();
}
inline void TrafficSign::unsafe_arena_set_allocated_shape_and_confidence(::sensoris::protobuf::categories::trafficregulation::TrafficSign_ShapeAndConfidence* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shape_and_confidence_);
  }
  _impl_.shape_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficregulation::TrafficSign_ShapeAndConfidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficregulation.TrafficSign.shape_and_confidence)
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ShapeAndConfidence* TrafficSign::release_shape_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ShapeAndConfidence* released = _impl_.shape_and_confidence_;
  _impl_.shape_and_confidence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ShapeAndConfidence* TrafficSign::unsafe_arena_release_shape_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficregulation.TrafficSign.shape_and_confidence)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ShapeAndConfidence* temp = _impl_.shape_and_confidence_;
  _impl_.shape_and_confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ShapeAndConfidence* TrafficSign::_internal_mutable_shape_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.shape_and_confidence_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::categories::trafficregulation::TrafficSign_ShapeAndConfidence>(GetArena());
    _impl_.shape_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficregulation::TrafficSign_ShapeAndConfidence*>(p);
  }
  return _impl_.shape_and_confidence_;
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ShapeAndConfidence* TrafficSign::mutable_shape_and_confidence() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ShapeAndConfidence* _msg = _internal_mutable_shape_and_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficregulation.TrafficSign.shape_and_confidence)
  return _msg;
}
inline void TrafficSign::set_allocated_shape_and_confidence(::sensoris::protobuf::categories::trafficregulation::TrafficSign_ShapeAndConfidence* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::sensoris::protobuf::categories::trafficregulation::TrafficSign_ShapeAndConfidence*>(_impl_.shape_and_confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::sensoris::protobuf::categories::trafficregulation::TrafficSign_ShapeAndConfidence*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.shape_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficregulation::TrafficSign_ShapeAndConfidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficregulation.TrafficSign.shape_and_confidence)
}

// .sensoris.protobuf.categories.trafficregulation.TrafficSign.TypeAndConfidence type_and_confidence = 6;
inline bool TrafficSign::has_type_and_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.type_and_confidence_ != nullptr);
  return value;
}
inline void TrafficSign::clear_type_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.type_and_confidence_ != nullptr) _impl_.type_and_confidence_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_TypeAndConfidence& TrafficSign::_internal_type_and_confidence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_TypeAndConfidence* p = _impl_.type_and_confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_TypeAndConfidence&>(::sensoris::protobuf::categories::trafficregulation::_TrafficSign_TypeAndConfidence_default_instance_);
}
inline const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_TypeAndConfidence& TrafficSign::type_and_confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficregulation.TrafficSign.type_and_confidence)
  return _internal_type_and_confidence();
}
inline void TrafficSign::unsafe_arena_set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficregulation::TrafficSign_TypeAndConfidence* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.type_and_confidence_);
  }
  _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficregulation::TrafficSign_TypeAndConfidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficregulation.TrafficSign.type_and_confidence)
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_TypeAndConfidence* TrafficSign::release_type_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_TypeAndConfidence* released = _impl_.type_and_confidence_;
  _impl_.type_and_confidence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_TypeAndConfidence* TrafficSign::unsafe_arena_release_type_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficregulation.TrafficSign.type_and_confidence)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_TypeAndConfidence* temp = _impl_.type_and_confidence_;
  _impl_.type_and_confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_TypeAndConfidence* TrafficSign::_internal_mutable_type_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.type_and_confidence_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::categories::trafficregulation::TrafficSign_TypeAndConfidence>(GetArena());
    _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficregulation::TrafficSign_TypeAndConfidence*>(p);
  }
  return _impl_.type_and_confidence_;
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_TypeAndConfidence* TrafficSign::mutable_type_and_confidence() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_TypeAndConfidence* _msg = _internal_mutable_type_and_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficregulation.TrafficSign.type_and_confidence)
  return _msg;
}
inline void TrafficSign::set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficregulation::TrafficSign_TypeAndConfidence* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::sensoris::protobuf::categories::trafficregulation::TrafficSign_TypeAndConfidence*>(_impl_.type_and_confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::sensoris::protobuf::categories::trafficregulation::TrafficSign_TypeAndConfidence*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficregulation::TrafficSign_TypeAndConfidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficregulation.TrafficSign.type_and_confidence)
}

// .sensoris.protobuf.categories.trafficregulation.TrafficSign.ValueAndConfidence value_and_confidence = 7;
inline bool TrafficSign::has_value_and_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.value_and_confidence_ != nullptr);
  return value;
}
inline void TrafficSign::clear_value_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.value_and_confidence_ != nullptr) _impl_.value_and_confidence_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence& TrafficSign::_internal_value_and_confidence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence* p = _impl_.value_and_confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence&>(::sensoris::protobuf::categories::trafficregulation::_TrafficSign_ValueAndConfidence_default_instance_);
}
inline const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence& TrafficSign::value_and_confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficregulation.TrafficSign.value_and_confidence)
  return _internal_value_and_confidence();
}
inline void TrafficSign::unsafe_arena_set_allocated_value_and_confidence(::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.value_and_confidence_);
  }
  _impl_.value_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficregulation.TrafficSign.value_and_confidence)
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence* TrafficSign::release_value_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence* released = _impl_.value_and_confidence_;
  _impl_.value_and_confidence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence* TrafficSign::unsafe_arena_release_value_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficregulation.TrafficSign.value_and_confidence)

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence* temp = _impl_.value_and_confidence_;
  _impl_.value_and_confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence* TrafficSign::_internal_mutable_value_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.value_and_confidence_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence>(GetArena());
    _impl_.value_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence*>(p);
  }
  return _impl_.value_and_confidence_;
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence* TrafficSign::mutable_value_and_confidence() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence* _msg = _internal_mutable_value_and_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficregulation.TrafficSign.value_and_confidence)
  return _msg;
}
inline void TrafficSign::set_allocated_value_and_confidence(::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence*>(_impl_.value_and_confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }

  _impl_.value_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficregulation.TrafficSign.value_and_confidence)
}

// .sensoris.protobuf.categories.trafficregulation.TrafficSign.PermanencyAndConfidence permanency_and_confidence = 8;
inline bool TrafficSign::has_permanency_and_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.permanency_and_confidence_ != nullptr);
  return value;
}
inline void TrafficSign::clear_permanency_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.permanency_and_confidence_ != nullptr) _impl_.permanency_and_confidence_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_PermanencyAndConfidence& TrafficSign::_internal_permanency_and_confidence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_PermanencyAndConfidence* p = _impl_.permanency_and_confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_PermanencyAndConfidence&>(::sensoris::protobuf::categories::trafficregulation::_TrafficSign_PermanencyAndConfidence_default_instance_);
}
inline const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_PermanencyAndConfidence& TrafficSign::permanency_and_confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficregulation.TrafficSign.permanency_and_confidence)
  return _internal_permanency_and_confidence();
}
inline void TrafficSign::unsafe_arena_set_allocated_permanency_and_confidence(::sensoris::protobuf::categories::trafficregulation::TrafficSign_PermanencyAndConfidence* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.permanency_and_confidence_);
  }
  _impl_.permanency_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficregulation::TrafficSign_PermanencyAndConfidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficregulation.TrafficSign.permanency_and_confidence)
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_PermanencyAndConfidence* TrafficSign::release_permanency_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_PermanencyAndConfidence* released = _impl_.permanency_and_confidence_;
  _impl_.permanency_and_confidence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_PermanencyAndConfidence* TrafficSign::unsafe_arena_release_permanency_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficregulation.TrafficSign.permanency_and_confidence)

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_PermanencyAndConfidence* temp = _impl_.permanency_and_confidence_;
  _impl_.permanency_and_confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_PermanencyAndConfidence* TrafficSign::_internal_mutable_permanency_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.permanency_and_confidence_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::categories::trafficregulation::TrafficSign_PermanencyAndConfidence>(GetArena());
    _impl_.permanency_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficregulation::TrafficSign_PermanencyAndConfidence*>(p);
  }
  return _impl_.permanency_and_confidence_;
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_PermanencyAndConfidence* TrafficSign::mutable_permanency_and_confidence() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_PermanencyAndConfidence* _msg = _internal_mutable_permanency_and_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficregulation.TrafficSign.permanency_and_confidence)
  return _msg;
}
inline void TrafficSign::set_allocated_permanency_and_confidence(::sensoris::protobuf::categories::trafficregulation::TrafficSign_PermanencyAndConfidence* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::sensoris::protobuf::categories::trafficregulation::TrafficSign_PermanencyAndConfidence*>(_impl_.permanency_and_confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::sensoris::protobuf::categories::trafficregulation::TrafficSign_PermanencyAndConfidence*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }

  _impl_.permanency_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficregulation::TrafficSign_PermanencyAndConfidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficregulation.TrafficSign.permanency_and_confidence)
}

// .sensoris.protobuf.categories.trafficregulation.TrafficSign.ValidationAndConfidence validation_and_confidence = 9;
inline bool TrafficSign::has_validation_and_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.validation_and_confidence_ != nullptr);
  return value;
}
inline void TrafficSign::clear_validation_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.validation_and_confidence_ != nullptr) _impl_.validation_and_confidence_->Clear();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValidationAndConfidence& TrafficSign::_internal_validation_and_confidence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValidationAndConfidence* p = _impl_.validation_and_confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValidationAndConfidence&>(::sensoris::protobuf::categories::trafficregulation::_TrafficSign_ValidationAndConfidence_default_instance_);
}
inline const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValidationAndConfidence& TrafficSign::validation_and_confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficregulation.TrafficSign.validation_and_confidence)
  return _internal_validation_and_confidence();
}
inline void TrafficSign::unsafe_arena_set_allocated_validation_and_confidence(::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValidationAndConfidence* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.validation_and_confidence_);
  }
  _impl_.validation_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValidationAndConfidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficregulation.TrafficSign.validation_and_confidence)
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValidationAndConfidence* TrafficSign::release_validation_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000100u;
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValidationAndConfidence* released = _impl_.validation_and_confidence_;
  _impl_.validation_and_confidence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValidationAndConfidence* TrafficSign::unsafe_arena_release_validation_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficregulation.TrafficSign.validation_and_confidence)

  _impl_._has_bits_[0] &= ~0x00000100u;
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValidationAndConfidence* temp = _impl_.validation_and_confidence_;
  _impl_.validation_and_confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValidationAndConfidence* TrafficSign::_internal_mutable_validation_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000100u;
  if (_impl_.validation_and_confidence_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValidationAndConfidence>(GetArena());
    _impl_.validation_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValidationAndConfidence*>(p);
  }
  return _impl_.validation_and_confidence_;
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValidationAndConfidence* TrafficSign::mutable_validation_and_confidence() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValidationAndConfidence* _msg = _internal_mutable_validation_and_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficregulation.TrafficSign.validation_and_confidence)
  return _msg;
}
inline void TrafficSign::set_allocated_validation_and_confidence(::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValidationAndConfidence* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValidationAndConfidence*>(_impl_.validation_and_confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValidationAndConfidence*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }

  _impl_.validation_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValidationAndConfidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficregulation.TrafficSign.validation_and_confidence)
}

// .sensoris.protobuf.categories.trafficregulation.TrafficSign.DominantBackgroundColorAndConfidence background_color_and_confidence = 10;
inline bool TrafficSign::has_background_color_and_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.background_color_and_confidence_ != nullptr);
  return value;
}
inline void TrafficSign::clear_background_color_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.background_color_and_confidence_ != nullptr) _impl_.background_color_and_confidence_->Clear();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_DominantBackgroundColorAndConfidence& TrafficSign::_internal_background_color_and_confidence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_DominantBackgroundColorAndConfidence* p = _impl_.background_color_and_confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_DominantBackgroundColorAndConfidence&>(::sensoris::protobuf::categories::trafficregulation::_TrafficSign_DominantBackgroundColorAndConfidence_default_instance_);
}
inline const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_DominantBackgroundColorAndConfidence& TrafficSign::background_color_and_confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficregulation.TrafficSign.background_color_and_confidence)
  return _internal_background_color_and_confidence();
}
inline void TrafficSign::unsafe_arena_set_allocated_background_color_and_confidence(::sensoris::protobuf::categories::trafficregulation::TrafficSign_DominantBackgroundColorAndConfidence* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.background_color_and_confidence_);
  }
  _impl_.background_color_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficregulation::TrafficSign_DominantBackgroundColorAndConfidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficregulation.TrafficSign.background_color_and_confidence)
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_DominantBackgroundColorAndConfidence* TrafficSign::release_background_color_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000200u;
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_DominantBackgroundColorAndConfidence* released = _impl_.background_color_and_confidence_;
  _impl_.background_color_and_confidence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_DominantBackgroundColorAndConfidence* TrafficSign::unsafe_arena_release_background_color_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficregulation.TrafficSign.background_color_and_confidence)

  _impl_._has_bits_[0] &= ~0x00000200u;
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_DominantBackgroundColorAndConfidence* temp = _impl_.background_color_and_confidence_;
  _impl_.background_color_and_confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_DominantBackgroundColorAndConfidence* TrafficSign::_internal_mutable_background_color_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000200u;
  if (_impl_.background_color_and_confidence_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::categories::trafficregulation::TrafficSign_DominantBackgroundColorAndConfidence>(GetArena());
    _impl_.background_color_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficregulation::TrafficSign_DominantBackgroundColorAndConfidence*>(p);
  }
  return _impl_.background_color_and_confidence_;
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_DominantBackgroundColorAndConfidence* TrafficSign::mutable_background_color_and_confidence() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_DominantBackgroundColorAndConfidence* _msg = _internal_mutable_background_color_and_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficregulation.TrafficSign.background_color_and_confidence)
  return _msg;
}
inline void TrafficSign::set_allocated_background_color_and_confidence(::sensoris::protobuf::categories::trafficregulation::TrafficSign_DominantBackgroundColorAndConfidence* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::sensoris::protobuf::categories::trafficregulation::TrafficSign_DominantBackgroundColorAndConfidence*>(_impl_.background_color_and_confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::sensoris::protobuf::categories::trafficregulation::TrafficSign_DominantBackgroundColorAndConfidence*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }

  _impl_.background_color_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficregulation::TrafficSign_DominantBackgroundColorAndConfidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficregulation.TrafficSign.background_color_and_confidence)
}

// repeated .sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence supplementary_sign_and_confidence = 11;
inline int TrafficSign::_internal_supplementary_sign_and_confidence_size() const {
  return _internal_supplementary_sign_and_confidence().size();
}
inline int TrafficSign::supplementary_sign_and_confidence_size() const {
  return _internal_supplementary_sign_and_confidence_size();
}
inline void TrafficSign::clear_supplementary_sign_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.supplementary_sign_and_confidence_.Clear();
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence* TrafficSign::mutable_supplementary_sign_and_confidence(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficregulation.TrafficSign.supplementary_sign_and_confidence)
  return _internal_mutable_supplementary_sign_and_confidence()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence>* TrafficSign::mutable_supplementary_sign_and_confidence()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.trafficregulation.TrafficSign.supplementary_sign_and_confidence)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_supplementary_sign_and_confidence();
}
inline const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence& TrafficSign::supplementary_sign_and_confidence(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficregulation.TrafficSign.supplementary_sign_and_confidence)
  return _internal_supplementary_sign_and_confidence().Get(index);
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence* TrafficSign::add_supplementary_sign_and_confidence() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence* _add = _internal_mutable_supplementary_sign_and_confidence()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.trafficregulation.TrafficSign.supplementary_sign_and_confidence)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence>& TrafficSign::supplementary_sign_and_confidence() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.trafficregulation.TrafficSign.supplementary_sign_and_confidence)
  return _internal_supplementary_sign_and_confidence();
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence>&
TrafficSign::_internal_supplementary_sign_and_confidence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.supplementary_sign_and_confidence_;
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence>*
TrafficSign::_internal_mutable_supplementary_sign_and_confidence() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.supplementary_sign_and_confidence_;
}

// -------------------------------------------------------------------

// TrafficRegulationCategory

// .sensoris.protobuf.types.base.CategoryEnvelope envelope = 1;
inline bool TrafficRegulationCategory::has_envelope() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.envelope_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::CategoryEnvelope& TrafficRegulationCategory::_internal_envelope() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::CategoryEnvelope* p = _impl_.envelope_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::CategoryEnvelope&>(::sensoris::protobuf::types::base::_CategoryEnvelope_default_instance_);
}
inline const ::sensoris::protobuf::types::base::CategoryEnvelope& TrafficRegulationCategory::envelope() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficregulation.TrafficRegulationCategory.envelope)
  return _internal_envelope();
}
inline void TrafficRegulationCategory::unsafe_arena_set_allocated_envelope(::sensoris::protobuf::types::base::CategoryEnvelope* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }
  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::CategoryEnvelope*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficregulation.TrafficRegulationCategory.envelope)
}
inline ::sensoris::protobuf::types::base::CategoryEnvelope* TrafficRegulationCategory::release_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::CategoryEnvelope* released = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::CategoryEnvelope* TrafficRegulationCategory::unsafe_arena_release_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficregulation.TrafficRegulationCategory.envelope)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::CategoryEnvelope* temp = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::CategoryEnvelope* TrafficRegulationCategory::_internal_mutable_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.envelope_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::CategoryEnvelope>(GetArena());
    _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::CategoryEnvelope*>(p);
  }
  return _impl_.envelope_;
}
inline ::sensoris::protobuf::types::base::CategoryEnvelope* TrafficRegulationCategory::mutable_envelope() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::CategoryEnvelope* _msg = _internal_mutable_envelope();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficregulation.TrafficRegulationCategory.envelope)
  return _msg;
}
inline void TrafficRegulationCategory::set_allocated_envelope(::sensoris::protobuf::types::base::CategoryEnvelope* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::CategoryEnvelope*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficregulation.TrafficRegulationCategory.envelope)
}

// repeated .sensoris.protobuf.categories.trafficregulation.TrafficSign traffic_sign = 2;
inline int TrafficRegulationCategory::_internal_traffic_sign_size() const {
  return _internal_traffic_sign().size();
}
inline int TrafficRegulationCategory::traffic_sign_size() const {
  return _internal_traffic_sign_size();
}
inline void TrafficRegulationCategory::clear_traffic_sign() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.traffic_sign_.Clear();
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign* TrafficRegulationCategory::mutable_traffic_sign(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficregulation.TrafficRegulationCategory.traffic_sign)
  return _internal_mutable_traffic_sign()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficregulation::TrafficSign>* TrafficRegulationCategory::mutable_traffic_sign()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.trafficregulation.TrafficRegulationCategory.traffic_sign)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_traffic_sign();
}
inline const ::sensoris::protobuf::categories::trafficregulation::TrafficSign& TrafficRegulationCategory::traffic_sign(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficregulation.TrafficRegulationCategory.traffic_sign)
  return _internal_traffic_sign().Get(index);
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign* TrafficRegulationCategory::add_traffic_sign() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign* _add = _internal_mutable_traffic_sign()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.trafficregulation.TrafficRegulationCategory.traffic_sign)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficregulation::TrafficSign>& TrafficRegulationCategory::traffic_sign() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.trafficregulation.TrafficRegulationCategory.traffic_sign)
  return _internal_traffic_sign();
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficregulation::TrafficSign>&
TrafficRegulationCategory::_internal_traffic_sign() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.traffic_sign_;
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficregulation::TrafficSign>*
TrafficRegulationCategory::_internal_mutable_traffic_sign() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.traffic_sign_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace trafficregulation
}  // namespace categories
}  // namespace protobuf
}  // namespace sensoris


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::sensoris::protobuf::categories::trafficregulation::TrafficSign_ShapeAndConfidence_Type> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::sensoris::protobuf::categories::trafficregulation::TrafficSign_ShapeAndConfidence_Type>() {
  return ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ShapeAndConfidence_Type_descriptor();
}
template <>
struct is_proto_enum<::sensoris::protobuf::categories::trafficregulation::TrafficSign_TypeAndConfidence_Type> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::sensoris::protobuf::categories::trafficregulation::TrafficSign_TypeAndConfidence_Type>() {
  return ::sensoris::protobuf::categories::trafficregulation::TrafficSign_TypeAndConfidence_Type_descriptor();
}
template <>
struct is_proto_enum<::sensoris::protobuf::categories::trafficregulation::TrafficSign_PermanencyAndConfidence_Type> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::sensoris::protobuf::categories::trafficregulation::TrafficSign_PermanencyAndConfidence_Type>() {
  return ::sensoris::protobuf::categories::trafficregulation::TrafficSign_PermanencyAndConfidence_Type_descriptor();
}
template <>
struct is_proto_enum<::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValidationAndConfidence_Type> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValidationAndConfidence_Type>() {
  return ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValidationAndConfidence_Type_descriptor();
}
template <>
struct is_proto_enum<::sensoris::protobuf::categories::trafficregulation::TrafficSign_DominantBackgroundColorAndConfidence_Type> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::sensoris::protobuf::categories::trafficregulation::TrafficSign_DominantBackgroundColorAndConfidence_Type>() {
  return ::sensoris::protobuf::categories::trafficregulation::TrafficSign_DominantBackgroundColorAndConfidence_Type_descriptor();
}
template <>
struct is_proto_enum<::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type>() {
  return ::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_sensoris_2fprotobuf_2fcategories_2ftraffic_5fregulation_2eproto_2epb_2eh
