// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sensoris/protobuf/categories/traffic_events.proto
// Protobuf C++ Version: 4.25.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "google/protobuf/wrappers.pb.h"
#include "sensoris/protobuf/types/base.pb.h"
#include "sensoris/protobuf/types/spatial.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto;
namespace sensoris {
namespace protobuf {
namespace categories {
namespace trafficevents {
class DangerousSlowDown;
struct DangerousSlowDownDefaultTypeInternal;
extern DangerousSlowDownDefaultTypeInternal _DangerousSlowDown_default_instance_;
class Hazard;
struct HazardDefaultTypeInternal;
extern HazardDefaultTypeInternal _Hazard_default_instance_;
class Hazard_TypeAndConfidence;
struct Hazard_TypeAndConfidenceDefaultTypeInternal;
extern Hazard_TypeAndConfidenceDefaultTypeInternal _Hazard_TypeAndConfidence_default_instance_;
class RoadWeatherCondition;
struct RoadWeatherConditionDefaultTypeInternal;
extern RoadWeatherConditionDefaultTypeInternal _RoadWeatherCondition_default_instance_;
class RoadWeatherCondition_TypeAndConfidence;
struct RoadWeatherCondition_TypeAndConfidenceDefaultTypeInternal;
extern RoadWeatherCondition_TypeAndConfidenceDefaultTypeInternal _RoadWeatherCondition_TypeAndConfidence_default_instance_;
class RoadWorks;
struct RoadWorksDefaultTypeInternal;
extern RoadWorksDefaultTypeInternal _RoadWorks_default_instance_;
class RoadWorks_TypeAndConfidence;
struct RoadWorks_TypeAndConfidenceDefaultTypeInternal;
extern RoadWorks_TypeAndConfidenceDefaultTypeInternal _RoadWorks_TypeAndConfidence_default_instance_;
class TrafficCondition;
struct TrafficConditionDefaultTypeInternal;
extern TrafficConditionDefaultTypeInternal _TrafficCondition_default_instance_;
class TrafficCondition_TypeAndConfidence;
struct TrafficCondition_TypeAndConfidenceDefaultTypeInternal;
extern TrafficCondition_TypeAndConfidenceDefaultTypeInternal _TrafficCondition_TypeAndConfidence_default_instance_;
class TrafficEventsCategory;
struct TrafficEventsCategoryDefaultTypeInternal;
extern TrafficEventsCategoryDefaultTypeInternal _TrafficEventsCategory_default_instance_;
}  // namespace trafficevents
}  // namespace categories
}  // namespace protobuf
}  // namespace sensoris
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace sensoris {
namespace protobuf {
namespace categories {
namespace trafficevents {
enum Hazard_TypeAndConfidence_Type : int {
  Hazard_TypeAndConfidence_Type_UNKNOWN_TYPE = 0,
  Hazard_TypeAndConfidence_Type_OBSTRUCTION = 1,
  Hazard_TypeAndConfidence_Type_ACCIDENT = 2,
  Hazard_TypeAndConfidence_Type_BROKEN_DOWN_VEHICLE = 3,
  Hazard_TypeAndConfidence_Type_SLOW_VEHICLE = 4,
  Hazard_TypeAndConfidence_Type_WRONG_WAY_VEHICLE = 5,
  Hazard_TypeAndConfidence_Type_ROADWORKS = 6,
  Hazard_TypeAndConfidence_Type_Hazard_TypeAndConfidence_Type_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Hazard_TypeAndConfidence_Type_Hazard_TypeAndConfidence_Type_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Hazard_TypeAndConfidence_Type_IsValid(int value);
extern const uint32_t Hazard_TypeAndConfidence_Type_internal_data_[];
constexpr Hazard_TypeAndConfidence_Type Hazard_TypeAndConfidence_Type_Type_MIN = static_cast<Hazard_TypeAndConfidence_Type>(0);
constexpr Hazard_TypeAndConfidence_Type Hazard_TypeAndConfidence_Type_Type_MAX = static_cast<Hazard_TypeAndConfidence_Type>(6);
constexpr int Hazard_TypeAndConfidence_Type_Type_ARRAYSIZE = 6 + 1;
const ::google::protobuf::EnumDescriptor*
Hazard_TypeAndConfidence_Type_descriptor();
template <typename T>
const std::string& Hazard_TypeAndConfidence_Type_Name(T value) {
  static_assert(std::is_same<T, Hazard_TypeAndConfidence_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return Hazard_TypeAndConfidence_Type_Name(static_cast<Hazard_TypeAndConfidence_Type>(value));
}
template <>
inline const std::string& Hazard_TypeAndConfidence_Type_Name(Hazard_TypeAndConfidence_Type value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Hazard_TypeAndConfidence_Type_descriptor,
                                                 0, 6>(
      static_cast<int>(value));
}
inline bool Hazard_TypeAndConfidence_Type_Parse(absl::string_view name, Hazard_TypeAndConfidence_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Hazard_TypeAndConfidence_Type>(
      Hazard_TypeAndConfidence_Type_descriptor(), name, value);
}
enum Hazard_Direction : int {
  Hazard_Direction_UNKNOWN_DIRECTION = 0,
  Hazard_Direction_EGO_DIRECTION = 1,
  Hazard_Direction_OPPOSITE_DIRECTION = 2,
  Hazard_Direction_BOTH = 3,
  Hazard_Direction_Hazard_Direction_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Hazard_Direction_Hazard_Direction_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Hazard_Direction_IsValid(int value);
extern const uint32_t Hazard_Direction_internal_data_[];
constexpr Hazard_Direction Hazard_Direction_Direction_MIN = static_cast<Hazard_Direction>(0);
constexpr Hazard_Direction Hazard_Direction_Direction_MAX = static_cast<Hazard_Direction>(3);
constexpr int Hazard_Direction_Direction_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
Hazard_Direction_descriptor();
template <typename T>
const std::string& Hazard_Direction_Name(T value) {
  static_assert(std::is_same<T, Hazard_Direction>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Direction_Name().");
  return Hazard_Direction_Name(static_cast<Hazard_Direction>(value));
}
template <>
inline const std::string& Hazard_Direction_Name(Hazard_Direction value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Hazard_Direction_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool Hazard_Direction_Parse(absl::string_view name, Hazard_Direction* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Hazard_Direction>(
      Hazard_Direction_descriptor(), name, value);
}
enum TrafficCondition_TypeAndConfidence_Type : int {
  TrafficCondition_TypeAndConfidence_Type_UNKNOWN_TYPE = 0,
  TrafficCondition_TypeAndConfidence_Type_FREE_FLOW = 1,
  TrafficCondition_TypeAndConfidence_Type_HEAVY = 2,
  TrafficCondition_TypeAndConfidence_Type_SLOW = 3,
  TrafficCondition_TypeAndConfidence_Type_QUEUING = 4,
  TrafficCondition_TypeAndConfidence_Type_STATIONARY = 5,
  TrafficCondition_TypeAndConfidence_Type_TrafficCondition_TypeAndConfidence_Type_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  TrafficCondition_TypeAndConfidence_Type_TrafficCondition_TypeAndConfidence_Type_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool TrafficCondition_TypeAndConfidence_Type_IsValid(int value);
extern const uint32_t TrafficCondition_TypeAndConfidence_Type_internal_data_[];
constexpr TrafficCondition_TypeAndConfidence_Type TrafficCondition_TypeAndConfidence_Type_Type_MIN = static_cast<TrafficCondition_TypeAndConfidence_Type>(0);
constexpr TrafficCondition_TypeAndConfidence_Type TrafficCondition_TypeAndConfidence_Type_Type_MAX = static_cast<TrafficCondition_TypeAndConfidence_Type>(5);
constexpr int TrafficCondition_TypeAndConfidence_Type_Type_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor*
TrafficCondition_TypeAndConfidence_Type_descriptor();
template <typename T>
const std::string& TrafficCondition_TypeAndConfidence_Type_Name(T value) {
  static_assert(std::is_same<T, TrafficCondition_TypeAndConfidence_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return TrafficCondition_TypeAndConfidence_Type_Name(static_cast<TrafficCondition_TypeAndConfidence_Type>(value));
}
template <>
inline const std::string& TrafficCondition_TypeAndConfidence_Type_Name(TrafficCondition_TypeAndConfidence_Type value) {
  return ::google::protobuf::internal::NameOfDenseEnum<TrafficCondition_TypeAndConfidence_Type_descriptor,
                                                 0, 5>(
      static_cast<int>(value));
}
inline bool TrafficCondition_TypeAndConfidence_Type_Parse(absl::string_view name, TrafficCondition_TypeAndConfidence_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrafficCondition_TypeAndConfidence_Type>(
      TrafficCondition_TypeAndConfidence_Type_descriptor(), name, value);
}
enum RoadWorks_TypeAndConfidence_Type : int {
  RoadWorks_TypeAndConfidence_Type_UNKNOWN_TYPE = 0,
  RoadWorks_TypeAndConfidence_Type_START = 1,
  RoadWorks_TypeAndConfidence_Type_END = 2,
  RoadWorks_TypeAndConfidence_Type_RoadWorks_TypeAndConfidence_Type_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  RoadWorks_TypeAndConfidence_Type_RoadWorks_TypeAndConfidence_Type_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool RoadWorks_TypeAndConfidence_Type_IsValid(int value);
extern const uint32_t RoadWorks_TypeAndConfidence_Type_internal_data_[];
constexpr RoadWorks_TypeAndConfidence_Type RoadWorks_TypeAndConfidence_Type_Type_MIN = static_cast<RoadWorks_TypeAndConfidence_Type>(0);
constexpr RoadWorks_TypeAndConfidence_Type RoadWorks_TypeAndConfidence_Type_Type_MAX = static_cast<RoadWorks_TypeAndConfidence_Type>(2);
constexpr int RoadWorks_TypeAndConfidence_Type_Type_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
RoadWorks_TypeAndConfidence_Type_descriptor();
template <typename T>
const std::string& RoadWorks_TypeAndConfidence_Type_Name(T value) {
  static_assert(std::is_same<T, RoadWorks_TypeAndConfidence_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return RoadWorks_TypeAndConfidence_Type_Name(static_cast<RoadWorks_TypeAndConfidence_Type>(value));
}
template <>
inline const std::string& RoadWorks_TypeAndConfidence_Type_Name(RoadWorks_TypeAndConfidence_Type value) {
  return ::google::protobuf::internal::NameOfDenseEnum<RoadWorks_TypeAndConfidence_Type_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool RoadWorks_TypeAndConfidence_Type_Parse(absl::string_view name, RoadWorks_TypeAndConfidence_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RoadWorks_TypeAndConfidence_Type>(
      RoadWorks_TypeAndConfidence_Type_descriptor(), name, value);
}
enum RoadWeatherCondition_TypeAndConfidence_Type : int {
  RoadWeatherCondition_TypeAndConfidence_Type_UNKNOWN_TYPE = 0,
  RoadWeatherCondition_TypeAndConfidence_Type_SNOW = 1,
  RoadWeatherCondition_TypeAndConfidence_Type_ICE = 2,
  RoadWeatherCondition_TypeAndConfidence_Type_FREEZING_RAIN = 3,
  RoadWeatherCondition_TypeAndConfidence_Type_FROST = 4,
  RoadWeatherCondition_TypeAndConfidence_Type_HYDROPLANING = 5,
  RoadWeatherCondition_TypeAndConfidence_Type_FLOODING = 6,
  RoadWeatherCondition_TypeAndConfidence_Type_RoadWeatherCondition_TypeAndConfidence_Type_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  RoadWeatherCondition_TypeAndConfidence_Type_RoadWeatherCondition_TypeAndConfidence_Type_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool RoadWeatherCondition_TypeAndConfidence_Type_IsValid(int value);
extern const uint32_t RoadWeatherCondition_TypeAndConfidence_Type_internal_data_[];
constexpr RoadWeatherCondition_TypeAndConfidence_Type RoadWeatherCondition_TypeAndConfidence_Type_Type_MIN = static_cast<RoadWeatherCondition_TypeAndConfidence_Type>(0);
constexpr RoadWeatherCondition_TypeAndConfidence_Type RoadWeatherCondition_TypeAndConfidence_Type_Type_MAX = static_cast<RoadWeatherCondition_TypeAndConfidence_Type>(6);
constexpr int RoadWeatherCondition_TypeAndConfidence_Type_Type_ARRAYSIZE = 6 + 1;
const ::google::protobuf::EnumDescriptor*
RoadWeatherCondition_TypeAndConfidence_Type_descriptor();
template <typename T>
const std::string& RoadWeatherCondition_TypeAndConfidence_Type_Name(T value) {
  static_assert(std::is_same<T, RoadWeatherCondition_TypeAndConfidence_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return RoadWeatherCondition_TypeAndConfidence_Type_Name(static_cast<RoadWeatherCondition_TypeAndConfidence_Type>(value));
}
template <>
inline const std::string& RoadWeatherCondition_TypeAndConfidence_Type_Name(RoadWeatherCondition_TypeAndConfidence_Type value) {
  return ::google::protobuf::internal::NameOfDenseEnum<RoadWeatherCondition_TypeAndConfidence_Type_descriptor,
                                                 0, 6>(
      static_cast<int>(value));
}
inline bool RoadWeatherCondition_TypeAndConfidence_Type_Parse(absl::string_view name, RoadWeatherCondition_TypeAndConfidence_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RoadWeatherCondition_TypeAndConfidence_Type>(
      RoadWeatherCondition_TypeAndConfidence_Type_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class TrafficCondition_TypeAndConfidence final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.trafficevents.TrafficCondition.TypeAndConfidence) */ {
 public:
  inline TrafficCondition_TypeAndConfidence() : TrafficCondition_TypeAndConfidence(nullptr) {}
  ~TrafficCondition_TypeAndConfidence() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TrafficCondition_TypeAndConfidence(::google::protobuf::internal::ConstantInitialized);

  inline TrafficCondition_TypeAndConfidence(const TrafficCondition_TypeAndConfidence& from)
      : TrafficCondition_TypeAndConfidence(nullptr, from) {}
  TrafficCondition_TypeAndConfidence(TrafficCondition_TypeAndConfidence&& from) noexcept
    : TrafficCondition_TypeAndConfidence() {
    *this = ::std::move(from);
  }

  inline TrafficCondition_TypeAndConfidence& operator=(const TrafficCondition_TypeAndConfidence& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrafficCondition_TypeAndConfidence& operator=(TrafficCondition_TypeAndConfidence&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrafficCondition_TypeAndConfidence& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrafficCondition_TypeAndConfidence* internal_default_instance() {
    return reinterpret_cast<const TrafficCondition_TypeAndConfidence*>(
               &_TrafficCondition_TypeAndConfidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(TrafficCondition_TypeAndConfidence& a, TrafficCondition_TypeAndConfidence& b) {
    a.Swap(&b);
  }
  inline void Swap(TrafficCondition_TypeAndConfidence* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrafficCondition_TypeAndConfidence* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrafficCondition_TypeAndConfidence* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrafficCondition_TypeAndConfidence>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TrafficCondition_TypeAndConfidence& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TrafficCondition_TypeAndConfidence& from) {
    TrafficCondition_TypeAndConfidence::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TrafficCondition_TypeAndConfidence* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.categories.trafficevents.TrafficCondition.TypeAndConfidence";
  }
  protected:
  explicit TrafficCondition_TypeAndConfidence(::google::protobuf::Arena* arena);
  TrafficCondition_TypeAndConfidence(::google::protobuf::Arena* arena, const TrafficCondition_TypeAndConfidence& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Type = TrafficCondition_TypeAndConfidence_Type;
  static constexpr Type UNKNOWN_TYPE = TrafficCondition_TypeAndConfidence_Type_UNKNOWN_TYPE;
  static constexpr Type FREE_FLOW = TrafficCondition_TypeAndConfidence_Type_FREE_FLOW;
  static constexpr Type HEAVY = TrafficCondition_TypeAndConfidence_Type_HEAVY;
  static constexpr Type SLOW = TrafficCondition_TypeAndConfidence_Type_SLOW;
  static constexpr Type QUEUING = TrafficCondition_TypeAndConfidence_Type_QUEUING;
  static constexpr Type STATIONARY = TrafficCondition_TypeAndConfidence_Type_STATIONARY;
  static inline bool Type_IsValid(int value) {
    return TrafficCondition_TypeAndConfidence_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = TrafficCondition_TypeAndConfidence_Type_Type_MIN;
  static constexpr Type Type_MAX = TrafficCondition_TypeAndConfidence_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = TrafficCondition_TypeAndConfidence_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Type_descriptor() {
    return TrafficCondition_TypeAndConfidence_Type_descriptor();
  }
  template <typename T>
  static inline const std::string& Type_Name(T value) {
    return TrafficCondition_TypeAndConfidence_Type_Name(value);
  }
  static inline bool Type_Parse(absl::string_view name, Type* value) {
    return TrafficCondition_TypeAndConfidence_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kConfidenceFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // .sensoris.protobuf.types.base.Confidence confidence = 2;
  bool has_confidence() const;
  void clear_confidence() ;
  const ::sensoris::protobuf::types::base::Confidence& confidence() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::Confidence* release_confidence();
  ::sensoris::protobuf::types::base::Confidence* mutable_confidence();
  void set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value);
  void unsafe_arena_set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value);
  ::sensoris::protobuf::types::base::Confidence* unsafe_arena_release_confidence();

  private:
  const ::sensoris::protobuf::types::base::Confidence& _internal_confidence() const;
  ::sensoris::protobuf::types::base::Confidence* _internal_mutable_confidence();

  public:
  // .sensoris.protobuf.categories.trafficevents.TrafficCondition.TypeAndConfidence.Type type = 1;
  void clear_type() ;
  ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence_Type type() const;
  void set_type(::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence_Type value);

  private:
  ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence_Type _internal_type() const;
  void _internal_set_type(::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence_Type value);

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.trafficevents.TrafficCondition.TypeAndConfidence)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::Confidence* confidence_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto;
};// -------------------------------------------------------------------

class RoadWorks_TypeAndConfidence final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.trafficevents.RoadWorks.TypeAndConfidence) */ {
 public:
  inline RoadWorks_TypeAndConfidence() : RoadWorks_TypeAndConfidence(nullptr) {}
  ~RoadWorks_TypeAndConfidence() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RoadWorks_TypeAndConfidence(::google::protobuf::internal::ConstantInitialized);

  inline RoadWorks_TypeAndConfidence(const RoadWorks_TypeAndConfidence& from)
      : RoadWorks_TypeAndConfidence(nullptr, from) {}
  RoadWorks_TypeAndConfidence(RoadWorks_TypeAndConfidence&& from) noexcept
    : RoadWorks_TypeAndConfidence() {
    *this = ::std::move(from);
  }

  inline RoadWorks_TypeAndConfidence& operator=(const RoadWorks_TypeAndConfidence& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoadWorks_TypeAndConfidence& operator=(RoadWorks_TypeAndConfidence&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoadWorks_TypeAndConfidence& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoadWorks_TypeAndConfidence* internal_default_instance() {
    return reinterpret_cast<const RoadWorks_TypeAndConfidence*>(
               &_RoadWorks_TypeAndConfidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(RoadWorks_TypeAndConfidence& a, RoadWorks_TypeAndConfidence& b) {
    a.Swap(&b);
  }
  inline void Swap(RoadWorks_TypeAndConfidence* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoadWorks_TypeAndConfidence* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoadWorks_TypeAndConfidence* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoadWorks_TypeAndConfidence>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RoadWorks_TypeAndConfidence& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RoadWorks_TypeAndConfidence& from) {
    RoadWorks_TypeAndConfidence::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RoadWorks_TypeAndConfidence* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.categories.trafficevents.RoadWorks.TypeAndConfidence";
  }
  protected:
  explicit RoadWorks_TypeAndConfidence(::google::protobuf::Arena* arena);
  RoadWorks_TypeAndConfidence(::google::protobuf::Arena* arena, const RoadWorks_TypeAndConfidence& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Type = RoadWorks_TypeAndConfidence_Type;
  static constexpr Type UNKNOWN_TYPE = RoadWorks_TypeAndConfidence_Type_UNKNOWN_TYPE;
  static constexpr Type START = RoadWorks_TypeAndConfidence_Type_START;
  static constexpr Type END = RoadWorks_TypeAndConfidence_Type_END;
  static inline bool Type_IsValid(int value) {
    return RoadWorks_TypeAndConfidence_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = RoadWorks_TypeAndConfidence_Type_Type_MIN;
  static constexpr Type Type_MAX = RoadWorks_TypeAndConfidence_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = RoadWorks_TypeAndConfidence_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Type_descriptor() {
    return RoadWorks_TypeAndConfidence_Type_descriptor();
  }
  template <typename T>
  static inline const std::string& Type_Name(T value) {
    return RoadWorks_TypeAndConfidence_Type_Name(value);
  }
  static inline bool Type_Parse(absl::string_view name, Type* value) {
    return RoadWorks_TypeAndConfidence_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kConfidenceFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // .sensoris.protobuf.types.base.Confidence confidence = 2;
  bool has_confidence() const;
  void clear_confidence() ;
  const ::sensoris::protobuf::types::base::Confidence& confidence() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::Confidence* release_confidence();
  ::sensoris::protobuf::types::base::Confidence* mutable_confidence();
  void set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value);
  void unsafe_arena_set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value);
  ::sensoris::protobuf::types::base::Confidence* unsafe_arena_release_confidence();

  private:
  const ::sensoris::protobuf::types::base::Confidence& _internal_confidence() const;
  ::sensoris::protobuf::types::base::Confidence* _internal_mutable_confidence();

  public:
  // .sensoris.protobuf.categories.trafficevents.RoadWorks.TypeAndConfidence.Type type = 1;
  void clear_type() ;
  ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence_Type type() const;
  void set_type(::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence_Type value);

  private:
  ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence_Type _internal_type() const;
  void _internal_set_type(::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence_Type value);

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.trafficevents.RoadWorks.TypeAndConfidence)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::Confidence* confidence_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto;
};// -------------------------------------------------------------------

class RoadWeatherCondition_TypeAndConfidence final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.TypeAndConfidence) */ {
 public:
  inline RoadWeatherCondition_TypeAndConfidence() : RoadWeatherCondition_TypeAndConfidence(nullptr) {}
  ~RoadWeatherCondition_TypeAndConfidence() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RoadWeatherCondition_TypeAndConfidence(::google::protobuf::internal::ConstantInitialized);

  inline RoadWeatherCondition_TypeAndConfidence(const RoadWeatherCondition_TypeAndConfidence& from)
      : RoadWeatherCondition_TypeAndConfidence(nullptr, from) {}
  RoadWeatherCondition_TypeAndConfidence(RoadWeatherCondition_TypeAndConfidence&& from) noexcept
    : RoadWeatherCondition_TypeAndConfidence() {
    *this = ::std::move(from);
  }

  inline RoadWeatherCondition_TypeAndConfidence& operator=(const RoadWeatherCondition_TypeAndConfidence& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoadWeatherCondition_TypeAndConfidence& operator=(RoadWeatherCondition_TypeAndConfidence&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoadWeatherCondition_TypeAndConfidence& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoadWeatherCondition_TypeAndConfidence* internal_default_instance() {
    return reinterpret_cast<const RoadWeatherCondition_TypeAndConfidence*>(
               &_RoadWeatherCondition_TypeAndConfidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(RoadWeatherCondition_TypeAndConfidence& a, RoadWeatherCondition_TypeAndConfidence& b) {
    a.Swap(&b);
  }
  inline void Swap(RoadWeatherCondition_TypeAndConfidence* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoadWeatherCondition_TypeAndConfidence* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoadWeatherCondition_TypeAndConfidence* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoadWeatherCondition_TypeAndConfidence>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RoadWeatherCondition_TypeAndConfidence& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RoadWeatherCondition_TypeAndConfidence& from) {
    RoadWeatherCondition_TypeAndConfidence::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RoadWeatherCondition_TypeAndConfidence* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.TypeAndConfidence";
  }
  protected:
  explicit RoadWeatherCondition_TypeAndConfidence(::google::protobuf::Arena* arena);
  RoadWeatherCondition_TypeAndConfidence(::google::protobuf::Arena* arena, const RoadWeatherCondition_TypeAndConfidence& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Type = RoadWeatherCondition_TypeAndConfidence_Type;
  static constexpr Type UNKNOWN_TYPE = RoadWeatherCondition_TypeAndConfidence_Type_UNKNOWN_TYPE;
  static constexpr Type SNOW = RoadWeatherCondition_TypeAndConfidence_Type_SNOW;
  static constexpr Type ICE = RoadWeatherCondition_TypeAndConfidence_Type_ICE;
  static constexpr Type FREEZING_RAIN = RoadWeatherCondition_TypeAndConfidence_Type_FREEZING_RAIN;
  static constexpr Type FROST = RoadWeatherCondition_TypeAndConfidence_Type_FROST;
  static constexpr Type HYDROPLANING = RoadWeatherCondition_TypeAndConfidence_Type_HYDROPLANING;
  static constexpr Type FLOODING = RoadWeatherCondition_TypeAndConfidence_Type_FLOODING;
  static inline bool Type_IsValid(int value) {
    return RoadWeatherCondition_TypeAndConfidence_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = RoadWeatherCondition_TypeAndConfidence_Type_Type_MIN;
  static constexpr Type Type_MAX = RoadWeatherCondition_TypeAndConfidence_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = RoadWeatherCondition_TypeAndConfidence_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Type_descriptor() {
    return RoadWeatherCondition_TypeAndConfidence_Type_descriptor();
  }
  template <typename T>
  static inline const std::string& Type_Name(T value) {
    return RoadWeatherCondition_TypeAndConfidence_Type_Name(value);
  }
  static inline bool Type_Parse(absl::string_view name, Type* value) {
    return RoadWeatherCondition_TypeAndConfidence_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kConfidenceFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // .sensoris.protobuf.types.base.Confidence confidence = 2;
  bool has_confidence() const;
  void clear_confidence() ;
  const ::sensoris::protobuf::types::base::Confidence& confidence() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::Confidence* release_confidence();
  ::sensoris::protobuf::types::base::Confidence* mutable_confidence();
  void set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value);
  void unsafe_arena_set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value);
  ::sensoris::protobuf::types::base::Confidence* unsafe_arena_release_confidence();

  private:
  const ::sensoris::protobuf::types::base::Confidence& _internal_confidence() const;
  ::sensoris::protobuf::types::base::Confidence* _internal_mutable_confidence();

  public:
  // .sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.TypeAndConfidence.Type type = 1;
  void clear_type() ;
  ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence_Type type() const;
  void set_type(::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence_Type value);

  private:
  ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence_Type _internal_type() const;
  void _internal_set_type(::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence_Type value);

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.TypeAndConfidence)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::Confidence* confidence_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto;
};// -------------------------------------------------------------------

class Hazard_TypeAndConfidence final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.trafficevents.Hazard.TypeAndConfidence) */ {
 public:
  inline Hazard_TypeAndConfidence() : Hazard_TypeAndConfidence(nullptr) {}
  ~Hazard_TypeAndConfidence() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Hazard_TypeAndConfidence(::google::protobuf::internal::ConstantInitialized);

  inline Hazard_TypeAndConfidence(const Hazard_TypeAndConfidence& from)
      : Hazard_TypeAndConfidence(nullptr, from) {}
  Hazard_TypeAndConfidence(Hazard_TypeAndConfidence&& from) noexcept
    : Hazard_TypeAndConfidence() {
    *this = ::std::move(from);
  }

  inline Hazard_TypeAndConfidence& operator=(const Hazard_TypeAndConfidence& from) {
    CopyFrom(from);
    return *this;
  }
  inline Hazard_TypeAndConfidence& operator=(Hazard_TypeAndConfidence&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Hazard_TypeAndConfidence& default_instance() {
    return *internal_default_instance();
  }
  static inline const Hazard_TypeAndConfidence* internal_default_instance() {
    return reinterpret_cast<const Hazard_TypeAndConfidence*>(
               &_Hazard_TypeAndConfidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Hazard_TypeAndConfidence& a, Hazard_TypeAndConfidence& b) {
    a.Swap(&b);
  }
  inline void Swap(Hazard_TypeAndConfidence* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Hazard_TypeAndConfidence* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Hazard_TypeAndConfidence* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Hazard_TypeAndConfidence>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Hazard_TypeAndConfidence& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Hazard_TypeAndConfidence& from) {
    Hazard_TypeAndConfidence::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Hazard_TypeAndConfidence* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.categories.trafficevents.Hazard.TypeAndConfidence";
  }
  protected:
  explicit Hazard_TypeAndConfidence(::google::protobuf::Arena* arena);
  Hazard_TypeAndConfidence(::google::protobuf::Arena* arena, const Hazard_TypeAndConfidence& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Type = Hazard_TypeAndConfidence_Type;
  static constexpr Type UNKNOWN_TYPE = Hazard_TypeAndConfidence_Type_UNKNOWN_TYPE;
  static constexpr Type OBSTRUCTION = Hazard_TypeAndConfidence_Type_OBSTRUCTION;
  static constexpr Type ACCIDENT = Hazard_TypeAndConfidence_Type_ACCIDENT;
  static constexpr Type BROKEN_DOWN_VEHICLE = Hazard_TypeAndConfidence_Type_BROKEN_DOWN_VEHICLE;
  static constexpr Type SLOW_VEHICLE = Hazard_TypeAndConfidence_Type_SLOW_VEHICLE;
  static constexpr Type WRONG_WAY_VEHICLE = Hazard_TypeAndConfidence_Type_WRONG_WAY_VEHICLE;
  static constexpr Type ROADWORKS = Hazard_TypeAndConfidence_Type_ROADWORKS;
  static inline bool Type_IsValid(int value) {
    return Hazard_TypeAndConfidence_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = Hazard_TypeAndConfidence_Type_Type_MIN;
  static constexpr Type Type_MAX = Hazard_TypeAndConfidence_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = Hazard_TypeAndConfidence_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Type_descriptor() {
    return Hazard_TypeAndConfidence_Type_descriptor();
  }
  template <typename T>
  static inline const std::string& Type_Name(T value) {
    return Hazard_TypeAndConfidence_Type_Name(value);
  }
  static inline bool Type_Parse(absl::string_view name, Type* value) {
    return Hazard_TypeAndConfidence_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kConfidenceFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // .sensoris.protobuf.types.base.Confidence confidence = 2;
  bool has_confidence() const;
  void clear_confidence() ;
  const ::sensoris::protobuf::types::base::Confidence& confidence() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::Confidence* release_confidence();
  ::sensoris::protobuf::types::base::Confidence* mutable_confidence();
  void set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value);
  void unsafe_arena_set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value);
  ::sensoris::protobuf::types::base::Confidence* unsafe_arena_release_confidence();

  private:
  const ::sensoris::protobuf::types::base::Confidence& _internal_confidence() const;
  ::sensoris::protobuf::types::base::Confidence* _internal_mutable_confidence();

  public:
  // .sensoris.protobuf.categories.trafficevents.Hazard.TypeAndConfidence.Type type = 1;
  void clear_type() ;
  ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence_Type type() const;
  void set_type(::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence_Type value);

  private:
  ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence_Type _internal_type() const;
  void _internal_set_type(::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence_Type value);

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.trafficevents.Hazard.TypeAndConfidence)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::Confidence* confidence_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto;
};// -------------------------------------------------------------------

class TrafficCondition final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.trafficevents.TrafficCondition) */ {
 public:
  inline TrafficCondition() : TrafficCondition(nullptr) {}
  ~TrafficCondition() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TrafficCondition(::google::protobuf::internal::ConstantInitialized);

  inline TrafficCondition(const TrafficCondition& from)
      : TrafficCondition(nullptr, from) {}
  TrafficCondition(TrafficCondition&& from) noexcept
    : TrafficCondition() {
    *this = ::std::move(from);
  }

  inline TrafficCondition& operator=(const TrafficCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrafficCondition& operator=(TrafficCondition&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrafficCondition& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrafficCondition* internal_default_instance() {
    return reinterpret_cast<const TrafficCondition*>(
               &_TrafficCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(TrafficCondition& a, TrafficCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(TrafficCondition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrafficCondition* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrafficCondition* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrafficCondition>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TrafficCondition& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TrafficCondition& from) {
    TrafficCondition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TrafficCondition* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.categories.trafficevents.TrafficCondition";
  }
  protected:
  explicit TrafficCondition(::google::protobuf::Arena* arena);
  TrafficCondition(::google::protobuf::Arena* arena, const TrafficCondition& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using TypeAndConfidence = TrafficCondition_TypeAndConfidence;

  // accessors -------------------------------------------------------

  enum : int {
    kEnvelopeFieldNumber = 1,
    kDetectionStatusFieldNumber = 2,
    kTypeAndConfidenceFieldNumber = 3,
  };
  // .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
  bool has_envelope() const;
  void clear_envelope() ;
  const ::sensoris::protobuf::types::base::EventEnvelope& envelope() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::EventEnvelope* release_envelope();
  ::sensoris::protobuf::types::base::EventEnvelope* mutable_envelope();
  void set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value);
  void unsafe_arena_set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value);
  ::sensoris::protobuf::types::base::EventEnvelope* unsafe_arena_release_envelope();

  private:
  const ::sensoris::protobuf::types::base::EventEnvelope& _internal_envelope() const;
  ::sensoris::protobuf::types::base::EventEnvelope* _internal_mutable_envelope();

  public:
  // .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 2;
  bool has_detection_status() const;
  void clear_detection_status() ;
  const ::sensoris::protobuf::types::base::EventDetectionStatus& detection_status() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::EventDetectionStatus* release_detection_status();
  ::sensoris::protobuf::types::base::EventDetectionStatus* mutable_detection_status();
  void set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* value);
  void unsafe_arena_set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* value);
  ::sensoris::protobuf::types::base::EventDetectionStatus* unsafe_arena_release_detection_status();

  private:
  const ::sensoris::protobuf::types::base::EventDetectionStatus& _internal_detection_status() const;
  ::sensoris::protobuf::types::base::EventDetectionStatus* _internal_mutable_detection_status();

  public:
  // .sensoris.protobuf.categories.trafficevents.TrafficCondition.TypeAndConfidence type_and_confidence = 3;
  bool has_type_and_confidence() const;
  void clear_type_and_confidence() ;
  const ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence& type_and_confidence() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence* release_type_and_confidence();
  ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence* mutable_type_and_confidence();
  void set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence* value);
  void unsafe_arena_set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence* value);
  ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence* unsafe_arena_release_type_and_confidence();

  private:
  const ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence& _internal_type_and_confidence() const;
  ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence* _internal_mutable_type_and_confidence();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.trafficevents.TrafficCondition)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::EventEnvelope* envelope_;
    ::sensoris::protobuf::types::base::EventDetectionStatus* detection_status_;
    ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence* type_and_confidence_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto;
};// -------------------------------------------------------------------

class RoadWorks final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.trafficevents.RoadWorks) */ {
 public:
  inline RoadWorks() : RoadWorks(nullptr) {}
  ~RoadWorks() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RoadWorks(::google::protobuf::internal::ConstantInitialized);

  inline RoadWorks(const RoadWorks& from)
      : RoadWorks(nullptr, from) {}
  RoadWorks(RoadWorks&& from) noexcept
    : RoadWorks() {
    *this = ::std::move(from);
  }

  inline RoadWorks& operator=(const RoadWorks& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoadWorks& operator=(RoadWorks&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoadWorks& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoadWorks* internal_default_instance() {
    return reinterpret_cast<const RoadWorks*>(
               &_RoadWorks_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(RoadWorks& a, RoadWorks& b) {
    a.Swap(&b);
  }
  inline void Swap(RoadWorks* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoadWorks* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoadWorks* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoadWorks>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RoadWorks& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RoadWorks& from) {
    RoadWorks::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RoadWorks* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.categories.trafficevents.RoadWorks";
  }
  protected:
  explicit RoadWorks(::google::protobuf::Arena* arena);
  RoadWorks(::google::protobuf::Arena* arena, const RoadWorks& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using TypeAndConfidence = RoadWorks_TypeAndConfidence;

  // accessors -------------------------------------------------------

  enum : int {
    kEnvelopeFieldNumber = 1,
    kDetectionStatusFieldNumber = 2,
    kTypeAndConfidenceFieldNumber = 3,
    kLanesClosedAndConfidenceFieldNumber = 5,
  };
  // .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
  bool has_envelope() const;
  void clear_envelope() ;
  const ::sensoris::protobuf::types::base::EventEnvelope& envelope() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::EventEnvelope* release_envelope();
  ::sensoris::protobuf::types::base::EventEnvelope* mutable_envelope();
  void set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value);
  void unsafe_arena_set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value);
  ::sensoris::protobuf::types::base::EventEnvelope* unsafe_arena_release_envelope();

  private:
  const ::sensoris::protobuf::types::base::EventEnvelope& _internal_envelope() const;
  ::sensoris::protobuf::types::base::EventEnvelope* _internal_mutable_envelope();

  public:
  // .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 2;
  bool has_detection_status() const;
  void clear_detection_status() ;
  const ::sensoris::protobuf::types::base::EventDetectionStatus& detection_status() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::EventDetectionStatus* release_detection_status();
  ::sensoris::protobuf::types::base::EventDetectionStatus* mutable_detection_status();
  void set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* value);
  void unsafe_arena_set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* value);
  ::sensoris::protobuf::types::base::EventDetectionStatus* unsafe_arena_release_detection_status();

  private:
  const ::sensoris::protobuf::types::base::EventDetectionStatus& _internal_detection_status() const;
  ::sensoris::protobuf::types::base::EventDetectionStatus* _internal_mutable_detection_status();

  public:
  // .sensoris.protobuf.categories.trafficevents.RoadWorks.TypeAndConfidence type_and_confidence = 3;
  bool has_type_and_confidence() const;
  void clear_type_and_confidence() ;
  const ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence& type_and_confidence() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence* release_type_and_confidence();
  ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence* mutable_type_and_confidence();
  void set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence* value);
  void unsafe_arena_set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence* value);
  ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence* unsafe_arena_release_type_and_confidence();

  private:
  const ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence& _internal_type_and_confidence() const;
  ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence* _internal_mutable_type_and_confidence();

  public:
  // .sensoris.protobuf.types.base.CountAndConfidence lanes_closed_and_confidence = 5;
  bool has_lanes_closed_and_confidence() const;
  void clear_lanes_closed_and_confidence() ;
  const ::sensoris::protobuf::types::base::CountAndConfidence& lanes_closed_and_confidence() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::CountAndConfidence* release_lanes_closed_and_confidence();
  ::sensoris::protobuf::types::base::CountAndConfidence* mutable_lanes_closed_and_confidence();
  void set_allocated_lanes_closed_and_confidence(::sensoris::protobuf::types::base::CountAndConfidence* value);
  void unsafe_arena_set_allocated_lanes_closed_and_confidence(::sensoris::protobuf::types::base::CountAndConfidence* value);
  ::sensoris::protobuf::types::base::CountAndConfidence* unsafe_arena_release_lanes_closed_and_confidence();

  private:
  const ::sensoris::protobuf::types::base::CountAndConfidence& _internal_lanes_closed_and_confidence() const;
  ::sensoris::protobuf::types::base::CountAndConfidence* _internal_mutable_lanes_closed_and_confidence();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.trafficevents.RoadWorks)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 4, 4,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::EventEnvelope* envelope_;
    ::sensoris::protobuf::types::base::EventDetectionStatus* detection_status_;
    ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence* type_and_confidence_;
    ::sensoris::protobuf::types::base::CountAndConfidence* lanes_closed_and_confidence_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto;
};// -------------------------------------------------------------------

class Hazard final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.trafficevents.Hazard) */ {
 public:
  inline Hazard() : Hazard(nullptr) {}
  ~Hazard() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Hazard(::google::protobuf::internal::ConstantInitialized);

  inline Hazard(const Hazard& from)
      : Hazard(nullptr, from) {}
  Hazard(Hazard&& from) noexcept
    : Hazard() {
    *this = ::std::move(from);
  }

  inline Hazard& operator=(const Hazard& from) {
    CopyFrom(from);
    return *this;
  }
  inline Hazard& operator=(Hazard&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Hazard& default_instance() {
    return *internal_default_instance();
  }
  static inline const Hazard* internal_default_instance() {
    return reinterpret_cast<const Hazard*>(
               &_Hazard_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Hazard& a, Hazard& b) {
    a.Swap(&b);
  }
  inline void Swap(Hazard* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Hazard* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Hazard* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Hazard>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Hazard& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Hazard& from) {
    Hazard::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Hazard* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.categories.trafficevents.Hazard";
  }
  protected:
  explicit Hazard(::google::protobuf::Arena* arena);
  Hazard(::google::protobuf::Arena* arena, const Hazard& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using TypeAndConfidence = Hazard_TypeAndConfidence;

  using Direction = Hazard_Direction;
  static constexpr Direction UNKNOWN_DIRECTION = Hazard_Direction_UNKNOWN_DIRECTION;
  static constexpr Direction EGO_DIRECTION = Hazard_Direction_EGO_DIRECTION;
  static constexpr Direction OPPOSITE_DIRECTION = Hazard_Direction_OPPOSITE_DIRECTION;
  static constexpr Direction BOTH = Hazard_Direction_BOTH;
  static inline bool Direction_IsValid(int value) {
    return Hazard_Direction_IsValid(value);
  }
  static constexpr Direction Direction_MIN = Hazard_Direction_Direction_MIN;
  static constexpr Direction Direction_MAX = Hazard_Direction_Direction_MAX;
  static constexpr int Direction_ARRAYSIZE = Hazard_Direction_Direction_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Direction_descriptor() {
    return Hazard_Direction_descriptor();
  }
  template <typename T>
  static inline const std::string& Direction_Name(T value) {
    return Hazard_Direction_Name(value);
  }
  static inline bool Direction_Parse(absl::string_view name, Direction* value) {
    return Hazard_Direction_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kEnvelopeFieldNumber = 1,
    kDetectionStatusFieldNumber = 2,
    kTypeAndConfidenceFieldNumber = 3,
    kDirectionFieldNumber = 4,
  };
  // .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
  bool has_envelope() const;
  void clear_envelope() ;
  const ::sensoris::protobuf::types::base::EventEnvelope& envelope() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::EventEnvelope* release_envelope();
  ::sensoris::protobuf::types::base::EventEnvelope* mutable_envelope();
  void set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value);
  void unsafe_arena_set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value);
  ::sensoris::protobuf::types::base::EventEnvelope* unsafe_arena_release_envelope();

  private:
  const ::sensoris::protobuf::types::base::EventEnvelope& _internal_envelope() const;
  ::sensoris::protobuf::types::base::EventEnvelope* _internal_mutable_envelope();

  public:
  // .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 2;
  bool has_detection_status() const;
  void clear_detection_status() ;
  const ::sensoris::protobuf::types::base::EventDetectionStatus& detection_status() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::EventDetectionStatus* release_detection_status();
  ::sensoris::protobuf::types::base::EventDetectionStatus* mutable_detection_status();
  void set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* value);
  void unsafe_arena_set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* value);
  ::sensoris::protobuf::types::base::EventDetectionStatus* unsafe_arena_release_detection_status();

  private:
  const ::sensoris::protobuf::types::base::EventDetectionStatus& _internal_detection_status() const;
  ::sensoris::protobuf::types::base::EventDetectionStatus* _internal_mutable_detection_status();

  public:
  // .sensoris.protobuf.categories.trafficevents.Hazard.TypeAndConfidence type_and_confidence = 3;
  bool has_type_and_confidence() const;
  void clear_type_and_confidence() ;
  const ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence& type_and_confidence() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence* release_type_and_confidence();
  ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence* mutable_type_and_confidence();
  void set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence* value);
  void unsafe_arena_set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence* value);
  ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence* unsafe_arena_release_type_and_confidence();

  private:
  const ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence& _internal_type_and_confidence() const;
  ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence* _internal_mutable_type_and_confidence();

  public:
  // .sensoris.protobuf.categories.trafficevents.Hazard.Direction direction = 4;
  void clear_direction() ;
  ::sensoris::protobuf::categories::trafficevents::Hazard_Direction direction() const;
  void set_direction(::sensoris::protobuf::categories::trafficevents::Hazard_Direction value);

  private:
  ::sensoris::protobuf::categories::trafficevents::Hazard_Direction _internal_direction() const;
  void _internal_set_direction(::sensoris::protobuf::categories::trafficevents::Hazard_Direction value);

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.trafficevents.Hazard)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::EventEnvelope* envelope_;
    ::sensoris::protobuf::types::base::EventDetectionStatus* detection_status_;
    ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence* type_and_confidence_;
    int direction_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto;
};// -------------------------------------------------------------------

class RoadWeatherCondition final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition) */ {
 public:
  inline RoadWeatherCondition() : RoadWeatherCondition(nullptr) {}
  ~RoadWeatherCondition() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RoadWeatherCondition(::google::protobuf::internal::ConstantInitialized);

  inline RoadWeatherCondition(const RoadWeatherCondition& from)
      : RoadWeatherCondition(nullptr, from) {}
  RoadWeatherCondition(RoadWeatherCondition&& from) noexcept
    : RoadWeatherCondition() {
    *this = ::std::move(from);
  }

  inline RoadWeatherCondition& operator=(const RoadWeatherCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoadWeatherCondition& operator=(RoadWeatherCondition&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoadWeatherCondition& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoadWeatherCondition* internal_default_instance() {
    return reinterpret_cast<const RoadWeatherCondition*>(
               &_RoadWeatherCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(RoadWeatherCondition& a, RoadWeatherCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(RoadWeatherCondition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoadWeatherCondition* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoadWeatherCondition* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoadWeatherCondition>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RoadWeatherCondition& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RoadWeatherCondition& from) {
    RoadWeatherCondition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RoadWeatherCondition* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.categories.trafficevents.RoadWeatherCondition";
  }
  protected:
  explicit RoadWeatherCondition(::google::protobuf::Arena* arena);
  RoadWeatherCondition(::google::protobuf::Arena* arena, const RoadWeatherCondition& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using TypeAndConfidence = RoadWeatherCondition_TypeAndConfidence;

  // accessors -------------------------------------------------------

  enum : int {
    kEnvelopeFieldNumber = 1,
    kDetectionStatusFieldNumber = 2,
    kTypeAndConfidenceFieldNumber = 3,
    kDepthAndAccuracyFieldNumber = 4,
  };
  // .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
  bool has_envelope() const;
  void clear_envelope() ;
  const ::sensoris::protobuf::types::base::EventEnvelope& envelope() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::EventEnvelope* release_envelope();
  ::sensoris::protobuf::types::base::EventEnvelope* mutable_envelope();
  void set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value);
  void unsafe_arena_set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value);
  ::sensoris::protobuf::types::base::EventEnvelope* unsafe_arena_release_envelope();

  private:
  const ::sensoris::protobuf::types::base::EventEnvelope& _internal_envelope() const;
  ::sensoris::protobuf::types::base::EventEnvelope* _internal_mutable_envelope();

  public:
  // .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 2;
  bool has_detection_status() const;
  void clear_detection_status() ;
  const ::sensoris::protobuf::types::base::EventDetectionStatus& detection_status() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::EventDetectionStatus* release_detection_status();
  ::sensoris::protobuf::types::base::EventDetectionStatus* mutable_detection_status();
  void set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* value);
  void unsafe_arena_set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* value);
  ::sensoris::protobuf::types::base::EventDetectionStatus* unsafe_arena_release_detection_status();

  private:
  const ::sensoris::protobuf::types::base::EventDetectionStatus& _internal_detection_status() const;
  ::sensoris::protobuf::types::base::EventDetectionStatus* _internal_mutable_detection_status();

  public:
  // .sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.TypeAndConfidence type_and_confidence = 3;
  bool has_type_and_confidence() const;
  void clear_type_and_confidence() ;
  const ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence& type_and_confidence() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence* release_type_and_confidence();
  ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence* mutable_type_and_confidence();
  void set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence* value);
  void unsafe_arena_set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence* value);
  ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence* unsafe_arena_release_type_and_confidence();

  private:
  const ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence& _internal_type_and_confidence() const;
  ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence* _internal_mutable_type_and_confidence();

  public:
  // .sensoris.protobuf.types.base.Int64ValueAndAccuracy depth_and_accuracy = 4 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_depth_and_accuracy() const;
  void clear_depth_and_accuracy() ;
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& depth_and_accuracy() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* release_depth_and_accuracy();
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* mutable_depth_and_accuracy();
  void set_allocated_depth_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* value);
  void unsafe_arena_set_allocated_depth_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* value);
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* unsafe_arena_release_depth_and_accuracy();

  private:
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& _internal_depth_and_accuracy() const;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* _internal_mutable_depth_and_accuracy();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 4,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::EventEnvelope* envelope_;
    ::sensoris::protobuf::types::base::EventDetectionStatus* detection_status_;
    ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence* type_and_confidence_;
    ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* depth_and_accuracy_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto;
};// -------------------------------------------------------------------

class DangerousSlowDown final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.trafficevents.DangerousSlowDown) */ {
 public:
  inline DangerousSlowDown() : DangerousSlowDown(nullptr) {}
  ~DangerousSlowDown() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DangerousSlowDown(::google::protobuf::internal::ConstantInitialized);

  inline DangerousSlowDown(const DangerousSlowDown& from)
      : DangerousSlowDown(nullptr, from) {}
  DangerousSlowDown(DangerousSlowDown&& from) noexcept
    : DangerousSlowDown() {
    *this = ::std::move(from);
  }

  inline DangerousSlowDown& operator=(const DangerousSlowDown& from) {
    CopyFrom(from);
    return *this;
  }
  inline DangerousSlowDown& operator=(DangerousSlowDown&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DangerousSlowDown& default_instance() {
    return *internal_default_instance();
  }
  static inline const DangerousSlowDown* internal_default_instance() {
    return reinterpret_cast<const DangerousSlowDown*>(
               &_DangerousSlowDown_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(DangerousSlowDown& a, DangerousSlowDown& b) {
    a.Swap(&b);
  }
  inline void Swap(DangerousSlowDown* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DangerousSlowDown* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DangerousSlowDown* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DangerousSlowDown>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DangerousSlowDown& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DangerousSlowDown& from) {
    DangerousSlowDown::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DangerousSlowDown* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.categories.trafficevents.DangerousSlowDown";
  }
  protected:
  explicit DangerousSlowDown(::google::protobuf::Arena* arena);
  DangerousSlowDown(::google::protobuf::Arena* arena, const DangerousSlowDown& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnvelopeFieldNumber = 1,
    kSpeedReductionAndAccuracyFieldNumber = 2,
    kTimePeriodFieldNumber = 3,
  };
  // .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
  bool has_envelope() const;
  void clear_envelope() ;
  const ::sensoris::protobuf::types::base::EventEnvelope& envelope() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::EventEnvelope* release_envelope();
  ::sensoris::protobuf::types::base::EventEnvelope* mutable_envelope();
  void set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value);
  void unsafe_arena_set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value);
  ::sensoris::protobuf::types::base::EventEnvelope* unsafe_arena_release_envelope();

  private:
  const ::sensoris::protobuf::types::base::EventEnvelope& _internal_envelope() const;
  ::sensoris::protobuf::types::base::EventEnvelope* _internal_mutable_envelope();

  public:
  // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy speed_reduction_and_accuracy = 2 [(.sensoris.protobuf.types.base.exponent) = 1];
  bool has_speed_reduction_and_accuracy() const;
  void clear_speed_reduction_and_accuracy() ;
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& speed_reduction_and_accuracy() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* release_speed_reduction_and_accuracy();
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* mutable_speed_reduction_and_accuracy();
  void set_allocated_speed_reduction_and_accuracy(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* value);
  void unsafe_arena_set_allocated_speed_reduction_and_accuracy(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* value);
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* unsafe_arena_release_speed_reduction_and_accuracy();

  private:
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& _internal_speed_reduction_and_accuracy() const;
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* _internal_mutable_speed_reduction_and_accuracy();

  public:
  // .google.protobuf.Int64Value time_period = 3 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_time_period() const;
  void clear_time_period() ;
  const ::google::protobuf::Int64Value& time_period() const;
  PROTOBUF_NODISCARD ::google::protobuf::Int64Value* release_time_period();
  ::google::protobuf::Int64Value* mutable_time_period();
  void set_allocated_time_period(::google::protobuf::Int64Value* value);
  void unsafe_arena_set_allocated_time_period(::google::protobuf::Int64Value* value);
  ::google::protobuf::Int64Value* unsafe_arena_release_time_period();

  private:
  const ::google::protobuf::Int64Value& _internal_time_period() const;
  ::google::protobuf::Int64Value* _internal_mutable_time_period();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.trafficevents.DangerousSlowDown)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::EventEnvelope* envelope_;
    ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* speed_reduction_and_accuracy_;
    ::google::protobuf::Int64Value* time_period_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto;
};// -------------------------------------------------------------------

class TrafficEventsCategory final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory) */ {
 public:
  inline TrafficEventsCategory() : TrafficEventsCategory(nullptr) {}
  ~TrafficEventsCategory() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TrafficEventsCategory(::google::protobuf::internal::ConstantInitialized);

  inline TrafficEventsCategory(const TrafficEventsCategory& from)
      : TrafficEventsCategory(nullptr, from) {}
  TrafficEventsCategory(TrafficEventsCategory&& from) noexcept
    : TrafficEventsCategory() {
    *this = ::std::move(from);
  }

  inline TrafficEventsCategory& operator=(const TrafficEventsCategory& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrafficEventsCategory& operator=(TrafficEventsCategory&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrafficEventsCategory& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrafficEventsCategory* internal_default_instance() {
    return reinterpret_cast<const TrafficEventsCategory*>(
               &_TrafficEventsCategory_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(TrafficEventsCategory& a, TrafficEventsCategory& b) {
    a.Swap(&b);
  }
  inline void Swap(TrafficEventsCategory* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrafficEventsCategory* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrafficEventsCategory* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrafficEventsCategory>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TrafficEventsCategory& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TrafficEventsCategory& from) {
    TrafficEventsCategory::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TrafficEventsCategory* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.categories.trafficevents.TrafficEventsCategory";
  }
  protected:
  explicit TrafficEventsCategory(::google::protobuf::Arena* arena);
  TrafficEventsCategory(::google::protobuf::Arena* arena, const TrafficEventsCategory& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHazardFieldNumber = 2,
    kDangerousSlowDownFieldNumber = 3,
    kTrafficConditionFieldNumber = 4,
    kRoadworksFieldNumber = 5,
    kRoadWeatherConditionFieldNumber = 6,
    kEnvelopeFieldNumber = 1,
  };
  // repeated .sensoris.protobuf.categories.trafficevents.Hazard hazard = 2;
  int hazard_size() const;
  private:
  int _internal_hazard_size() const;

  public:
  void clear_hazard() ;
  ::sensoris::protobuf::categories::trafficevents::Hazard* mutable_hazard(int index);
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficevents::Hazard >*
      mutable_hazard();
  private:
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::Hazard>& _internal_hazard() const;
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::Hazard>* _internal_mutable_hazard();
  public:
  const ::sensoris::protobuf::categories::trafficevents::Hazard& hazard(int index) const;
  ::sensoris::protobuf::categories::trafficevents::Hazard* add_hazard();
  const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficevents::Hazard >&
      hazard() const;
  // repeated .sensoris.protobuf.categories.trafficevents.DangerousSlowDown dangerous_slow_down = 3;
  int dangerous_slow_down_size() const;
  private:
  int _internal_dangerous_slow_down_size() const;

  public:
  void clear_dangerous_slow_down() ;
  ::sensoris::protobuf::categories::trafficevents::DangerousSlowDown* mutable_dangerous_slow_down(int index);
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficevents::DangerousSlowDown >*
      mutable_dangerous_slow_down();
  private:
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::DangerousSlowDown>& _internal_dangerous_slow_down() const;
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::DangerousSlowDown>* _internal_mutable_dangerous_slow_down();
  public:
  const ::sensoris::protobuf::categories::trafficevents::DangerousSlowDown& dangerous_slow_down(int index) const;
  ::sensoris::protobuf::categories::trafficevents::DangerousSlowDown* add_dangerous_slow_down();
  const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficevents::DangerousSlowDown >&
      dangerous_slow_down() const;
  // repeated .sensoris.protobuf.categories.trafficevents.TrafficCondition traffic_condition = 4;
  int traffic_condition_size() const;
  private:
  int _internal_traffic_condition_size() const;

  public:
  void clear_traffic_condition() ;
  ::sensoris::protobuf::categories::trafficevents::TrafficCondition* mutable_traffic_condition(int index);
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficevents::TrafficCondition >*
      mutable_traffic_condition();
  private:
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::TrafficCondition>& _internal_traffic_condition() const;
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::TrafficCondition>* _internal_mutable_traffic_condition();
  public:
  const ::sensoris::protobuf::categories::trafficevents::TrafficCondition& traffic_condition(int index) const;
  ::sensoris::protobuf::categories::trafficevents::TrafficCondition* add_traffic_condition();
  const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficevents::TrafficCondition >&
      traffic_condition() const;
  // repeated .sensoris.protobuf.categories.trafficevents.RoadWorks roadworks = 5;
  int roadworks_size() const;
  private:
  int _internal_roadworks_size() const;

  public:
  void clear_roadworks() ;
  ::sensoris::protobuf::categories::trafficevents::RoadWorks* mutable_roadworks(int index);
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficevents::RoadWorks >*
      mutable_roadworks();
  private:
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::RoadWorks>& _internal_roadworks() const;
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::RoadWorks>* _internal_mutable_roadworks();
  public:
  const ::sensoris::protobuf::categories::trafficevents::RoadWorks& roadworks(int index) const;
  ::sensoris::protobuf::categories::trafficevents::RoadWorks* add_roadworks();
  const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficevents::RoadWorks >&
      roadworks() const;
  // repeated .sensoris.protobuf.categories.trafficevents.RoadWeatherCondition road_weather_condition = 6;
  int road_weather_condition_size() const;
  private:
  int _internal_road_weather_condition_size() const;

  public:
  void clear_road_weather_condition() ;
  ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition* mutable_road_weather_condition(int index);
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition >*
      mutable_road_weather_condition();
  private:
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition>& _internal_road_weather_condition() const;
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition>* _internal_mutable_road_weather_condition();
  public:
  const ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition& road_weather_condition(int index) const;
  ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition* add_road_weather_condition();
  const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition >&
      road_weather_condition() const;
  // .sensoris.protobuf.types.base.CategoryEnvelope envelope = 1;
  bool has_envelope() const;
  void clear_envelope() ;
  const ::sensoris::protobuf::types::base::CategoryEnvelope& envelope() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::CategoryEnvelope* release_envelope();
  ::sensoris::protobuf::types::base::CategoryEnvelope* mutable_envelope();
  void set_allocated_envelope(::sensoris::protobuf::types::base::CategoryEnvelope* value);
  void unsafe_arena_set_allocated_envelope(::sensoris::protobuf::types::base::CategoryEnvelope* value);
  ::sensoris::protobuf::types::base::CategoryEnvelope* unsafe_arena_release_envelope();

  private:
  const ::sensoris::protobuf::types::base::CategoryEnvelope& _internal_envelope() const;
  ::sensoris::protobuf::types::base::CategoryEnvelope* _internal_mutable_envelope();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 6,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficevents::Hazard > hazard_;
    ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficevents::DangerousSlowDown > dangerous_slow_down_;
    ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficevents::TrafficCondition > traffic_condition_;
    ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficevents::RoadWorks > roadworks_;
    ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition > road_weather_condition_;
    ::sensoris::protobuf::types::base::CategoryEnvelope* envelope_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Hazard_TypeAndConfidence

// .sensoris.protobuf.categories.trafficevents.Hazard.TypeAndConfidence.Type type = 1;
inline void Hazard_TypeAndConfidence::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
}
inline ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence_Type Hazard_TypeAndConfidence::type() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.Hazard.TypeAndConfidence.type)
  return _internal_type();
}
inline void Hazard_TypeAndConfidence::set_type(::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.trafficevents.Hazard.TypeAndConfidence.type)
}
inline ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence_Type Hazard_TypeAndConfidence::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence_Type>(_impl_.type_);
}
inline void Hazard_TypeAndConfidence::_internal_set_type(::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence_Type value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// .sensoris.protobuf.types.base.Confidence confidence = 2;
inline bool Hazard_TypeAndConfidence::has_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.confidence_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Confidence& Hazard_TypeAndConfidence::_internal_confidence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::Confidence* p = _impl_.confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Confidence&>(::sensoris::protobuf::types::base::_Confidence_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Confidence& Hazard_TypeAndConfidence::confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.Hazard.TypeAndConfidence.confidence)
  return _internal_confidence();
}
inline void Hazard_TypeAndConfidence::unsafe_arena_set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }
  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.Hazard.TypeAndConfidence.confidence)
}
inline ::sensoris::protobuf::types::base::Confidence* Hazard_TypeAndConfidence::release_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* released = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::Confidence* Hazard_TypeAndConfidence::unsafe_arena_release_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.Hazard.TypeAndConfidence.confidence)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* temp = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* Hazard_TypeAndConfidence::_internal_mutable_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.confidence_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Confidence>(GetArena());
    _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(p);
  }
  return _impl_.confidence_;
}
inline ::sensoris::protobuf::types::base::Confidence* Hazard_TypeAndConfidence::mutable_confidence() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::Confidence* _msg = _internal_mutable_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.Hazard.TypeAndConfidence.confidence)
  return _msg;
}
inline void Hazard_TypeAndConfidence::set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.Hazard.TypeAndConfidence.confidence)
}

// -------------------------------------------------------------------

// Hazard

// .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
inline bool Hazard::has_envelope() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.envelope_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& Hazard::_internal_envelope() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::EventEnvelope* p = _impl_.envelope_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::EventEnvelope&>(::sensoris::protobuf::types::base::_EventEnvelope_default_instance_);
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& Hazard::envelope() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.Hazard.envelope)
  return _internal_envelope();
}
inline void Hazard::unsafe_arena_set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }
  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.Hazard.envelope)
}
inline ::sensoris::protobuf::types::base::EventEnvelope* Hazard::release_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* released = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* Hazard::unsafe_arena_release_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.Hazard.envelope)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* temp = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* Hazard::_internal_mutable_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.envelope_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::EventEnvelope>(GetArena());
    _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(p);
  }
  return _impl_.envelope_;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* Hazard::mutable_envelope() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::EventEnvelope* _msg = _internal_mutable_envelope();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.Hazard.envelope)
  return _msg;
}
inline void Hazard::set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.Hazard.envelope)
}

// .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 2;
inline bool Hazard::has_detection_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.detection_status_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::EventDetectionStatus& Hazard::_internal_detection_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::EventDetectionStatus* p = _impl_.detection_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::EventDetectionStatus&>(::sensoris::protobuf::types::base::_EventDetectionStatus_default_instance_);
}
inline const ::sensoris::protobuf::types::base::EventDetectionStatus& Hazard::detection_status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.Hazard.detection_status)
  return _internal_detection_status();
}
inline void Hazard::unsafe_arena_set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.detection_status_);
  }
  _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.Hazard.detection_status)
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* Hazard::release_detection_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::EventDetectionStatus* released = _impl_.detection_status_;
  _impl_.detection_status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* Hazard::unsafe_arena_release_detection_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.Hazard.detection_status)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::EventDetectionStatus* temp = _impl_.detection_status_;
  _impl_.detection_status_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* Hazard::_internal_mutable_detection_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.detection_status_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::EventDetectionStatus>(GetArena());
    _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(p);
  }
  return _impl_.detection_status_;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* Hazard::mutable_detection_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::EventDetectionStatus* _msg = _internal_mutable_detection_status();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.Hazard.detection_status)
  return _msg;
}
inline void Hazard::set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.detection_status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.Hazard.detection_status)
}

// .sensoris.protobuf.categories.trafficevents.Hazard.TypeAndConfidence type_and_confidence = 3;
inline bool Hazard::has_type_and_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.type_and_confidence_ != nullptr);
  return value;
}
inline void Hazard::clear_type_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.type_and_confidence_ != nullptr) _impl_.type_and_confidence_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence& Hazard::_internal_type_and_confidence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence* p = _impl_.type_and_confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence&>(::sensoris::protobuf::categories::trafficevents::_Hazard_TypeAndConfidence_default_instance_);
}
inline const ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence& Hazard::type_and_confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.Hazard.type_and_confidence)
  return _internal_type_and_confidence();
}
inline void Hazard::unsafe_arena_set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.type_and_confidence_);
  }
  _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.Hazard.type_and_confidence)
}
inline ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence* Hazard::release_type_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence* released = _impl_.type_and_confidence_;
  _impl_.type_and_confidence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence* Hazard::unsafe_arena_release_type_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.Hazard.type_and_confidence)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence* temp = _impl_.type_and_confidence_;
  _impl_.type_and_confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence* Hazard::_internal_mutable_type_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.type_and_confidence_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence>(GetArena());
    _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence*>(p);
  }
  return _impl_.type_and_confidence_;
}
inline ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence* Hazard::mutable_type_and_confidence() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence* _msg = _internal_mutable_type_and_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.Hazard.type_and_confidence)
  return _msg;
}
inline void Hazard::set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence*>(_impl_.type_and_confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.Hazard.type_and_confidence)
}

// .sensoris.protobuf.categories.trafficevents.Hazard.Direction direction = 4;
inline void Hazard::clear_direction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.direction_ = 0;
}
inline ::sensoris::protobuf::categories::trafficevents::Hazard_Direction Hazard::direction() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.Hazard.direction)
  return _internal_direction();
}
inline void Hazard::set_direction(::sensoris::protobuf::categories::trafficevents::Hazard_Direction value) {
  _internal_set_direction(value);
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.trafficevents.Hazard.direction)
}
inline ::sensoris::protobuf::categories::trafficevents::Hazard_Direction Hazard::_internal_direction() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::sensoris::protobuf::categories::trafficevents::Hazard_Direction>(_impl_.direction_);
}
inline void Hazard::_internal_set_direction(::sensoris::protobuf::categories::trafficevents::Hazard_Direction value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.direction_ = value;
}

// -------------------------------------------------------------------

// DangerousSlowDown

// .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
inline bool DangerousSlowDown::has_envelope() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.envelope_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& DangerousSlowDown::_internal_envelope() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::EventEnvelope* p = _impl_.envelope_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::EventEnvelope&>(::sensoris::protobuf::types::base::_EventEnvelope_default_instance_);
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& DangerousSlowDown::envelope() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.DangerousSlowDown.envelope)
  return _internal_envelope();
}
inline void DangerousSlowDown::unsafe_arena_set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }
  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.DangerousSlowDown.envelope)
}
inline ::sensoris::protobuf::types::base::EventEnvelope* DangerousSlowDown::release_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* released = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* DangerousSlowDown::unsafe_arena_release_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.DangerousSlowDown.envelope)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* temp = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* DangerousSlowDown::_internal_mutable_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.envelope_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::EventEnvelope>(GetArena());
    _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(p);
  }
  return _impl_.envelope_;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* DangerousSlowDown::mutable_envelope() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::EventEnvelope* _msg = _internal_mutable_envelope();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.DangerousSlowDown.envelope)
  return _msg;
}
inline void DangerousSlowDown::set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.DangerousSlowDown.envelope)
}

// .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy speed_reduction_and_accuracy = 2 [(.sensoris.protobuf.types.base.exponent) = 1];
inline bool DangerousSlowDown::has_speed_reduction_and_accuracy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.speed_reduction_and_accuracy_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& DangerousSlowDown::_internal_speed_reduction_and_accuracy() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* p = _impl_.speed_reduction_and_accuracy_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy&>(::sensoris::protobuf::types::spatial::_XyzVectorAndAccuracy_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& DangerousSlowDown::speed_reduction_and_accuracy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.DangerousSlowDown.speed_reduction_and_accuracy)
  return _internal_speed_reduction_and_accuracy();
}
inline void DangerousSlowDown::unsafe_arena_set_allocated_speed_reduction_and_accuracy(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.speed_reduction_and_accuracy_);
  }
  _impl_.speed_reduction_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.DangerousSlowDown.speed_reduction_and_accuracy)
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* DangerousSlowDown::release_speed_reduction_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* released = _impl_.speed_reduction_and_accuracy_;
  _impl_.speed_reduction_and_accuracy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* DangerousSlowDown::unsafe_arena_release_speed_reduction_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.DangerousSlowDown.speed_reduction_and_accuracy)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* temp = _impl_.speed_reduction_and_accuracy_;
  _impl_.speed_reduction_and_accuracy_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* DangerousSlowDown::_internal_mutable_speed_reduction_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.speed_reduction_and_accuracy_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy>(GetArena());
    _impl_.speed_reduction_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy*>(p);
  }
  return _impl_.speed_reduction_and_accuracy_;
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* DangerousSlowDown::mutable_speed_reduction_and_accuracy() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* _msg = _internal_mutable_speed_reduction_and_accuracy();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.DangerousSlowDown.speed_reduction_and_accuracy)
  return _msg;
}
inline void DangerousSlowDown::set_allocated_speed_reduction_and_accuracy(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.speed_reduction_and_accuracy_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.speed_reduction_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.DangerousSlowDown.speed_reduction_and_accuracy)
}

// .google.protobuf.Int64Value time_period = 3 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool DangerousSlowDown::has_time_period() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.time_period_ != nullptr);
  return value;
}
inline const ::google::protobuf::Int64Value& DangerousSlowDown::_internal_time_period() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Int64Value* p = _impl_.time_period_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Int64Value&>(::google::protobuf::_Int64Value_default_instance_);
}
inline const ::google::protobuf::Int64Value& DangerousSlowDown::time_period() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.DangerousSlowDown.time_period)
  return _internal_time_period();
}
inline void DangerousSlowDown::unsafe_arena_set_allocated_time_period(::google::protobuf::Int64Value* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.time_period_);
  }
  _impl_.time_period_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.DangerousSlowDown.time_period)
}
inline ::google::protobuf::Int64Value* DangerousSlowDown::release_time_period() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Int64Value* released = _impl_.time_period_;
  _impl_.time_period_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Int64Value* DangerousSlowDown::unsafe_arena_release_time_period() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.DangerousSlowDown.time_period)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Int64Value* temp = _impl_.time_period_;
  _impl_.time_period_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int64Value* DangerousSlowDown::_internal_mutable_time_period() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.time_period_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int64Value>(GetArena());
    _impl_.time_period_ = reinterpret_cast<::google::protobuf::Int64Value*>(p);
  }
  return _impl_.time_period_;
}
inline ::google::protobuf::Int64Value* DangerousSlowDown::mutable_time_period() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Int64Value* _msg = _internal_mutable_time_period();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.DangerousSlowDown.time_period)
  return _msg;
}
inline void DangerousSlowDown::set_allocated_time_period(::google::protobuf::Int64Value* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.time_period_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.time_period_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.DangerousSlowDown.time_period)
}

// -------------------------------------------------------------------

// TrafficCondition_TypeAndConfidence

// .sensoris.protobuf.categories.trafficevents.TrafficCondition.TypeAndConfidence.Type type = 1;
inline void TrafficCondition_TypeAndConfidence::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
}
inline ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence_Type TrafficCondition_TypeAndConfidence::type() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.TrafficCondition.TypeAndConfidence.type)
  return _internal_type();
}
inline void TrafficCondition_TypeAndConfidence::set_type(::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.trafficevents.TrafficCondition.TypeAndConfidence.type)
}
inline ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence_Type TrafficCondition_TypeAndConfidence::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence_Type>(_impl_.type_);
}
inline void TrafficCondition_TypeAndConfidence::_internal_set_type(::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence_Type value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// .sensoris.protobuf.types.base.Confidence confidence = 2;
inline bool TrafficCondition_TypeAndConfidence::has_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.confidence_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Confidence& TrafficCondition_TypeAndConfidence::_internal_confidence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::Confidence* p = _impl_.confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Confidence&>(::sensoris::protobuf::types::base::_Confidence_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Confidence& TrafficCondition_TypeAndConfidence::confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.TrafficCondition.TypeAndConfidence.confidence)
  return _internal_confidence();
}
inline void TrafficCondition_TypeAndConfidence::unsafe_arena_set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }
  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.TrafficCondition.TypeAndConfidence.confidence)
}
inline ::sensoris::protobuf::types::base::Confidence* TrafficCondition_TypeAndConfidence::release_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* released = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::Confidence* TrafficCondition_TypeAndConfidence::unsafe_arena_release_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.TrafficCondition.TypeAndConfidence.confidence)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* temp = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* TrafficCondition_TypeAndConfidence::_internal_mutable_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.confidence_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Confidence>(GetArena());
    _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(p);
  }
  return _impl_.confidence_;
}
inline ::sensoris::protobuf::types::base::Confidence* TrafficCondition_TypeAndConfidence::mutable_confidence() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::Confidence* _msg = _internal_mutable_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.TrafficCondition.TypeAndConfidence.confidence)
  return _msg;
}
inline void TrafficCondition_TypeAndConfidence::set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.TrafficCondition.TypeAndConfidence.confidence)
}

// -------------------------------------------------------------------

// TrafficCondition

// .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
inline bool TrafficCondition::has_envelope() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.envelope_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& TrafficCondition::_internal_envelope() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::EventEnvelope* p = _impl_.envelope_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::EventEnvelope&>(::sensoris::protobuf::types::base::_EventEnvelope_default_instance_);
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& TrafficCondition::envelope() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.TrafficCondition.envelope)
  return _internal_envelope();
}
inline void TrafficCondition::unsafe_arena_set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }
  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.TrafficCondition.envelope)
}
inline ::sensoris::protobuf::types::base::EventEnvelope* TrafficCondition::release_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* released = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* TrafficCondition::unsafe_arena_release_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.TrafficCondition.envelope)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* temp = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* TrafficCondition::_internal_mutable_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.envelope_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::EventEnvelope>(GetArena());
    _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(p);
  }
  return _impl_.envelope_;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* TrafficCondition::mutable_envelope() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::EventEnvelope* _msg = _internal_mutable_envelope();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.TrafficCondition.envelope)
  return _msg;
}
inline void TrafficCondition::set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.TrafficCondition.envelope)
}

// .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 2;
inline bool TrafficCondition::has_detection_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.detection_status_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::EventDetectionStatus& TrafficCondition::_internal_detection_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::EventDetectionStatus* p = _impl_.detection_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::EventDetectionStatus&>(::sensoris::protobuf::types::base::_EventDetectionStatus_default_instance_);
}
inline const ::sensoris::protobuf::types::base::EventDetectionStatus& TrafficCondition::detection_status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.TrafficCondition.detection_status)
  return _internal_detection_status();
}
inline void TrafficCondition::unsafe_arena_set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.detection_status_);
  }
  _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.TrafficCondition.detection_status)
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* TrafficCondition::release_detection_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::EventDetectionStatus* released = _impl_.detection_status_;
  _impl_.detection_status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* TrafficCondition::unsafe_arena_release_detection_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.TrafficCondition.detection_status)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::EventDetectionStatus* temp = _impl_.detection_status_;
  _impl_.detection_status_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* TrafficCondition::_internal_mutable_detection_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.detection_status_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::EventDetectionStatus>(GetArena());
    _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(p);
  }
  return _impl_.detection_status_;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* TrafficCondition::mutable_detection_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::EventDetectionStatus* _msg = _internal_mutable_detection_status();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.TrafficCondition.detection_status)
  return _msg;
}
inline void TrafficCondition::set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.detection_status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.TrafficCondition.detection_status)
}

// .sensoris.protobuf.categories.trafficevents.TrafficCondition.TypeAndConfidence type_and_confidence = 3;
inline bool TrafficCondition::has_type_and_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.type_and_confidence_ != nullptr);
  return value;
}
inline void TrafficCondition::clear_type_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.type_and_confidence_ != nullptr) _impl_.type_and_confidence_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence& TrafficCondition::_internal_type_and_confidence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence* p = _impl_.type_and_confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence&>(::sensoris::protobuf::categories::trafficevents::_TrafficCondition_TypeAndConfidence_default_instance_);
}
inline const ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence& TrafficCondition::type_and_confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.TrafficCondition.type_and_confidence)
  return _internal_type_and_confidence();
}
inline void TrafficCondition::unsafe_arena_set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.type_and_confidence_);
  }
  _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.TrafficCondition.type_and_confidence)
}
inline ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence* TrafficCondition::release_type_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence* released = _impl_.type_and_confidence_;
  _impl_.type_and_confidence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence* TrafficCondition::unsafe_arena_release_type_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.TrafficCondition.type_and_confidence)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence* temp = _impl_.type_and_confidence_;
  _impl_.type_and_confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence* TrafficCondition::_internal_mutable_type_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.type_and_confidence_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence>(GetArena());
    _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence*>(p);
  }
  return _impl_.type_and_confidence_;
}
inline ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence* TrafficCondition::mutable_type_and_confidence() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence* _msg = _internal_mutable_type_and_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.TrafficCondition.type_and_confidence)
  return _msg;
}
inline void TrafficCondition::set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence*>(_impl_.type_and_confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.TrafficCondition.type_and_confidence)
}

// -------------------------------------------------------------------

// RoadWorks_TypeAndConfidence

// .sensoris.protobuf.categories.trafficevents.RoadWorks.TypeAndConfidence.Type type = 1;
inline void RoadWorks_TypeAndConfidence::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
}
inline ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence_Type RoadWorks_TypeAndConfidence::type() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.RoadWorks.TypeAndConfidence.type)
  return _internal_type();
}
inline void RoadWorks_TypeAndConfidence::set_type(::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.trafficevents.RoadWorks.TypeAndConfidence.type)
}
inline ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence_Type RoadWorks_TypeAndConfidence::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence_Type>(_impl_.type_);
}
inline void RoadWorks_TypeAndConfidence::_internal_set_type(::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence_Type value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// .sensoris.protobuf.types.base.Confidence confidence = 2;
inline bool RoadWorks_TypeAndConfidence::has_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.confidence_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Confidence& RoadWorks_TypeAndConfidence::_internal_confidence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::Confidence* p = _impl_.confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Confidence&>(::sensoris::protobuf::types::base::_Confidence_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Confidence& RoadWorks_TypeAndConfidence::confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.RoadWorks.TypeAndConfidence.confidence)
  return _internal_confidence();
}
inline void RoadWorks_TypeAndConfidence::unsafe_arena_set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }
  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.RoadWorks.TypeAndConfidence.confidence)
}
inline ::sensoris::protobuf::types::base::Confidence* RoadWorks_TypeAndConfidence::release_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* released = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::Confidence* RoadWorks_TypeAndConfidence::unsafe_arena_release_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.RoadWorks.TypeAndConfidence.confidence)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* temp = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* RoadWorks_TypeAndConfidence::_internal_mutable_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.confidence_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Confidence>(GetArena());
    _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(p);
  }
  return _impl_.confidence_;
}
inline ::sensoris::protobuf::types::base::Confidence* RoadWorks_TypeAndConfidence::mutable_confidence() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::Confidence* _msg = _internal_mutable_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.RoadWorks.TypeAndConfidence.confidence)
  return _msg;
}
inline void RoadWorks_TypeAndConfidence::set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.RoadWorks.TypeAndConfidence.confidence)
}

// -------------------------------------------------------------------

// RoadWorks

// .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
inline bool RoadWorks::has_envelope() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.envelope_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& RoadWorks::_internal_envelope() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::EventEnvelope* p = _impl_.envelope_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::EventEnvelope&>(::sensoris::protobuf::types::base::_EventEnvelope_default_instance_);
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& RoadWorks::envelope() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.RoadWorks.envelope)
  return _internal_envelope();
}
inline void RoadWorks::unsafe_arena_set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }
  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.RoadWorks.envelope)
}
inline ::sensoris::protobuf::types::base::EventEnvelope* RoadWorks::release_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* released = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* RoadWorks::unsafe_arena_release_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.RoadWorks.envelope)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* temp = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* RoadWorks::_internal_mutable_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.envelope_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::EventEnvelope>(GetArena());
    _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(p);
  }
  return _impl_.envelope_;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* RoadWorks::mutable_envelope() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::EventEnvelope* _msg = _internal_mutable_envelope();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.RoadWorks.envelope)
  return _msg;
}
inline void RoadWorks::set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.RoadWorks.envelope)
}

// .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 2;
inline bool RoadWorks::has_detection_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.detection_status_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::EventDetectionStatus& RoadWorks::_internal_detection_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::EventDetectionStatus* p = _impl_.detection_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::EventDetectionStatus&>(::sensoris::protobuf::types::base::_EventDetectionStatus_default_instance_);
}
inline const ::sensoris::protobuf::types::base::EventDetectionStatus& RoadWorks::detection_status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.RoadWorks.detection_status)
  return _internal_detection_status();
}
inline void RoadWorks::unsafe_arena_set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.detection_status_);
  }
  _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.RoadWorks.detection_status)
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* RoadWorks::release_detection_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::EventDetectionStatus* released = _impl_.detection_status_;
  _impl_.detection_status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* RoadWorks::unsafe_arena_release_detection_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.RoadWorks.detection_status)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::EventDetectionStatus* temp = _impl_.detection_status_;
  _impl_.detection_status_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* RoadWorks::_internal_mutable_detection_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.detection_status_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::EventDetectionStatus>(GetArena());
    _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(p);
  }
  return _impl_.detection_status_;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* RoadWorks::mutable_detection_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::EventDetectionStatus* _msg = _internal_mutable_detection_status();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.RoadWorks.detection_status)
  return _msg;
}
inline void RoadWorks::set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.detection_status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.RoadWorks.detection_status)
}

// .sensoris.protobuf.categories.trafficevents.RoadWorks.TypeAndConfidence type_and_confidence = 3;
inline bool RoadWorks::has_type_and_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.type_and_confidence_ != nullptr);
  return value;
}
inline void RoadWorks::clear_type_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.type_and_confidence_ != nullptr) _impl_.type_and_confidence_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence& RoadWorks::_internal_type_and_confidence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence* p = _impl_.type_and_confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence&>(::sensoris::protobuf::categories::trafficevents::_RoadWorks_TypeAndConfidence_default_instance_);
}
inline const ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence& RoadWorks::type_and_confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.RoadWorks.type_and_confidence)
  return _internal_type_and_confidence();
}
inline void RoadWorks::unsafe_arena_set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.type_and_confidence_);
  }
  _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.RoadWorks.type_and_confidence)
}
inline ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence* RoadWorks::release_type_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence* released = _impl_.type_and_confidence_;
  _impl_.type_and_confidence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence* RoadWorks::unsafe_arena_release_type_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.RoadWorks.type_and_confidence)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence* temp = _impl_.type_and_confidence_;
  _impl_.type_and_confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence* RoadWorks::_internal_mutable_type_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.type_and_confidence_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence>(GetArena());
    _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence*>(p);
  }
  return _impl_.type_and_confidence_;
}
inline ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence* RoadWorks::mutable_type_and_confidence() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence* _msg = _internal_mutable_type_and_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.RoadWorks.type_and_confidence)
  return _msg;
}
inline void RoadWorks::set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence*>(_impl_.type_and_confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.RoadWorks.type_and_confidence)
}

// .sensoris.protobuf.types.base.CountAndConfidence lanes_closed_and_confidence = 5;
inline bool RoadWorks::has_lanes_closed_and_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.lanes_closed_and_confidence_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::CountAndConfidence& RoadWorks::_internal_lanes_closed_and_confidence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::CountAndConfidence* p = _impl_.lanes_closed_and_confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::CountAndConfidence&>(::sensoris::protobuf::types::base::_CountAndConfidence_default_instance_);
}
inline const ::sensoris::protobuf::types::base::CountAndConfidence& RoadWorks::lanes_closed_and_confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.RoadWorks.lanes_closed_and_confidence)
  return _internal_lanes_closed_and_confidence();
}
inline void RoadWorks::unsafe_arena_set_allocated_lanes_closed_and_confidence(::sensoris::protobuf::types::base::CountAndConfidence* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.lanes_closed_and_confidence_);
  }
  _impl_.lanes_closed_and_confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::CountAndConfidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.RoadWorks.lanes_closed_and_confidence)
}
inline ::sensoris::protobuf::types::base::CountAndConfidence* RoadWorks::release_lanes_closed_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::sensoris::protobuf::types::base::CountAndConfidence* released = _impl_.lanes_closed_and_confidence_;
  _impl_.lanes_closed_and_confidence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::CountAndConfidence* RoadWorks::unsafe_arena_release_lanes_closed_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.RoadWorks.lanes_closed_and_confidence)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::sensoris::protobuf::types::base::CountAndConfidence* temp = _impl_.lanes_closed_and_confidence_;
  _impl_.lanes_closed_and_confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::CountAndConfidence* RoadWorks::_internal_mutable_lanes_closed_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.lanes_closed_and_confidence_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::CountAndConfidence>(GetArena());
    _impl_.lanes_closed_and_confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::CountAndConfidence*>(p);
  }
  return _impl_.lanes_closed_and_confidence_;
}
inline ::sensoris::protobuf::types::base::CountAndConfidence* RoadWorks::mutable_lanes_closed_and_confidence() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::CountAndConfidence* _msg = _internal_mutable_lanes_closed_and_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.RoadWorks.lanes_closed_and_confidence)
  return _msg;
}
inline void RoadWorks::set_allocated_lanes_closed_and_confidence(::sensoris::protobuf::types::base::CountAndConfidence* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.lanes_closed_and_confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.lanes_closed_and_confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::CountAndConfidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.RoadWorks.lanes_closed_and_confidence)
}

// -------------------------------------------------------------------

// RoadWeatherCondition_TypeAndConfidence

// .sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.TypeAndConfidence.Type type = 1;
inline void RoadWeatherCondition_TypeAndConfidence::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
}
inline ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence_Type RoadWeatherCondition_TypeAndConfidence::type() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.TypeAndConfidence.type)
  return _internal_type();
}
inline void RoadWeatherCondition_TypeAndConfidence::set_type(::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.TypeAndConfidence.type)
}
inline ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence_Type RoadWeatherCondition_TypeAndConfidence::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence_Type>(_impl_.type_);
}
inline void RoadWeatherCondition_TypeAndConfidence::_internal_set_type(::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence_Type value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// .sensoris.protobuf.types.base.Confidence confidence = 2;
inline bool RoadWeatherCondition_TypeAndConfidence::has_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.confidence_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Confidence& RoadWeatherCondition_TypeAndConfidence::_internal_confidence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::Confidence* p = _impl_.confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Confidence&>(::sensoris::protobuf::types::base::_Confidence_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Confidence& RoadWeatherCondition_TypeAndConfidence::confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.TypeAndConfidence.confidence)
  return _internal_confidence();
}
inline void RoadWeatherCondition_TypeAndConfidence::unsafe_arena_set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }
  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.TypeAndConfidence.confidence)
}
inline ::sensoris::protobuf::types::base::Confidence* RoadWeatherCondition_TypeAndConfidence::release_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* released = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::Confidence* RoadWeatherCondition_TypeAndConfidence::unsafe_arena_release_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.TypeAndConfidence.confidence)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* temp = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* RoadWeatherCondition_TypeAndConfidence::_internal_mutable_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.confidence_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Confidence>(GetArena());
    _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(p);
  }
  return _impl_.confidence_;
}
inline ::sensoris::protobuf::types::base::Confidence* RoadWeatherCondition_TypeAndConfidence::mutable_confidence() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::Confidence* _msg = _internal_mutable_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.TypeAndConfidence.confidence)
  return _msg;
}
inline void RoadWeatherCondition_TypeAndConfidence::set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.TypeAndConfidence.confidence)
}

// -------------------------------------------------------------------

// RoadWeatherCondition

// .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
inline bool RoadWeatherCondition::has_envelope() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.envelope_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& RoadWeatherCondition::_internal_envelope() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::EventEnvelope* p = _impl_.envelope_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::EventEnvelope&>(::sensoris::protobuf::types::base::_EventEnvelope_default_instance_);
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& RoadWeatherCondition::envelope() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.envelope)
  return _internal_envelope();
}
inline void RoadWeatherCondition::unsafe_arena_set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }
  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.envelope)
}
inline ::sensoris::protobuf::types::base::EventEnvelope* RoadWeatherCondition::release_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* released = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* RoadWeatherCondition::unsafe_arena_release_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.envelope)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* temp = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* RoadWeatherCondition::_internal_mutable_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.envelope_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::EventEnvelope>(GetArena());
    _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(p);
  }
  return _impl_.envelope_;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* RoadWeatherCondition::mutable_envelope() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::EventEnvelope* _msg = _internal_mutable_envelope();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.envelope)
  return _msg;
}
inline void RoadWeatherCondition::set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.envelope)
}

// .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 2;
inline bool RoadWeatherCondition::has_detection_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.detection_status_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::EventDetectionStatus& RoadWeatherCondition::_internal_detection_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::EventDetectionStatus* p = _impl_.detection_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::EventDetectionStatus&>(::sensoris::protobuf::types::base::_EventDetectionStatus_default_instance_);
}
inline const ::sensoris::protobuf::types::base::EventDetectionStatus& RoadWeatherCondition::detection_status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.detection_status)
  return _internal_detection_status();
}
inline void RoadWeatherCondition::unsafe_arena_set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.detection_status_);
  }
  _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.detection_status)
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* RoadWeatherCondition::release_detection_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::EventDetectionStatus* released = _impl_.detection_status_;
  _impl_.detection_status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* RoadWeatherCondition::unsafe_arena_release_detection_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.detection_status)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::EventDetectionStatus* temp = _impl_.detection_status_;
  _impl_.detection_status_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* RoadWeatherCondition::_internal_mutable_detection_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.detection_status_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::EventDetectionStatus>(GetArena());
    _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(p);
  }
  return _impl_.detection_status_;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* RoadWeatherCondition::mutable_detection_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::EventDetectionStatus* _msg = _internal_mutable_detection_status();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.detection_status)
  return _msg;
}
inline void RoadWeatherCondition::set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.detection_status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.detection_status)
}

// .sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.TypeAndConfidence type_and_confidence = 3;
inline bool RoadWeatherCondition::has_type_and_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.type_and_confidence_ != nullptr);
  return value;
}
inline void RoadWeatherCondition::clear_type_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.type_and_confidence_ != nullptr) _impl_.type_and_confidence_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence& RoadWeatherCondition::_internal_type_and_confidence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence* p = _impl_.type_and_confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence&>(::sensoris::protobuf::categories::trafficevents::_RoadWeatherCondition_TypeAndConfidence_default_instance_);
}
inline const ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence& RoadWeatherCondition::type_and_confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.type_and_confidence)
  return _internal_type_and_confidence();
}
inline void RoadWeatherCondition::unsafe_arena_set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.type_and_confidence_);
  }
  _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.type_and_confidence)
}
inline ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence* RoadWeatherCondition::release_type_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence* released = _impl_.type_and_confidence_;
  _impl_.type_and_confidence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence* RoadWeatherCondition::unsafe_arena_release_type_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.type_and_confidence)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence* temp = _impl_.type_and_confidence_;
  _impl_.type_and_confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence* RoadWeatherCondition::_internal_mutable_type_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.type_and_confidence_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence>(GetArena());
    _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence*>(p);
  }
  return _impl_.type_and_confidence_;
}
inline ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence* RoadWeatherCondition::mutable_type_and_confidence() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence* _msg = _internal_mutable_type_and_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.type_and_confidence)
  return _msg;
}
inline void RoadWeatherCondition::set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence*>(_impl_.type_and_confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.type_and_confidence)
}

// .sensoris.protobuf.types.base.Int64ValueAndAccuracy depth_and_accuracy = 4 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool RoadWeatherCondition::has_depth_and_accuracy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.depth_and_accuracy_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& RoadWeatherCondition::_internal_depth_and_accuracy() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* p = _impl_.depth_and_accuracy_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy&>(::sensoris::protobuf::types::base::_Int64ValueAndAccuracy_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& RoadWeatherCondition::depth_and_accuracy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.depth_and_accuracy)
  return _internal_depth_and_accuracy();
}
inline void RoadWeatherCondition::unsafe_arena_set_allocated_depth_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.depth_and_accuracy_);
  }
  _impl_.depth_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.depth_and_accuracy)
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* RoadWeatherCondition::release_depth_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* released = _impl_.depth_and_accuracy_;
  _impl_.depth_and_accuracy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* RoadWeatherCondition::unsafe_arena_release_depth_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.depth_and_accuracy)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* temp = _impl_.depth_and_accuracy_;
  _impl_.depth_and_accuracy_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* RoadWeatherCondition::_internal_mutable_depth_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.depth_and_accuracy_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64ValueAndAccuracy>(GetArena());
    _impl_.depth_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(p);
  }
  return _impl_.depth_and_accuracy_;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* RoadWeatherCondition::mutable_depth_and_accuracy() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* _msg = _internal_mutable_depth_and_accuracy();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.depth_and_accuracy)
  return _msg;
}
inline void RoadWeatherCondition::set_allocated_depth_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.depth_and_accuracy_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.depth_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.depth_and_accuracy)
}

// -------------------------------------------------------------------

// TrafficEventsCategory

// .sensoris.protobuf.types.base.CategoryEnvelope envelope = 1;
inline bool TrafficEventsCategory::has_envelope() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.envelope_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::CategoryEnvelope& TrafficEventsCategory::_internal_envelope() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::CategoryEnvelope* p = _impl_.envelope_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::CategoryEnvelope&>(::sensoris::protobuf::types::base::_CategoryEnvelope_default_instance_);
}
inline const ::sensoris::protobuf::types::base::CategoryEnvelope& TrafficEventsCategory::envelope() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.envelope)
  return _internal_envelope();
}
inline void TrafficEventsCategory::unsafe_arena_set_allocated_envelope(::sensoris::protobuf::types::base::CategoryEnvelope* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }
  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::CategoryEnvelope*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.envelope)
}
inline ::sensoris::protobuf::types::base::CategoryEnvelope* TrafficEventsCategory::release_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::CategoryEnvelope* released = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::CategoryEnvelope* TrafficEventsCategory::unsafe_arena_release_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.envelope)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::CategoryEnvelope* temp = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::CategoryEnvelope* TrafficEventsCategory::_internal_mutable_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.envelope_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::CategoryEnvelope>(GetArena());
    _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::CategoryEnvelope*>(p);
  }
  return _impl_.envelope_;
}
inline ::sensoris::protobuf::types::base::CategoryEnvelope* TrafficEventsCategory::mutable_envelope() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::CategoryEnvelope* _msg = _internal_mutable_envelope();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.envelope)
  return _msg;
}
inline void TrafficEventsCategory::set_allocated_envelope(::sensoris::protobuf::types::base::CategoryEnvelope* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::CategoryEnvelope*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.envelope)
}

// repeated .sensoris.protobuf.categories.trafficevents.Hazard hazard = 2;
inline int TrafficEventsCategory::_internal_hazard_size() const {
  return _internal_hazard().size();
}
inline int TrafficEventsCategory::hazard_size() const {
  return _internal_hazard_size();
}
inline void TrafficEventsCategory::clear_hazard() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.hazard_.Clear();
}
inline ::sensoris::protobuf::categories::trafficevents::Hazard* TrafficEventsCategory::mutable_hazard(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.hazard)
  return _internal_mutable_hazard()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::Hazard>* TrafficEventsCategory::mutable_hazard()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.hazard)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_hazard();
}
inline const ::sensoris::protobuf::categories::trafficevents::Hazard& TrafficEventsCategory::hazard(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.hazard)
  return _internal_hazard().Get(index);
}
inline ::sensoris::protobuf::categories::trafficevents::Hazard* TrafficEventsCategory::add_hazard() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::sensoris::protobuf::categories::trafficevents::Hazard* _add = _internal_mutable_hazard()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.hazard)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::Hazard>& TrafficEventsCategory::hazard() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.hazard)
  return _internal_hazard();
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::Hazard>&
TrafficEventsCategory::_internal_hazard() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.hazard_;
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::Hazard>*
TrafficEventsCategory::_internal_mutable_hazard() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.hazard_;
}

// repeated .sensoris.protobuf.categories.trafficevents.DangerousSlowDown dangerous_slow_down = 3;
inline int TrafficEventsCategory::_internal_dangerous_slow_down_size() const {
  return _internal_dangerous_slow_down().size();
}
inline int TrafficEventsCategory::dangerous_slow_down_size() const {
  return _internal_dangerous_slow_down_size();
}
inline void TrafficEventsCategory::clear_dangerous_slow_down() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dangerous_slow_down_.Clear();
}
inline ::sensoris::protobuf::categories::trafficevents::DangerousSlowDown* TrafficEventsCategory::mutable_dangerous_slow_down(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.dangerous_slow_down)
  return _internal_mutable_dangerous_slow_down()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::DangerousSlowDown>* TrafficEventsCategory::mutable_dangerous_slow_down()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.dangerous_slow_down)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_dangerous_slow_down();
}
inline const ::sensoris::protobuf::categories::trafficevents::DangerousSlowDown& TrafficEventsCategory::dangerous_slow_down(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.dangerous_slow_down)
  return _internal_dangerous_slow_down().Get(index);
}
inline ::sensoris::protobuf::categories::trafficevents::DangerousSlowDown* TrafficEventsCategory::add_dangerous_slow_down() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::sensoris::protobuf::categories::trafficevents::DangerousSlowDown* _add = _internal_mutable_dangerous_slow_down()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.dangerous_slow_down)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::DangerousSlowDown>& TrafficEventsCategory::dangerous_slow_down() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.dangerous_slow_down)
  return _internal_dangerous_slow_down();
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::DangerousSlowDown>&
TrafficEventsCategory::_internal_dangerous_slow_down() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dangerous_slow_down_;
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::DangerousSlowDown>*
TrafficEventsCategory::_internal_mutable_dangerous_slow_down() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.dangerous_slow_down_;
}

// repeated .sensoris.protobuf.categories.trafficevents.TrafficCondition traffic_condition = 4;
inline int TrafficEventsCategory::_internal_traffic_condition_size() const {
  return _internal_traffic_condition().size();
}
inline int TrafficEventsCategory::traffic_condition_size() const {
  return _internal_traffic_condition_size();
}
inline void TrafficEventsCategory::clear_traffic_condition() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.traffic_condition_.Clear();
}
inline ::sensoris::protobuf::categories::trafficevents::TrafficCondition* TrafficEventsCategory::mutable_traffic_condition(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.traffic_condition)
  return _internal_mutable_traffic_condition()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::TrafficCondition>* TrafficEventsCategory::mutable_traffic_condition()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.traffic_condition)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_traffic_condition();
}
inline const ::sensoris::protobuf::categories::trafficevents::TrafficCondition& TrafficEventsCategory::traffic_condition(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.traffic_condition)
  return _internal_traffic_condition().Get(index);
}
inline ::sensoris::protobuf::categories::trafficevents::TrafficCondition* TrafficEventsCategory::add_traffic_condition() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::sensoris::protobuf::categories::trafficevents::TrafficCondition* _add = _internal_mutable_traffic_condition()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.traffic_condition)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::TrafficCondition>& TrafficEventsCategory::traffic_condition() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.traffic_condition)
  return _internal_traffic_condition();
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::TrafficCondition>&
TrafficEventsCategory::_internal_traffic_condition() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.traffic_condition_;
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::TrafficCondition>*
TrafficEventsCategory::_internal_mutable_traffic_condition() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.traffic_condition_;
}

// repeated .sensoris.protobuf.categories.trafficevents.RoadWorks roadworks = 5;
inline int TrafficEventsCategory::_internal_roadworks_size() const {
  return _internal_roadworks().size();
}
inline int TrafficEventsCategory::roadworks_size() const {
  return _internal_roadworks_size();
}
inline void TrafficEventsCategory::clear_roadworks() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.roadworks_.Clear();
}
inline ::sensoris::protobuf::categories::trafficevents::RoadWorks* TrafficEventsCategory::mutable_roadworks(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.roadworks)
  return _internal_mutable_roadworks()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::RoadWorks>* TrafficEventsCategory::mutable_roadworks()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.roadworks)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_roadworks();
}
inline const ::sensoris::protobuf::categories::trafficevents::RoadWorks& TrafficEventsCategory::roadworks(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.roadworks)
  return _internal_roadworks().Get(index);
}
inline ::sensoris::protobuf::categories::trafficevents::RoadWorks* TrafficEventsCategory::add_roadworks() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::sensoris::protobuf::categories::trafficevents::RoadWorks* _add = _internal_mutable_roadworks()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.roadworks)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::RoadWorks>& TrafficEventsCategory::roadworks() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.roadworks)
  return _internal_roadworks();
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::RoadWorks>&
TrafficEventsCategory::_internal_roadworks() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.roadworks_;
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::RoadWorks>*
TrafficEventsCategory::_internal_mutable_roadworks() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.roadworks_;
}

// repeated .sensoris.protobuf.categories.trafficevents.RoadWeatherCondition road_weather_condition = 6;
inline int TrafficEventsCategory::_internal_road_weather_condition_size() const {
  return _internal_road_weather_condition().size();
}
inline int TrafficEventsCategory::road_weather_condition_size() const {
  return _internal_road_weather_condition_size();
}
inline void TrafficEventsCategory::clear_road_weather_condition() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.road_weather_condition_.Clear();
}
inline ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition* TrafficEventsCategory::mutable_road_weather_condition(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.road_weather_condition)
  return _internal_mutable_road_weather_condition()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition>* TrafficEventsCategory::mutable_road_weather_condition()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.road_weather_condition)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_road_weather_condition();
}
inline const ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition& TrafficEventsCategory::road_weather_condition(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.road_weather_condition)
  return _internal_road_weather_condition().Get(index);
}
inline ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition* TrafficEventsCategory::add_road_weather_condition() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition* _add = _internal_mutable_road_weather_condition()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.road_weather_condition)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition>& TrafficEventsCategory::road_weather_condition() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.road_weather_condition)
  return _internal_road_weather_condition();
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition>&
TrafficEventsCategory::_internal_road_weather_condition() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.road_weather_condition_;
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition>*
TrafficEventsCategory::_internal_mutable_road_weather_condition() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.road_weather_condition_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace trafficevents
}  // namespace categories
}  // namespace protobuf
}  // namespace sensoris


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence_Type> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence_Type>() {
  return ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence_Type_descriptor();
}
template <>
struct is_proto_enum<::sensoris::protobuf::categories::trafficevents::Hazard_Direction> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::sensoris::protobuf::categories::trafficevents::Hazard_Direction>() {
  return ::sensoris::protobuf::categories::trafficevents::Hazard_Direction_descriptor();
}
template <>
struct is_proto_enum<::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence_Type> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence_Type>() {
  return ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence_Type_descriptor();
}
template <>
struct is_proto_enum<::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence_Type> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence_Type>() {
  return ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence_Type_descriptor();
}
template <>
struct is_proto_enum<::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence_Type> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence_Type>() {
  return ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence_Type_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto_2epb_2eh
