// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sensoris/protobuf/types/source.proto
// Protobuf C++ Version: 4.25.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_sensoris_2fprotobuf_2ftypes_2fsource_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_sensoris_2fprotobuf_2ftypes_2fsource_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "google/protobuf/any.pb.h"
#include "google/protobuf/wrappers.pb.h"
#include "sensoris/protobuf/types/base.pb.h"
#include "sensoris/protobuf/types/spatial.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_sensoris_2fprotobuf_2ftypes_2fsource_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_sensoris_2fprotobuf_2ftypes_2fsource_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_sensoris_2fprotobuf_2ftypes_2fsource_2eproto;
namespace sensoris {
namespace protobuf {
namespace types {
namespace source {
class NavigationSatelliteSystem;
struct NavigationSatelliteSystemDefaultTypeInternal;
extern NavigationSatelliteSystemDefaultTypeInternal _NavigationSatelliteSystem_default_instance_;
class Sensor;
struct SensorDefaultTypeInternal;
extern SensorDefaultTypeInternal _Sensor_default_instance_;
class SensorFusion;
struct SensorFusionDefaultTypeInternal;
extern SensorFusionDefaultTypeInternal _SensorFusion_default_instance_;
class Sensor_MountingPositionAndOrientation;
struct Sensor_MountingPositionAndOrientationDefaultTypeInternal;
extern Sensor_MountingPositionAndOrientationDefaultTypeInternal _Sensor_MountingPositionAndOrientation_default_instance_;
class Source;
struct SourceDefaultTypeInternal;
extern SourceDefaultTypeInternal _Source_default_instance_;
}  // namespace source
}  // namespace types
}  // namespace protobuf
}  // namespace sensoris
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace sensoris {
namespace protobuf {
namespace types {
namespace source {
enum NavigationSatelliteSystem_SatelliteSystem : int {
  NavigationSatelliteSystem_SatelliteSystem_UNKNOWN_SATELLITE_SYSTEM = 0,
  NavigationSatelliteSystem_SatelliteSystem_GPS = 1,
  NavigationSatelliteSystem_SatelliteSystem_GLONASS = 2,
  NavigationSatelliteSystem_SatelliteSystem_GALILEO = 3,
  NavigationSatelliteSystem_SatelliteSystem_BEIDOU_1 = 4,
  NavigationSatelliteSystem_SatelliteSystem_BEIDOU_2 = 5,
  NavigationSatelliteSystem_SatelliteSystem_NAVIC = 6,
  NavigationSatelliteSystem_SatelliteSystem_QZSS = 7,
  NavigationSatelliteSystem_SatelliteSystem_NavigationSatelliteSystem_SatelliteSystem_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  NavigationSatelliteSystem_SatelliteSystem_NavigationSatelliteSystem_SatelliteSystem_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool NavigationSatelliteSystem_SatelliteSystem_IsValid(int value);
extern const uint32_t NavigationSatelliteSystem_SatelliteSystem_internal_data_[];
constexpr NavigationSatelliteSystem_SatelliteSystem NavigationSatelliteSystem_SatelliteSystem_SatelliteSystem_MIN = static_cast<NavigationSatelliteSystem_SatelliteSystem>(0);
constexpr NavigationSatelliteSystem_SatelliteSystem NavigationSatelliteSystem_SatelliteSystem_SatelliteSystem_MAX = static_cast<NavigationSatelliteSystem_SatelliteSystem>(7);
constexpr int NavigationSatelliteSystem_SatelliteSystem_SatelliteSystem_ARRAYSIZE = 7 + 1;
const ::google::protobuf::EnumDescriptor*
NavigationSatelliteSystem_SatelliteSystem_descriptor();
template <typename T>
const std::string& NavigationSatelliteSystem_SatelliteSystem_Name(T value) {
  static_assert(std::is_same<T, NavigationSatelliteSystem_SatelliteSystem>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SatelliteSystem_Name().");
  return NavigationSatelliteSystem_SatelliteSystem_Name(static_cast<NavigationSatelliteSystem_SatelliteSystem>(value));
}
template <>
inline const std::string& NavigationSatelliteSystem_SatelliteSystem_Name(NavigationSatelliteSystem_SatelliteSystem value) {
  return ::google::protobuf::internal::NameOfDenseEnum<NavigationSatelliteSystem_SatelliteSystem_descriptor,
                                                 0, 7>(
      static_cast<int>(value));
}
inline bool NavigationSatelliteSystem_SatelliteSystem_Parse(absl::string_view name, NavigationSatelliteSystem_SatelliteSystem* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NavigationSatelliteSystem_SatelliteSystem>(
      NavigationSatelliteSystem_SatelliteSystem_descriptor(), name, value);
}
enum NavigationSatelliteSystem_SatelliteBasedAugmentationSystem : int {
  NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_UNKNOWN_SATELLITE_BASED = 0,
  NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_SATELLITE_BASED = 1,
  NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_WAAS = 2,
  NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_EGNOS = 3,
  NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_MSAS = 4,
  NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_QZSS_SATELLITE_BASED = 5,
  NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_GAGAN = 6,
  NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_SDCM = 7,
  NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_SNAS = 8,
  NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_WAGE = 9,
  NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_STAR_FIRE = 10,
  NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_STAR_FIX = 11,
  NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_OMNI_STAR = 12,
  NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_IsValid(int value);
extern const uint32_t NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_internal_data_[];
constexpr NavigationSatelliteSystem_SatelliteBasedAugmentationSystem NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_SatelliteBasedAugmentationSystem_MIN = static_cast<NavigationSatelliteSystem_SatelliteBasedAugmentationSystem>(0);
constexpr NavigationSatelliteSystem_SatelliteBasedAugmentationSystem NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_SatelliteBasedAugmentationSystem_MAX = static_cast<NavigationSatelliteSystem_SatelliteBasedAugmentationSystem>(12);
constexpr int NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_SatelliteBasedAugmentationSystem_ARRAYSIZE = 12 + 1;
const ::google::protobuf::EnumDescriptor*
NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_descriptor();
template <typename T>
const std::string& NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_Name(T value) {
  static_assert(std::is_same<T, NavigationSatelliteSystem_SatelliteBasedAugmentationSystem>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SatelliteBasedAugmentationSystem_Name().");
  return NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_Name(static_cast<NavigationSatelliteSystem_SatelliteBasedAugmentationSystem>(value));
}
template <>
inline const std::string& NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_Name(NavigationSatelliteSystem_SatelliteBasedAugmentationSystem value) {
  return ::google::protobuf::internal::NameOfDenseEnum<NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_descriptor,
                                                 0, 12>(
      static_cast<int>(value));
}
inline bool NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_Parse(absl::string_view name, NavigationSatelliteSystem_SatelliteBasedAugmentationSystem* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NavigationSatelliteSystem_SatelliteBasedAugmentationSystem>(
      NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_descriptor(), name, value);
}
enum NavigationSatelliteSystem_GroundBasedAugmentationSystem : int {
  NavigationSatelliteSystem_GroundBasedAugmentationSystem_UNKNOWN_GROUND_BASED = 0,
  NavigationSatelliteSystem_GroundBasedAugmentationSystem_GROUND_BASED = 1,
  NavigationSatelliteSystem_GroundBasedAugmentationSystem_GBAS = 2,
  NavigationSatelliteSystem_GroundBasedAugmentationSystem_NDGPS = 3,
  NavigationSatelliteSystem_GroundBasedAugmentationSystem_SAPOS = 4,
  NavigationSatelliteSystem_GroundBasedAugmentationSystem_ALF = 5,
  NavigationSatelliteSystem_GroundBasedAugmentationSystem_AXIO_NET = 6,
  NavigationSatelliteSystem_GroundBasedAugmentationSystem_VRS_NOW = 7,
  NavigationSatelliteSystem_GroundBasedAugmentationSystem_SMART_NET = 8,
  NavigationSatelliteSystem_GroundBasedAugmentationSystem_NavigationSatelliteSystem_GroundBasedAugmentationSystem_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  NavigationSatelliteSystem_GroundBasedAugmentationSystem_NavigationSatelliteSystem_GroundBasedAugmentationSystem_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool NavigationSatelliteSystem_GroundBasedAugmentationSystem_IsValid(int value);
extern const uint32_t NavigationSatelliteSystem_GroundBasedAugmentationSystem_internal_data_[];
constexpr NavigationSatelliteSystem_GroundBasedAugmentationSystem NavigationSatelliteSystem_GroundBasedAugmentationSystem_GroundBasedAugmentationSystem_MIN = static_cast<NavigationSatelliteSystem_GroundBasedAugmentationSystem>(0);
constexpr NavigationSatelliteSystem_GroundBasedAugmentationSystem NavigationSatelliteSystem_GroundBasedAugmentationSystem_GroundBasedAugmentationSystem_MAX = static_cast<NavigationSatelliteSystem_GroundBasedAugmentationSystem>(8);
constexpr int NavigationSatelliteSystem_GroundBasedAugmentationSystem_GroundBasedAugmentationSystem_ARRAYSIZE = 8 + 1;
const ::google::protobuf::EnumDescriptor*
NavigationSatelliteSystem_GroundBasedAugmentationSystem_descriptor();
template <typename T>
const std::string& NavigationSatelliteSystem_GroundBasedAugmentationSystem_Name(T value) {
  static_assert(std::is_same<T, NavigationSatelliteSystem_GroundBasedAugmentationSystem>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to GroundBasedAugmentationSystem_Name().");
  return NavigationSatelliteSystem_GroundBasedAugmentationSystem_Name(static_cast<NavigationSatelliteSystem_GroundBasedAugmentationSystem>(value));
}
template <>
inline const std::string& NavigationSatelliteSystem_GroundBasedAugmentationSystem_Name(NavigationSatelliteSystem_GroundBasedAugmentationSystem value) {
  return ::google::protobuf::internal::NameOfDenseEnum<NavigationSatelliteSystem_GroundBasedAugmentationSystem_descriptor,
                                                 0, 8>(
      static_cast<int>(value));
}
inline bool NavigationSatelliteSystem_GroundBasedAugmentationSystem_Parse(absl::string_view name, NavigationSatelliteSystem_GroundBasedAugmentationSystem* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NavigationSatelliteSystem_GroundBasedAugmentationSystem>(
      NavigationSatelliteSystem_GroundBasedAugmentationSystem_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class SensorFusion final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.source.SensorFusion) */ {
 public:
  inline SensorFusion() : SensorFusion(nullptr) {}
  ~SensorFusion() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SensorFusion(::google::protobuf::internal::ConstantInitialized);

  inline SensorFusion(const SensorFusion& from)
      : SensorFusion(nullptr, from) {}
  SensorFusion(SensorFusion&& from) noexcept
    : SensorFusion() {
    *this = ::std::move(from);
  }

  inline SensorFusion& operator=(const SensorFusion& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorFusion& operator=(SensorFusion&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorFusion& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorFusion* internal_default_instance() {
    return reinterpret_cast<const SensorFusion*>(
               &_SensorFusion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SensorFusion& a, SensorFusion& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorFusion* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorFusion* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorFusion* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SensorFusion>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SensorFusion& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SensorFusion& from) {
    SensorFusion::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SensorFusion* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.types.source.SensorFusion";
  }
  protected:
  explicit SensorFusion(::google::protobuf::Arena* arena);
  SensorFusion(::google::protobuf::Arena* arena, const SensorFusion& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSensorIdFieldNumber = 1,
  };
  // repeated .google.protobuf.Int64Value sensor_id = 1;
  int sensor_id_size() const;
  private:
  int _internal_sensor_id_size() const;

  public:
  void clear_sensor_id() ;
  ::google::protobuf::Int64Value* mutable_sensor_id(int index);
  ::google::protobuf::RepeatedPtrField< ::google::protobuf::Int64Value >*
      mutable_sensor_id();
  private:
  const ::google::protobuf::RepeatedPtrField<::google::protobuf::Int64Value>& _internal_sensor_id() const;
  ::google::protobuf::RepeatedPtrField<::google::protobuf::Int64Value>* _internal_mutable_sensor_id();
  public:
  const ::google::protobuf::Int64Value& sensor_id(int index) const;
  ::google::protobuf::Int64Value* add_sensor_id();
  const ::google::protobuf::RepeatedPtrField< ::google::protobuf::Int64Value >&
      sensor_id() const;
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.source.SensorFusion)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::google::protobuf::Int64Value > sensor_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2ftypes_2fsource_2eproto;
};// -------------------------------------------------------------------

class Sensor_MountingPositionAndOrientation final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.source.Sensor.MountingPositionAndOrientation) */ {
 public:
  inline Sensor_MountingPositionAndOrientation() : Sensor_MountingPositionAndOrientation(nullptr) {}
  ~Sensor_MountingPositionAndOrientation() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Sensor_MountingPositionAndOrientation(::google::protobuf::internal::ConstantInitialized);

  inline Sensor_MountingPositionAndOrientation(const Sensor_MountingPositionAndOrientation& from)
      : Sensor_MountingPositionAndOrientation(nullptr, from) {}
  Sensor_MountingPositionAndOrientation(Sensor_MountingPositionAndOrientation&& from) noexcept
    : Sensor_MountingPositionAndOrientation() {
    *this = ::std::move(from);
  }

  inline Sensor_MountingPositionAndOrientation& operator=(const Sensor_MountingPositionAndOrientation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Sensor_MountingPositionAndOrientation& operator=(Sensor_MountingPositionAndOrientation&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Sensor_MountingPositionAndOrientation& default_instance() {
    return *internal_default_instance();
  }
  static inline const Sensor_MountingPositionAndOrientation* internal_default_instance() {
    return reinterpret_cast<const Sensor_MountingPositionAndOrientation*>(
               &_Sensor_MountingPositionAndOrientation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Sensor_MountingPositionAndOrientation& a, Sensor_MountingPositionAndOrientation& b) {
    a.Swap(&b);
  }
  inline void Swap(Sensor_MountingPositionAndOrientation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Sensor_MountingPositionAndOrientation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Sensor_MountingPositionAndOrientation* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Sensor_MountingPositionAndOrientation>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Sensor_MountingPositionAndOrientation& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Sensor_MountingPositionAndOrientation& from) {
    Sensor_MountingPositionAndOrientation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Sensor_MountingPositionAndOrientation* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.types.source.Sensor.MountingPositionAndOrientation";
  }
  protected:
  explicit Sensor_MountingPositionAndOrientation(::google::protobuf::Arena* arena);
  Sensor_MountingPositionAndOrientation(::google::protobuf::Arena* arena, const Sensor_MountingPositionAndOrientation& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTranslationAndAccuracyFieldNumber = 1,
    kOrientationAndAccuracyFieldNumber = 2,
  };
  // .sensoris.protobuf.types.spatial.PositionAndAccuracy translation_and_accuracy = 1;
  bool has_translation_and_accuracy() const;
  void clear_translation_and_accuracy() ;
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& translation_and_accuracy() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::spatial::PositionAndAccuracy* release_translation_and_accuracy();
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* mutable_translation_and_accuracy();
  void set_allocated_translation_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* value);
  void unsafe_arena_set_allocated_translation_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* value);
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* unsafe_arena_release_translation_and_accuracy();

  private:
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& _internal_translation_and_accuracy() const;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* _internal_mutable_translation_and_accuracy();

  public:
  // .sensoris.protobuf.types.spatial.RotationAndAccuracy orientation_and_accuracy = 2;
  bool has_orientation_and_accuracy() const;
  void clear_orientation_and_accuracy() ;
  const ::sensoris::protobuf::types::spatial::RotationAndAccuracy& orientation_and_accuracy() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::spatial::RotationAndAccuracy* release_orientation_and_accuracy();
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy* mutable_orientation_and_accuracy();
  void set_allocated_orientation_and_accuracy(::sensoris::protobuf::types::spatial::RotationAndAccuracy* value);
  void unsafe_arena_set_allocated_orientation_and_accuracy(::sensoris::protobuf::types::spatial::RotationAndAccuracy* value);
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy* unsafe_arena_release_orientation_and_accuracy();

  private:
  const ::sensoris::protobuf::types::spatial::RotationAndAccuracy& _internal_orientation_and_accuracy() const;
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy* _internal_mutable_orientation_and_accuracy();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.source.Sensor.MountingPositionAndOrientation)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::spatial::PositionAndAccuracy* translation_and_accuracy_;
    ::sensoris::protobuf::types::spatial::RotationAndAccuracy* orientation_and_accuracy_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2ftypes_2fsource_2eproto;
};// -------------------------------------------------------------------

class NavigationSatelliteSystem final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.source.NavigationSatelliteSystem) */ {
 public:
  inline NavigationSatelliteSystem() : NavigationSatelliteSystem(nullptr) {}
  ~NavigationSatelliteSystem() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NavigationSatelliteSystem(::google::protobuf::internal::ConstantInitialized);

  inline NavigationSatelliteSystem(const NavigationSatelliteSystem& from)
      : NavigationSatelliteSystem(nullptr, from) {}
  NavigationSatelliteSystem(NavigationSatelliteSystem&& from) noexcept
    : NavigationSatelliteSystem() {
    *this = ::std::move(from);
  }

  inline NavigationSatelliteSystem& operator=(const NavigationSatelliteSystem& from) {
    CopyFrom(from);
    return *this;
  }
  inline NavigationSatelliteSystem& operator=(NavigationSatelliteSystem&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NavigationSatelliteSystem& default_instance() {
    return *internal_default_instance();
  }
  static inline const NavigationSatelliteSystem* internal_default_instance() {
    return reinterpret_cast<const NavigationSatelliteSystem*>(
               &_NavigationSatelliteSystem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(NavigationSatelliteSystem& a, NavigationSatelliteSystem& b) {
    a.Swap(&b);
  }
  inline void Swap(NavigationSatelliteSystem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NavigationSatelliteSystem* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NavigationSatelliteSystem* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NavigationSatelliteSystem>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NavigationSatelliteSystem& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const NavigationSatelliteSystem& from) {
    NavigationSatelliteSystem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NavigationSatelliteSystem* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.types.source.NavigationSatelliteSystem";
  }
  protected:
  explicit NavigationSatelliteSystem(::google::protobuf::Arena* arena);
  NavigationSatelliteSystem(::google::protobuf::Arena* arena, const NavigationSatelliteSystem& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using SatelliteSystem = NavigationSatelliteSystem_SatelliteSystem;
  static constexpr SatelliteSystem UNKNOWN_SATELLITE_SYSTEM = NavigationSatelliteSystem_SatelliteSystem_UNKNOWN_SATELLITE_SYSTEM;
  static constexpr SatelliteSystem GPS = NavigationSatelliteSystem_SatelliteSystem_GPS;
  static constexpr SatelliteSystem GLONASS = NavigationSatelliteSystem_SatelliteSystem_GLONASS;
  static constexpr SatelliteSystem GALILEO = NavigationSatelliteSystem_SatelliteSystem_GALILEO;
  static constexpr SatelliteSystem BEIDOU_1 = NavigationSatelliteSystem_SatelliteSystem_BEIDOU_1;
  static constexpr SatelliteSystem BEIDOU_2 = NavigationSatelliteSystem_SatelliteSystem_BEIDOU_2;
  static constexpr SatelliteSystem NAVIC = NavigationSatelliteSystem_SatelliteSystem_NAVIC;
  static constexpr SatelliteSystem QZSS = NavigationSatelliteSystem_SatelliteSystem_QZSS;
  static inline bool SatelliteSystem_IsValid(int value) {
    return NavigationSatelliteSystem_SatelliteSystem_IsValid(value);
  }
  static constexpr SatelliteSystem SatelliteSystem_MIN = NavigationSatelliteSystem_SatelliteSystem_SatelliteSystem_MIN;
  static constexpr SatelliteSystem SatelliteSystem_MAX = NavigationSatelliteSystem_SatelliteSystem_SatelliteSystem_MAX;
  static constexpr int SatelliteSystem_ARRAYSIZE = NavigationSatelliteSystem_SatelliteSystem_SatelliteSystem_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* SatelliteSystem_descriptor() {
    return NavigationSatelliteSystem_SatelliteSystem_descriptor();
  }
  template <typename T>
  static inline const std::string& SatelliteSystem_Name(T value) {
    return NavigationSatelliteSystem_SatelliteSystem_Name(value);
  }
  static inline bool SatelliteSystem_Parse(absl::string_view name, SatelliteSystem* value) {
    return NavigationSatelliteSystem_SatelliteSystem_Parse(name, value);
  }

  using SatelliteBasedAugmentationSystem = NavigationSatelliteSystem_SatelliteBasedAugmentationSystem;
  static constexpr SatelliteBasedAugmentationSystem UNKNOWN_SATELLITE_BASED = NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_UNKNOWN_SATELLITE_BASED;
  static constexpr SatelliteBasedAugmentationSystem SATELLITE_BASED = NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_SATELLITE_BASED;
  static constexpr SatelliteBasedAugmentationSystem WAAS = NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_WAAS;
  static constexpr SatelliteBasedAugmentationSystem EGNOS = NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_EGNOS;
  static constexpr SatelliteBasedAugmentationSystem MSAS = NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_MSAS;
  static constexpr SatelliteBasedAugmentationSystem QZSS_SATELLITE_BASED = NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_QZSS_SATELLITE_BASED;
  static constexpr SatelliteBasedAugmentationSystem GAGAN = NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_GAGAN;
  static constexpr SatelliteBasedAugmentationSystem SDCM = NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_SDCM;
  static constexpr SatelliteBasedAugmentationSystem SNAS = NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_SNAS;
  static constexpr SatelliteBasedAugmentationSystem WAGE = NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_WAGE;
  static constexpr SatelliteBasedAugmentationSystem STAR_FIRE = NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_STAR_FIRE;
  static constexpr SatelliteBasedAugmentationSystem STAR_FIX = NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_STAR_FIX;
  static constexpr SatelliteBasedAugmentationSystem OMNI_STAR = NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_OMNI_STAR;
  static inline bool SatelliteBasedAugmentationSystem_IsValid(int value) {
    return NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_IsValid(value);
  }
  static constexpr SatelliteBasedAugmentationSystem SatelliteBasedAugmentationSystem_MIN = NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_SatelliteBasedAugmentationSystem_MIN;
  static constexpr SatelliteBasedAugmentationSystem SatelliteBasedAugmentationSystem_MAX = NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_SatelliteBasedAugmentationSystem_MAX;
  static constexpr int SatelliteBasedAugmentationSystem_ARRAYSIZE = NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_SatelliteBasedAugmentationSystem_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* SatelliteBasedAugmentationSystem_descriptor() {
    return NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_descriptor();
  }
  template <typename T>
  static inline const std::string& SatelliteBasedAugmentationSystem_Name(T value) {
    return NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_Name(value);
  }
  static inline bool SatelliteBasedAugmentationSystem_Parse(absl::string_view name, SatelliteBasedAugmentationSystem* value) {
    return NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_Parse(name, value);
  }

  using GroundBasedAugmentationSystem = NavigationSatelliteSystem_GroundBasedAugmentationSystem;
  static constexpr GroundBasedAugmentationSystem UNKNOWN_GROUND_BASED = NavigationSatelliteSystem_GroundBasedAugmentationSystem_UNKNOWN_GROUND_BASED;
  static constexpr GroundBasedAugmentationSystem GROUND_BASED = NavigationSatelliteSystem_GroundBasedAugmentationSystem_GROUND_BASED;
  static constexpr GroundBasedAugmentationSystem GBAS = NavigationSatelliteSystem_GroundBasedAugmentationSystem_GBAS;
  static constexpr GroundBasedAugmentationSystem NDGPS = NavigationSatelliteSystem_GroundBasedAugmentationSystem_NDGPS;
  static constexpr GroundBasedAugmentationSystem SAPOS = NavigationSatelliteSystem_GroundBasedAugmentationSystem_SAPOS;
  static constexpr GroundBasedAugmentationSystem ALF = NavigationSatelliteSystem_GroundBasedAugmentationSystem_ALF;
  static constexpr GroundBasedAugmentationSystem AXIO_NET = NavigationSatelliteSystem_GroundBasedAugmentationSystem_AXIO_NET;
  static constexpr GroundBasedAugmentationSystem VRS_NOW = NavigationSatelliteSystem_GroundBasedAugmentationSystem_VRS_NOW;
  static constexpr GroundBasedAugmentationSystem SMART_NET = NavigationSatelliteSystem_GroundBasedAugmentationSystem_SMART_NET;
  static inline bool GroundBasedAugmentationSystem_IsValid(int value) {
    return NavigationSatelliteSystem_GroundBasedAugmentationSystem_IsValid(value);
  }
  static constexpr GroundBasedAugmentationSystem GroundBasedAugmentationSystem_MIN = NavigationSatelliteSystem_GroundBasedAugmentationSystem_GroundBasedAugmentationSystem_MIN;
  static constexpr GroundBasedAugmentationSystem GroundBasedAugmentationSystem_MAX = NavigationSatelliteSystem_GroundBasedAugmentationSystem_GroundBasedAugmentationSystem_MAX;
  static constexpr int GroundBasedAugmentationSystem_ARRAYSIZE = NavigationSatelliteSystem_GroundBasedAugmentationSystem_GroundBasedAugmentationSystem_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* GroundBasedAugmentationSystem_descriptor() {
    return NavigationSatelliteSystem_GroundBasedAugmentationSystem_descriptor();
  }
  template <typename T>
  static inline const std::string& GroundBasedAugmentationSystem_Name(T value) {
    return NavigationSatelliteSystem_GroundBasedAugmentationSystem_Name(value);
  }
  static inline bool GroundBasedAugmentationSystem_Parse(absl::string_view name, GroundBasedAugmentationSystem* value) {
    return NavigationSatelliteSystem_GroundBasedAugmentationSystem_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSatelliteSystemFieldNumber = 1,
    kSatelliteBasedAugmentationSystemFieldNumber = 2,
    kGroundBasedAugmentationSystemFieldNumber = 3,
    kExtensionFieldNumber = 15,
    kElevationMaskFieldNumber = 4,
    kAntennaOffsetAndAccuracyFieldNumber = 5,
  };
  // repeated .sensoris.protobuf.types.source.NavigationSatelliteSystem.SatelliteSystem satellite_system = 1;
  int satellite_system_size() const;
  private:
  int _internal_satellite_system_size() const;

  public:
  void clear_satellite_system() ;
  public:
  ::sensoris::protobuf::types::source::NavigationSatelliteSystem_SatelliteSystem satellite_system(int index) const;
  void set_satellite_system(int index, ::sensoris::protobuf::types::source::NavigationSatelliteSystem_SatelliteSystem value);
  void add_satellite_system(::sensoris::protobuf::types::source::NavigationSatelliteSystem_SatelliteSystem value);
  const ::google::protobuf::RepeatedField<int>& satellite_system() const;
  ::google::protobuf::RepeatedField<int>* mutable_satellite_system();

  private:
  const ::google::protobuf::RepeatedField<int>& _internal_satellite_system() const;
  ::google::protobuf::RepeatedField<int>* _internal_mutable_satellite_system();

  public:
  // repeated .sensoris.protobuf.types.source.NavigationSatelliteSystem.SatelliteBasedAugmentationSystem satellite_based_augmentation_system = 2;
  int satellite_based_augmentation_system_size() const;
  private:
  int _internal_satellite_based_augmentation_system_size() const;

  public:
  void clear_satellite_based_augmentation_system() ;
  public:
  ::sensoris::protobuf::types::source::NavigationSatelliteSystem_SatelliteBasedAugmentationSystem satellite_based_augmentation_system(int index) const;
  void set_satellite_based_augmentation_system(int index, ::sensoris::protobuf::types::source::NavigationSatelliteSystem_SatelliteBasedAugmentationSystem value);
  void add_satellite_based_augmentation_system(::sensoris::protobuf::types::source::NavigationSatelliteSystem_SatelliteBasedAugmentationSystem value);
  const ::google::protobuf::RepeatedField<int>& satellite_based_augmentation_system() const;
  ::google::protobuf::RepeatedField<int>* mutable_satellite_based_augmentation_system();

  private:
  const ::google::protobuf::RepeatedField<int>& _internal_satellite_based_augmentation_system() const;
  ::google::protobuf::RepeatedField<int>* _internal_mutable_satellite_based_augmentation_system();

  public:
  // repeated .sensoris.protobuf.types.source.NavigationSatelliteSystem.GroundBasedAugmentationSystem ground_based_augmentation_system = 3;
  int ground_based_augmentation_system_size() const;
  private:
  int _internal_ground_based_augmentation_system_size() const;

  public:
  void clear_ground_based_augmentation_system() ;
  public:
  ::sensoris::protobuf::types::source::NavigationSatelliteSystem_GroundBasedAugmentationSystem ground_based_augmentation_system(int index) const;
  void set_ground_based_augmentation_system(int index, ::sensoris::protobuf::types::source::NavigationSatelliteSystem_GroundBasedAugmentationSystem value);
  void add_ground_based_augmentation_system(::sensoris::protobuf::types::source::NavigationSatelliteSystem_GroundBasedAugmentationSystem value);
  const ::google::protobuf::RepeatedField<int>& ground_based_augmentation_system() const;
  ::google::protobuf::RepeatedField<int>* mutable_ground_based_augmentation_system();

  private:
  const ::google::protobuf::RepeatedField<int>& _internal_ground_based_augmentation_system() const;
  ::google::protobuf::RepeatedField<int>* _internal_mutable_ground_based_augmentation_system();

  public:
  // repeated .google.protobuf.Any extension = 15;
  int extension_size() const;
  private:
  int _internal_extension_size() const;

  public:
  void clear_extension() ;
  ::google::protobuf::Any* mutable_extension(int index);
  ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >*
      mutable_extension();
  private:
  const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& _internal_extension() const;
  ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* _internal_mutable_extension();
  public:
  const ::google::protobuf::Any& extension(int index) const;
  ::google::protobuf::Any* add_extension();
  const ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >&
      extension() const;
  // .google.protobuf.Int64Value elevation_mask = 4 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_elevation_mask() const;
  void clear_elevation_mask() ;
  const ::google::protobuf::Int64Value& elevation_mask() const;
  PROTOBUF_NODISCARD ::google::protobuf::Int64Value* release_elevation_mask();
  ::google::protobuf::Int64Value* mutable_elevation_mask();
  void set_allocated_elevation_mask(::google::protobuf::Int64Value* value);
  void unsafe_arena_set_allocated_elevation_mask(::google::protobuf::Int64Value* value);
  ::google::protobuf::Int64Value* unsafe_arena_release_elevation_mask();

  private:
  const ::google::protobuf::Int64Value& _internal_elevation_mask() const;
  ::google::protobuf::Int64Value* _internal_mutable_elevation_mask();

  public:
  // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy antenna_offset_and_accuracy = 5;
  bool has_antenna_offset_and_accuracy() const;
  void clear_antenna_offset_and_accuracy() ;
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& antenna_offset_and_accuracy() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* release_antenna_offset_and_accuracy();
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* mutable_antenna_offset_and_accuracy();
  void set_allocated_antenna_offset_and_accuracy(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* value);
  void unsafe_arena_set_allocated_antenna_offset_and_accuracy(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* value);
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* unsafe_arena_release_antenna_offset_and_accuracy();

  private:
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& _internal_antenna_offset_and_accuracy() const;
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* _internal_mutable_antenna_offset_and_accuracy();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.source.NavigationSatelliteSystem)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<int> satellite_system_;
    mutable ::google::protobuf::internal::CachedSize _satellite_system_cached_byte_size_;
    ::google::protobuf::RepeatedField<int> satellite_based_augmentation_system_;
    mutable ::google::protobuf::internal::CachedSize _satellite_based_augmentation_system_cached_byte_size_;
    ::google::protobuf::RepeatedField<int> ground_based_augmentation_system_;
    mutable ::google::protobuf::internal::CachedSize _ground_based_augmentation_system_cached_byte_size_;
    ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any > extension_;
    ::google::protobuf::Int64Value* elevation_mask_;
    ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* antenna_offset_and_accuracy_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2ftypes_2fsource_2eproto;
};// -------------------------------------------------------------------

class Sensor final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.source.Sensor) */ {
 public:
  inline Sensor() : Sensor(nullptr) {}
  ~Sensor() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Sensor(::google::protobuf::internal::ConstantInitialized);

  inline Sensor(const Sensor& from)
      : Sensor(nullptr, from) {}
  Sensor(Sensor&& from) noexcept
    : Sensor() {
    *this = ::std::move(from);
  }

  inline Sensor& operator=(const Sensor& from) {
    CopyFrom(from);
    return *this;
  }
  inline Sensor& operator=(Sensor&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Sensor& default_instance() {
    return *internal_default_instance();
  }
  enum SpecificCase {
    kNavigationSatelliteSystem = 2,
    SPECIFIC_NOT_SET = 0,
  };

  static inline const Sensor* internal_default_instance() {
    return reinterpret_cast<const Sensor*>(
               &_Sensor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Sensor& a, Sensor& b) {
    a.Swap(&b);
  }
  inline void Swap(Sensor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Sensor* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Sensor* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Sensor>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Sensor& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Sensor& from) {
    Sensor::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Sensor* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.types.source.Sensor";
  }
  protected:
  explicit Sensor(::google::protobuf::Arena* arena);
  Sensor(::google::protobuf::Arena* arena, const Sensor& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using MountingPositionAndOrientation = Sensor_MountingPositionAndOrientation;

  // accessors -------------------------------------------------------

  enum : int {
    kMountingPositionAndOrientationFieldNumber = 1,
    kNavigationSatelliteSystemFieldNumber = 2,
  };
  // .sensoris.protobuf.types.source.Sensor.MountingPositionAndOrientation mounting_position_and_orientation = 1;
  bool has_mounting_position_and_orientation() const;
  void clear_mounting_position_and_orientation() ;
  const ::sensoris::protobuf::types::source::Sensor_MountingPositionAndOrientation& mounting_position_and_orientation() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::source::Sensor_MountingPositionAndOrientation* release_mounting_position_and_orientation();
  ::sensoris::protobuf::types::source::Sensor_MountingPositionAndOrientation* mutable_mounting_position_and_orientation();
  void set_allocated_mounting_position_and_orientation(::sensoris::protobuf::types::source::Sensor_MountingPositionAndOrientation* value);
  void unsafe_arena_set_allocated_mounting_position_and_orientation(::sensoris::protobuf::types::source::Sensor_MountingPositionAndOrientation* value);
  ::sensoris::protobuf::types::source::Sensor_MountingPositionAndOrientation* unsafe_arena_release_mounting_position_and_orientation();

  private:
  const ::sensoris::protobuf::types::source::Sensor_MountingPositionAndOrientation& _internal_mounting_position_and_orientation() const;
  ::sensoris::protobuf::types::source::Sensor_MountingPositionAndOrientation* _internal_mutable_mounting_position_and_orientation();

  public:
  // .sensoris.protobuf.types.source.NavigationSatelliteSystem navigation_satellite_system = 2;
  bool has_navigation_satellite_system() const;
  private:
  bool _internal_has_navigation_satellite_system() const;

  public:
  void clear_navigation_satellite_system() ;
  const ::sensoris::protobuf::types::source::NavigationSatelliteSystem& navigation_satellite_system() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::source::NavigationSatelliteSystem* release_navigation_satellite_system();
  ::sensoris::protobuf::types::source::NavigationSatelliteSystem* mutable_navigation_satellite_system();
  void set_allocated_navigation_satellite_system(::sensoris::protobuf::types::source::NavigationSatelliteSystem* value);
  void unsafe_arena_set_allocated_navigation_satellite_system(::sensoris::protobuf::types::source::NavigationSatelliteSystem* value);
  ::sensoris::protobuf::types::source::NavigationSatelliteSystem* unsafe_arena_release_navigation_satellite_system();

  private:
  const ::sensoris::protobuf::types::source::NavigationSatelliteSystem& _internal_navigation_satellite_system() const;
  ::sensoris::protobuf::types::source::NavigationSatelliteSystem* _internal_mutable_navigation_satellite_system();

  public:
  void clear_specific();
  SpecificCase specific_case() const;
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.source.Sensor)
 private:
  class _Internal;
  void set_has_navigation_satellite_system();

  inline bool has_specific() const;
  inline void clear_has_specific();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::source::Sensor_MountingPositionAndOrientation* mounting_position_and_orientation_;
    union SpecificUnion {
      constexpr SpecificUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::sensoris::protobuf::types::source::NavigationSatelliteSystem* navigation_satellite_system_;
    } specific_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2ftypes_2fsource_2eproto;
};// -------------------------------------------------------------------

class Source final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.source.Source) */ {
 public:
  inline Source() : Source(nullptr) {}
  ~Source() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Source(::google::protobuf::internal::ConstantInitialized);

  inline Source(const Source& from)
      : Source(nullptr, from) {}
  Source(Source&& from) noexcept
    : Source() {
    *this = ::std::move(from);
  }

  inline Source& operator=(const Source& from) {
    CopyFrom(from);
    return *this;
  }
  inline Source& operator=(Source&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Source& default_instance() {
    return *internal_default_instance();
  }
  enum SourceCase {
    kSensor = 4,
    kSensorFusion = 5,
    SOURCE_NOT_SET = 0,
  };

  static inline const Source* internal_default_instance() {
    return reinterpret_cast<const Source*>(
               &_Source_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Source& a, Source& b) {
    a.Swap(&b);
  }
  inline void Swap(Source* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Source* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Source* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Source>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Source& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Source& from) {
    Source::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Source* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.types.source.Source";
  }
  protected:
  explicit Source(::google::protobuf::Arena* arena);
  Source(::google::protobuf::Arena* arena, const Source& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExtensionFieldNumber = 15,
    kIdFieldNumber = 1,
    kEntityFieldNumber = 2,
    kSamplingFrequencyFieldNumber = 3,
    kSensorFieldNumber = 4,
    kSensorFusionFieldNumber = 5,
  };
  // repeated .google.protobuf.Any extension = 15;
  int extension_size() const;
  private:
  int _internal_extension_size() const;

  public:
  void clear_extension() ;
  ::google::protobuf::Any* mutable_extension(int index);
  ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >*
      mutable_extension();
  private:
  const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& _internal_extension() const;
  ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* _internal_mutable_extension();
  public:
  const ::google::protobuf::Any& extension(int index) const;
  ::google::protobuf::Any* add_extension();
  const ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >&
      extension() const;
  // .google.protobuf.Int64Value id = 1;
  bool has_id() const;
  void clear_id() ;
  const ::google::protobuf::Int64Value& id() const;
  PROTOBUF_NODISCARD ::google::protobuf::Int64Value* release_id();
  ::google::protobuf::Int64Value* mutable_id();
  void set_allocated_id(::google::protobuf::Int64Value* value);
  void unsafe_arena_set_allocated_id(::google::protobuf::Int64Value* value);
  ::google::protobuf::Int64Value* unsafe_arena_release_id();

  private:
  const ::google::protobuf::Int64Value& _internal_id() const;
  ::google::protobuf::Int64Value* _internal_mutable_id();

  public:
  // .sensoris.protobuf.types.base.Entity entity = 2;
  bool has_entity() const;
  void clear_entity() ;
  const ::sensoris::protobuf::types::base::Entity& entity() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::Entity* release_entity();
  ::sensoris::protobuf::types::base::Entity* mutable_entity();
  void set_allocated_entity(::sensoris::protobuf::types::base::Entity* value);
  void unsafe_arena_set_allocated_entity(::sensoris::protobuf::types::base::Entity* value);
  ::sensoris::protobuf::types::base::Entity* unsafe_arena_release_entity();

  private:
  const ::sensoris::protobuf::types::base::Entity& _internal_entity() const;
  ::sensoris::protobuf::types::base::Entity* _internal_mutable_entity();

  public:
  // .sensoris.protobuf.types.base.Int64Value sampling_frequency = 3 [(.sensoris.protobuf.types.base.exponent) = 3];
  bool has_sampling_frequency() const;
  void clear_sampling_frequency() ;
  const ::sensoris::protobuf::types::base::Int64Value& sampling_frequency() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::Int64Value* release_sampling_frequency();
  ::sensoris::protobuf::types::base::Int64Value* mutable_sampling_frequency();
  void set_allocated_sampling_frequency(::sensoris::protobuf::types::base::Int64Value* value);
  void unsafe_arena_set_allocated_sampling_frequency(::sensoris::protobuf::types::base::Int64Value* value);
  ::sensoris::protobuf::types::base::Int64Value* unsafe_arena_release_sampling_frequency();

  private:
  const ::sensoris::protobuf::types::base::Int64Value& _internal_sampling_frequency() const;
  ::sensoris::protobuf::types::base::Int64Value* _internal_mutable_sampling_frequency();

  public:
  // .sensoris.protobuf.types.source.Sensor sensor = 4;
  bool has_sensor() const;
  private:
  bool _internal_has_sensor() const;

  public:
  void clear_sensor() ;
  const ::sensoris::protobuf::types::source::Sensor& sensor() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::source::Sensor* release_sensor();
  ::sensoris::protobuf::types::source::Sensor* mutable_sensor();
  void set_allocated_sensor(::sensoris::protobuf::types::source::Sensor* value);
  void unsafe_arena_set_allocated_sensor(::sensoris::protobuf::types::source::Sensor* value);
  ::sensoris::protobuf::types::source::Sensor* unsafe_arena_release_sensor();

  private:
  const ::sensoris::protobuf::types::source::Sensor& _internal_sensor() const;
  ::sensoris::protobuf::types::source::Sensor* _internal_mutable_sensor();

  public:
  // .sensoris.protobuf.types.source.SensorFusion sensor_fusion = 5;
  bool has_sensor_fusion() const;
  private:
  bool _internal_has_sensor_fusion() const;

  public:
  void clear_sensor_fusion() ;
  const ::sensoris::protobuf::types::source::SensorFusion& sensor_fusion() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::source::SensorFusion* release_sensor_fusion();
  ::sensoris::protobuf::types::source::SensorFusion* mutable_sensor_fusion();
  void set_allocated_sensor_fusion(::sensoris::protobuf::types::source::SensorFusion* value);
  void unsafe_arena_set_allocated_sensor_fusion(::sensoris::protobuf::types::source::SensorFusion* value);
  ::sensoris::protobuf::types::source::SensorFusion* unsafe_arena_release_sensor_fusion();

  private:
  const ::sensoris::protobuf::types::source::SensorFusion& _internal_sensor_fusion() const;
  ::sensoris::protobuf::types::source::SensorFusion* _internal_mutable_sensor_fusion();

  public:
  void clear_source();
  SourceCase source_case() const;
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.source.Source)
 private:
  class _Internal;
  void set_has_sensor();
  void set_has_sensor_fusion();

  inline bool has_source() const;
  inline void clear_has_source();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 6,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any > extension_;
    ::google::protobuf::Int64Value* id_;
    ::sensoris::protobuf::types::base::Entity* entity_;
    ::sensoris::protobuf::types::base::Int64Value* sampling_frequency_;
    union SourceUnion {
      constexpr SourceUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::sensoris::protobuf::types::source::Sensor* sensor_;
      ::sensoris::protobuf::types::source::SensorFusion* sensor_fusion_;
    } source_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2ftypes_2fsource_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// NavigationSatelliteSystem

// repeated .sensoris.protobuf.types.source.NavigationSatelliteSystem.SatelliteSystem satellite_system = 1;
inline int NavigationSatelliteSystem::_internal_satellite_system_size() const {
  return _internal_satellite_system().size();
}
inline int NavigationSatelliteSystem::satellite_system_size() const {
  return _internal_satellite_system_size();
}
inline void NavigationSatelliteSystem::clear_satellite_system() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.satellite_system_.Clear();
}
inline ::sensoris::protobuf::types::source::NavigationSatelliteSystem_SatelliteSystem NavigationSatelliteSystem::satellite_system(int index) const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.source.NavigationSatelliteSystem.satellite_system)
  return static_cast<::sensoris::protobuf::types::source::NavigationSatelliteSystem_SatelliteSystem>(_internal_satellite_system().Get(index));
}
inline void NavigationSatelliteSystem::set_satellite_system(int index, ::sensoris::protobuf::types::source::NavigationSatelliteSystem_SatelliteSystem value) {
  _internal_mutable_satellite_system()->Set(index, value);
  // @@protoc_insertion_point(field_set:sensoris.protobuf.types.source.NavigationSatelliteSystem.satellite_system)
}
inline void NavigationSatelliteSystem::add_satellite_system(::sensoris::protobuf::types::source::NavigationSatelliteSystem_SatelliteSystem value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_satellite_system()->Add(value);
  // @@protoc_insertion_point(field_add:sensoris.protobuf.types.source.NavigationSatelliteSystem.satellite_system)
}
inline const ::google::protobuf::RepeatedField<int>& NavigationSatelliteSystem::satellite_system() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.types.source.NavigationSatelliteSystem.satellite_system)
  return _internal_satellite_system();
}
inline ::google::protobuf::RepeatedField<int>* NavigationSatelliteSystem::mutable_satellite_system()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.types.source.NavigationSatelliteSystem.satellite_system)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_satellite_system();
}
inline const ::google::protobuf::RepeatedField<int>& NavigationSatelliteSystem::_internal_satellite_system() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.satellite_system_;
}
inline ::google::protobuf::RepeatedField<int>* NavigationSatelliteSystem::_internal_mutable_satellite_system() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.satellite_system_;
}

// repeated .sensoris.protobuf.types.source.NavigationSatelliteSystem.SatelliteBasedAugmentationSystem satellite_based_augmentation_system = 2;
inline int NavigationSatelliteSystem::_internal_satellite_based_augmentation_system_size() const {
  return _internal_satellite_based_augmentation_system().size();
}
inline int NavigationSatelliteSystem::satellite_based_augmentation_system_size() const {
  return _internal_satellite_based_augmentation_system_size();
}
inline void NavigationSatelliteSystem::clear_satellite_based_augmentation_system() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.satellite_based_augmentation_system_.Clear();
}
inline ::sensoris::protobuf::types::source::NavigationSatelliteSystem_SatelliteBasedAugmentationSystem NavigationSatelliteSystem::satellite_based_augmentation_system(int index) const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.source.NavigationSatelliteSystem.satellite_based_augmentation_system)
  return static_cast<::sensoris::protobuf::types::source::NavigationSatelliteSystem_SatelliteBasedAugmentationSystem>(_internal_satellite_based_augmentation_system().Get(index));
}
inline void NavigationSatelliteSystem::set_satellite_based_augmentation_system(int index, ::sensoris::protobuf::types::source::NavigationSatelliteSystem_SatelliteBasedAugmentationSystem value) {
  _internal_mutable_satellite_based_augmentation_system()->Set(index, value);
  // @@protoc_insertion_point(field_set:sensoris.protobuf.types.source.NavigationSatelliteSystem.satellite_based_augmentation_system)
}
inline void NavigationSatelliteSystem::add_satellite_based_augmentation_system(::sensoris::protobuf::types::source::NavigationSatelliteSystem_SatelliteBasedAugmentationSystem value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_satellite_based_augmentation_system()->Add(value);
  // @@protoc_insertion_point(field_add:sensoris.protobuf.types.source.NavigationSatelliteSystem.satellite_based_augmentation_system)
}
inline const ::google::protobuf::RepeatedField<int>& NavigationSatelliteSystem::satellite_based_augmentation_system() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.types.source.NavigationSatelliteSystem.satellite_based_augmentation_system)
  return _internal_satellite_based_augmentation_system();
}
inline ::google::protobuf::RepeatedField<int>* NavigationSatelliteSystem::mutable_satellite_based_augmentation_system()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.types.source.NavigationSatelliteSystem.satellite_based_augmentation_system)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_satellite_based_augmentation_system();
}
inline const ::google::protobuf::RepeatedField<int>& NavigationSatelliteSystem::_internal_satellite_based_augmentation_system() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.satellite_based_augmentation_system_;
}
inline ::google::protobuf::RepeatedField<int>* NavigationSatelliteSystem::_internal_mutable_satellite_based_augmentation_system() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.satellite_based_augmentation_system_;
}

// repeated .sensoris.protobuf.types.source.NavigationSatelliteSystem.GroundBasedAugmentationSystem ground_based_augmentation_system = 3;
inline int NavigationSatelliteSystem::_internal_ground_based_augmentation_system_size() const {
  return _internal_ground_based_augmentation_system().size();
}
inline int NavigationSatelliteSystem::ground_based_augmentation_system_size() const {
  return _internal_ground_based_augmentation_system_size();
}
inline void NavigationSatelliteSystem::clear_ground_based_augmentation_system() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ground_based_augmentation_system_.Clear();
}
inline ::sensoris::protobuf::types::source::NavigationSatelliteSystem_GroundBasedAugmentationSystem NavigationSatelliteSystem::ground_based_augmentation_system(int index) const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.source.NavigationSatelliteSystem.ground_based_augmentation_system)
  return static_cast<::sensoris::protobuf::types::source::NavigationSatelliteSystem_GroundBasedAugmentationSystem>(_internal_ground_based_augmentation_system().Get(index));
}
inline void NavigationSatelliteSystem::set_ground_based_augmentation_system(int index, ::sensoris::protobuf::types::source::NavigationSatelliteSystem_GroundBasedAugmentationSystem value) {
  _internal_mutable_ground_based_augmentation_system()->Set(index, value);
  // @@protoc_insertion_point(field_set:sensoris.protobuf.types.source.NavigationSatelliteSystem.ground_based_augmentation_system)
}
inline void NavigationSatelliteSystem::add_ground_based_augmentation_system(::sensoris::protobuf::types::source::NavigationSatelliteSystem_GroundBasedAugmentationSystem value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_ground_based_augmentation_system()->Add(value);
  // @@protoc_insertion_point(field_add:sensoris.protobuf.types.source.NavigationSatelliteSystem.ground_based_augmentation_system)
}
inline const ::google::protobuf::RepeatedField<int>& NavigationSatelliteSystem::ground_based_augmentation_system() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.types.source.NavigationSatelliteSystem.ground_based_augmentation_system)
  return _internal_ground_based_augmentation_system();
}
inline ::google::protobuf::RepeatedField<int>* NavigationSatelliteSystem::mutable_ground_based_augmentation_system()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.types.source.NavigationSatelliteSystem.ground_based_augmentation_system)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_ground_based_augmentation_system();
}
inline const ::google::protobuf::RepeatedField<int>& NavigationSatelliteSystem::_internal_ground_based_augmentation_system() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ground_based_augmentation_system_;
}
inline ::google::protobuf::RepeatedField<int>* NavigationSatelliteSystem::_internal_mutable_ground_based_augmentation_system() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.ground_based_augmentation_system_;
}

// .google.protobuf.Int64Value elevation_mask = 4 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool NavigationSatelliteSystem::has_elevation_mask() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.elevation_mask_ != nullptr);
  return value;
}
inline const ::google::protobuf::Int64Value& NavigationSatelliteSystem::_internal_elevation_mask() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Int64Value* p = _impl_.elevation_mask_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Int64Value&>(::google::protobuf::_Int64Value_default_instance_);
}
inline const ::google::protobuf::Int64Value& NavigationSatelliteSystem::elevation_mask() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.source.NavigationSatelliteSystem.elevation_mask)
  return _internal_elevation_mask();
}
inline void NavigationSatelliteSystem::unsafe_arena_set_allocated_elevation_mask(::google::protobuf::Int64Value* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.elevation_mask_);
  }
  _impl_.elevation_mask_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.source.NavigationSatelliteSystem.elevation_mask)
}
inline ::google::protobuf::Int64Value* NavigationSatelliteSystem::release_elevation_mask() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Int64Value* released = _impl_.elevation_mask_;
  _impl_.elevation_mask_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Int64Value* NavigationSatelliteSystem::unsafe_arena_release_elevation_mask() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.source.NavigationSatelliteSystem.elevation_mask)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Int64Value* temp = _impl_.elevation_mask_;
  _impl_.elevation_mask_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int64Value* NavigationSatelliteSystem::_internal_mutable_elevation_mask() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.elevation_mask_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int64Value>(GetArena());
    _impl_.elevation_mask_ = reinterpret_cast<::google::protobuf::Int64Value*>(p);
  }
  return _impl_.elevation_mask_;
}
inline ::google::protobuf::Int64Value* NavigationSatelliteSystem::mutable_elevation_mask() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Int64Value* _msg = _internal_mutable_elevation_mask();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.source.NavigationSatelliteSystem.elevation_mask)
  return _msg;
}
inline void NavigationSatelliteSystem::set_allocated_elevation_mask(::google::protobuf::Int64Value* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.elevation_mask_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.elevation_mask_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.source.NavigationSatelliteSystem.elevation_mask)
}

// .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy antenna_offset_and_accuracy = 5;
inline bool NavigationSatelliteSystem::has_antenna_offset_and_accuracy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.antenna_offset_and_accuracy_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& NavigationSatelliteSystem::_internal_antenna_offset_and_accuracy() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* p = _impl_.antenna_offset_and_accuracy_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy&>(::sensoris::protobuf::types::spatial::_XyzVectorAndAccuracy_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& NavigationSatelliteSystem::antenna_offset_and_accuracy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.source.NavigationSatelliteSystem.antenna_offset_and_accuracy)
  return _internal_antenna_offset_and_accuracy();
}
inline void NavigationSatelliteSystem::unsafe_arena_set_allocated_antenna_offset_and_accuracy(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.antenna_offset_and_accuracy_);
  }
  _impl_.antenna_offset_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.source.NavigationSatelliteSystem.antenna_offset_and_accuracy)
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* NavigationSatelliteSystem::release_antenna_offset_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* released = _impl_.antenna_offset_and_accuracy_;
  _impl_.antenna_offset_and_accuracy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* NavigationSatelliteSystem::unsafe_arena_release_antenna_offset_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.source.NavigationSatelliteSystem.antenna_offset_and_accuracy)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* temp = _impl_.antenna_offset_and_accuracy_;
  _impl_.antenna_offset_and_accuracy_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* NavigationSatelliteSystem::_internal_mutable_antenna_offset_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.antenna_offset_and_accuracy_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy>(GetArena());
    _impl_.antenna_offset_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy*>(p);
  }
  return _impl_.antenna_offset_and_accuracy_;
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* NavigationSatelliteSystem::mutable_antenna_offset_and_accuracy() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* _msg = _internal_mutable_antenna_offset_and_accuracy();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.source.NavigationSatelliteSystem.antenna_offset_and_accuracy)
  return _msg;
}
inline void NavigationSatelliteSystem::set_allocated_antenna_offset_and_accuracy(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.antenna_offset_and_accuracy_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.antenna_offset_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.source.NavigationSatelliteSystem.antenna_offset_and_accuracy)
}

// repeated .google.protobuf.Any extension = 15;
inline int NavigationSatelliteSystem::_internal_extension_size() const {
  return _internal_extension().size();
}
inline int NavigationSatelliteSystem::extension_size() const {
  return _internal_extension_size();
}
inline ::google::protobuf::Any* NavigationSatelliteSystem::mutable_extension(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.source.NavigationSatelliteSystem.extension)
  return _internal_mutable_extension()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* NavigationSatelliteSystem::mutable_extension()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.types.source.NavigationSatelliteSystem.extension)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_extension();
}
inline const ::google::protobuf::Any& NavigationSatelliteSystem::extension(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.source.NavigationSatelliteSystem.extension)
  return _internal_extension().Get(index);
}
inline ::google::protobuf::Any* NavigationSatelliteSystem::add_extension() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::google::protobuf::Any* _add = _internal_mutable_extension()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.types.source.NavigationSatelliteSystem.extension)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& NavigationSatelliteSystem::extension() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.types.source.NavigationSatelliteSystem.extension)
  return _internal_extension();
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>&
NavigationSatelliteSystem::_internal_extension() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.extension_;
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>*
NavigationSatelliteSystem::_internal_mutable_extension() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.extension_;
}

// -------------------------------------------------------------------

// Sensor_MountingPositionAndOrientation

// .sensoris.protobuf.types.spatial.PositionAndAccuracy translation_and_accuracy = 1;
inline bool Sensor_MountingPositionAndOrientation::has_translation_and_accuracy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.translation_and_accuracy_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& Sensor_MountingPositionAndOrientation::_internal_translation_and_accuracy() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy* p = _impl_.translation_and_accuracy_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::spatial::PositionAndAccuracy&>(::sensoris::protobuf::types::spatial::_PositionAndAccuracy_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& Sensor_MountingPositionAndOrientation::translation_and_accuracy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.source.Sensor.MountingPositionAndOrientation.translation_and_accuracy)
  return _internal_translation_and_accuracy();
}
inline void Sensor_MountingPositionAndOrientation::unsafe_arena_set_allocated_translation_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.translation_and_accuracy_);
  }
  _impl_.translation_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.source.Sensor.MountingPositionAndOrientation.translation_and_accuracy)
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* Sensor_MountingPositionAndOrientation::release_translation_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* released = _impl_.translation_and_accuracy_;
  _impl_.translation_and_accuracy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* Sensor_MountingPositionAndOrientation::unsafe_arena_release_translation_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.source.Sensor.MountingPositionAndOrientation.translation_and_accuracy)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* temp = _impl_.translation_and_accuracy_;
  _impl_.translation_and_accuracy_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* Sensor_MountingPositionAndOrientation::_internal_mutable_translation_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.translation_and_accuracy_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::spatial::PositionAndAccuracy>(GetArena());
    _impl_.translation_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(p);
  }
  return _impl_.translation_and_accuracy_;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* Sensor_MountingPositionAndOrientation::mutable_translation_and_accuracy() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* _msg = _internal_mutable_translation_and_accuracy();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.source.Sensor.MountingPositionAndOrientation.translation_and_accuracy)
  return _msg;
}
inline void Sensor_MountingPositionAndOrientation::set_allocated_translation_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.translation_and_accuracy_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.translation_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.source.Sensor.MountingPositionAndOrientation.translation_and_accuracy)
}

// .sensoris.protobuf.types.spatial.RotationAndAccuracy orientation_and_accuracy = 2;
inline bool Sensor_MountingPositionAndOrientation::has_orientation_and_accuracy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.orientation_and_accuracy_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::spatial::RotationAndAccuracy& Sensor_MountingPositionAndOrientation::_internal_orientation_and_accuracy() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::spatial::RotationAndAccuracy* p = _impl_.orientation_and_accuracy_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::spatial::RotationAndAccuracy&>(::sensoris::protobuf::types::spatial::_RotationAndAccuracy_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::RotationAndAccuracy& Sensor_MountingPositionAndOrientation::orientation_and_accuracy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.source.Sensor.MountingPositionAndOrientation.orientation_and_accuracy)
  return _internal_orientation_and_accuracy();
}
inline void Sensor_MountingPositionAndOrientation::unsafe_arena_set_allocated_orientation_and_accuracy(::sensoris::protobuf::types::spatial::RotationAndAccuracy* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.orientation_and_accuracy_);
  }
  _impl_.orientation_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::RotationAndAccuracy*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.source.Sensor.MountingPositionAndOrientation.orientation_and_accuracy)
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy* Sensor_MountingPositionAndOrientation::release_orientation_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy* released = _impl_.orientation_and_accuracy_;
  _impl_.orientation_and_accuracy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy* Sensor_MountingPositionAndOrientation::unsafe_arena_release_orientation_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.source.Sensor.MountingPositionAndOrientation.orientation_and_accuracy)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy* temp = _impl_.orientation_and_accuracy_;
  _impl_.orientation_and_accuracy_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy* Sensor_MountingPositionAndOrientation::_internal_mutable_orientation_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.orientation_and_accuracy_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::spatial::RotationAndAccuracy>(GetArena());
    _impl_.orientation_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::RotationAndAccuracy*>(p);
  }
  return _impl_.orientation_and_accuracy_;
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy* Sensor_MountingPositionAndOrientation::mutable_orientation_and_accuracy() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy* _msg = _internal_mutable_orientation_and_accuracy();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.source.Sensor.MountingPositionAndOrientation.orientation_and_accuracy)
  return _msg;
}
inline void Sensor_MountingPositionAndOrientation::set_allocated_orientation_and_accuracy(::sensoris::protobuf::types::spatial::RotationAndAccuracy* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.orientation_and_accuracy_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.orientation_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::RotationAndAccuracy*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.source.Sensor.MountingPositionAndOrientation.orientation_and_accuracy)
}

// -------------------------------------------------------------------

// Sensor

// .sensoris.protobuf.types.source.Sensor.MountingPositionAndOrientation mounting_position_and_orientation = 1;
inline bool Sensor::has_mounting_position_and_orientation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.mounting_position_and_orientation_ != nullptr);
  return value;
}
inline void Sensor::clear_mounting_position_and_orientation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.mounting_position_and_orientation_ != nullptr) _impl_.mounting_position_and_orientation_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::sensoris::protobuf::types::source::Sensor_MountingPositionAndOrientation& Sensor::_internal_mounting_position_and_orientation() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::source::Sensor_MountingPositionAndOrientation* p = _impl_.mounting_position_and_orientation_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::source::Sensor_MountingPositionAndOrientation&>(::sensoris::protobuf::types::source::_Sensor_MountingPositionAndOrientation_default_instance_);
}
inline const ::sensoris::protobuf::types::source::Sensor_MountingPositionAndOrientation& Sensor::mounting_position_and_orientation() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.source.Sensor.mounting_position_and_orientation)
  return _internal_mounting_position_and_orientation();
}
inline void Sensor::unsafe_arena_set_allocated_mounting_position_and_orientation(::sensoris::protobuf::types::source::Sensor_MountingPositionAndOrientation* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.mounting_position_and_orientation_);
  }
  _impl_.mounting_position_and_orientation_ = reinterpret_cast<::sensoris::protobuf::types::source::Sensor_MountingPositionAndOrientation*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.source.Sensor.mounting_position_and_orientation)
}
inline ::sensoris::protobuf::types::source::Sensor_MountingPositionAndOrientation* Sensor::release_mounting_position_and_orientation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::source::Sensor_MountingPositionAndOrientation* released = _impl_.mounting_position_and_orientation_;
  _impl_.mounting_position_and_orientation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::source::Sensor_MountingPositionAndOrientation* Sensor::unsafe_arena_release_mounting_position_and_orientation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.source.Sensor.mounting_position_and_orientation)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::source::Sensor_MountingPositionAndOrientation* temp = _impl_.mounting_position_and_orientation_;
  _impl_.mounting_position_and_orientation_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::source::Sensor_MountingPositionAndOrientation* Sensor::_internal_mutable_mounting_position_and_orientation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.mounting_position_and_orientation_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::source::Sensor_MountingPositionAndOrientation>(GetArena());
    _impl_.mounting_position_and_orientation_ = reinterpret_cast<::sensoris::protobuf::types::source::Sensor_MountingPositionAndOrientation*>(p);
  }
  return _impl_.mounting_position_and_orientation_;
}
inline ::sensoris::protobuf::types::source::Sensor_MountingPositionAndOrientation* Sensor::mutable_mounting_position_and_orientation() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::source::Sensor_MountingPositionAndOrientation* _msg = _internal_mutable_mounting_position_and_orientation();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.source.Sensor.mounting_position_and_orientation)
  return _msg;
}
inline void Sensor::set_allocated_mounting_position_and_orientation(::sensoris::protobuf::types::source::Sensor_MountingPositionAndOrientation* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::sensoris::protobuf::types::source::Sensor_MountingPositionAndOrientation*>(_impl_.mounting_position_and_orientation_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::sensoris::protobuf::types::source::Sensor_MountingPositionAndOrientation*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.mounting_position_and_orientation_ = reinterpret_cast<::sensoris::protobuf::types::source::Sensor_MountingPositionAndOrientation*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.source.Sensor.mounting_position_and_orientation)
}

// .sensoris.protobuf.types.source.NavigationSatelliteSystem navigation_satellite_system = 2;
inline bool Sensor::has_navigation_satellite_system() const {
  return specific_case() == kNavigationSatelliteSystem;
}
inline bool Sensor::_internal_has_navigation_satellite_system() const {
  return specific_case() == kNavigationSatelliteSystem;
}
inline void Sensor::set_has_navigation_satellite_system() {
  _impl_._oneof_case_[0] = kNavigationSatelliteSystem;
}
inline void Sensor::clear_navigation_satellite_system() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (specific_case() == kNavigationSatelliteSystem) {
    if (GetArena() == nullptr) {
      delete _impl_.specific_.navigation_satellite_system_;
    }
    clear_has_specific();
  }
}
inline ::sensoris::protobuf::types::source::NavigationSatelliteSystem* Sensor::release_navigation_satellite_system() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.source.Sensor.navigation_satellite_system)
  if (specific_case() == kNavigationSatelliteSystem) {
    clear_has_specific();
    auto* temp = _impl_.specific_.navigation_satellite_system_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.specific_.navigation_satellite_system_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensoris::protobuf::types::source::NavigationSatelliteSystem& Sensor::_internal_navigation_satellite_system() const {
  return specific_case() == kNavigationSatelliteSystem ? *_impl_.specific_.navigation_satellite_system_ : reinterpret_cast<::sensoris::protobuf::types::source::NavigationSatelliteSystem&>(::sensoris::protobuf::types::source::_NavigationSatelliteSystem_default_instance_);
}
inline const ::sensoris::protobuf::types::source::NavigationSatelliteSystem& Sensor::navigation_satellite_system() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.source.Sensor.navigation_satellite_system)
  return _internal_navigation_satellite_system();
}
inline ::sensoris::protobuf::types::source::NavigationSatelliteSystem* Sensor::unsafe_arena_release_navigation_satellite_system() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.source.Sensor.navigation_satellite_system)
  if (specific_case() == kNavigationSatelliteSystem) {
    clear_has_specific();
    auto* temp = _impl_.specific_.navigation_satellite_system_;
    _impl_.specific_.navigation_satellite_system_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Sensor::unsafe_arena_set_allocated_navigation_satellite_system(::sensoris::protobuf::types::source::NavigationSatelliteSystem* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_specific();
  if (value) {
    set_has_navigation_satellite_system();
    _impl_.specific_.navigation_satellite_system_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.source.Sensor.navigation_satellite_system)
}
inline ::sensoris::protobuf::types::source::NavigationSatelliteSystem* Sensor::_internal_mutable_navigation_satellite_system() {
  if (specific_case() != kNavigationSatelliteSystem) {
    clear_specific();
    set_has_navigation_satellite_system();
    _impl_.specific_.navigation_satellite_system_ = CreateMaybeMessage<::sensoris::protobuf::types::source::NavigationSatelliteSystem>(GetArena());
  }
  return _impl_.specific_.navigation_satellite_system_;
}
inline ::sensoris::protobuf::types::source::NavigationSatelliteSystem* Sensor::mutable_navigation_satellite_system() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::source::NavigationSatelliteSystem* _msg = _internal_mutable_navigation_satellite_system();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.source.Sensor.navigation_satellite_system)
  return _msg;
}

inline bool Sensor::has_specific() const {
  return specific_case() != SPECIFIC_NOT_SET;
}
inline void Sensor::clear_has_specific() {
  _impl_._oneof_case_[0] = SPECIFIC_NOT_SET;
}
inline Sensor::SpecificCase Sensor::specific_case() const {
  return Sensor::SpecificCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// SensorFusion

// repeated .google.protobuf.Int64Value sensor_id = 1;
inline int SensorFusion::_internal_sensor_id_size() const {
  return _internal_sensor_id().size();
}
inline int SensorFusion::sensor_id_size() const {
  return _internal_sensor_id_size();
}
inline ::google::protobuf::Int64Value* SensorFusion::mutable_sensor_id(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.source.SensorFusion.sensor_id)
  return _internal_mutable_sensor_id()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Int64Value>* SensorFusion::mutable_sensor_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.types.source.SensorFusion.sensor_id)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_sensor_id();
}
inline const ::google::protobuf::Int64Value& SensorFusion::sensor_id(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.source.SensorFusion.sensor_id)
  return _internal_sensor_id().Get(index);
}
inline ::google::protobuf::Int64Value* SensorFusion::add_sensor_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::google::protobuf::Int64Value* _add = _internal_mutable_sensor_id()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.types.source.SensorFusion.sensor_id)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Int64Value>& SensorFusion::sensor_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.types.source.SensorFusion.sensor_id)
  return _internal_sensor_id();
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Int64Value>&
SensorFusion::_internal_sensor_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sensor_id_;
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Int64Value>*
SensorFusion::_internal_mutable_sensor_id() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.sensor_id_;
}

// -------------------------------------------------------------------

// Source

// .google.protobuf.Int64Value id = 1;
inline bool Source::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.id_ != nullptr);
  return value;
}
inline const ::google::protobuf::Int64Value& Source::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Int64Value* p = _impl_.id_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Int64Value&>(::google::protobuf::_Int64Value_default_instance_);
}
inline const ::google::protobuf::Int64Value& Source::id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.source.Source.id)
  return _internal_id();
}
inline void Source::unsafe_arena_set_allocated_id(::google::protobuf::Int64Value* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.id_);
  }
  _impl_.id_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.source.Source.id)
}
inline ::google::protobuf::Int64Value* Source::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Int64Value* released = _impl_.id_;
  _impl_.id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Int64Value* Source::unsafe_arena_release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.source.Source.id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Int64Value* temp = _impl_.id_;
  _impl_.id_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int64Value* Source::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.id_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int64Value>(GetArena());
    _impl_.id_ = reinterpret_cast<::google::protobuf::Int64Value*>(p);
  }
  return _impl_.id_;
}
inline ::google::protobuf::Int64Value* Source::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Int64Value* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.source.Source.id)
  return _msg;
}
inline void Source::set_allocated_id(::google::protobuf::Int64Value* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.id_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.source.Source.id)
}

// .sensoris.protobuf.types.base.Entity entity = 2;
inline bool Source::has_entity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.entity_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Entity& Source::_internal_entity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::Entity* p = _impl_.entity_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Entity&>(::sensoris::protobuf::types::base::_Entity_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Entity& Source::entity() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.source.Source.entity)
  return _internal_entity();
}
inline void Source::unsafe_arena_set_allocated_entity(::sensoris::protobuf::types::base::Entity* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.entity_);
  }
  _impl_.entity_ = reinterpret_cast<::sensoris::protobuf::types::base::Entity*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.source.Source.entity)
}
inline ::sensoris::protobuf::types::base::Entity* Source::release_entity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::Entity* released = _impl_.entity_;
  _impl_.entity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::Entity* Source::unsafe_arena_release_entity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.source.Source.entity)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::Entity* temp = _impl_.entity_;
  _impl_.entity_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Entity* Source::_internal_mutable_entity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.entity_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Entity>(GetArena());
    _impl_.entity_ = reinterpret_cast<::sensoris::protobuf::types::base::Entity*>(p);
  }
  return _impl_.entity_;
}
inline ::sensoris::protobuf::types::base::Entity* Source::mutable_entity() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::Entity* _msg = _internal_mutable_entity();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.source.Source.entity)
  return _msg;
}
inline void Source::set_allocated_entity(::sensoris::protobuf::types::base::Entity* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.entity_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.entity_ = reinterpret_cast<::sensoris::protobuf::types::base::Entity*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.source.Source.entity)
}

// .sensoris.protobuf.types.base.Int64Value sampling_frequency = 3 [(.sensoris.protobuf.types.base.exponent) = 3];
inline bool Source::has_sampling_frequency() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.sampling_frequency_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Int64Value& Source::_internal_sampling_frequency() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::Int64Value* p = _impl_.sampling_frequency_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Int64Value&>(::sensoris::protobuf::types::base::_Int64Value_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64Value& Source::sampling_frequency() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.source.Source.sampling_frequency)
  return _internal_sampling_frequency();
}
inline void Source::unsafe_arena_set_allocated_sampling_frequency(::sensoris::protobuf::types::base::Int64Value* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.sampling_frequency_);
  }
  _impl_.sampling_frequency_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.source.Source.sampling_frequency)
}
inline ::sensoris::protobuf::types::base::Int64Value* Source::release_sampling_frequency() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::types::base::Int64Value* released = _impl_.sampling_frequency_;
  _impl_.sampling_frequency_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::Int64Value* Source::unsafe_arena_release_sampling_frequency() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.source.Source.sampling_frequency)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::types::base::Int64Value* temp = _impl_.sampling_frequency_;
  _impl_.sampling_frequency_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* Source::_internal_mutable_sampling_frequency() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.sampling_frequency_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64Value>(GetArena());
    _impl_.sampling_frequency_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(p);
  }
  return _impl_.sampling_frequency_;
}
inline ::sensoris::protobuf::types::base::Int64Value* Source::mutable_sampling_frequency() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::Int64Value* _msg = _internal_mutable_sampling_frequency();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.source.Source.sampling_frequency)
  return _msg;
}
inline void Source::set_allocated_sampling_frequency(::sensoris::protobuf::types::base::Int64Value* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.sampling_frequency_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.sampling_frequency_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.source.Source.sampling_frequency)
}

// .sensoris.protobuf.types.source.Sensor sensor = 4;
inline bool Source::has_sensor() const {
  return source_case() == kSensor;
}
inline bool Source::_internal_has_sensor() const {
  return source_case() == kSensor;
}
inline void Source::set_has_sensor() {
  _impl_._oneof_case_[0] = kSensor;
}
inline void Source::clear_sensor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (source_case() == kSensor) {
    if (GetArena() == nullptr) {
      delete _impl_.source_.sensor_;
    }
    clear_has_source();
  }
}
inline ::sensoris::protobuf::types::source::Sensor* Source::release_sensor() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.source.Source.sensor)
  if (source_case() == kSensor) {
    clear_has_source();
    auto* temp = _impl_.source_.sensor_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.source_.sensor_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensoris::protobuf::types::source::Sensor& Source::_internal_sensor() const {
  return source_case() == kSensor ? *_impl_.source_.sensor_ : reinterpret_cast<::sensoris::protobuf::types::source::Sensor&>(::sensoris::protobuf::types::source::_Sensor_default_instance_);
}
inline const ::sensoris::protobuf::types::source::Sensor& Source::sensor() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.source.Source.sensor)
  return _internal_sensor();
}
inline ::sensoris::protobuf::types::source::Sensor* Source::unsafe_arena_release_sensor() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.source.Source.sensor)
  if (source_case() == kSensor) {
    clear_has_source();
    auto* temp = _impl_.source_.sensor_;
    _impl_.source_.sensor_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Source::unsafe_arena_set_allocated_sensor(::sensoris::protobuf::types::source::Sensor* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_source();
  if (value) {
    set_has_sensor();
    _impl_.source_.sensor_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.source.Source.sensor)
}
inline ::sensoris::protobuf::types::source::Sensor* Source::_internal_mutable_sensor() {
  if (source_case() != kSensor) {
    clear_source();
    set_has_sensor();
    _impl_.source_.sensor_ = CreateMaybeMessage<::sensoris::protobuf::types::source::Sensor>(GetArena());
  }
  return _impl_.source_.sensor_;
}
inline ::sensoris::protobuf::types::source::Sensor* Source::mutable_sensor() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::source::Sensor* _msg = _internal_mutable_sensor();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.source.Source.sensor)
  return _msg;
}

// .sensoris.protobuf.types.source.SensorFusion sensor_fusion = 5;
inline bool Source::has_sensor_fusion() const {
  return source_case() == kSensorFusion;
}
inline bool Source::_internal_has_sensor_fusion() const {
  return source_case() == kSensorFusion;
}
inline void Source::set_has_sensor_fusion() {
  _impl_._oneof_case_[0] = kSensorFusion;
}
inline void Source::clear_sensor_fusion() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (source_case() == kSensorFusion) {
    if (GetArena() == nullptr) {
      delete _impl_.source_.sensor_fusion_;
    }
    clear_has_source();
  }
}
inline ::sensoris::protobuf::types::source::SensorFusion* Source::release_sensor_fusion() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.source.Source.sensor_fusion)
  if (source_case() == kSensorFusion) {
    clear_has_source();
    auto* temp = _impl_.source_.sensor_fusion_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.source_.sensor_fusion_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensoris::protobuf::types::source::SensorFusion& Source::_internal_sensor_fusion() const {
  return source_case() == kSensorFusion ? *_impl_.source_.sensor_fusion_ : reinterpret_cast<::sensoris::protobuf::types::source::SensorFusion&>(::sensoris::protobuf::types::source::_SensorFusion_default_instance_);
}
inline const ::sensoris::protobuf::types::source::SensorFusion& Source::sensor_fusion() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.source.Source.sensor_fusion)
  return _internal_sensor_fusion();
}
inline ::sensoris::protobuf::types::source::SensorFusion* Source::unsafe_arena_release_sensor_fusion() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.source.Source.sensor_fusion)
  if (source_case() == kSensorFusion) {
    clear_has_source();
    auto* temp = _impl_.source_.sensor_fusion_;
    _impl_.source_.sensor_fusion_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Source::unsafe_arena_set_allocated_sensor_fusion(::sensoris::protobuf::types::source::SensorFusion* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_source();
  if (value) {
    set_has_sensor_fusion();
    _impl_.source_.sensor_fusion_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.source.Source.sensor_fusion)
}
inline ::sensoris::protobuf::types::source::SensorFusion* Source::_internal_mutable_sensor_fusion() {
  if (source_case() != kSensorFusion) {
    clear_source();
    set_has_sensor_fusion();
    _impl_.source_.sensor_fusion_ = CreateMaybeMessage<::sensoris::protobuf::types::source::SensorFusion>(GetArena());
  }
  return _impl_.source_.sensor_fusion_;
}
inline ::sensoris::protobuf::types::source::SensorFusion* Source::mutable_sensor_fusion() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::source::SensorFusion* _msg = _internal_mutable_sensor_fusion();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.source.Source.sensor_fusion)
  return _msg;
}

// repeated .google.protobuf.Any extension = 15;
inline int Source::_internal_extension_size() const {
  return _internal_extension().size();
}
inline int Source::extension_size() const {
  return _internal_extension_size();
}
inline ::google::protobuf::Any* Source::mutable_extension(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.source.Source.extension)
  return _internal_mutable_extension()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* Source::mutable_extension()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.types.source.Source.extension)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_extension();
}
inline const ::google::protobuf::Any& Source::extension(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.source.Source.extension)
  return _internal_extension().Get(index);
}
inline ::google::protobuf::Any* Source::add_extension() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::google::protobuf::Any* _add = _internal_mutable_extension()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.types.source.Source.extension)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& Source::extension() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.types.source.Source.extension)
  return _internal_extension();
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>&
Source::_internal_extension() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.extension_;
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>*
Source::_internal_mutable_extension() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.extension_;
}

inline bool Source::has_source() const {
  return source_case() != SOURCE_NOT_SET;
}
inline void Source::clear_has_source() {
  _impl_._oneof_case_[0] = SOURCE_NOT_SET;
}
inline Source::SourceCase Source::source_case() const {
  return Source::SourceCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace source
}  // namespace types
}  // namespace protobuf
}  // namespace sensoris


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::sensoris::protobuf::types::source::NavigationSatelliteSystem_SatelliteSystem> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::sensoris::protobuf::types::source::NavigationSatelliteSystem_SatelliteSystem>() {
  return ::sensoris::protobuf::types::source::NavigationSatelliteSystem_SatelliteSystem_descriptor();
}
template <>
struct is_proto_enum<::sensoris::protobuf::types::source::NavigationSatelliteSystem_SatelliteBasedAugmentationSystem> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::sensoris::protobuf::types::source::NavigationSatelliteSystem_SatelliteBasedAugmentationSystem>() {
  return ::sensoris::protobuf::types::source::NavigationSatelliteSystem_SatelliteBasedAugmentationSystem_descriptor();
}
template <>
struct is_proto_enum<::sensoris::protobuf::types::source::NavigationSatelliteSystem_GroundBasedAugmentationSystem> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::sensoris::protobuf::types::source::NavigationSatelliteSystem_GroundBasedAugmentationSystem>() {
  return ::sensoris::protobuf::types::source::NavigationSatelliteSystem_GroundBasedAugmentationSystem_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_sensoris_2fprotobuf_2ftypes_2fsource_2eproto_2epb_2eh
