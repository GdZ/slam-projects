/**
 * Copyright (c) 2017-2022 SENSORIS Innovation Platform hosted by ERTICO - ITS Europe.
 *
 * This program and the accompanying materials are made available under the terms of the Creative Commons Attribution-NoDerivatives 4.0 International license which accompanies this distribution, and is available at https://creativecommons.org/licenses/by-nd/4.0/legalcode.
 */
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sensoris/protobuf/categories/traffic_events.proto
// Protobuf C++ Version: 4.25.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "google/protobuf/wrappers.pb.h"
#include "sensoris/protobuf/types/base.pb.h"
#include "sensoris/protobuf/types/spatial.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto;
namespace sensoris {
namespace protobuf {
namespace categories {
namespace trafficevents {
class DangerousSlowDown;
struct DangerousSlowDownDefaultTypeInternal;
extern DangerousSlowDownDefaultTypeInternal _DangerousSlowDown_default_instance_;
class ECallStatus;
struct ECallStatusDefaultTypeInternal;
extern ECallStatusDefaultTypeInternal _ECallStatus_default_instance_;
class Hazard;
struct HazardDefaultTypeInternal;
extern HazardDefaultTypeInternal _Hazard_default_instance_;
class Hazard_TypeAndConfidence;
struct Hazard_TypeAndConfidenceDefaultTypeInternal;
extern Hazard_TypeAndConfidenceDefaultTypeInternal _Hazard_TypeAndConfidence_default_instance_;
class RoadObstructionCondition;
struct RoadObstructionConditionDefaultTypeInternal;
extern RoadObstructionConditionDefaultTypeInternal _RoadObstructionCondition_default_instance_;
class RoadObstructionCondition_TypeAndConfidence;
struct RoadObstructionCondition_TypeAndConfidenceDefaultTypeInternal;
extern RoadObstructionCondition_TypeAndConfidenceDefaultTypeInternal _RoadObstructionCondition_TypeAndConfidence_default_instance_;
class RoadSurfaceCondition;
struct RoadSurfaceConditionDefaultTypeInternal;
extern RoadSurfaceConditionDefaultTypeInternal _RoadSurfaceCondition_default_instance_;
class RoadSurfaceCondition_TypeAndConfidence;
struct RoadSurfaceCondition_TypeAndConfidenceDefaultTypeInternal;
extern RoadSurfaceCondition_TypeAndConfidenceDefaultTypeInternal _RoadSurfaceCondition_TypeAndConfidence_default_instance_;
class RoadWeatherCondition;
struct RoadWeatherConditionDefaultTypeInternal;
extern RoadWeatherConditionDefaultTypeInternal _RoadWeatherCondition_default_instance_;
class RoadWeatherCondition_TypeAndConfidence;
struct RoadWeatherCondition_TypeAndConfidenceDefaultTypeInternal;
extern RoadWeatherCondition_TypeAndConfidenceDefaultTypeInternal _RoadWeatherCondition_TypeAndConfidence_default_instance_;
class RoadWorks;
struct RoadWorksDefaultTypeInternal;
extern RoadWorksDefaultTypeInternal _RoadWorks_default_instance_;
class RoadWorks_TypeAndConfidence;
struct RoadWorks_TypeAndConfidenceDefaultTypeInternal;
extern RoadWorks_TypeAndConfidenceDefaultTypeInternal _RoadWorks_TypeAndConfidence_default_instance_;
class TrafficCondition;
struct TrafficConditionDefaultTypeInternal;
extern TrafficConditionDefaultTypeInternal _TrafficCondition_default_instance_;
class TrafficCondition_TypeAndConfidence;
struct TrafficCondition_TypeAndConfidenceDefaultTypeInternal;
extern TrafficCondition_TypeAndConfidenceDefaultTypeInternal _TrafficCondition_TypeAndConfidence_default_instance_;
class TrafficEventsCategory;
struct TrafficEventsCategoryDefaultTypeInternal;
extern TrafficEventsCategoryDefaultTypeInternal _TrafficEventsCategory_default_instance_;
class VulnerableRoadUserCondition;
struct VulnerableRoadUserConditionDefaultTypeInternal;
extern VulnerableRoadUserConditionDefaultTypeInternal _VulnerableRoadUserCondition_default_instance_;
class VulnerableRoadUserCondition_TypeAndConfidence;
struct VulnerableRoadUserCondition_TypeAndConfidenceDefaultTypeInternal;
extern VulnerableRoadUserCondition_TypeAndConfidenceDefaultTypeInternal _VulnerableRoadUserCondition_TypeAndConfidence_default_instance_;
}  // namespace trafficevents
}  // namespace categories
}  // namespace protobuf
}  // namespace sensoris
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace sensoris {
namespace protobuf {
namespace categories {
namespace trafficevents {
enum Hazard_TypeAndConfidence_Type : int {
  Hazard_TypeAndConfidence_Type_UNKNOWN_TYPE = 0,
  Hazard_TypeAndConfidence_Type_OBSTRUCTION = 1,
  Hazard_TypeAndConfidence_Type_ACCIDENT = 2,
  Hazard_TypeAndConfidence_Type_BROKEN_DOWN_VEHICLE = 3,
  Hazard_TypeAndConfidence_Type_SLOW_VEHICLE = 4,
  Hazard_TypeAndConfidence_Type_WRONG_WAY_VEHICLE = 5,
  Hazard_TypeAndConfidence_Type_ROADWORKS = 6,
  Hazard_TypeAndConfidence_Type_SLIPPERY_ROAD = 7,
  Hazard_TypeAndConfidence_Type_PEOPLE_THROWING_OBJECTS = 8,
  Hazard_TypeAndConfidence_Type_VEHICLE_ON_FIRE = 9,
  Hazard_TypeAndConfidence_Type_STATIONARY_VEHICLE = 10,
  Hazard_TypeAndConfidence_Type_EXCEPTIONAL_CONDITION_LOW_VISIBILITY = 11,
  Hazard_TypeAndConfidence_Type_EXCEPTIONAL_CONDITION_PRECIPITATION = 12,
  Hazard_TypeAndConfidence_Type_EXCEPTIONAL_CONDITION_WIND = 13,
  Hazard_TypeAndConfidence_Type_EXCEPTIONAL_CONDITION_ROAD_SURFACE = 14,
  Hazard_TypeAndConfidence_Type_EXCEPTIONAL_CONDITION_VULNERABLE_ROAD_USER = 15,
  Hazard_TypeAndConfidence_Type_Hazard_TypeAndConfidence_Type_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Hazard_TypeAndConfidence_Type_Hazard_TypeAndConfidence_Type_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Hazard_TypeAndConfidence_Type_IsValid(int value);
extern const uint32_t Hazard_TypeAndConfidence_Type_internal_data_[];
constexpr Hazard_TypeAndConfidence_Type Hazard_TypeAndConfidence_Type_Type_MIN = static_cast<Hazard_TypeAndConfidence_Type>(0);
constexpr Hazard_TypeAndConfidence_Type Hazard_TypeAndConfidence_Type_Type_MAX = static_cast<Hazard_TypeAndConfidence_Type>(15);
constexpr int Hazard_TypeAndConfidence_Type_Type_ARRAYSIZE = 15 + 1;
const ::google::protobuf::EnumDescriptor*
Hazard_TypeAndConfidence_Type_descriptor();
template <typename T>
const std::string& Hazard_TypeAndConfidence_Type_Name(T value) {
  static_assert(std::is_same<T, Hazard_TypeAndConfidence_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return Hazard_TypeAndConfidence_Type_Name(static_cast<Hazard_TypeAndConfidence_Type>(value));
}
template <>
inline const std::string& Hazard_TypeAndConfidence_Type_Name(Hazard_TypeAndConfidence_Type value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Hazard_TypeAndConfidence_Type_descriptor,
                                                 0, 15>(
      static_cast<int>(value));
}
inline bool Hazard_TypeAndConfidence_Type_Parse(absl::string_view name, Hazard_TypeAndConfidence_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Hazard_TypeAndConfidence_Type>(
      Hazard_TypeAndConfidence_Type_descriptor(), name, value);
}
enum Hazard_Direction : int {
  Hazard_Direction_UNKNOWN_DIRECTION = 0,
  Hazard_Direction_EGO_DIRECTION = 1,
  Hazard_Direction_OPPOSITE_DIRECTION = 2,
  Hazard_Direction_BOTH = 3,
  Hazard_Direction_Hazard_Direction_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Hazard_Direction_Hazard_Direction_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Hazard_Direction_IsValid(int value);
extern const uint32_t Hazard_Direction_internal_data_[];
constexpr Hazard_Direction Hazard_Direction_Direction_MIN = static_cast<Hazard_Direction>(0);
constexpr Hazard_Direction Hazard_Direction_Direction_MAX = static_cast<Hazard_Direction>(3);
constexpr int Hazard_Direction_Direction_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
Hazard_Direction_descriptor();
template <typename T>
const std::string& Hazard_Direction_Name(T value) {
  static_assert(std::is_same<T, Hazard_Direction>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Direction_Name().");
  return Hazard_Direction_Name(static_cast<Hazard_Direction>(value));
}
template <>
inline const std::string& Hazard_Direction_Name(Hazard_Direction value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Hazard_Direction_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool Hazard_Direction_Parse(absl::string_view name, Hazard_Direction* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Hazard_Direction>(
      Hazard_Direction_descriptor(), name, value);
}
enum TrafficCondition_TypeAndConfidence_Type : int {
  TrafficCondition_TypeAndConfidence_Type_UNKNOWN_TYPE = 0,
  TrafficCondition_TypeAndConfidence_Type_FREE_FLOW = 1,
  TrafficCondition_TypeAndConfidence_Type_HEAVY = 2,
  TrafficCondition_TypeAndConfidence_Type_SLOW = 3,
  TrafficCondition_TypeAndConfidence_Type_QUEUING = 4,
  TrafficCondition_TypeAndConfidence_Type_STATIONARY = 5,
  TrafficCondition_TypeAndConfidence_Type_TrafficCondition_TypeAndConfidence_Type_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  TrafficCondition_TypeAndConfidence_Type_TrafficCondition_TypeAndConfidence_Type_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool TrafficCondition_TypeAndConfidence_Type_IsValid(int value);
extern const uint32_t TrafficCondition_TypeAndConfidence_Type_internal_data_[];
constexpr TrafficCondition_TypeAndConfidence_Type TrafficCondition_TypeAndConfidence_Type_Type_MIN = static_cast<TrafficCondition_TypeAndConfidence_Type>(0);
constexpr TrafficCondition_TypeAndConfidence_Type TrafficCondition_TypeAndConfidence_Type_Type_MAX = static_cast<TrafficCondition_TypeAndConfidence_Type>(5);
constexpr int TrafficCondition_TypeAndConfidence_Type_Type_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor*
TrafficCondition_TypeAndConfidence_Type_descriptor();
template <typename T>
const std::string& TrafficCondition_TypeAndConfidence_Type_Name(T value) {
  static_assert(std::is_same<T, TrafficCondition_TypeAndConfidence_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return TrafficCondition_TypeAndConfidence_Type_Name(static_cast<TrafficCondition_TypeAndConfidence_Type>(value));
}
template <>
inline const std::string& TrafficCondition_TypeAndConfidence_Type_Name(TrafficCondition_TypeAndConfidence_Type value) {
  return ::google::protobuf::internal::NameOfDenseEnum<TrafficCondition_TypeAndConfidence_Type_descriptor,
                                                 0, 5>(
      static_cast<int>(value));
}
inline bool TrafficCondition_TypeAndConfidence_Type_Parse(absl::string_view name, TrafficCondition_TypeAndConfidence_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrafficCondition_TypeAndConfidence_Type>(
      TrafficCondition_TypeAndConfidence_Type_descriptor(), name, value);
}
enum RoadWorks_TypeAndConfidence_Type : int {
  RoadWorks_TypeAndConfidence_Type_UNKNOWN_TYPE = 0,
  RoadWorks_TypeAndConfidence_Type_START = 1,
  RoadWorks_TypeAndConfidence_Type_END = 2,
  RoadWorks_TypeAndConfidence_Type_RoadWorks_TypeAndConfidence_Type_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  RoadWorks_TypeAndConfidence_Type_RoadWorks_TypeAndConfidence_Type_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool RoadWorks_TypeAndConfidence_Type_IsValid(int value);
extern const uint32_t RoadWorks_TypeAndConfidence_Type_internal_data_[];
constexpr RoadWorks_TypeAndConfidence_Type RoadWorks_TypeAndConfidence_Type_Type_MIN = static_cast<RoadWorks_TypeAndConfidence_Type>(0);
constexpr RoadWorks_TypeAndConfidence_Type RoadWorks_TypeAndConfidence_Type_Type_MAX = static_cast<RoadWorks_TypeAndConfidence_Type>(2);
constexpr int RoadWorks_TypeAndConfidence_Type_Type_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
RoadWorks_TypeAndConfidence_Type_descriptor();
template <typename T>
const std::string& RoadWorks_TypeAndConfidence_Type_Name(T value) {
  static_assert(std::is_same<T, RoadWorks_TypeAndConfidence_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return RoadWorks_TypeAndConfidence_Type_Name(static_cast<RoadWorks_TypeAndConfidence_Type>(value));
}
template <>
inline const std::string& RoadWorks_TypeAndConfidence_Type_Name(RoadWorks_TypeAndConfidence_Type value) {
  return ::google::protobuf::internal::NameOfDenseEnum<RoadWorks_TypeAndConfidence_Type_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool RoadWorks_TypeAndConfidence_Type_Parse(absl::string_view name, RoadWorks_TypeAndConfidence_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RoadWorks_TypeAndConfidence_Type>(
      RoadWorks_TypeAndConfidence_Type_descriptor(), name, value);
}
enum RoadWeatherCondition_TypeAndConfidence_Type : int {
  RoadWeatherCondition_TypeAndConfidence_Type_UNKNOWN_TYPE = 0,
  RoadWeatherCondition_TypeAndConfidence_Type_SNOW = 1,
  RoadWeatherCondition_TypeAndConfidence_Type_ICE = 2,
  RoadWeatherCondition_TypeAndConfidence_Type_FREEZING_RAIN = 3,
  RoadWeatherCondition_TypeAndConfidence_Type_FROST = 4,
  RoadWeatherCondition_TypeAndConfidence_Type_HYDROPLANING = 5,
  RoadWeatherCondition_TypeAndConfidence_Type_FLOODING = 6,
  RoadWeatherCondition_TypeAndConfidence_Type_WATER = 7,
  RoadWeatherCondition_TypeAndConfidence_Type_RoadWeatherCondition_TypeAndConfidence_Type_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  RoadWeatherCondition_TypeAndConfidence_Type_RoadWeatherCondition_TypeAndConfidence_Type_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool RoadWeatherCondition_TypeAndConfidence_Type_IsValid(int value);
extern const uint32_t RoadWeatherCondition_TypeAndConfidence_Type_internal_data_[];
constexpr RoadWeatherCondition_TypeAndConfidence_Type RoadWeatherCondition_TypeAndConfidence_Type_Type_MIN = static_cast<RoadWeatherCondition_TypeAndConfidence_Type>(0);
constexpr RoadWeatherCondition_TypeAndConfidence_Type RoadWeatherCondition_TypeAndConfidence_Type_Type_MAX = static_cast<RoadWeatherCondition_TypeAndConfidence_Type>(7);
constexpr int RoadWeatherCondition_TypeAndConfidence_Type_Type_ARRAYSIZE = 7 + 1;
const ::google::protobuf::EnumDescriptor*
RoadWeatherCondition_TypeAndConfidence_Type_descriptor();
template <typename T>
const std::string& RoadWeatherCondition_TypeAndConfidence_Type_Name(T value) {
  static_assert(std::is_same<T, RoadWeatherCondition_TypeAndConfidence_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return RoadWeatherCondition_TypeAndConfidence_Type_Name(static_cast<RoadWeatherCondition_TypeAndConfidence_Type>(value));
}
template <>
inline const std::string& RoadWeatherCondition_TypeAndConfidence_Type_Name(RoadWeatherCondition_TypeAndConfidence_Type value) {
  return ::google::protobuf::internal::NameOfDenseEnum<RoadWeatherCondition_TypeAndConfidence_Type_descriptor,
                                                 0, 7>(
      static_cast<int>(value));
}
inline bool RoadWeatherCondition_TypeAndConfidence_Type_Parse(absl::string_view name, RoadWeatherCondition_TypeAndConfidence_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RoadWeatherCondition_TypeAndConfidence_Type>(
      RoadWeatherCondition_TypeAndConfidence_Type_descriptor(), name, value);
}
enum RoadSurfaceCondition_TypeAndConfidence_Type : int {
  RoadSurfaceCondition_TypeAndConfidence_Type_UNKNOWN_TYPE = 0,
  RoadSurfaceCondition_TypeAndConfidence_Type_MUD = 1,
  RoadSurfaceCondition_TypeAndConfidence_Type_CHIPPINGS = 2,
  RoadSurfaceCondition_TypeAndConfidence_Type_OIL = 3,
  RoadSurfaceCondition_TypeAndConfidence_Type_FUEL = 4,
  RoadSurfaceCondition_TypeAndConfidence_Type_RoadSurfaceCondition_TypeAndConfidence_Type_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  RoadSurfaceCondition_TypeAndConfidence_Type_RoadSurfaceCondition_TypeAndConfidence_Type_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool RoadSurfaceCondition_TypeAndConfidence_Type_IsValid(int value);
extern const uint32_t RoadSurfaceCondition_TypeAndConfidence_Type_internal_data_[];
constexpr RoadSurfaceCondition_TypeAndConfidence_Type RoadSurfaceCondition_TypeAndConfidence_Type_Type_MIN = static_cast<RoadSurfaceCondition_TypeAndConfidence_Type>(0);
constexpr RoadSurfaceCondition_TypeAndConfidence_Type RoadSurfaceCondition_TypeAndConfidence_Type_Type_MAX = static_cast<RoadSurfaceCondition_TypeAndConfidence_Type>(4);
constexpr int RoadSurfaceCondition_TypeAndConfidence_Type_Type_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
RoadSurfaceCondition_TypeAndConfidence_Type_descriptor();
template <typename T>
const std::string& RoadSurfaceCondition_TypeAndConfidence_Type_Name(T value) {
  static_assert(std::is_same<T, RoadSurfaceCondition_TypeAndConfidence_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return RoadSurfaceCondition_TypeAndConfidence_Type_Name(static_cast<RoadSurfaceCondition_TypeAndConfidence_Type>(value));
}
template <>
inline const std::string& RoadSurfaceCondition_TypeAndConfidence_Type_Name(RoadSurfaceCondition_TypeAndConfidence_Type value) {
  return ::google::protobuf::internal::NameOfDenseEnum<RoadSurfaceCondition_TypeAndConfidence_Type_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool RoadSurfaceCondition_TypeAndConfidence_Type_Parse(absl::string_view name, RoadSurfaceCondition_TypeAndConfidence_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RoadSurfaceCondition_TypeAndConfidence_Type>(
      RoadSurfaceCondition_TypeAndConfidence_Type_descriptor(), name, value);
}
enum RoadObstructionCondition_TypeAndConfidence_Type : int {
  RoadObstructionCondition_TypeAndConfidence_Type_UNKNOWN_TYPE = 0,
  RoadObstructionCondition_TypeAndConfidence_Type_TREE = 1,
  RoadObstructionCondition_TypeAndConfidence_Type_AVALANCHE = 2,
  RoadObstructionCondition_TypeAndConfidence_Type_ROCKFALLS = 3,
  RoadObstructionCondition_TypeAndConfidence_Type_SHED_LOAD = 4,
  RoadObstructionCondition_TypeAndConfidence_Type_LAND_SLIP = 5,
  RoadObstructionCondition_TypeAndConfidence_Type_ANIMAL = 6,
  RoadObstructionCondition_TypeAndConfidence_Type_ANIMAL_LARGE = 7,
  RoadObstructionCondition_TypeAndConfidence_Type_ANIMAL_HERD = 8,
  RoadObstructionCondition_TypeAndConfidence_Type_RoadObstructionCondition_TypeAndConfidence_Type_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  RoadObstructionCondition_TypeAndConfidence_Type_RoadObstructionCondition_TypeAndConfidence_Type_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool RoadObstructionCondition_TypeAndConfidence_Type_IsValid(int value);
extern const uint32_t RoadObstructionCondition_TypeAndConfidence_Type_internal_data_[];
constexpr RoadObstructionCondition_TypeAndConfidence_Type RoadObstructionCondition_TypeAndConfidence_Type_Type_MIN = static_cast<RoadObstructionCondition_TypeAndConfidence_Type>(0);
constexpr RoadObstructionCondition_TypeAndConfidence_Type RoadObstructionCondition_TypeAndConfidence_Type_Type_MAX = static_cast<RoadObstructionCondition_TypeAndConfidence_Type>(8);
constexpr int RoadObstructionCondition_TypeAndConfidence_Type_Type_ARRAYSIZE = 8 + 1;
const ::google::protobuf::EnumDescriptor*
RoadObstructionCondition_TypeAndConfidence_Type_descriptor();
template <typename T>
const std::string& RoadObstructionCondition_TypeAndConfidence_Type_Name(T value) {
  static_assert(std::is_same<T, RoadObstructionCondition_TypeAndConfidence_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return RoadObstructionCondition_TypeAndConfidence_Type_Name(static_cast<RoadObstructionCondition_TypeAndConfidence_Type>(value));
}
template <>
inline const std::string& RoadObstructionCondition_TypeAndConfidence_Type_Name(RoadObstructionCondition_TypeAndConfidence_Type value) {
  return ::google::protobuf::internal::NameOfDenseEnum<RoadObstructionCondition_TypeAndConfidence_Type_descriptor,
                                                 0, 8>(
      static_cast<int>(value));
}
inline bool RoadObstructionCondition_TypeAndConfidence_Type_Parse(absl::string_view name, RoadObstructionCondition_TypeAndConfidence_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RoadObstructionCondition_TypeAndConfidence_Type>(
      RoadObstructionCondition_TypeAndConfidence_Type_descriptor(), name, value);
}
enum VulnerableRoadUserCondition_TypeAndConfidence_Type : int {
  VulnerableRoadUserCondition_TypeAndConfidence_Type_UNKNOWN_TYPE = 0,
  VulnerableRoadUserCondition_TypeAndConfidence_Type_PEOPLE = 1,
  VulnerableRoadUserCondition_TypeAndConfidence_Type_CHILDREN = 2,
  VulnerableRoadUserCondition_TypeAndConfidence_Type_CYCLIST = 3,
  VulnerableRoadUserCondition_TypeAndConfidence_Type_VulnerableRoadUserCondition_TypeAndConfidence_Type_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  VulnerableRoadUserCondition_TypeAndConfidence_Type_VulnerableRoadUserCondition_TypeAndConfidence_Type_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool VulnerableRoadUserCondition_TypeAndConfidence_Type_IsValid(int value);
extern const uint32_t VulnerableRoadUserCondition_TypeAndConfidence_Type_internal_data_[];
constexpr VulnerableRoadUserCondition_TypeAndConfidence_Type VulnerableRoadUserCondition_TypeAndConfidence_Type_Type_MIN = static_cast<VulnerableRoadUserCondition_TypeAndConfidence_Type>(0);
constexpr VulnerableRoadUserCondition_TypeAndConfidence_Type VulnerableRoadUserCondition_TypeAndConfidence_Type_Type_MAX = static_cast<VulnerableRoadUserCondition_TypeAndConfidence_Type>(3);
constexpr int VulnerableRoadUserCondition_TypeAndConfidence_Type_Type_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
VulnerableRoadUserCondition_TypeAndConfidence_Type_descriptor();
template <typename T>
const std::string& VulnerableRoadUserCondition_TypeAndConfidence_Type_Name(T value) {
  static_assert(std::is_same<T, VulnerableRoadUserCondition_TypeAndConfidence_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return VulnerableRoadUserCondition_TypeAndConfidence_Type_Name(static_cast<VulnerableRoadUserCondition_TypeAndConfidence_Type>(value));
}
template <>
inline const std::string& VulnerableRoadUserCondition_TypeAndConfidence_Type_Name(VulnerableRoadUserCondition_TypeAndConfidence_Type value) {
  return ::google::protobuf::internal::NameOfDenseEnum<VulnerableRoadUserCondition_TypeAndConfidence_Type_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool VulnerableRoadUserCondition_TypeAndConfidence_Type_Parse(absl::string_view name, VulnerableRoadUserCondition_TypeAndConfidence_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VulnerableRoadUserCondition_TypeAndConfidence_Type>(
      VulnerableRoadUserCondition_TypeAndConfidence_Type_descriptor(), name, value);
}
enum ECallStatus_ActivationType : int {
  ECallStatus_ActivationType_UNKNOWN_ACTIVATION_TYPE = 0,
  ECallStatus_ActivationType_NONE = 1,
  ECallStatus_ActivationType_MANUAL = 2,
  ECallStatus_ActivationType_AUTOMATIC = 3,
  ECallStatus_ActivationType_ECallStatus_ActivationType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ECallStatus_ActivationType_ECallStatus_ActivationType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ECallStatus_ActivationType_IsValid(int value);
extern const uint32_t ECallStatus_ActivationType_internal_data_[];
constexpr ECallStatus_ActivationType ECallStatus_ActivationType_ActivationType_MIN = static_cast<ECallStatus_ActivationType>(0);
constexpr ECallStatus_ActivationType ECallStatus_ActivationType_ActivationType_MAX = static_cast<ECallStatus_ActivationType>(3);
constexpr int ECallStatus_ActivationType_ActivationType_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
ECallStatus_ActivationType_descriptor();
template <typename T>
const std::string& ECallStatus_ActivationType_Name(T value) {
  static_assert(std::is_same<T, ECallStatus_ActivationType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ActivationType_Name().");
  return ECallStatus_ActivationType_Name(static_cast<ECallStatus_ActivationType>(value));
}
template <>
inline const std::string& ECallStatus_ActivationType_Name(ECallStatus_ActivationType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ECallStatus_ActivationType_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool ECallStatus_ActivationType_Parse(absl::string_view name, ECallStatus_ActivationType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ECallStatus_ActivationType>(
      ECallStatus_ActivationType_descriptor(), name, value);
}
enum ECallStatus_Availability : int {
  ECallStatus_Availability_UNKNOWN_AVAILABILITY = 0,
  ECallStatus_Availability_AVAILABLE = 1,
  ECallStatus_Availability_UNAVAILABLE = 2,
  ECallStatus_Availability_ECallStatus_Availability_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ECallStatus_Availability_ECallStatus_Availability_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ECallStatus_Availability_IsValid(int value);
extern const uint32_t ECallStatus_Availability_internal_data_[];
constexpr ECallStatus_Availability ECallStatus_Availability_Availability_MIN = static_cast<ECallStatus_Availability>(0);
constexpr ECallStatus_Availability ECallStatus_Availability_Availability_MAX = static_cast<ECallStatus_Availability>(2);
constexpr int ECallStatus_Availability_Availability_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
ECallStatus_Availability_descriptor();
template <typename T>
const std::string& ECallStatus_Availability_Name(T value) {
  static_assert(std::is_same<T, ECallStatus_Availability>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Availability_Name().");
  return ECallStatus_Availability_Name(static_cast<ECallStatus_Availability>(value));
}
template <>
inline const std::string& ECallStatus_Availability_Name(ECallStatus_Availability value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ECallStatus_Availability_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool ECallStatus_Availability_Parse(absl::string_view name, ECallStatus_Availability* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ECallStatus_Availability>(
      ECallStatus_Availability_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class VulnerableRoadUserCondition_TypeAndConfidence final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.trafficevents.VulnerableRoadUserCondition.TypeAndConfidence) */ {
 public:
  inline VulnerableRoadUserCondition_TypeAndConfidence() : VulnerableRoadUserCondition_TypeAndConfidence(nullptr) {}
  ~VulnerableRoadUserCondition_TypeAndConfidence() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR VulnerableRoadUserCondition_TypeAndConfidence(::google::protobuf::internal::ConstantInitialized);

  inline VulnerableRoadUserCondition_TypeAndConfidence(const VulnerableRoadUserCondition_TypeAndConfidence& from)
      : VulnerableRoadUserCondition_TypeAndConfidence(nullptr, from) {}
  VulnerableRoadUserCondition_TypeAndConfidence(VulnerableRoadUserCondition_TypeAndConfidence&& from) noexcept
    : VulnerableRoadUserCondition_TypeAndConfidence() {
    *this = ::std::move(from);
  }

  inline VulnerableRoadUserCondition_TypeAndConfidence& operator=(const VulnerableRoadUserCondition_TypeAndConfidence& from) {
    CopyFrom(from);
    return *this;
  }
  inline VulnerableRoadUserCondition_TypeAndConfidence& operator=(VulnerableRoadUserCondition_TypeAndConfidence&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VulnerableRoadUserCondition_TypeAndConfidence& default_instance() {
    return *internal_default_instance();
  }
  static inline const VulnerableRoadUserCondition_TypeAndConfidence* internal_default_instance() {
    return reinterpret_cast<const VulnerableRoadUserCondition_TypeAndConfidence*>(
               &_VulnerableRoadUserCondition_TypeAndConfidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(VulnerableRoadUserCondition_TypeAndConfidence& a, VulnerableRoadUserCondition_TypeAndConfidence& b) {
    a.Swap(&b);
  }
  inline void Swap(VulnerableRoadUserCondition_TypeAndConfidence* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VulnerableRoadUserCondition_TypeAndConfidence* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VulnerableRoadUserCondition_TypeAndConfidence* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VulnerableRoadUserCondition_TypeAndConfidence>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VulnerableRoadUserCondition_TypeAndConfidence& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const VulnerableRoadUserCondition_TypeAndConfidence& from) {
    VulnerableRoadUserCondition_TypeAndConfidence::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(VulnerableRoadUserCondition_TypeAndConfidence* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.categories.trafficevents.VulnerableRoadUserCondition.TypeAndConfidence";
  }
  protected:
  explicit VulnerableRoadUserCondition_TypeAndConfidence(::google::protobuf::Arena* arena);
  VulnerableRoadUserCondition_TypeAndConfidence(::google::protobuf::Arena* arena, const VulnerableRoadUserCondition_TypeAndConfidence& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Type = VulnerableRoadUserCondition_TypeAndConfidence_Type;
  static constexpr Type UNKNOWN_TYPE = VulnerableRoadUserCondition_TypeAndConfidence_Type_UNKNOWN_TYPE;
  static constexpr Type PEOPLE = VulnerableRoadUserCondition_TypeAndConfidence_Type_PEOPLE;
  static constexpr Type CHILDREN = VulnerableRoadUserCondition_TypeAndConfidence_Type_CHILDREN;
  static constexpr Type CYCLIST = VulnerableRoadUserCondition_TypeAndConfidence_Type_CYCLIST;
  static inline bool Type_IsValid(int value) {
    return VulnerableRoadUserCondition_TypeAndConfidence_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = VulnerableRoadUserCondition_TypeAndConfidence_Type_Type_MIN;
  static constexpr Type Type_MAX = VulnerableRoadUserCondition_TypeAndConfidence_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = VulnerableRoadUserCondition_TypeAndConfidence_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Type_descriptor() {
    return VulnerableRoadUserCondition_TypeAndConfidence_Type_descriptor();
  }
  template <typename T>
  static inline const std::string& Type_Name(T value) {
    return VulnerableRoadUserCondition_TypeAndConfidence_Type_Name(value);
  }
  static inline bool Type_Parse(absl::string_view name, Type* value) {
    return VulnerableRoadUserCondition_TypeAndConfidence_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kConfidenceFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // .sensoris.protobuf.types.base.Confidence confidence = 2;
  bool has_confidence() const;
  void clear_confidence() ;
  const ::sensoris::protobuf::types::base::Confidence& confidence() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::Confidence* release_confidence();
  ::sensoris::protobuf::types::base::Confidence* mutable_confidence();
  void set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value);
  void unsafe_arena_set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value);
  ::sensoris::protobuf::types::base::Confidence* unsafe_arena_release_confidence();

  private:
  const ::sensoris::protobuf::types::base::Confidence& _internal_confidence() const;
  ::sensoris::protobuf::types::base::Confidence* _internal_mutable_confidence();

  public:
  // .sensoris.protobuf.categories.trafficevents.VulnerableRoadUserCondition.TypeAndConfidence.Type type = 1;
  void clear_type() ;
  ::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence_Type type() const;
  void set_type(::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence_Type value);

  private:
  ::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence_Type _internal_type() const;
  void _internal_set_type(::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence_Type value);

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.trafficevents.VulnerableRoadUserCondition.TypeAndConfidence)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::Confidence* confidence_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto;
};// -------------------------------------------------------------------

class TrafficCondition_TypeAndConfidence final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.trafficevents.TrafficCondition.TypeAndConfidence) */ {
 public:
  inline TrafficCondition_TypeAndConfidence() : TrafficCondition_TypeAndConfidence(nullptr) {}
  ~TrafficCondition_TypeAndConfidence() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TrafficCondition_TypeAndConfidence(::google::protobuf::internal::ConstantInitialized);

  inline TrafficCondition_TypeAndConfidence(const TrafficCondition_TypeAndConfidence& from)
      : TrafficCondition_TypeAndConfidence(nullptr, from) {}
  TrafficCondition_TypeAndConfidence(TrafficCondition_TypeAndConfidence&& from) noexcept
    : TrafficCondition_TypeAndConfidence() {
    *this = ::std::move(from);
  }

  inline TrafficCondition_TypeAndConfidence& operator=(const TrafficCondition_TypeAndConfidence& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrafficCondition_TypeAndConfidence& operator=(TrafficCondition_TypeAndConfidence&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrafficCondition_TypeAndConfidence& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrafficCondition_TypeAndConfidence* internal_default_instance() {
    return reinterpret_cast<const TrafficCondition_TypeAndConfidence*>(
               &_TrafficCondition_TypeAndConfidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(TrafficCondition_TypeAndConfidence& a, TrafficCondition_TypeAndConfidence& b) {
    a.Swap(&b);
  }
  inline void Swap(TrafficCondition_TypeAndConfidence* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrafficCondition_TypeAndConfidence* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrafficCondition_TypeAndConfidence* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrafficCondition_TypeAndConfidence>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TrafficCondition_TypeAndConfidence& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TrafficCondition_TypeAndConfidence& from) {
    TrafficCondition_TypeAndConfidence::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TrafficCondition_TypeAndConfidence* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.categories.trafficevents.TrafficCondition.TypeAndConfidence";
  }
  protected:
  explicit TrafficCondition_TypeAndConfidence(::google::protobuf::Arena* arena);
  TrafficCondition_TypeAndConfidence(::google::protobuf::Arena* arena, const TrafficCondition_TypeAndConfidence& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Type = TrafficCondition_TypeAndConfidence_Type;
  static constexpr Type UNKNOWN_TYPE = TrafficCondition_TypeAndConfidence_Type_UNKNOWN_TYPE;
  static constexpr Type FREE_FLOW = TrafficCondition_TypeAndConfidence_Type_FREE_FLOW;
  static constexpr Type HEAVY = TrafficCondition_TypeAndConfidence_Type_HEAVY;
  static constexpr Type SLOW = TrafficCondition_TypeAndConfidence_Type_SLOW;
  static constexpr Type QUEUING = TrafficCondition_TypeAndConfidence_Type_QUEUING;
  static constexpr Type STATIONARY = TrafficCondition_TypeAndConfidence_Type_STATIONARY;
  static inline bool Type_IsValid(int value) {
    return TrafficCondition_TypeAndConfidence_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = TrafficCondition_TypeAndConfidence_Type_Type_MIN;
  static constexpr Type Type_MAX = TrafficCondition_TypeAndConfidence_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = TrafficCondition_TypeAndConfidence_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Type_descriptor() {
    return TrafficCondition_TypeAndConfidence_Type_descriptor();
  }
  template <typename T>
  static inline const std::string& Type_Name(T value) {
    return TrafficCondition_TypeAndConfidence_Type_Name(value);
  }
  static inline bool Type_Parse(absl::string_view name, Type* value) {
    return TrafficCondition_TypeAndConfidence_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kConfidenceFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // .sensoris.protobuf.types.base.Confidence confidence = 2;
  bool has_confidence() const;
  void clear_confidence() ;
  const ::sensoris::protobuf::types::base::Confidence& confidence() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::Confidence* release_confidence();
  ::sensoris::protobuf::types::base::Confidence* mutable_confidence();
  void set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value);
  void unsafe_arena_set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value);
  ::sensoris::protobuf::types::base::Confidence* unsafe_arena_release_confidence();

  private:
  const ::sensoris::protobuf::types::base::Confidence& _internal_confidence() const;
  ::sensoris::protobuf::types::base::Confidence* _internal_mutable_confidence();

  public:
  // .sensoris.protobuf.categories.trafficevents.TrafficCondition.TypeAndConfidence.Type type = 1;
  void clear_type() ;
  ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence_Type type() const;
  void set_type(::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence_Type value);

  private:
  ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence_Type _internal_type() const;
  void _internal_set_type(::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence_Type value);

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.trafficevents.TrafficCondition.TypeAndConfidence)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::Confidence* confidence_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto;
};// -------------------------------------------------------------------

class RoadWorks_TypeAndConfidence final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.trafficevents.RoadWorks.TypeAndConfidence) */ {
 public:
  inline RoadWorks_TypeAndConfidence() : RoadWorks_TypeAndConfidence(nullptr) {}
  ~RoadWorks_TypeAndConfidence() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RoadWorks_TypeAndConfidence(::google::protobuf::internal::ConstantInitialized);

  inline RoadWorks_TypeAndConfidence(const RoadWorks_TypeAndConfidence& from)
      : RoadWorks_TypeAndConfidence(nullptr, from) {}
  RoadWorks_TypeAndConfidence(RoadWorks_TypeAndConfidence&& from) noexcept
    : RoadWorks_TypeAndConfidence() {
    *this = ::std::move(from);
  }

  inline RoadWorks_TypeAndConfidence& operator=(const RoadWorks_TypeAndConfidence& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoadWorks_TypeAndConfidence& operator=(RoadWorks_TypeAndConfidence&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoadWorks_TypeAndConfidence& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoadWorks_TypeAndConfidence* internal_default_instance() {
    return reinterpret_cast<const RoadWorks_TypeAndConfidence*>(
               &_RoadWorks_TypeAndConfidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(RoadWorks_TypeAndConfidence& a, RoadWorks_TypeAndConfidence& b) {
    a.Swap(&b);
  }
  inline void Swap(RoadWorks_TypeAndConfidence* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoadWorks_TypeAndConfidence* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoadWorks_TypeAndConfidence* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoadWorks_TypeAndConfidence>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RoadWorks_TypeAndConfidence& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RoadWorks_TypeAndConfidence& from) {
    RoadWorks_TypeAndConfidence::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RoadWorks_TypeAndConfidence* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.categories.trafficevents.RoadWorks.TypeAndConfidence";
  }
  protected:
  explicit RoadWorks_TypeAndConfidence(::google::protobuf::Arena* arena);
  RoadWorks_TypeAndConfidence(::google::protobuf::Arena* arena, const RoadWorks_TypeAndConfidence& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Type = RoadWorks_TypeAndConfidence_Type;
  static constexpr Type UNKNOWN_TYPE = RoadWorks_TypeAndConfidence_Type_UNKNOWN_TYPE;
  static constexpr Type START = RoadWorks_TypeAndConfidence_Type_START;
  static constexpr Type END = RoadWorks_TypeAndConfidence_Type_END;
  static inline bool Type_IsValid(int value) {
    return RoadWorks_TypeAndConfidence_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = RoadWorks_TypeAndConfidence_Type_Type_MIN;
  static constexpr Type Type_MAX = RoadWorks_TypeAndConfidence_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = RoadWorks_TypeAndConfidence_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Type_descriptor() {
    return RoadWorks_TypeAndConfidence_Type_descriptor();
  }
  template <typename T>
  static inline const std::string& Type_Name(T value) {
    return RoadWorks_TypeAndConfidence_Type_Name(value);
  }
  static inline bool Type_Parse(absl::string_view name, Type* value) {
    return RoadWorks_TypeAndConfidence_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kConfidenceFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // .sensoris.protobuf.types.base.Confidence confidence = 2;
  bool has_confidence() const;
  void clear_confidence() ;
  const ::sensoris::protobuf::types::base::Confidence& confidence() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::Confidence* release_confidence();
  ::sensoris::protobuf::types::base::Confidence* mutable_confidence();
  void set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value);
  void unsafe_arena_set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value);
  ::sensoris::protobuf::types::base::Confidence* unsafe_arena_release_confidence();

  private:
  const ::sensoris::protobuf::types::base::Confidence& _internal_confidence() const;
  ::sensoris::protobuf::types::base::Confidence* _internal_mutable_confidence();

  public:
  // .sensoris.protobuf.categories.trafficevents.RoadWorks.TypeAndConfidence.Type type = 1;
  void clear_type() ;
  ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence_Type type() const;
  void set_type(::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence_Type value);

  private:
  ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence_Type _internal_type() const;
  void _internal_set_type(::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence_Type value);

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.trafficevents.RoadWorks.TypeAndConfidence)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::Confidence* confidence_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto;
};// -------------------------------------------------------------------

class RoadWeatherCondition_TypeAndConfidence final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.TypeAndConfidence) */ {
 public:
  inline RoadWeatherCondition_TypeAndConfidence() : RoadWeatherCondition_TypeAndConfidence(nullptr) {}
  ~RoadWeatherCondition_TypeAndConfidence() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RoadWeatherCondition_TypeAndConfidence(::google::protobuf::internal::ConstantInitialized);

  inline RoadWeatherCondition_TypeAndConfidence(const RoadWeatherCondition_TypeAndConfidence& from)
      : RoadWeatherCondition_TypeAndConfidence(nullptr, from) {}
  RoadWeatherCondition_TypeAndConfidence(RoadWeatherCondition_TypeAndConfidence&& from) noexcept
    : RoadWeatherCondition_TypeAndConfidence() {
    *this = ::std::move(from);
  }

  inline RoadWeatherCondition_TypeAndConfidence& operator=(const RoadWeatherCondition_TypeAndConfidence& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoadWeatherCondition_TypeAndConfidence& operator=(RoadWeatherCondition_TypeAndConfidence&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoadWeatherCondition_TypeAndConfidence& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoadWeatherCondition_TypeAndConfidence* internal_default_instance() {
    return reinterpret_cast<const RoadWeatherCondition_TypeAndConfidence*>(
               &_RoadWeatherCondition_TypeAndConfidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(RoadWeatherCondition_TypeAndConfidence& a, RoadWeatherCondition_TypeAndConfidence& b) {
    a.Swap(&b);
  }
  inline void Swap(RoadWeatherCondition_TypeAndConfidence* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoadWeatherCondition_TypeAndConfidence* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoadWeatherCondition_TypeAndConfidence* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoadWeatherCondition_TypeAndConfidence>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RoadWeatherCondition_TypeAndConfidence& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RoadWeatherCondition_TypeAndConfidence& from) {
    RoadWeatherCondition_TypeAndConfidence::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RoadWeatherCondition_TypeAndConfidence* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.TypeAndConfidence";
  }
  protected:
  explicit RoadWeatherCondition_TypeAndConfidence(::google::protobuf::Arena* arena);
  RoadWeatherCondition_TypeAndConfidence(::google::protobuf::Arena* arena, const RoadWeatherCondition_TypeAndConfidence& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Type = RoadWeatherCondition_TypeAndConfidence_Type;
  static constexpr Type UNKNOWN_TYPE = RoadWeatherCondition_TypeAndConfidence_Type_UNKNOWN_TYPE;
  static constexpr Type SNOW = RoadWeatherCondition_TypeAndConfidence_Type_SNOW;
  static constexpr Type ICE = RoadWeatherCondition_TypeAndConfidence_Type_ICE;
  static constexpr Type FREEZING_RAIN = RoadWeatherCondition_TypeAndConfidence_Type_FREEZING_RAIN;
  static constexpr Type FROST = RoadWeatherCondition_TypeAndConfidence_Type_FROST;
  static constexpr Type HYDROPLANING = RoadWeatherCondition_TypeAndConfidence_Type_HYDROPLANING;
  static constexpr Type FLOODING = RoadWeatherCondition_TypeAndConfidence_Type_FLOODING;
  static constexpr Type WATER = RoadWeatherCondition_TypeAndConfidence_Type_WATER;
  static inline bool Type_IsValid(int value) {
    return RoadWeatherCondition_TypeAndConfidence_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = RoadWeatherCondition_TypeAndConfidence_Type_Type_MIN;
  static constexpr Type Type_MAX = RoadWeatherCondition_TypeAndConfidence_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = RoadWeatherCondition_TypeAndConfidence_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Type_descriptor() {
    return RoadWeatherCondition_TypeAndConfidence_Type_descriptor();
  }
  template <typename T>
  static inline const std::string& Type_Name(T value) {
    return RoadWeatherCondition_TypeAndConfidence_Type_Name(value);
  }
  static inline bool Type_Parse(absl::string_view name, Type* value) {
    return RoadWeatherCondition_TypeAndConfidence_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kConfidenceFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // .sensoris.protobuf.types.base.Confidence confidence = 2;
  bool has_confidence() const;
  void clear_confidence() ;
  const ::sensoris::protobuf::types::base::Confidence& confidence() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::Confidence* release_confidence();
  ::sensoris::protobuf::types::base::Confidence* mutable_confidence();
  void set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value);
  void unsafe_arena_set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value);
  ::sensoris::protobuf::types::base::Confidence* unsafe_arena_release_confidence();

  private:
  const ::sensoris::protobuf::types::base::Confidence& _internal_confidence() const;
  ::sensoris::protobuf::types::base::Confidence* _internal_mutable_confidence();

  public:
  // .sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.TypeAndConfidence.Type type = 1;
  void clear_type() ;
  ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence_Type type() const;
  void set_type(::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence_Type value);

  private:
  ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence_Type _internal_type() const;
  void _internal_set_type(::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence_Type value);

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.TypeAndConfidence)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::Confidence* confidence_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto;
};// -------------------------------------------------------------------

class RoadSurfaceCondition_TypeAndConfidence final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.trafficevents.RoadSurfaceCondition.TypeAndConfidence) */ {
 public:
  inline RoadSurfaceCondition_TypeAndConfidence() : RoadSurfaceCondition_TypeAndConfidence(nullptr) {}
  ~RoadSurfaceCondition_TypeAndConfidence() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RoadSurfaceCondition_TypeAndConfidence(::google::protobuf::internal::ConstantInitialized);

  inline RoadSurfaceCondition_TypeAndConfidence(const RoadSurfaceCondition_TypeAndConfidence& from)
      : RoadSurfaceCondition_TypeAndConfidence(nullptr, from) {}
  RoadSurfaceCondition_TypeAndConfidence(RoadSurfaceCondition_TypeAndConfidence&& from) noexcept
    : RoadSurfaceCondition_TypeAndConfidence() {
    *this = ::std::move(from);
  }

  inline RoadSurfaceCondition_TypeAndConfidence& operator=(const RoadSurfaceCondition_TypeAndConfidence& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoadSurfaceCondition_TypeAndConfidence& operator=(RoadSurfaceCondition_TypeAndConfidence&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoadSurfaceCondition_TypeAndConfidence& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoadSurfaceCondition_TypeAndConfidence* internal_default_instance() {
    return reinterpret_cast<const RoadSurfaceCondition_TypeAndConfidence*>(
               &_RoadSurfaceCondition_TypeAndConfidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(RoadSurfaceCondition_TypeAndConfidence& a, RoadSurfaceCondition_TypeAndConfidence& b) {
    a.Swap(&b);
  }
  inline void Swap(RoadSurfaceCondition_TypeAndConfidence* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoadSurfaceCondition_TypeAndConfidence* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoadSurfaceCondition_TypeAndConfidence* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoadSurfaceCondition_TypeAndConfidence>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RoadSurfaceCondition_TypeAndConfidence& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RoadSurfaceCondition_TypeAndConfidence& from) {
    RoadSurfaceCondition_TypeAndConfidence::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RoadSurfaceCondition_TypeAndConfidence* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.categories.trafficevents.RoadSurfaceCondition.TypeAndConfidence";
  }
  protected:
  explicit RoadSurfaceCondition_TypeAndConfidence(::google::protobuf::Arena* arena);
  RoadSurfaceCondition_TypeAndConfidence(::google::protobuf::Arena* arena, const RoadSurfaceCondition_TypeAndConfidence& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Type = RoadSurfaceCondition_TypeAndConfidence_Type;
  static constexpr Type UNKNOWN_TYPE = RoadSurfaceCondition_TypeAndConfidence_Type_UNKNOWN_TYPE;
  static constexpr Type MUD = RoadSurfaceCondition_TypeAndConfidence_Type_MUD;
  static constexpr Type CHIPPINGS = RoadSurfaceCondition_TypeAndConfidence_Type_CHIPPINGS;
  static constexpr Type OIL = RoadSurfaceCondition_TypeAndConfidence_Type_OIL;
  static constexpr Type FUEL = RoadSurfaceCondition_TypeAndConfidence_Type_FUEL;
  static inline bool Type_IsValid(int value) {
    return RoadSurfaceCondition_TypeAndConfidence_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = RoadSurfaceCondition_TypeAndConfidence_Type_Type_MIN;
  static constexpr Type Type_MAX = RoadSurfaceCondition_TypeAndConfidence_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = RoadSurfaceCondition_TypeAndConfidence_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Type_descriptor() {
    return RoadSurfaceCondition_TypeAndConfidence_Type_descriptor();
  }
  template <typename T>
  static inline const std::string& Type_Name(T value) {
    return RoadSurfaceCondition_TypeAndConfidence_Type_Name(value);
  }
  static inline bool Type_Parse(absl::string_view name, Type* value) {
    return RoadSurfaceCondition_TypeAndConfidence_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kConfidenceFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // .sensoris.protobuf.types.base.Confidence confidence = 2;
  bool has_confidence() const;
  void clear_confidence() ;
  const ::sensoris::protobuf::types::base::Confidence& confidence() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::Confidence* release_confidence();
  ::sensoris::protobuf::types::base::Confidence* mutable_confidence();
  void set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value);
  void unsafe_arena_set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value);
  ::sensoris::protobuf::types::base::Confidence* unsafe_arena_release_confidence();

  private:
  const ::sensoris::protobuf::types::base::Confidence& _internal_confidence() const;
  ::sensoris::protobuf::types::base::Confidence* _internal_mutable_confidence();

  public:
  // .sensoris.protobuf.categories.trafficevents.RoadSurfaceCondition.TypeAndConfidence.Type type = 1;
  void clear_type() ;
  ::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence_Type type() const;
  void set_type(::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence_Type value);

  private:
  ::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence_Type _internal_type() const;
  void _internal_set_type(::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence_Type value);

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.trafficevents.RoadSurfaceCondition.TypeAndConfidence)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::Confidence* confidence_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto;
};// -------------------------------------------------------------------

class RoadObstructionCondition_TypeAndConfidence final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.trafficevents.RoadObstructionCondition.TypeAndConfidence) */ {
 public:
  inline RoadObstructionCondition_TypeAndConfidence() : RoadObstructionCondition_TypeAndConfidence(nullptr) {}
  ~RoadObstructionCondition_TypeAndConfidence() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RoadObstructionCondition_TypeAndConfidence(::google::protobuf::internal::ConstantInitialized);

  inline RoadObstructionCondition_TypeAndConfidence(const RoadObstructionCondition_TypeAndConfidence& from)
      : RoadObstructionCondition_TypeAndConfidence(nullptr, from) {}
  RoadObstructionCondition_TypeAndConfidence(RoadObstructionCondition_TypeAndConfidence&& from) noexcept
    : RoadObstructionCondition_TypeAndConfidence() {
    *this = ::std::move(from);
  }

  inline RoadObstructionCondition_TypeAndConfidence& operator=(const RoadObstructionCondition_TypeAndConfidence& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoadObstructionCondition_TypeAndConfidence& operator=(RoadObstructionCondition_TypeAndConfidence&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoadObstructionCondition_TypeAndConfidence& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoadObstructionCondition_TypeAndConfidence* internal_default_instance() {
    return reinterpret_cast<const RoadObstructionCondition_TypeAndConfidence*>(
               &_RoadObstructionCondition_TypeAndConfidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(RoadObstructionCondition_TypeAndConfidence& a, RoadObstructionCondition_TypeAndConfidence& b) {
    a.Swap(&b);
  }
  inline void Swap(RoadObstructionCondition_TypeAndConfidence* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoadObstructionCondition_TypeAndConfidence* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoadObstructionCondition_TypeAndConfidence* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoadObstructionCondition_TypeAndConfidence>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RoadObstructionCondition_TypeAndConfidence& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RoadObstructionCondition_TypeAndConfidence& from) {
    RoadObstructionCondition_TypeAndConfidence::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RoadObstructionCondition_TypeAndConfidence* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.categories.trafficevents.RoadObstructionCondition.TypeAndConfidence";
  }
  protected:
  explicit RoadObstructionCondition_TypeAndConfidence(::google::protobuf::Arena* arena);
  RoadObstructionCondition_TypeAndConfidence(::google::protobuf::Arena* arena, const RoadObstructionCondition_TypeAndConfidence& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Type = RoadObstructionCondition_TypeAndConfidence_Type;
  static constexpr Type UNKNOWN_TYPE = RoadObstructionCondition_TypeAndConfidence_Type_UNKNOWN_TYPE;
  static constexpr Type TREE = RoadObstructionCondition_TypeAndConfidence_Type_TREE;
  static constexpr Type AVALANCHE = RoadObstructionCondition_TypeAndConfidence_Type_AVALANCHE;
  static constexpr Type ROCKFALLS = RoadObstructionCondition_TypeAndConfidence_Type_ROCKFALLS;
  static constexpr Type SHED_LOAD = RoadObstructionCondition_TypeAndConfidence_Type_SHED_LOAD;
  static constexpr Type LAND_SLIP = RoadObstructionCondition_TypeAndConfidence_Type_LAND_SLIP;
  static constexpr Type ANIMAL = RoadObstructionCondition_TypeAndConfidence_Type_ANIMAL;
  static constexpr Type ANIMAL_LARGE = RoadObstructionCondition_TypeAndConfidence_Type_ANIMAL_LARGE;
  static constexpr Type ANIMAL_HERD = RoadObstructionCondition_TypeAndConfidence_Type_ANIMAL_HERD;
  static inline bool Type_IsValid(int value) {
    return RoadObstructionCondition_TypeAndConfidence_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = RoadObstructionCondition_TypeAndConfidence_Type_Type_MIN;
  static constexpr Type Type_MAX = RoadObstructionCondition_TypeAndConfidence_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = RoadObstructionCondition_TypeAndConfidence_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Type_descriptor() {
    return RoadObstructionCondition_TypeAndConfidence_Type_descriptor();
  }
  template <typename T>
  static inline const std::string& Type_Name(T value) {
    return RoadObstructionCondition_TypeAndConfidence_Type_Name(value);
  }
  static inline bool Type_Parse(absl::string_view name, Type* value) {
    return RoadObstructionCondition_TypeAndConfidence_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kConfidenceFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // .sensoris.protobuf.types.base.Confidence confidence = 2;
  bool has_confidence() const;
  void clear_confidence() ;
  const ::sensoris::protobuf::types::base::Confidence& confidence() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::Confidence* release_confidence();
  ::sensoris::protobuf::types::base::Confidence* mutable_confidence();
  void set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value);
  void unsafe_arena_set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value);
  ::sensoris::protobuf::types::base::Confidence* unsafe_arena_release_confidence();

  private:
  const ::sensoris::protobuf::types::base::Confidence& _internal_confidence() const;
  ::sensoris::protobuf::types::base::Confidence* _internal_mutable_confidence();

  public:
  // .sensoris.protobuf.categories.trafficevents.RoadObstructionCondition.TypeAndConfidence.Type type = 1;
  void clear_type() ;
  ::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence_Type type() const;
  void set_type(::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence_Type value);

  private:
  ::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence_Type _internal_type() const;
  void _internal_set_type(::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence_Type value);

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.trafficevents.RoadObstructionCondition.TypeAndConfidence)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::Confidence* confidence_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto;
};// -------------------------------------------------------------------

class Hazard_TypeAndConfidence final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.trafficevents.Hazard.TypeAndConfidence) */ {
 public:
  inline Hazard_TypeAndConfidence() : Hazard_TypeAndConfidence(nullptr) {}
  ~Hazard_TypeAndConfidence() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Hazard_TypeAndConfidence(::google::protobuf::internal::ConstantInitialized);

  inline Hazard_TypeAndConfidence(const Hazard_TypeAndConfidence& from)
      : Hazard_TypeAndConfidence(nullptr, from) {}
  Hazard_TypeAndConfidence(Hazard_TypeAndConfidence&& from) noexcept
    : Hazard_TypeAndConfidence() {
    *this = ::std::move(from);
  }

  inline Hazard_TypeAndConfidence& operator=(const Hazard_TypeAndConfidence& from) {
    CopyFrom(from);
    return *this;
  }
  inline Hazard_TypeAndConfidence& operator=(Hazard_TypeAndConfidence&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Hazard_TypeAndConfidence& default_instance() {
    return *internal_default_instance();
  }
  static inline const Hazard_TypeAndConfidence* internal_default_instance() {
    return reinterpret_cast<const Hazard_TypeAndConfidence*>(
               &_Hazard_TypeAndConfidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Hazard_TypeAndConfidence& a, Hazard_TypeAndConfidence& b) {
    a.Swap(&b);
  }
  inline void Swap(Hazard_TypeAndConfidence* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Hazard_TypeAndConfidence* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Hazard_TypeAndConfidence* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Hazard_TypeAndConfidence>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Hazard_TypeAndConfidence& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Hazard_TypeAndConfidence& from) {
    Hazard_TypeAndConfidence::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Hazard_TypeAndConfidence* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.categories.trafficevents.Hazard.TypeAndConfidence";
  }
  protected:
  explicit Hazard_TypeAndConfidence(::google::protobuf::Arena* arena);
  Hazard_TypeAndConfidence(::google::protobuf::Arena* arena, const Hazard_TypeAndConfidence& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Type = Hazard_TypeAndConfidence_Type;
  static constexpr Type UNKNOWN_TYPE = Hazard_TypeAndConfidence_Type_UNKNOWN_TYPE;
  static constexpr Type OBSTRUCTION = Hazard_TypeAndConfidence_Type_OBSTRUCTION;
  static constexpr Type ACCIDENT = Hazard_TypeAndConfidence_Type_ACCIDENT;
  static constexpr Type BROKEN_DOWN_VEHICLE = Hazard_TypeAndConfidence_Type_BROKEN_DOWN_VEHICLE;
  static constexpr Type SLOW_VEHICLE = Hazard_TypeAndConfidence_Type_SLOW_VEHICLE;
  static constexpr Type WRONG_WAY_VEHICLE = Hazard_TypeAndConfidence_Type_WRONG_WAY_VEHICLE;
  static constexpr Type ROADWORKS = Hazard_TypeAndConfidence_Type_ROADWORKS;
  static constexpr Type SLIPPERY_ROAD = Hazard_TypeAndConfidence_Type_SLIPPERY_ROAD;
  static constexpr Type PEOPLE_THROWING_OBJECTS = Hazard_TypeAndConfidence_Type_PEOPLE_THROWING_OBJECTS;
  static constexpr Type VEHICLE_ON_FIRE = Hazard_TypeAndConfidence_Type_VEHICLE_ON_FIRE;
  static constexpr Type STATIONARY_VEHICLE = Hazard_TypeAndConfidence_Type_STATIONARY_VEHICLE;
  static constexpr Type EXCEPTIONAL_CONDITION_LOW_VISIBILITY = Hazard_TypeAndConfidence_Type_EXCEPTIONAL_CONDITION_LOW_VISIBILITY;
  static constexpr Type EXCEPTIONAL_CONDITION_PRECIPITATION = Hazard_TypeAndConfidence_Type_EXCEPTIONAL_CONDITION_PRECIPITATION;
  static constexpr Type EXCEPTIONAL_CONDITION_WIND = Hazard_TypeAndConfidence_Type_EXCEPTIONAL_CONDITION_WIND;
  static constexpr Type EXCEPTIONAL_CONDITION_ROAD_SURFACE = Hazard_TypeAndConfidence_Type_EXCEPTIONAL_CONDITION_ROAD_SURFACE;
  static constexpr Type EXCEPTIONAL_CONDITION_VULNERABLE_ROAD_USER = Hazard_TypeAndConfidence_Type_EXCEPTIONAL_CONDITION_VULNERABLE_ROAD_USER;
  static inline bool Type_IsValid(int value) {
    return Hazard_TypeAndConfidence_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = Hazard_TypeAndConfidence_Type_Type_MIN;
  static constexpr Type Type_MAX = Hazard_TypeAndConfidence_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = Hazard_TypeAndConfidence_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Type_descriptor() {
    return Hazard_TypeAndConfidence_Type_descriptor();
  }
  template <typename T>
  static inline const std::string& Type_Name(T value) {
    return Hazard_TypeAndConfidence_Type_Name(value);
  }
  static inline bool Type_Parse(absl::string_view name, Type* value) {
    return Hazard_TypeAndConfidence_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kConfidenceFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // .sensoris.protobuf.types.base.Confidence confidence = 2;
  bool has_confidence() const;
  void clear_confidence() ;
  const ::sensoris::protobuf::types::base::Confidence& confidence() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::Confidence* release_confidence();
  ::sensoris::protobuf::types::base::Confidence* mutable_confidence();
  void set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value);
  void unsafe_arena_set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value);
  ::sensoris::protobuf::types::base::Confidence* unsafe_arena_release_confidence();

  private:
  const ::sensoris::protobuf::types::base::Confidence& _internal_confidence() const;
  ::sensoris::protobuf::types::base::Confidence* _internal_mutable_confidence();

  public:
  // .sensoris.protobuf.categories.trafficevents.Hazard.TypeAndConfidence.Type type = 1;
  void clear_type() ;
  ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence_Type type() const;
  void set_type(::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence_Type value);

  private:
  ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence_Type _internal_type() const;
  void _internal_set_type(::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence_Type value);

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.trafficevents.Hazard.TypeAndConfidence)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::Confidence* confidence_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto;
};// -------------------------------------------------------------------

class VulnerableRoadUserCondition final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.trafficevents.VulnerableRoadUserCondition) */ {
 public:
  inline VulnerableRoadUserCondition() : VulnerableRoadUserCondition(nullptr) {}
  ~VulnerableRoadUserCondition() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR VulnerableRoadUserCondition(::google::protobuf::internal::ConstantInitialized);

  inline VulnerableRoadUserCondition(const VulnerableRoadUserCondition& from)
      : VulnerableRoadUserCondition(nullptr, from) {}
  VulnerableRoadUserCondition(VulnerableRoadUserCondition&& from) noexcept
    : VulnerableRoadUserCondition() {
    *this = ::std::move(from);
  }

  inline VulnerableRoadUserCondition& operator=(const VulnerableRoadUserCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline VulnerableRoadUserCondition& operator=(VulnerableRoadUserCondition&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VulnerableRoadUserCondition& default_instance() {
    return *internal_default_instance();
  }
  static inline const VulnerableRoadUserCondition* internal_default_instance() {
    return reinterpret_cast<const VulnerableRoadUserCondition*>(
               &_VulnerableRoadUserCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(VulnerableRoadUserCondition& a, VulnerableRoadUserCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(VulnerableRoadUserCondition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VulnerableRoadUserCondition* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VulnerableRoadUserCondition* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VulnerableRoadUserCondition>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VulnerableRoadUserCondition& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const VulnerableRoadUserCondition& from) {
    VulnerableRoadUserCondition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(VulnerableRoadUserCondition* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.categories.trafficevents.VulnerableRoadUserCondition";
  }
  protected:
  explicit VulnerableRoadUserCondition(::google::protobuf::Arena* arena);
  VulnerableRoadUserCondition(::google::protobuf::Arena* arena, const VulnerableRoadUserCondition& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using TypeAndConfidence = VulnerableRoadUserCondition_TypeAndConfidence;

  // accessors -------------------------------------------------------

  enum : int {
    kEnvelopeFieldNumber = 1,
    kDetectionStatusFieldNumber = 2,
    kTypeAndConfidenceFieldNumber = 3,
  };
  // .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
  bool has_envelope() const;
  void clear_envelope() ;
  const ::sensoris::protobuf::types::base::EventEnvelope& envelope() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::EventEnvelope* release_envelope();
  ::sensoris::protobuf::types::base::EventEnvelope* mutable_envelope();
  void set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value);
  void unsafe_arena_set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value);
  ::sensoris::protobuf::types::base::EventEnvelope* unsafe_arena_release_envelope();

  private:
  const ::sensoris::protobuf::types::base::EventEnvelope& _internal_envelope() const;
  ::sensoris::protobuf::types::base::EventEnvelope* _internal_mutable_envelope();

  public:
  // .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 2;
  bool has_detection_status() const;
  void clear_detection_status() ;
  const ::sensoris::protobuf::types::base::EventDetectionStatus& detection_status() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::EventDetectionStatus* release_detection_status();
  ::sensoris::protobuf::types::base::EventDetectionStatus* mutable_detection_status();
  void set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* value);
  void unsafe_arena_set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* value);
  ::sensoris::protobuf::types::base::EventDetectionStatus* unsafe_arena_release_detection_status();

  private:
  const ::sensoris::protobuf::types::base::EventDetectionStatus& _internal_detection_status() const;
  ::sensoris::protobuf::types::base::EventDetectionStatus* _internal_mutable_detection_status();

  public:
  // .sensoris.protobuf.categories.trafficevents.VulnerableRoadUserCondition.TypeAndConfidence type_and_confidence = 3;
  bool has_type_and_confidence() const;
  void clear_type_and_confidence() ;
  const ::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence& type_and_confidence() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence* release_type_and_confidence();
  ::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence* mutable_type_and_confidence();
  void set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence* value);
  void unsafe_arena_set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence* value);
  ::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence* unsafe_arena_release_type_and_confidence();

  private:
  const ::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence& _internal_type_and_confidence() const;
  ::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence* _internal_mutable_type_and_confidence();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.trafficevents.VulnerableRoadUserCondition)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::EventEnvelope* envelope_;
    ::sensoris::protobuf::types::base::EventDetectionStatus* detection_status_;
    ::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence* type_and_confidence_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto;
};// -------------------------------------------------------------------

class TrafficCondition final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.trafficevents.TrafficCondition) */ {
 public:
  inline TrafficCondition() : TrafficCondition(nullptr) {}
  ~TrafficCondition() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TrafficCondition(::google::protobuf::internal::ConstantInitialized);

  inline TrafficCondition(const TrafficCondition& from)
      : TrafficCondition(nullptr, from) {}
  TrafficCondition(TrafficCondition&& from) noexcept
    : TrafficCondition() {
    *this = ::std::move(from);
  }

  inline TrafficCondition& operator=(const TrafficCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrafficCondition& operator=(TrafficCondition&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrafficCondition& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrafficCondition* internal_default_instance() {
    return reinterpret_cast<const TrafficCondition*>(
               &_TrafficCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(TrafficCondition& a, TrafficCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(TrafficCondition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrafficCondition* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrafficCondition* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrafficCondition>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TrafficCondition& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TrafficCondition& from) {
    TrafficCondition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TrafficCondition* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.categories.trafficevents.TrafficCondition";
  }
  protected:
  explicit TrafficCondition(::google::protobuf::Arena* arena);
  TrafficCondition(::google::protobuf::Arena* arena, const TrafficCondition& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using TypeAndConfidence = TrafficCondition_TypeAndConfidence;

  // accessors -------------------------------------------------------

  enum : int {
    kEnvelopeFieldNumber = 1,
    kDetectionStatusFieldNumber = 2,
    kTypeAndConfidenceFieldNumber = 3,
  };
  // .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
  bool has_envelope() const;
  void clear_envelope() ;
  const ::sensoris::protobuf::types::base::EventEnvelope& envelope() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::EventEnvelope* release_envelope();
  ::sensoris::protobuf::types::base::EventEnvelope* mutable_envelope();
  void set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value);
  void unsafe_arena_set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value);
  ::sensoris::protobuf::types::base::EventEnvelope* unsafe_arena_release_envelope();

  private:
  const ::sensoris::protobuf::types::base::EventEnvelope& _internal_envelope() const;
  ::sensoris::protobuf::types::base::EventEnvelope* _internal_mutable_envelope();

  public:
  // .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 2;
  bool has_detection_status() const;
  void clear_detection_status() ;
  const ::sensoris::protobuf::types::base::EventDetectionStatus& detection_status() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::EventDetectionStatus* release_detection_status();
  ::sensoris::protobuf::types::base::EventDetectionStatus* mutable_detection_status();
  void set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* value);
  void unsafe_arena_set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* value);
  ::sensoris::protobuf::types::base::EventDetectionStatus* unsafe_arena_release_detection_status();

  private:
  const ::sensoris::protobuf::types::base::EventDetectionStatus& _internal_detection_status() const;
  ::sensoris::protobuf::types::base::EventDetectionStatus* _internal_mutable_detection_status();

  public:
  // .sensoris.protobuf.categories.trafficevents.TrafficCondition.TypeAndConfidence type_and_confidence = 3;
  bool has_type_and_confidence() const;
  void clear_type_and_confidence() ;
  const ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence& type_and_confidence() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence* release_type_and_confidence();
  ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence* mutable_type_and_confidence();
  void set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence* value);
  void unsafe_arena_set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence* value);
  ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence* unsafe_arena_release_type_and_confidence();

  private:
  const ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence& _internal_type_and_confidence() const;
  ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence* _internal_mutable_type_and_confidence();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.trafficevents.TrafficCondition)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::EventEnvelope* envelope_;
    ::sensoris::protobuf::types::base::EventDetectionStatus* detection_status_;
    ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence* type_and_confidence_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto;
};// -------------------------------------------------------------------

class RoadWorks final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.trafficevents.RoadWorks) */ {
 public:
  inline RoadWorks() : RoadWorks(nullptr) {}
  ~RoadWorks() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RoadWorks(::google::protobuf::internal::ConstantInitialized);

  inline RoadWorks(const RoadWorks& from)
      : RoadWorks(nullptr, from) {}
  RoadWorks(RoadWorks&& from) noexcept
    : RoadWorks() {
    *this = ::std::move(from);
  }

  inline RoadWorks& operator=(const RoadWorks& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoadWorks& operator=(RoadWorks&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoadWorks& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoadWorks* internal_default_instance() {
    return reinterpret_cast<const RoadWorks*>(
               &_RoadWorks_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(RoadWorks& a, RoadWorks& b) {
    a.Swap(&b);
  }
  inline void Swap(RoadWorks* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoadWorks* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoadWorks* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoadWorks>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RoadWorks& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RoadWorks& from) {
    RoadWorks::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RoadWorks* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.categories.trafficevents.RoadWorks";
  }
  protected:
  explicit RoadWorks(::google::protobuf::Arena* arena);
  RoadWorks(::google::protobuf::Arena* arena, const RoadWorks& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using TypeAndConfidence = RoadWorks_TypeAndConfidence;

  // accessors -------------------------------------------------------

  enum : int {
    kEnvelopeFieldNumber = 1,
    kDetectionStatusFieldNumber = 2,
    kTypeAndConfidenceFieldNumber = 3,
    kLanesClosedAndConfidenceFieldNumber = 5,
  };
  // .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
  bool has_envelope() const;
  void clear_envelope() ;
  const ::sensoris::protobuf::types::base::EventEnvelope& envelope() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::EventEnvelope* release_envelope();
  ::sensoris::protobuf::types::base::EventEnvelope* mutable_envelope();
  void set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value);
  void unsafe_arena_set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value);
  ::sensoris::protobuf::types::base::EventEnvelope* unsafe_arena_release_envelope();

  private:
  const ::sensoris::protobuf::types::base::EventEnvelope& _internal_envelope() const;
  ::sensoris::protobuf::types::base::EventEnvelope* _internal_mutable_envelope();

  public:
  // .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 2;
  bool has_detection_status() const;
  void clear_detection_status() ;
  const ::sensoris::protobuf::types::base::EventDetectionStatus& detection_status() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::EventDetectionStatus* release_detection_status();
  ::sensoris::protobuf::types::base::EventDetectionStatus* mutable_detection_status();
  void set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* value);
  void unsafe_arena_set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* value);
  ::sensoris::protobuf::types::base::EventDetectionStatus* unsafe_arena_release_detection_status();

  private:
  const ::sensoris::protobuf::types::base::EventDetectionStatus& _internal_detection_status() const;
  ::sensoris::protobuf::types::base::EventDetectionStatus* _internal_mutable_detection_status();

  public:
  // .sensoris.protobuf.categories.trafficevents.RoadWorks.TypeAndConfidence type_and_confidence = 3;
  bool has_type_and_confidence() const;
  void clear_type_and_confidence() ;
  const ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence& type_and_confidence() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence* release_type_and_confidence();
  ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence* mutable_type_and_confidence();
  void set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence* value);
  void unsafe_arena_set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence* value);
  ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence* unsafe_arena_release_type_and_confidence();

  private:
  const ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence& _internal_type_and_confidence() const;
  ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence* _internal_mutable_type_and_confidence();

  public:
  // .sensoris.protobuf.types.base.CountAndConfidence lanes_closed_and_confidence = 5;
  bool has_lanes_closed_and_confidence() const;
  void clear_lanes_closed_and_confidence() ;
  const ::sensoris::protobuf::types::base::CountAndConfidence& lanes_closed_and_confidence() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::CountAndConfidence* release_lanes_closed_and_confidence();
  ::sensoris::protobuf::types::base::CountAndConfidence* mutable_lanes_closed_and_confidence();
  void set_allocated_lanes_closed_and_confidence(::sensoris::protobuf::types::base::CountAndConfidence* value);
  void unsafe_arena_set_allocated_lanes_closed_and_confidence(::sensoris::protobuf::types::base::CountAndConfidence* value);
  ::sensoris::protobuf::types::base::CountAndConfidence* unsafe_arena_release_lanes_closed_and_confidence();

  private:
  const ::sensoris::protobuf::types::base::CountAndConfidence& _internal_lanes_closed_and_confidence() const;
  ::sensoris::protobuf::types::base::CountAndConfidence* _internal_mutable_lanes_closed_and_confidence();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.trafficevents.RoadWorks)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 4, 4,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::EventEnvelope* envelope_;
    ::sensoris::protobuf::types::base::EventDetectionStatus* detection_status_;
    ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence* type_and_confidence_;
    ::sensoris::protobuf::types::base::CountAndConfidence* lanes_closed_and_confidence_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto;
};// -------------------------------------------------------------------

class RoadSurfaceCondition final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.trafficevents.RoadSurfaceCondition) */ {
 public:
  inline RoadSurfaceCondition() : RoadSurfaceCondition(nullptr) {}
  ~RoadSurfaceCondition() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RoadSurfaceCondition(::google::protobuf::internal::ConstantInitialized);

  inline RoadSurfaceCondition(const RoadSurfaceCondition& from)
      : RoadSurfaceCondition(nullptr, from) {}
  RoadSurfaceCondition(RoadSurfaceCondition&& from) noexcept
    : RoadSurfaceCondition() {
    *this = ::std::move(from);
  }

  inline RoadSurfaceCondition& operator=(const RoadSurfaceCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoadSurfaceCondition& operator=(RoadSurfaceCondition&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoadSurfaceCondition& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoadSurfaceCondition* internal_default_instance() {
    return reinterpret_cast<const RoadSurfaceCondition*>(
               &_RoadSurfaceCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(RoadSurfaceCondition& a, RoadSurfaceCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(RoadSurfaceCondition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoadSurfaceCondition* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoadSurfaceCondition* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoadSurfaceCondition>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RoadSurfaceCondition& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RoadSurfaceCondition& from) {
    RoadSurfaceCondition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RoadSurfaceCondition* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.categories.trafficevents.RoadSurfaceCondition";
  }
  protected:
  explicit RoadSurfaceCondition(::google::protobuf::Arena* arena);
  RoadSurfaceCondition(::google::protobuf::Arena* arena, const RoadSurfaceCondition& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using TypeAndConfidence = RoadSurfaceCondition_TypeAndConfidence;

  // accessors -------------------------------------------------------

  enum : int {
    kEnvelopeFieldNumber = 1,
    kDetectionStatusFieldNumber = 2,
    kTypeAndConfidenceFieldNumber = 3,
  };
  // .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
  bool has_envelope() const;
  void clear_envelope() ;
  const ::sensoris::protobuf::types::base::EventEnvelope& envelope() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::EventEnvelope* release_envelope();
  ::sensoris::protobuf::types::base::EventEnvelope* mutable_envelope();
  void set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value);
  void unsafe_arena_set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value);
  ::sensoris::protobuf::types::base::EventEnvelope* unsafe_arena_release_envelope();

  private:
  const ::sensoris::protobuf::types::base::EventEnvelope& _internal_envelope() const;
  ::sensoris::protobuf::types::base::EventEnvelope* _internal_mutable_envelope();

  public:
  // .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 2;
  bool has_detection_status() const;
  void clear_detection_status() ;
  const ::sensoris::protobuf::types::base::EventDetectionStatus& detection_status() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::EventDetectionStatus* release_detection_status();
  ::sensoris::protobuf::types::base::EventDetectionStatus* mutable_detection_status();
  void set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* value);
  void unsafe_arena_set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* value);
  ::sensoris::protobuf::types::base::EventDetectionStatus* unsafe_arena_release_detection_status();

  private:
  const ::sensoris::protobuf::types::base::EventDetectionStatus& _internal_detection_status() const;
  ::sensoris::protobuf::types::base::EventDetectionStatus* _internal_mutable_detection_status();

  public:
  // .sensoris.protobuf.categories.trafficevents.RoadSurfaceCondition.TypeAndConfidence type_and_confidence = 3;
  bool has_type_and_confidence() const;
  void clear_type_and_confidence() ;
  const ::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence& type_and_confidence() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence* release_type_and_confidence();
  ::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence* mutable_type_and_confidence();
  void set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence* value);
  void unsafe_arena_set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence* value);
  ::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence* unsafe_arena_release_type_and_confidence();

  private:
  const ::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence& _internal_type_and_confidence() const;
  ::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence* _internal_mutable_type_and_confidence();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.trafficevents.RoadSurfaceCondition)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::EventEnvelope* envelope_;
    ::sensoris::protobuf::types::base::EventDetectionStatus* detection_status_;
    ::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence* type_and_confidence_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto;
};// -------------------------------------------------------------------

class RoadObstructionCondition final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.trafficevents.RoadObstructionCondition) */ {
 public:
  inline RoadObstructionCondition() : RoadObstructionCondition(nullptr) {}
  ~RoadObstructionCondition() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RoadObstructionCondition(::google::protobuf::internal::ConstantInitialized);

  inline RoadObstructionCondition(const RoadObstructionCondition& from)
      : RoadObstructionCondition(nullptr, from) {}
  RoadObstructionCondition(RoadObstructionCondition&& from) noexcept
    : RoadObstructionCondition() {
    *this = ::std::move(from);
  }

  inline RoadObstructionCondition& operator=(const RoadObstructionCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoadObstructionCondition& operator=(RoadObstructionCondition&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoadObstructionCondition& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoadObstructionCondition* internal_default_instance() {
    return reinterpret_cast<const RoadObstructionCondition*>(
               &_RoadObstructionCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(RoadObstructionCondition& a, RoadObstructionCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(RoadObstructionCondition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoadObstructionCondition* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoadObstructionCondition* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoadObstructionCondition>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RoadObstructionCondition& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RoadObstructionCondition& from) {
    RoadObstructionCondition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RoadObstructionCondition* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.categories.trafficevents.RoadObstructionCondition";
  }
  protected:
  explicit RoadObstructionCondition(::google::protobuf::Arena* arena);
  RoadObstructionCondition(::google::protobuf::Arena* arena, const RoadObstructionCondition& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using TypeAndConfidence = RoadObstructionCondition_TypeAndConfidence;

  // accessors -------------------------------------------------------

  enum : int {
    kEnvelopeFieldNumber = 1,
    kDetectionStatusFieldNumber = 2,
    kTypeAndConfidenceFieldNumber = 3,
  };
  // .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
  bool has_envelope() const;
  void clear_envelope() ;
  const ::sensoris::protobuf::types::base::EventEnvelope& envelope() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::EventEnvelope* release_envelope();
  ::sensoris::protobuf::types::base::EventEnvelope* mutable_envelope();
  void set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value);
  void unsafe_arena_set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value);
  ::sensoris::protobuf::types::base::EventEnvelope* unsafe_arena_release_envelope();

  private:
  const ::sensoris::protobuf::types::base::EventEnvelope& _internal_envelope() const;
  ::sensoris::protobuf::types::base::EventEnvelope* _internal_mutable_envelope();

  public:
  // .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 2;
  bool has_detection_status() const;
  void clear_detection_status() ;
  const ::sensoris::protobuf::types::base::EventDetectionStatus& detection_status() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::EventDetectionStatus* release_detection_status();
  ::sensoris::protobuf::types::base::EventDetectionStatus* mutable_detection_status();
  void set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* value);
  void unsafe_arena_set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* value);
  ::sensoris::protobuf::types::base::EventDetectionStatus* unsafe_arena_release_detection_status();

  private:
  const ::sensoris::protobuf::types::base::EventDetectionStatus& _internal_detection_status() const;
  ::sensoris::protobuf::types::base::EventDetectionStatus* _internal_mutable_detection_status();

  public:
  // .sensoris.protobuf.categories.trafficevents.RoadObstructionCondition.TypeAndConfidence type_and_confidence = 3;
  bool has_type_and_confidence() const;
  void clear_type_and_confidence() ;
  const ::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence& type_and_confidence() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence* release_type_and_confidence();
  ::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence* mutable_type_and_confidence();
  void set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence* value);
  void unsafe_arena_set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence* value);
  ::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence* unsafe_arena_release_type_and_confidence();

  private:
  const ::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence& _internal_type_and_confidence() const;
  ::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence* _internal_mutable_type_and_confidence();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.trafficevents.RoadObstructionCondition)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::EventEnvelope* envelope_;
    ::sensoris::protobuf::types::base::EventDetectionStatus* detection_status_;
    ::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence* type_and_confidence_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto;
};// -------------------------------------------------------------------

class Hazard final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.trafficevents.Hazard) */ {
 public:
  inline Hazard() : Hazard(nullptr) {}
  ~Hazard() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Hazard(::google::protobuf::internal::ConstantInitialized);

  inline Hazard(const Hazard& from)
      : Hazard(nullptr, from) {}
  Hazard(Hazard&& from) noexcept
    : Hazard() {
    *this = ::std::move(from);
  }

  inline Hazard& operator=(const Hazard& from) {
    CopyFrom(from);
    return *this;
  }
  inline Hazard& operator=(Hazard&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Hazard& default_instance() {
    return *internal_default_instance();
  }
  static inline const Hazard* internal_default_instance() {
    return reinterpret_cast<const Hazard*>(
               &_Hazard_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Hazard& a, Hazard& b) {
    a.Swap(&b);
  }
  inline void Swap(Hazard* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Hazard* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Hazard* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Hazard>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Hazard& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Hazard& from) {
    Hazard::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Hazard* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.categories.trafficevents.Hazard";
  }
  protected:
  explicit Hazard(::google::protobuf::Arena* arena);
  Hazard(::google::protobuf::Arena* arena, const Hazard& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using TypeAndConfidence = Hazard_TypeAndConfidence;

  using Direction = Hazard_Direction;
  static constexpr Direction UNKNOWN_DIRECTION = Hazard_Direction_UNKNOWN_DIRECTION;
  static constexpr Direction EGO_DIRECTION = Hazard_Direction_EGO_DIRECTION;
  static constexpr Direction OPPOSITE_DIRECTION = Hazard_Direction_OPPOSITE_DIRECTION;
  static constexpr Direction BOTH = Hazard_Direction_BOTH;
  static inline bool Direction_IsValid(int value) {
    return Hazard_Direction_IsValid(value);
  }
  static constexpr Direction Direction_MIN = Hazard_Direction_Direction_MIN;
  static constexpr Direction Direction_MAX = Hazard_Direction_Direction_MAX;
  static constexpr int Direction_ARRAYSIZE = Hazard_Direction_Direction_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Direction_descriptor() {
    return Hazard_Direction_descriptor();
  }
  template <typename T>
  static inline const std::string& Direction_Name(T value) {
    return Hazard_Direction_Name(value);
  }
  static inline bool Direction_Parse(absl::string_view name, Direction* value) {
    return Hazard_Direction_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kEnvelopeFieldNumber = 1,
    kDetectionStatusFieldNumber = 2,
    kTypeAndConfidenceFieldNumber = 3,
    kDirectionFieldNumber = 4,
  };
  // .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
  bool has_envelope() const;
  void clear_envelope() ;
  const ::sensoris::protobuf::types::base::EventEnvelope& envelope() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::EventEnvelope* release_envelope();
  ::sensoris::protobuf::types::base::EventEnvelope* mutable_envelope();
  void set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value);
  void unsafe_arena_set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value);
  ::sensoris::protobuf::types::base::EventEnvelope* unsafe_arena_release_envelope();

  private:
  const ::sensoris::protobuf::types::base::EventEnvelope& _internal_envelope() const;
  ::sensoris::protobuf::types::base::EventEnvelope* _internal_mutable_envelope();

  public:
  // .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 2;
  bool has_detection_status() const;
  void clear_detection_status() ;
  const ::sensoris::protobuf::types::base::EventDetectionStatus& detection_status() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::EventDetectionStatus* release_detection_status();
  ::sensoris::protobuf::types::base::EventDetectionStatus* mutable_detection_status();
  void set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* value);
  void unsafe_arena_set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* value);
  ::sensoris::protobuf::types::base::EventDetectionStatus* unsafe_arena_release_detection_status();

  private:
  const ::sensoris::protobuf::types::base::EventDetectionStatus& _internal_detection_status() const;
  ::sensoris::protobuf::types::base::EventDetectionStatus* _internal_mutable_detection_status();

  public:
  // .sensoris.protobuf.categories.trafficevents.Hazard.TypeAndConfidence type_and_confidence = 3;
  bool has_type_and_confidence() const;
  void clear_type_and_confidence() ;
  const ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence& type_and_confidence() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence* release_type_and_confidence();
  ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence* mutable_type_and_confidence();
  void set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence* value);
  void unsafe_arena_set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence* value);
  ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence* unsafe_arena_release_type_and_confidence();

  private:
  const ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence& _internal_type_and_confidence() const;
  ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence* _internal_mutable_type_and_confidence();

  public:
  // .sensoris.protobuf.categories.trafficevents.Hazard.Direction direction = 4;
  void clear_direction() ;
  ::sensoris::protobuf::categories::trafficevents::Hazard_Direction direction() const;
  void set_direction(::sensoris::protobuf::categories::trafficevents::Hazard_Direction value);

  private:
  ::sensoris::protobuf::categories::trafficevents::Hazard_Direction _internal_direction() const;
  void _internal_set_direction(::sensoris::protobuf::categories::trafficevents::Hazard_Direction value);

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.trafficevents.Hazard)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::EventEnvelope* envelope_;
    ::sensoris::protobuf::types::base::EventDetectionStatus* detection_status_;
    ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence* type_and_confidence_;
    int direction_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto;
};// -------------------------------------------------------------------

class ECallStatus final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.trafficevents.ECallStatus) */ {
 public:
  inline ECallStatus() : ECallStatus(nullptr) {}
  ~ECallStatus() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ECallStatus(::google::protobuf::internal::ConstantInitialized);

  inline ECallStatus(const ECallStatus& from)
      : ECallStatus(nullptr, from) {}
  ECallStatus(ECallStatus&& from) noexcept
    : ECallStatus() {
    *this = ::std::move(from);
  }

  inline ECallStatus& operator=(const ECallStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline ECallStatus& operator=(ECallStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ECallStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const ECallStatus* internal_default_instance() {
    return reinterpret_cast<const ECallStatus*>(
               &_ECallStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ECallStatus& a, ECallStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(ECallStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ECallStatus* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ECallStatus* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ECallStatus>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ECallStatus& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ECallStatus& from) {
    ECallStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ECallStatus* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.categories.trafficevents.ECallStatus";
  }
  protected:
  explicit ECallStatus(::google::protobuf::Arena* arena);
  ECallStatus(::google::protobuf::Arena* arena, const ECallStatus& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using ActivationType = ECallStatus_ActivationType;
  static constexpr ActivationType UNKNOWN_ACTIVATION_TYPE = ECallStatus_ActivationType_UNKNOWN_ACTIVATION_TYPE;
  static constexpr ActivationType NONE = ECallStatus_ActivationType_NONE;
  static constexpr ActivationType MANUAL = ECallStatus_ActivationType_MANUAL;
  static constexpr ActivationType AUTOMATIC = ECallStatus_ActivationType_AUTOMATIC;
  static inline bool ActivationType_IsValid(int value) {
    return ECallStatus_ActivationType_IsValid(value);
  }
  static constexpr ActivationType ActivationType_MIN = ECallStatus_ActivationType_ActivationType_MIN;
  static constexpr ActivationType ActivationType_MAX = ECallStatus_ActivationType_ActivationType_MAX;
  static constexpr int ActivationType_ARRAYSIZE = ECallStatus_ActivationType_ActivationType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* ActivationType_descriptor() {
    return ECallStatus_ActivationType_descriptor();
  }
  template <typename T>
  static inline const std::string& ActivationType_Name(T value) {
    return ECallStatus_ActivationType_Name(value);
  }
  static inline bool ActivationType_Parse(absl::string_view name, ActivationType* value) {
    return ECallStatus_ActivationType_Parse(name, value);
  }

  using Availability = ECallStatus_Availability;
  static constexpr Availability UNKNOWN_AVAILABILITY = ECallStatus_Availability_UNKNOWN_AVAILABILITY;
  static constexpr Availability AVAILABLE = ECallStatus_Availability_AVAILABLE;
  static constexpr Availability UNAVAILABLE = ECallStatus_Availability_UNAVAILABLE;
  static inline bool Availability_IsValid(int value) {
    return ECallStatus_Availability_IsValid(value);
  }
  static constexpr Availability Availability_MIN = ECallStatus_Availability_Availability_MIN;
  static constexpr Availability Availability_MAX = ECallStatus_Availability_Availability_MAX;
  static constexpr int Availability_ARRAYSIZE = ECallStatus_Availability_Availability_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Availability_descriptor() {
    return ECallStatus_Availability_descriptor();
  }
  template <typename T>
  static inline const std::string& Availability_Name(T value) {
    return ECallStatus_Availability_Name(value);
  }
  static inline bool Availability_Parse(absl::string_view name, Availability* value) {
    return ECallStatus_Availability_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kEnvelopeFieldNumber = 1,
    kActivationTypeFieldNumber = 2,
    kAvailabilityFieldNumber = 3,
  };
  // .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
  bool has_envelope() const;
  void clear_envelope() ;
  const ::sensoris::protobuf::types::base::EventEnvelope& envelope() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::EventEnvelope* release_envelope();
  ::sensoris::protobuf::types::base::EventEnvelope* mutable_envelope();
  void set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value);
  void unsafe_arena_set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value);
  ::sensoris::protobuf::types::base::EventEnvelope* unsafe_arena_release_envelope();

  private:
  const ::sensoris::protobuf::types::base::EventEnvelope& _internal_envelope() const;
  ::sensoris::protobuf::types::base::EventEnvelope* _internal_mutable_envelope();

  public:
  // .sensoris.protobuf.categories.trafficevents.ECallStatus.ActivationType activation_type = 2;
  void clear_activation_type() ;
  ::sensoris::protobuf::categories::trafficevents::ECallStatus_ActivationType activation_type() const;
  void set_activation_type(::sensoris::protobuf::categories::trafficevents::ECallStatus_ActivationType value);

  private:
  ::sensoris::protobuf::categories::trafficevents::ECallStatus_ActivationType _internal_activation_type() const;
  void _internal_set_activation_type(::sensoris::protobuf::categories::trafficevents::ECallStatus_ActivationType value);

  public:
  // .sensoris.protobuf.categories.trafficevents.ECallStatus.Availability availability = 3;
  void clear_availability() ;
  ::sensoris::protobuf::categories::trafficevents::ECallStatus_Availability availability() const;
  void set_availability(::sensoris::protobuf::categories::trafficevents::ECallStatus_Availability value);

  private:
  ::sensoris::protobuf::categories::trafficevents::ECallStatus_Availability _internal_availability() const;
  void _internal_set_availability(::sensoris::protobuf::categories::trafficevents::ECallStatus_Availability value);

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.trafficevents.ECallStatus)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::EventEnvelope* envelope_;
    int activation_type_;
    int availability_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto;
};// -------------------------------------------------------------------

class RoadWeatherCondition final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition) */ {
 public:
  inline RoadWeatherCondition() : RoadWeatherCondition(nullptr) {}
  ~RoadWeatherCondition() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RoadWeatherCondition(::google::protobuf::internal::ConstantInitialized);

  inline RoadWeatherCondition(const RoadWeatherCondition& from)
      : RoadWeatherCondition(nullptr, from) {}
  RoadWeatherCondition(RoadWeatherCondition&& from) noexcept
    : RoadWeatherCondition() {
    *this = ::std::move(from);
  }

  inline RoadWeatherCondition& operator=(const RoadWeatherCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoadWeatherCondition& operator=(RoadWeatherCondition&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoadWeatherCondition& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoadWeatherCondition* internal_default_instance() {
    return reinterpret_cast<const RoadWeatherCondition*>(
               &_RoadWeatherCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(RoadWeatherCondition& a, RoadWeatherCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(RoadWeatherCondition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoadWeatherCondition* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoadWeatherCondition* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoadWeatherCondition>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RoadWeatherCondition& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RoadWeatherCondition& from) {
    RoadWeatherCondition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RoadWeatherCondition* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.categories.trafficevents.RoadWeatherCondition";
  }
  protected:
  explicit RoadWeatherCondition(::google::protobuf::Arena* arena);
  RoadWeatherCondition(::google::protobuf::Arena* arena, const RoadWeatherCondition& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using TypeAndConfidence = RoadWeatherCondition_TypeAndConfidence;

  // accessors -------------------------------------------------------

  enum : int {
    kEnvelopeFieldNumber = 1,
    kDetectionStatusFieldNumber = 2,
    kTypeAndConfidenceFieldNumber = 3,
    kDepthAndAccuracyFieldNumber = 4,
  };
  // .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
  bool has_envelope() const;
  void clear_envelope() ;
  const ::sensoris::protobuf::types::base::EventEnvelope& envelope() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::EventEnvelope* release_envelope();
  ::sensoris::protobuf::types::base::EventEnvelope* mutable_envelope();
  void set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value);
  void unsafe_arena_set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value);
  ::sensoris::protobuf::types::base::EventEnvelope* unsafe_arena_release_envelope();

  private:
  const ::sensoris::protobuf::types::base::EventEnvelope& _internal_envelope() const;
  ::sensoris::protobuf::types::base::EventEnvelope* _internal_mutable_envelope();

  public:
  // .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 2;
  bool has_detection_status() const;
  void clear_detection_status() ;
  const ::sensoris::protobuf::types::base::EventDetectionStatus& detection_status() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::EventDetectionStatus* release_detection_status();
  ::sensoris::protobuf::types::base::EventDetectionStatus* mutable_detection_status();
  void set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* value);
  void unsafe_arena_set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* value);
  ::sensoris::protobuf::types::base::EventDetectionStatus* unsafe_arena_release_detection_status();

  private:
  const ::sensoris::protobuf::types::base::EventDetectionStatus& _internal_detection_status() const;
  ::sensoris::protobuf::types::base::EventDetectionStatus* _internal_mutable_detection_status();

  public:
  // .sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.TypeAndConfidence type_and_confidence = 3;
  bool has_type_and_confidence() const;
  void clear_type_and_confidence() ;
  const ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence& type_and_confidence() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence* release_type_and_confidence();
  ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence* mutable_type_and_confidence();
  void set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence* value);
  void unsafe_arena_set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence* value);
  ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence* unsafe_arena_release_type_and_confidence();

  private:
  const ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence& _internal_type_and_confidence() const;
  ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence* _internal_mutable_type_and_confidence();

  public:
  // .sensoris.protobuf.types.base.Int64ValueAndAccuracy depth_and_accuracy = 4 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_depth_and_accuracy() const;
  void clear_depth_and_accuracy() ;
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& depth_and_accuracy() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* release_depth_and_accuracy();
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* mutable_depth_and_accuracy();
  void set_allocated_depth_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* value);
  void unsafe_arena_set_allocated_depth_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* value);
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* unsafe_arena_release_depth_and_accuracy();

  private:
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& _internal_depth_and_accuracy() const;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* _internal_mutable_depth_and_accuracy();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 4,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::EventEnvelope* envelope_;
    ::sensoris::protobuf::types::base::EventDetectionStatus* detection_status_;
    ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence* type_and_confidence_;
    ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* depth_and_accuracy_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto;
};// -------------------------------------------------------------------

class DangerousSlowDown final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.trafficevents.DangerousSlowDown) */ {
 public:
  inline DangerousSlowDown() : DangerousSlowDown(nullptr) {}
  ~DangerousSlowDown() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DangerousSlowDown(::google::protobuf::internal::ConstantInitialized);

  inline DangerousSlowDown(const DangerousSlowDown& from)
      : DangerousSlowDown(nullptr, from) {}
  DangerousSlowDown(DangerousSlowDown&& from) noexcept
    : DangerousSlowDown() {
    *this = ::std::move(from);
  }

  inline DangerousSlowDown& operator=(const DangerousSlowDown& from) {
    CopyFrom(from);
    return *this;
  }
  inline DangerousSlowDown& operator=(DangerousSlowDown&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DangerousSlowDown& default_instance() {
    return *internal_default_instance();
  }
  static inline const DangerousSlowDown* internal_default_instance() {
    return reinterpret_cast<const DangerousSlowDown*>(
               &_DangerousSlowDown_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(DangerousSlowDown& a, DangerousSlowDown& b) {
    a.Swap(&b);
  }
  inline void Swap(DangerousSlowDown* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DangerousSlowDown* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DangerousSlowDown* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DangerousSlowDown>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DangerousSlowDown& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DangerousSlowDown& from) {
    DangerousSlowDown::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DangerousSlowDown* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.categories.trafficevents.DangerousSlowDown";
  }
  protected:
  explicit DangerousSlowDown(::google::protobuf::Arena* arena);
  DangerousSlowDown(::google::protobuf::Arena* arena, const DangerousSlowDown& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnvelopeFieldNumber = 1,
    kSpeedReductionAndAccuracyFieldNumber = 2,
    kTimePeriodFieldNumber = 3,
  };
  // .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
  bool has_envelope() const;
  void clear_envelope() ;
  const ::sensoris::protobuf::types::base::EventEnvelope& envelope() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::EventEnvelope* release_envelope();
  ::sensoris::protobuf::types::base::EventEnvelope* mutable_envelope();
  void set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value);
  void unsafe_arena_set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value);
  ::sensoris::protobuf::types::base::EventEnvelope* unsafe_arena_release_envelope();

  private:
  const ::sensoris::protobuf::types::base::EventEnvelope& _internal_envelope() const;
  ::sensoris::protobuf::types::base::EventEnvelope* _internal_mutable_envelope();

  public:
  // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy speed_reduction_and_accuracy = 2 [(.sensoris.protobuf.types.base.exponent) = 1];
  bool has_speed_reduction_and_accuracy() const;
  void clear_speed_reduction_and_accuracy() ;
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& speed_reduction_and_accuracy() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* release_speed_reduction_and_accuracy();
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* mutable_speed_reduction_and_accuracy();
  void set_allocated_speed_reduction_and_accuracy(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* value);
  void unsafe_arena_set_allocated_speed_reduction_and_accuracy(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* value);
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* unsafe_arena_release_speed_reduction_and_accuracy();

  private:
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& _internal_speed_reduction_and_accuracy() const;
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* _internal_mutable_speed_reduction_and_accuracy();

  public:
  // .google.protobuf.Int64Value time_period = 3 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_time_period() const;
  void clear_time_period() ;
  const ::google::protobuf::Int64Value& time_period() const;
  PROTOBUF_NODISCARD ::google::protobuf::Int64Value* release_time_period();
  ::google::protobuf::Int64Value* mutable_time_period();
  void set_allocated_time_period(::google::protobuf::Int64Value* value);
  void unsafe_arena_set_allocated_time_period(::google::protobuf::Int64Value* value);
  ::google::protobuf::Int64Value* unsafe_arena_release_time_period();

  private:
  const ::google::protobuf::Int64Value& _internal_time_period() const;
  ::google::protobuf::Int64Value* _internal_mutable_time_period();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.trafficevents.DangerousSlowDown)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::EventEnvelope* envelope_;
    ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* speed_reduction_and_accuracy_;
    ::google::protobuf::Int64Value* time_period_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto;
};// -------------------------------------------------------------------

class TrafficEventsCategory final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory) */ {
 public:
  inline TrafficEventsCategory() : TrafficEventsCategory(nullptr) {}
  ~TrafficEventsCategory() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TrafficEventsCategory(::google::protobuf::internal::ConstantInitialized);

  inline TrafficEventsCategory(const TrafficEventsCategory& from)
      : TrafficEventsCategory(nullptr, from) {}
  TrafficEventsCategory(TrafficEventsCategory&& from) noexcept
    : TrafficEventsCategory() {
    *this = ::std::move(from);
  }

  inline TrafficEventsCategory& operator=(const TrafficEventsCategory& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrafficEventsCategory& operator=(TrafficEventsCategory&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrafficEventsCategory& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrafficEventsCategory* internal_default_instance() {
    return reinterpret_cast<const TrafficEventsCategory*>(
               &_TrafficEventsCategory_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(TrafficEventsCategory& a, TrafficEventsCategory& b) {
    a.Swap(&b);
  }
  inline void Swap(TrafficEventsCategory* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrafficEventsCategory* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrafficEventsCategory* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrafficEventsCategory>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TrafficEventsCategory& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TrafficEventsCategory& from) {
    TrafficEventsCategory::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TrafficEventsCategory* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.categories.trafficevents.TrafficEventsCategory";
  }
  protected:
  explicit TrafficEventsCategory(::google::protobuf::Arena* arena);
  TrafficEventsCategory(::google::protobuf::Arena* arena, const TrafficEventsCategory& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHazardFieldNumber = 2,
    kDangerousSlowDownFieldNumber = 3,
    kTrafficConditionFieldNumber = 4,
    kRoadworksFieldNumber = 5,
    kRoadWeatherConditionFieldNumber = 6,
    kRoadSurfaceConditionFieldNumber = 7,
    kRoadObstructionConditionFieldNumber = 8,
    kVulnerableRoadUserConditionFieldNumber = 9,
    kECallStatusFieldNumber = 10,
    kEnvelopeFieldNumber = 1,
  };
  // repeated .sensoris.protobuf.categories.trafficevents.Hazard hazard = 2;
  int hazard_size() const;
  private:
  int _internal_hazard_size() const;

  public:
  void clear_hazard() ;
  ::sensoris::protobuf::categories::trafficevents::Hazard* mutable_hazard(int index);
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficevents::Hazard >*
      mutable_hazard();
  private:
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::Hazard>& _internal_hazard() const;
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::Hazard>* _internal_mutable_hazard();
  public:
  const ::sensoris::protobuf::categories::trafficevents::Hazard& hazard(int index) const;
  ::sensoris::protobuf::categories::trafficevents::Hazard* add_hazard();
  const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficevents::Hazard >&
      hazard() const;
  // repeated .sensoris.protobuf.categories.trafficevents.DangerousSlowDown dangerous_slow_down = 3;
  int dangerous_slow_down_size() const;
  private:
  int _internal_dangerous_slow_down_size() const;

  public:
  void clear_dangerous_slow_down() ;
  ::sensoris::protobuf::categories::trafficevents::DangerousSlowDown* mutable_dangerous_slow_down(int index);
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficevents::DangerousSlowDown >*
      mutable_dangerous_slow_down();
  private:
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::DangerousSlowDown>& _internal_dangerous_slow_down() const;
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::DangerousSlowDown>* _internal_mutable_dangerous_slow_down();
  public:
  const ::sensoris::protobuf::categories::trafficevents::DangerousSlowDown& dangerous_slow_down(int index) const;
  ::sensoris::protobuf::categories::trafficevents::DangerousSlowDown* add_dangerous_slow_down();
  const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficevents::DangerousSlowDown >&
      dangerous_slow_down() const;
  // repeated .sensoris.protobuf.categories.trafficevents.TrafficCondition traffic_condition = 4;
  int traffic_condition_size() const;
  private:
  int _internal_traffic_condition_size() const;

  public:
  void clear_traffic_condition() ;
  ::sensoris::protobuf::categories::trafficevents::TrafficCondition* mutable_traffic_condition(int index);
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficevents::TrafficCondition >*
      mutable_traffic_condition();
  private:
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::TrafficCondition>& _internal_traffic_condition() const;
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::TrafficCondition>* _internal_mutable_traffic_condition();
  public:
  const ::sensoris::protobuf::categories::trafficevents::TrafficCondition& traffic_condition(int index) const;
  ::sensoris::protobuf::categories::trafficevents::TrafficCondition* add_traffic_condition();
  const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficevents::TrafficCondition >&
      traffic_condition() const;
  // repeated .sensoris.protobuf.categories.trafficevents.RoadWorks roadworks = 5;
  int roadworks_size() const;
  private:
  int _internal_roadworks_size() const;

  public:
  void clear_roadworks() ;
  ::sensoris::protobuf::categories::trafficevents::RoadWorks* mutable_roadworks(int index);
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficevents::RoadWorks >*
      mutable_roadworks();
  private:
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::RoadWorks>& _internal_roadworks() const;
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::RoadWorks>* _internal_mutable_roadworks();
  public:
  const ::sensoris::protobuf::categories::trafficevents::RoadWorks& roadworks(int index) const;
  ::sensoris::protobuf::categories::trafficevents::RoadWorks* add_roadworks();
  const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficevents::RoadWorks >&
      roadworks() const;
  // repeated .sensoris.protobuf.categories.trafficevents.RoadWeatherCondition road_weather_condition = 6;
  int road_weather_condition_size() const;
  private:
  int _internal_road_weather_condition_size() const;

  public:
  void clear_road_weather_condition() ;
  ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition* mutable_road_weather_condition(int index);
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition >*
      mutable_road_weather_condition();
  private:
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition>& _internal_road_weather_condition() const;
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition>* _internal_mutable_road_weather_condition();
  public:
  const ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition& road_weather_condition(int index) const;
  ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition* add_road_weather_condition();
  const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition >&
      road_weather_condition() const;
  // repeated .sensoris.protobuf.categories.trafficevents.RoadSurfaceCondition road_surface_condition = 7;
  int road_surface_condition_size() const;
  private:
  int _internal_road_surface_condition_size() const;

  public:
  void clear_road_surface_condition() ;
  ::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition* mutable_road_surface_condition(int index);
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition >*
      mutable_road_surface_condition();
  private:
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition>& _internal_road_surface_condition() const;
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition>* _internal_mutable_road_surface_condition();
  public:
  const ::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition& road_surface_condition(int index) const;
  ::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition* add_road_surface_condition();
  const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition >&
      road_surface_condition() const;
  // repeated .sensoris.protobuf.categories.trafficevents.RoadObstructionCondition road_obstruction_condition = 8;
  int road_obstruction_condition_size() const;
  private:
  int _internal_road_obstruction_condition_size() const;

  public:
  void clear_road_obstruction_condition() ;
  ::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition* mutable_road_obstruction_condition(int index);
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition >*
      mutable_road_obstruction_condition();
  private:
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition>& _internal_road_obstruction_condition() const;
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition>* _internal_mutable_road_obstruction_condition();
  public:
  const ::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition& road_obstruction_condition(int index) const;
  ::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition* add_road_obstruction_condition();
  const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition >&
      road_obstruction_condition() const;
  // repeated .sensoris.protobuf.categories.trafficevents.VulnerableRoadUserCondition vulnerable_road_user_condition = 9;
  int vulnerable_road_user_condition_size() const;
  private:
  int _internal_vulnerable_road_user_condition_size() const;

  public:
  void clear_vulnerable_road_user_condition() ;
  ::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition* mutable_vulnerable_road_user_condition(int index);
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition >*
      mutable_vulnerable_road_user_condition();
  private:
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition>& _internal_vulnerable_road_user_condition() const;
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition>* _internal_mutable_vulnerable_road_user_condition();
  public:
  const ::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition& vulnerable_road_user_condition(int index) const;
  ::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition* add_vulnerable_road_user_condition();
  const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition >&
      vulnerable_road_user_condition() const;
  // repeated .sensoris.protobuf.categories.trafficevents.ECallStatus e_call_status = 10;
  int e_call_status_size() const;
  private:
  int _internal_e_call_status_size() const;

  public:
  void clear_e_call_status() ;
  ::sensoris::protobuf::categories::trafficevents::ECallStatus* mutable_e_call_status(int index);
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficevents::ECallStatus >*
      mutable_e_call_status();
  private:
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::ECallStatus>& _internal_e_call_status() const;
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::ECallStatus>* _internal_mutable_e_call_status();
  public:
  const ::sensoris::protobuf::categories::trafficevents::ECallStatus& e_call_status(int index) const;
  ::sensoris::protobuf::categories::trafficevents::ECallStatus* add_e_call_status();
  const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficevents::ECallStatus >&
      e_call_status() const;
  // .sensoris.protobuf.types.base.CategoryEnvelope envelope = 1;
  bool has_envelope() const;
  void clear_envelope() ;
  const ::sensoris::protobuf::types::base::CategoryEnvelope& envelope() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::CategoryEnvelope* release_envelope();
  ::sensoris::protobuf::types::base::CategoryEnvelope* mutable_envelope();
  void set_allocated_envelope(::sensoris::protobuf::types::base::CategoryEnvelope* value);
  void unsafe_arena_set_allocated_envelope(::sensoris::protobuf::types::base::CategoryEnvelope* value);
  ::sensoris::protobuf::types::base::CategoryEnvelope* unsafe_arena_release_envelope();

  private:
  const ::sensoris::protobuf::types::base::CategoryEnvelope& _internal_envelope() const;
  ::sensoris::protobuf::types::base::CategoryEnvelope* _internal_mutable_envelope();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 10, 10,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficevents::Hazard > hazard_;
    ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficevents::DangerousSlowDown > dangerous_slow_down_;
    ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficevents::TrafficCondition > traffic_condition_;
    ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficevents::RoadWorks > roadworks_;
    ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition > road_weather_condition_;
    ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition > road_surface_condition_;
    ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition > road_obstruction_condition_;
    ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition > vulnerable_road_user_condition_;
    ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficevents::ECallStatus > e_call_status_;
    ::sensoris::protobuf::types::base::CategoryEnvelope* envelope_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Hazard_TypeAndConfidence

// .sensoris.protobuf.categories.trafficevents.Hazard.TypeAndConfidence.Type type = 1;
inline void Hazard_TypeAndConfidence::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
}
inline ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence_Type Hazard_TypeAndConfidence::type() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.Hazard.TypeAndConfidence.type)
  return _internal_type();
}
inline void Hazard_TypeAndConfidence::set_type(::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.trafficevents.Hazard.TypeAndConfidence.type)
}
inline ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence_Type Hazard_TypeAndConfidence::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence_Type>(_impl_.type_);
}
inline void Hazard_TypeAndConfidence::_internal_set_type(::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence_Type value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// .sensoris.protobuf.types.base.Confidence confidence = 2;
inline bool Hazard_TypeAndConfidence::has_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.confidence_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Confidence& Hazard_TypeAndConfidence::_internal_confidence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::Confidence* p = _impl_.confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Confidence&>(::sensoris::protobuf::types::base::_Confidence_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Confidence& Hazard_TypeAndConfidence::confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.Hazard.TypeAndConfidence.confidence)
  return _internal_confidence();
}
inline void Hazard_TypeAndConfidence::unsafe_arena_set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }
  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.Hazard.TypeAndConfidence.confidence)
}
inline ::sensoris::protobuf::types::base::Confidence* Hazard_TypeAndConfidence::release_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* released = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::Confidence* Hazard_TypeAndConfidence::unsafe_arena_release_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.Hazard.TypeAndConfidence.confidence)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* temp = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* Hazard_TypeAndConfidence::_internal_mutable_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.confidence_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Confidence>(GetArena());
    _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(p);
  }
  return _impl_.confidence_;
}
inline ::sensoris::protobuf::types::base::Confidence* Hazard_TypeAndConfidence::mutable_confidence() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::Confidence* _msg = _internal_mutable_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.Hazard.TypeAndConfidence.confidence)
  return _msg;
}
inline void Hazard_TypeAndConfidence::set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.Hazard.TypeAndConfidence.confidence)
}

// -------------------------------------------------------------------

// Hazard

// .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
inline bool Hazard::has_envelope() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.envelope_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& Hazard::_internal_envelope() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::EventEnvelope* p = _impl_.envelope_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::EventEnvelope&>(::sensoris::protobuf::types::base::_EventEnvelope_default_instance_);
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& Hazard::envelope() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.Hazard.envelope)
  return _internal_envelope();
}
inline void Hazard::unsafe_arena_set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }
  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.Hazard.envelope)
}
inline ::sensoris::protobuf::types::base::EventEnvelope* Hazard::release_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* released = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* Hazard::unsafe_arena_release_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.Hazard.envelope)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* temp = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* Hazard::_internal_mutable_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.envelope_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::EventEnvelope>(GetArena());
    _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(p);
  }
  return _impl_.envelope_;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* Hazard::mutable_envelope() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::EventEnvelope* _msg = _internal_mutable_envelope();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.Hazard.envelope)
  return _msg;
}
inline void Hazard::set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.Hazard.envelope)
}

// .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 2;
inline bool Hazard::has_detection_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.detection_status_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::EventDetectionStatus& Hazard::_internal_detection_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::EventDetectionStatus* p = _impl_.detection_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::EventDetectionStatus&>(::sensoris::protobuf::types::base::_EventDetectionStatus_default_instance_);
}
inline const ::sensoris::protobuf::types::base::EventDetectionStatus& Hazard::detection_status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.Hazard.detection_status)
  return _internal_detection_status();
}
inline void Hazard::unsafe_arena_set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.detection_status_);
  }
  _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.Hazard.detection_status)
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* Hazard::release_detection_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::EventDetectionStatus* released = _impl_.detection_status_;
  _impl_.detection_status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* Hazard::unsafe_arena_release_detection_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.Hazard.detection_status)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::EventDetectionStatus* temp = _impl_.detection_status_;
  _impl_.detection_status_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* Hazard::_internal_mutable_detection_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.detection_status_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::EventDetectionStatus>(GetArena());
    _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(p);
  }
  return _impl_.detection_status_;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* Hazard::mutable_detection_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::EventDetectionStatus* _msg = _internal_mutable_detection_status();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.Hazard.detection_status)
  return _msg;
}
inline void Hazard::set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.detection_status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.Hazard.detection_status)
}

// .sensoris.protobuf.categories.trafficevents.Hazard.TypeAndConfidence type_and_confidence = 3;
inline bool Hazard::has_type_and_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.type_and_confidence_ != nullptr);
  return value;
}
inline void Hazard::clear_type_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.type_and_confidence_ != nullptr) _impl_.type_and_confidence_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence& Hazard::_internal_type_and_confidence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence* p = _impl_.type_and_confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence&>(::sensoris::protobuf::categories::trafficevents::_Hazard_TypeAndConfidence_default_instance_);
}
inline const ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence& Hazard::type_and_confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.Hazard.type_and_confidence)
  return _internal_type_and_confidence();
}
inline void Hazard::unsafe_arena_set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.type_and_confidence_);
  }
  _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.Hazard.type_and_confidence)
}
inline ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence* Hazard::release_type_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence* released = _impl_.type_and_confidence_;
  _impl_.type_and_confidence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence* Hazard::unsafe_arena_release_type_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.Hazard.type_and_confidence)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence* temp = _impl_.type_and_confidence_;
  _impl_.type_and_confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence* Hazard::_internal_mutable_type_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.type_and_confidence_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence>(GetArena());
    _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence*>(p);
  }
  return _impl_.type_and_confidence_;
}
inline ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence* Hazard::mutable_type_and_confidence() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence* _msg = _internal_mutable_type_and_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.Hazard.type_and_confidence)
  return _msg;
}
inline void Hazard::set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence*>(_impl_.type_and_confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.Hazard.type_and_confidence)
}

// .sensoris.protobuf.categories.trafficevents.Hazard.Direction direction = 4;
inline void Hazard::clear_direction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.direction_ = 0;
}
inline ::sensoris::protobuf::categories::trafficevents::Hazard_Direction Hazard::direction() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.Hazard.direction)
  return _internal_direction();
}
inline void Hazard::set_direction(::sensoris::protobuf::categories::trafficevents::Hazard_Direction value) {
  _internal_set_direction(value);
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.trafficevents.Hazard.direction)
}
inline ::sensoris::protobuf::categories::trafficevents::Hazard_Direction Hazard::_internal_direction() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::sensoris::protobuf::categories::trafficevents::Hazard_Direction>(_impl_.direction_);
}
inline void Hazard::_internal_set_direction(::sensoris::protobuf::categories::trafficevents::Hazard_Direction value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.direction_ = value;
}

// -------------------------------------------------------------------

// DangerousSlowDown

// .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
inline bool DangerousSlowDown::has_envelope() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.envelope_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& DangerousSlowDown::_internal_envelope() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::EventEnvelope* p = _impl_.envelope_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::EventEnvelope&>(::sensoris::protobuf::types::base::_EventEnvelope_default_instance_);
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& DangerousSlowDown::envelope() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.DangerousSlowDown.envelope)
  return _internal_envelope();
}
inline void DangerousSlowDown::unsafe_arena_set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }
  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.DangerousSlowDown.envelope)
}
inline ::sensoris::protobuf::types::base::EventEnvelope* DangerousSlowDown::release_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* released = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* DangerousSlowDown::unsafe_arena_release_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.DangerousSlowDown.envelope)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* temp = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* DangerousSlowDown::_internal_mutable_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.envelope_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::EventEnvelope>(GetArena());
    _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(p);
  }
  return _impl_.envelope_;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* DangerousSlowDown::mutable_envelope() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::EventEnvelope* _msg = _internal_mutable_envelope();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.DangerousSlowDown.envelope)
  return _msg;
}
inline void DangerousSlowDown::set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.DangerousSlowDown.envelope)
}

// .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy speed_reduction_and_accuracy = 2 [(.sensoris.protobuf.types.base.exponent) = 1];
inline bool DangerousSlowDown::has_speed_reduction_and_accuracy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.speed_reduction_and_accuracy_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& DangerousSlowDown::_internal_speed_reduction_and_accuracy() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* p = _impl_.speed_reduction_and_accuracy_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy&>(::sensoris::protobuf::types::spatial::_XyzVectorAndAccuracy_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& DangerousSlowDown::speed_reduction_and_accuracy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.DangerousSlowDown.speed_reduction_and_accuracy)
  return _internal_speed_reduction_and_accuracy();
}
inline void DangerousSlowDown::unsafe_arena_set_allocated_speed_reduction_and_accuracy(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.speed_reduction_and_accuracy_);
  }
  _impl_.speed_reduction_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.DangerousSlowDown.speed_reduction_and_accuracy)
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* DangerousSlowDown::release_speed_reduction_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* released = _impl_.speed_reduction_and_accuracy_;
  _impl_.speed_reduction_and_accuracy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* DangerousSlowDown::unsafe_arena_release_speed_reduction_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.DangerousSlowDown.speed_reduction_and_accuracy)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* temp = _impl_.speed_reduction_and_accuracy_;
  _impl_.speed_reduction_and_accuracy_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* DangerousSlowDown::_internal_mutable_speed_reduction_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.speed_reduction_and_accuracy_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy>(GetArena());
    _impl_.speed_reduction_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy*>(p);
  }
  return _impl_.speed_reduction_and_accuracy_;
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* DangerousSlowDown::mutable_speed_reduction_and_accuracy() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* _msg = _internal_mutable_speed_reduction_and_accuracy();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.DangerousSlowDown.speed_reduction_and_accuracy)
  return _msg;
}
inline void DangerousSlowDown::set_allocated_speed_reduction_and_accuracy(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.speed_reduction_and_accuracy_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.speed_reduction_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.DangerousSlowDown.speed_reduction_and_accuracy)
}

// .google.protobuf.Int64Value time_period = 3 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool DangerousSlowDown::has_time_period() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.time_period_ != nullptr);
  return value;
}
inline const ::google::protobuf::Int64Value& DangerousSlowDown::_internal_time_period() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Int64Value* p = _impl_.time_period_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Int64Value&>(::google::protobuf::_Int64Value_default_instance_);
}
inline const ::google::protobuf::Int64Value& DangerousSlowDown::time_period() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.DangerousSlowDown.time_period)
  return _internal_time_period();
}
inline void DangerousSlowDown::unsafe_arena_set_allocated_time_period(::google::protobuf::Int64Value* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.time_period_);
  }
  _impl_.time_period_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.DangerousSlowDown.time_period)
}
inline ::google::protobuf::Int64Value* DangerousSlowDown::release_time_period() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Int64Value* released = _impl_.time_period_;
  _impl_.time_period_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Int64Value* DangerousSlowDown::unsafe_arena_release_time_period() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.DangerousSlowDown.time_period)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Int64Value* temp = _impl_.time_period_;
  _impl_.time_period_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int64Value* DangerousSlowDown::_internal_mutable_time_period() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.time_period_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int64Value>(GetArena());
    _impl_.time_period_ = reinterpret_cast<::google::protobuf::Int64Value*>(p);
  }
  return _impl_.time_period_;
}
inline ::google::protobuf::Int64Value* DangerousSlowDown::mutable_time_period() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Int64Value* _msg = _internal_mutable_time_period();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.DangerousSlowDown.time_period)
  return _msg;
}
inline void DangerousSlowDown::set_allocated_time_period(::google::protobuf::Int64Value* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.time_period_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.time_period_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.DangerousSlowDown.time_period)
}

// -------------------------------------------------------------------

// TrafficCondition_TypeAndConfidence

// .sensoris.protobuf.categories.trafficevents.TrafficCondition.TypeAndConfidence.Type type = 1;
inline void TrafficCondition_TypeAndConfidence::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
}
inline ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence_Type TrafficCondition_TypeAndConfidence::type() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.TrafficCondition.TypeAndConfidence.type)
  return _internal_type();
}
inline void TrafficCondition_TypeAndConfidence::set_type(::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.trafficevents.TrafficCondition.TypeAndConfidence.type)
}
inline ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence_Type TrafficCondition_TypeAndConfidence::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence_Type>(_impl_.type_);
}
inline void TrafficCondition_TypeAndConfidence::_internal_set_type(::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence_Type value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// .sensoris.protobuf.types.base.Confidence confidence = 2;
inline bool TrafficCondition_TypeAndConfidence::has_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.confidence_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Confidence& TrafficCondition_TypeAndConfidence::_internal_confidence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::Confidence* p = _impl_.confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Confidence&>(::sensoris::protobuf::types::base::_Confidence_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Confidence& TrafficCondition_TypeAndConfidence::confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.TrafficCondition.TypeAndConfidence.confidence)
  return _internal_confidence();
}
inline void TrafficCondition_TypeAndConfidence::unsafe_arena_set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }
  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.TrafficCondition.TypeAndConfidence.confidence)
}
inline ::sensoris::protobuf::types::base::Confidence* TrafficCondition_TypeAndConfidence::release_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* released = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::Confidence* TrafficCondition_TypeAndConfidence::unsafe_arena_release_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.TrafficCondition.TypeAndConfidence.confidence)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* temp = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* TrafficCondition_TypeAndConfidence::_internal_mutable_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.confidence_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Confidence>(GetArena());
    _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(p);
  }
  return _impl_.confidence_;
}
inline ::sensoris::protobuf::types::base::Confidence* TrafficCondition_TypeAndConfidence::mutable_confidence() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::Confidence* _msg = _internal_mutable_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.TrafficCondition.TypeAndConfidence.confidence)
  return _msg;
}
inline void TrafficCondition_TypeAndConfidence::set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.TrafficCondition.TypeAndConfidence.confidence)
}

// -------------------------------------------------------------------

// TrafficCondition

// .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
inline bool TrafficCondition::has_envelope() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.envelope_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& TrafficCondition::_internal_envelope() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::EventEnvelope* p = _impl_.envelope_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::EventEnvelope&>(::sensoris::protobuf::types::base::_EventEnvelope_default_instance_);
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& TrafficCondition::envelope() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.TrafficCondition.envelope)
  return _internal_envelope();
}
inline void TrafficCondition::unsafe_arena_set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }
  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.TrafficCondition.envelope)
}
inline ::sensoris::protobuf::types::base::EventEnvelope* TrafficCondition::release_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* released = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* TrafficCondition::unsafe_arena_release_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.TrafficCondition.envelope)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* temp = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* TrafficCondition::_internal_mutable_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.envelope_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::EventEnvelope>(GetArena());
    _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(p);
  }
  return _impl_.envelope_;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* TrafficCondition::mutable_envelope() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::EventEnvelope* _msg = _internal_mutable_envelope();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.TrafficCondition.envelope)
  return _msg;
}
inline void TrafficCondition::set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.TrafficCondition.envelope)
}

// .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 2;
inline bool TrafficCondition::has_detection_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.detection_status_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::EventDetectionStatus& TrafficCondition::_internal_detection_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::EventDetectionStatus* p = _impl_.detection_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::EventDetectionStatus&>(::sensoris::protobuf::types::base::_EventDetectionStatus_default_instance_);
}
inline const ::sensoris::protobuf::types::base::EventDetectionStatus& TrafficCondition::detection_status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.TrafficCondition.detection_status)
  return _internal_detection_status();
}
inline void TrafficCondition::unsafe_arena_set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.detection_status_);
  }
  _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.TrafficCondition.detection_status)
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* TrafficCondition::release_detection_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::EventDetectionStatus* released = _impl_.detection_status_;
  _impl_.detection_status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* TrafficCondition::unsafe_arena_release_detection_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.TrafficCondition.detection_status)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::EventDetectionStatus* temp = _impl_.detection_status_;
  _impl_.detection_status_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* TrafficCondition::_internal_mutable_detection_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.detection_status_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::EventDetectionStatus>(GetArena());
    _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(p);
  }
  return _impl_.detection_status_;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* TrafficCondition::mutable_detection_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::EventDetectionStatus* _msg = _internal_mutable_detection_status();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.TrafficCondition.detection_status)
  return _msg;
}
inline void TrafficCondition::set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.detection_status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.TrafficCondition.detection_status)
}

// .sensoris.protobuf.categories.trafficevents.TrafficCondition.TypeAndConfidence type_and_confidence = 3;
inline bool TrafficCondition::has_type_and_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.type_and_confidence_ != nullptr);
  return value;
}
inline void TrafficCondition::clear_type_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.type_and_confidence_ != nullptr) _impl_.type_and_confidence_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence& TrafficCondition::_internal_type_and_confidence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence* p = _impl_.type_and_confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence&>(::sensoris::protobuf::categories::trafficevents::_TrafficCondition_TypeAndConfidence_default_instance_);
}
inline const ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence& TrafficCondition::type_and_confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.TrafficCondition.type_and_confidence)
  return _internal_type_and_confidence();
}
inline void TrafficCondition::unsafe_arena_set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.type_and_confidence_);
  }
  _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.TrafficCondition.type_and_confidence)
}
inline ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence* TrafficCondition::release_type_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence* released = _impl_.type_and_confidence_;
  _impl_.type_and_confidence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence* TrafficCondition::unsafe_arena_release_type_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.TrafficCondition.type_and_confidence)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence* temp = _impl_.type_and_confidence_;
  _impl_.type_and_confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence* TrafficCondition::_internal_mutable_type_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.type_and_confidence_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence>(GetArena());
    _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence*>(p);
  }
  return _impl_.type_and_confidence_;
}
inline ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence* TrafficCondition::mutable_type_and_confidence() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence* _msg = _internal_mutable_type_and_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.TrafficCondition.type_and_confidence)
  return _msg;
}
inline void TrafficCondition::set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence*>(_impl_.type_and_confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.TrafficCondition.type_and_confidence)
}

// -------------------------------------------------------------------

// RoadWorks_TypeAndConfidence

// .sensoris.protobuf.categories.trafficevents.RoadWorks.TypeAndConfidence.Type type = 1;
inline void RoadWorks_TypeAndConfidence::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
}
inline ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence_Type RoadWorks_TypeAndConfidence::type() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.RoadWorks.TypeAndConfidence.type)
  return _internal_type();
}
inline void RoadWorks_TypeAndConfidence::set_type(::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.trafficevents.RoadWorks.TypeAndConfidence.type)
}
inline ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence_Type RoadWorks_TypeAndConfidence::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence_Type>(_impl_.type_);
}
inline void RoadWorks_TypeAndConfidence::_internal_set_type(::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence_Type value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// .sensoris.protobuf.types.base.Confidence confidence = 2;
inline bool RoadWorks_TypeAndConfidence::has_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.confidence_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Confidence& RoadWorks_TypeAndConfidence::_internal_confidence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::Confidence* p = _impl_.confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Confidence&>(::sensoris::protobuf::types::base::_Confidence_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Confidence& RoadWorks_TypeAndConfidence::confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.RoadWorks.TypeAndConfidence.confidence)
  return _internal_confidence();
}
inline void RoadWorks_TypeAndConfidence::unsafe_arena_set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }
  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.RoadWorks.TypeAndConfidence.confidence)
}
inline ::sensoris::protobuf::types::base::Confidence* RoadWorks_TypeAndConfidence::release_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* released = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::Confidence* RoadWorks_TypeAndConfidence::unsafe_arena_release_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.RoadWorks.TypeAndConfidence.confidence)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* temp = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* RoadWorks_TypeAndConfidence::_internal_mutable_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.confidence_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Confidence>(GetArena());
    _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(p);
  }
  return _impl_.confidence_;
}
inline ::sensoris::protobuf::types::base::Confidence* RoadWorks_TypeAndConfidence::mutable_confidence() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::Confidence* _msg = _internal_mutable_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.RoadWorks.TypeAndConfidence.confidence)
  return _msg;
}
inline void RoadWorks_TypeAndConfidence::set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.RoadWorks.TypeAndConfidence.confidence)
}

// -------------------------------------------------------------------

// RoadWorks

// .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
inline bool RoadWorks::has_envelope() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.envelope_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& RoadWorks::_internal_envelope() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::EventEnvelope* p = _impl_.envelope_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::EventEnvelope&>(::sensoris::protobuf::types::base::_EventEnvelope_default_instance_);
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& RoadWorks::envelope() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.RoadWorks.envelope)
  return _internal_envelope();
}
inline void RoadWorks::unsafe_arena_set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }
  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.RoadWorks.envelope)
}
inline ::sensoris::protobuf::types::base::EventEnvelope* RoadWorks::release_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* released = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* RoadWorks::unsafe_arena_release_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.RoadWorks.envelope)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* temp = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* RoadWorks::_internal_mutable_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.envelope_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::EventEnvelope>(GetArena());
    _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(p);
  }
  return _impl_.envelope_;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* RoadWorks::mutable_envelope() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::EventEnvelope* _msg = _internal_mutable_envelope();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.RoadWorks.envelope)
  return _msg;
}
inline void RoadWorks::set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.RoadWorks.envelope)
}

// .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 2;
inline bool RoadWorks::has_detection_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.detection_status_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::EventDetectionStatus& RoadWorks::_internal_detection_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::EventDetectionStatus* p = _impl_.detection_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::EventDetectionStatus&>(::sensoris::protobuf::types::base::_EventDetectionStatus_default_instance_);
}
inline const ::sensoris::protobuf::types::base::EventDetectionStatus& RoadWorks::detection_status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.RoadWorks.detection_status)
  return _internal_detection_status();
}
inline void RoadWorks::unsafe_arena_set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.detection_status_);
  }
  _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.RoadWorks.detection_status)
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* RoadWorks::release_detection_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::EventDetectionStatus* released = _impl_.detection_status_;
  _impl_.detection_status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* RoadWorks::unsafe_arena_release_detection_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.RoadWorks.detection_status)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::EventDetectionStatus* temp = _impl_.detection_status_;
  _impl_.detection_status_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* RoadWorks::_internal_mutable_detection_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.detection_status_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::EventDetectionStatus>(GetArena());
    _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(p);
  }
  return _impl_.detection_status_;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* RoadWorks::mutable_detection_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::EventDetectionStatus* _msg = _internal_mutable_detection_status();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.RoadWorks.detection_status)
  return _msg;
}
inline void RoadWorks::set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.detection_status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.RoadWorks.detection_status)
}

// .sensoris.protobuf.categories.trafficevents.RoadWorks.TypeAndConfidence type_and_confidence = 3;
inline bool RoadWorks::has_type_and_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.type_and_confidence_ != nullptr);
  return value;
}
inline void RoadWorks::clear_type_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.type_and_confidence_ != nullptr) _impl_.type_and_confidence_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence& RoadWorks::_internal_type_and_confidence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence* p = _impl_.type_and_confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence&>(::sensoris::protobuf::categories::trafficevents::_RoadWorks_TypeAndConfidence_default_instance_);
}
inline const ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence& RoadWorks::type_and_confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.RoadWorks.type_and_confidence)
  return _internal_type_and_confidence();
}
inline void RoadWorks::unsafe_arena_set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.type_and_confidence_);
  }
  _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.RoadWorks.type_and_confidence)
}
inline ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence* RoadWorks::release_type_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence* released = _impl_.type_and_confidence_;
  _impl_.type_and_confidence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence* RoadWorks::unsafe_arena_release_type_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.RoadWorks.type_and_confidence)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence* temp = _impl_.type_and_confidence_;
  _impl_.type_and_confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence* RoadWorks::_internal_mutable_type_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.type_and_confidence_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence>(GetArena());
    _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence*>(p);
  }
  return _impl_.type_and_confidence_;
}
inline ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence* RoadWorks::mutable_type_and_confidence() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence* _msg = _internal_mutable_type_and_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.RoadWorks.type_and_confidence)
  return _msg;
}
inline void RoadWorks::set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence*>(_impl_.type_and_confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.RoadWorks.type_and_confidence)
}

// .sensoris.protobuf.types.base.CountAndConfidence lanes_closed_and_confidence = 5;
inline bool RoadWorks::has_lanes_closed_and_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.lanes_closed_and_confidence_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::CountAndConfidence& RoadWorks::_internal_lanes_closed_and_confidence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::CountAndConfidence* p = _impl_.lanes_closed_and_confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::CountAndConfidence&>(::sensoris::protobuf::types::base::_CountAndConfidence_default_instance_);
}
inline const ::sensoris::protobuf::types::base::CountAndConfidence& RoadWorks::lanes_closed_and_confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.RoadWorks.lanes_closed_and_confidence)
  return _internal_lanes_closed_and_confidence();
}
inline void RoadWorks::unsafe_arena_set_allocated_lanes_closed_and_confidence(::sensoris::protobuf::types::base::CountAndConfidence* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.lanes_closed_and_confidence_);
  }
  _impl_.lanes_closed_and_confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::CountAndConfidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.RoadWorks.lanes_closed_and_confidence)
}
inline ::sensoris::protobuf::types::base::CountAndConfidence* RoadWorks::release_lanes_closed_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::sensoris::protobuf::types::base::CountAndConfidence* released = _impl_.lanes_closed_and_confidence_;
  _impl_.lanes_closed_and_confidence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::CountAndConfidence* RoadWorks::unsafe_arena_release_lanes_closed_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.RoadWorks.lanes_closed_and_confidence)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::sensoris::protobuf::types::base::CountAndConfidence* temp = _impl_.lanes_closed_and_confidence_;
  _impl_.lanes_closed_and_confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::CountAndConfidence* RoadWorks::_internal_mutable_lanes_closed_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.lanes_closed_and_confidence_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::CountAndConfidence>(GetArena());
    _impl_.lanes_closed_and_confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::CountAndConfidence*>(p);
  }
  return _impl_.lanes_closed_and_confidence_;
}
inline ::sensoris::protobuf::types::base::CountAndConfidence* RoadWorks::mutable_lanes_closed_and_confidence() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::CountAndConfidence* _msg = _internal_mutable_lanes_closed_and_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.RoadWorks.lanes_closed_and_confidence)
  return _msg;
}
inline void RoadWorks::set_allocated_lanes_closed_and_confidence(::sensoris::protobuf::types::base::CountAndConfidence* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.lanes_closed_and_confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.lanes_closed_and_confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::CountAndConfidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.RoadWorks.lanes_closed_and_confidence)
}

// -------------------------------------------------------------------

// RoadWeatherCondition_TypeAndConfidence

// .sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.TypeAndConfidence.Type type = 1;
inline void RoadWeatherCondition_TypeAndConfidence::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
}
inline ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence_Type RoadWeatherCondition_TypeAndConfidence::type() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.TypeAndConfidence.type)
  return _internal_type();
}
inline void RoadWeatherCondition_TypeAndConfidence::set_type(::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.TypeAndConfidence.type)
}
inline ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence_Type RoadWeatherCondition_TypeAndConfidence::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence_Type>(_impl_.type_);
}
inline void RoadWeatherCondition_TypeAndConfidence::_internal_set_type(::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence_Type value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// .sensoris.protobuf.types.base.Confidence confidence = 2;
inline bool RoadWeatherCondition_TypeAndConfidence::has_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.confidence_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Confidence& RoadWeatherCondition_TypeAndConfidence::_internal_confidence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::Confidence* p = _impl_.confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Confidence&>(::sensoris::protobuf::types::base::_Confidence_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Confidence& RoadWeatherCondition_TypeAndConfidence::confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.TypeAndConfidence.confidence)
  return _internal_confidence();
}
inline void RoadWeatherCondition_TypeAndConfidence::unsafe_arena_set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }
  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.TypeAndConfidence.confidence)
}
inline ::sensoris::protobuf::types::base::Confidence* RoadWeatherCondition_TypeAndConfidence::release_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* released = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::Confidence* RoadWeatherCondition_TypeAndConfidence::unsafe_arena_release_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.TypeAndConfidence.confidence)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* temp = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* RoadWeatherCondition_TypeAndConfidence::_internal_mutable_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.confidence_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Confidence>(GetArena());
    _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(p);
  }
  return _impl_.confidence_;
}
inline ::sensoris::protobuf::types::base::Confidence* RoadWeatherCondition_TypeAndConfidence::mutable_confidence() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::Confidence* _msg = _internal_mutable_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.TypeAndConfidence.confidence)
  return _msg;
}
inline void RoadWeatherCondition_TypeAndConfidence::set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.TypeAndConfidence.confidence)
}

// -------------------------------------------------------------------

// RoadWeatherCondition

// .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
inline bool RoadWeatherCondition::has_envelope() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.envelope_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& RoadWeatherCondition::_internal_envelope() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::EventEnvelope* p = _impl_.envelope_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::EventEnvelope&>(::sensoris::protobuf::types::base::_EventEnvelope_default_instance_);
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& RoadWeatherCondition::envelope() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.envelope)
  return _internal_envelope();
}
inline void RoadWeatherCondition::unsafe_arena_set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }
  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.envelope)
}
inline ::sensoris::protobuf::types::base::EventEnvelope* RoadWeatherCondition::release_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* released = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* RoadWeatherCondition::unsafe_arena_release_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.envelope)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* temp = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* RoadWeatherCondition::_internal_mutable_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.envelope_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::EventEnvelope>(GetArena());
    _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(p);
  }
  return _impl_.envelope_;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* RoadWeatherCondition::mutable_envelope() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::EventEnvelope* _msg = _internal_mutable_envelope();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.envelope)
  return _msg;
}
inline void RoadWeatherCondition::set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.envelope)
}

// .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 2;
inline bool RoadWeatherCondition::has_detection_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.detection_status_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::EventDetectionStatus& RoadWeatherCondition::_internal_detection_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::EventDetectionStatus* p = _impl_.detection_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::EventDetectionStatus&>(::sensoris::protobuf::types::base::_EventDetectionStatus_default_instance_);
}
inline const ::sensoris::protobuf::types::base::EventDetectionStatus& RoadWeatherCondition::detection_status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.detection_status)
  return _internal_detection_status();
}
inline void RoadWeatherCondition::unsafe_arena_set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.detection_status_);
  }
  _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.detection_status)
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* RoadWeatherCondition::release_detection_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::EventDetectionStatus* released = _impl_.detection_status_;
  _impl_.detection_status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* RoadWeatherCondition::unsafe_arena_release_detection_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.detection_status)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::EventDetectionStatus* temp = _impl_.detection_status_;
  _impl_.detection_status_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* RoadWeatherCondition::_internal_mutable_detection_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.detection_status_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::EventDetectionStatus>(GetArena());
    _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(p);
  }
  return _impl_.detection_status_;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* RoadWeatherCondition::mutable_detection_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::EventDetectionStatus* _msg = _internal_mutable_detection_status();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.detection_status)
  return _msg;
}
inline void RoadWeatherCondition::set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.detection_status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.detection_status)
}

// .sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.TypeAndConfidence type_and_confidence = 3;
inline bool RoadWeatherCondition::has_type_and_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.type_and_confidence_ != nullptr);
  return value;
}
inline void RoadWeatherCondition::clear_type_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.type_and_confidence_ != nullptr) _impl_.type_and_confidence_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence& RoadWeatherCondition::_internal_type_and_confidence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence* p = _impl_.type_and_confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence&>(::sensoris::protobuf::categories::trafficevents::_RoadWeatherCondition_TypeAndConfidence_default_instance_);
}
inline const ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence& RoadWeatherCondition::type_and_confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.type_and_confidence)
  return _internal_type_and_confidence();
}
inline void RoadWeatherCondition::unsafe_arena_set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.type_and_confidence_);
  }
  _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.type_and_confidence)
}
inline ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence* RoadWeatherCondition::release_type_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence* released = _impl_.type_and_confidence_;
  _impl_.type_and_confidence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence* RoadWeatherCondition::unsafe_arena_release_type_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.type_and_confidence)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence* temp = _impl_.type_and_confidence_;
  _impl_.type_and_confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence* RoadWeatherCondition::_internal_mutable_type_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.type_and_confidence_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence>(GetArena());
    _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence*>(p);
  }
  return _impl_.type_and_confidence_;
}
inline ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence* RoadWeatherCondition::mutable_type_and_confidence() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence* _msg = _internal_mutable_type_and_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.type_and_confidence)
  return _msg;
}
inline void RoadWeatherCondition::set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence*>(_impl_.type_and_confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.type_and_confidence)
}

// .sensoris.protobuf.types.base.Int64ValueAndAccuracy depth_and_accuracy = 4 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool RoadWeatherCondition::has_depth_and_accuracy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.depth_and_accuracy_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& RoadWeatherCondition::_internal_depth_and_accuracy() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* p = _impl_.depth_and_accuracy_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy&>(::sensoris::protobuf::types::base::_Int64ValueAndAccuracy_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& RoadWeatherCondition::depth_and_accuracy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.depth_and_accuracy)
  return _internal_depth_and_accuracy();
}
inline void RoadWeatherCondition::unsafe_arena_set_allocated_depth_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.depth_and_accuracy_);
  }
  _impl_.depth_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.depth_and_accuracy)
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* RoadWeatherCondition::release_depth_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* released = _impl_.depth_and_accuracy_;
  _impl_.depth_and_accuracy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* RoadWeatherCondition::unsafe_arena_release_depth_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.depth_and_accuracy)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* temp = _impl_.depth_and_accuracy_;
  _impl_.depth_and_accuracy_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* RoadWeatherCondition::_internal_mutable_depth_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.depth_and_accuracy_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64ValueAndAccuracy>(GetArena());
    _impl_.depth_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(p);
  }
  return _impl_.depth_and_accuracy_;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* RoadWeatherCondition::mutable_depth_and_accuracy() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* _msg = _internal_mutable_depth_and_accuracy();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.depth_and_accuracy)
  return _msg;
}
inline void RoadWeatherCondition::set_allocated_depth_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.depth_and_accuracy_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.depth_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.depth_and_accuracy)
}

// -------------------------------------------------------------------

// RoadSurfaceCondition_TypeAndConfidence

// .sensoris.protobuf.categories.trafficevents.RoadSurfaceCondition.TypeAndConfidence.Type type = 1;
inline void RoadSurfaceCondition_TypeAndConfidence::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
}
inline ::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence_Type RoadSurfaceCondition_TypeAndConfidence::type() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.RoadSurfaceCondition.TypeAndConfidence.type)
  return _internal_type();
}
inline void RoadSurfaceCondition_TypeAndConfidence::set_type(::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.trafficevents.RoadSurfaceCondition.TypeAndConfidence.type)
}
inline ::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence_Type RoadSurfaceCondition_TypeAndConfidence::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence_Type>(_impl_.type_);
}
inline void RoadSurfaceCondition_TypeAndConfidence::_internal_set_type(::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence_Type value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// .sensoris.protobuf.types.base.Confidence confidence = 2;
inline bool RoadSurfaceCondition_TypeAndConfidence::has_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.confidence_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Confidence& RoadSurfaceCondition_TypeAndConfidence::_internal_confidence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::Confidence* p = _impl_.confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Confidence&>(::sensoris::protobuf::types::base::_Confidence_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Confidence& RoadSurfaceCondition_TypeAndConfidence::confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.RoadSurfaceCondition.TypeAndConfidence.confidence)
  return _internal_confidence();
}
inline void RoadSurfaceCondition_TypeAndConfidence::unsafe_arena_set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }
  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.RoadSurfaceCondition.TypeAndConfidence.confidence)
}
inline ::sensoris::protobuf::types::base::Confidence* RoadSurfaceCondition_TypeAndConfidence::release_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* released = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::Confidence* RoadSurfaceCondition_TypeAndConfidence::unsafe_arena_release_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.RoadSurfaceCondition.TypeAndConfidence.confidence)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* temp = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* RoadSurfaceCondition_TypeAndConfidence::_internal_mutable_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.confidence_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Confidence>(GetArena());
    _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(p);
  }
  return _impl_.confidence_;
}
inline ::sensoris::protobuf::types::base::Confidence* RoadSurfaceCondition_TypeAndConfidence::mutable_confidence() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::Confidence* _msg = _internal_mutable_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.RoadSurfaceCondition.TypeAndConfidence.confidence)
  return _msg;
}
inline void RoadSurfaceCondition_TypeAndConfidence::set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.RoadSurfaceCondition.TypeAndConfidence.confidence)
}

// -------------------------------------------------------------------

// RoadSurfaceCondition

// .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
inline bool RoadSurfaceCondition::has_envelope() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.envelope_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& RoadSurfaceCondition::_internal_envelope() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::EventEnvelope* p = _impl_.envelope_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::EventEnvelope&>(::sensoris::protobuf::types::base::_EventEnvelope_default_instance_);
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& RoadSurfaceCondition::envelope() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.RoadSurfaceCondition.envelope)
  return _internal_envelope();
}
inline void RoadSurfaceCondition::unsafe_arena_set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }
  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.RoadSurfaceCondition.envelope)
}
inline ::sensoris::protobuf::types::base::EventEnvelope* RoadSurfaceCondition::release_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* released = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* RoadSurfaceCondition::unsafe_arena_release_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.RoadSurfaceCondition.envelope)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* temp = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* RoadSurfaceCondition::_internal_mutable_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.envelope_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::EventEnvelope>(GetArena());
    _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(p);
  }
  return _impl_.envelope_;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* RoadSurfaceCondition::mutable_envelope() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::EventEnvelope* _msg = _internal_mutable_envelope();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.RoadSurfaceCondition.envelope)
  return _msg;
}
inline void RoadSurfaceCondition::set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.RoadSurfaceCondition.envelope)
}

// .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 2;
inline bool RoadSurfaceCondition::has_detection_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.detection_status_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::EventDetectionStatus& RoadSurfaceCondition::_internal_detection_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::EventDetectionStatus* p = _impl_.detection_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::EventDetectionStatus&>(::sensoris::protobuf::types::base::_EventDetectionStatus_default_instance_);
}
inline const ::sensoris::protobuf::types::base::EventDetectionStatus& RoadSurfaceCondition::detection_status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.RoadSurfaceCondition.detection_status)
  return _internal_detection_status();
}
inline void RoadSurfaceCondition::unsafe_arena_set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.detection_status_);
  }
  _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.RoadSurfaceCondition.detection_status)
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* RoadSurfaceCondition::release_detection_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::EventDetectionStatus* released = _impl_.detection_status_;
  _impl_.detection_status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* RoadSurfaceCondition::unsafe_arena_release_detection_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.RoadSurfaceCondition.detection_status)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::EventDetectionStatus* temp = _impl_.detection_status_;
  _impl_.detection_status_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* RoadSurfaceCondition::_internal_mutable_detection_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.detection_status_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::EventDetectionStatus>(GetArena());
    _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(p);
  }
  return _impl_.detection_status_;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* RoadSurfaceCondition::mutable_detection_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::EventDetectionStatus* _msg = _internal_mutable_detection_status();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.RoadSurfaceCondition.detection_status)
  return _msg;
}
inline void RoadSurfaceCondition::set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.detection_status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.RoadSurfaceCondition.detection_status)
}

// .sensoris.protobuf.categories.trafficevents.RoadSurfaceCondition.TypeAndConfidence type_and_confidence = 3;
inline bool RoadSurfaceCondition::has_type_and_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.type_and_confidence_ != nullptr);
  return value;
}
inline void RoadSurfaceCondition::clear_type_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.type_and_confidence_ != nullptr) _impl_.type_and_confidence_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence& RoadSurfaceCondition::_internal_type_and_confidence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence* p = _impl_.type_and_confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence&>(::sensoris::protobuf::categories::trafficevents::_RoadSurfaceCondition_TypeAndConfidence_default_instance_);
}
inline const ::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence& RoadSurfaceCondition::type_and_confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.RoadSurfaceCondition.type_and_confidence)
  return _internal_type_and_confidence();
}
inline void RoadSurfaceCondition::unsafe_arena_set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.type_and_confidence_);
  }
  _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.RoadSurfaceCondition.type_and_confidence)
}
inline ::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence* RoadSurfaceCondition::release_type_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence* released = _impl_.type_and_confidence_;
  _impl_.type_and_confidence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence* RoadSurfaceCondition::unsafe_arena_release_type_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.RoadSurfaceCondition.type_and_confidence)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence* temp = _impl_.type_and_confidence_;
  _impl_.type_and_confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence* RoadSurfaceCondition::_internal_mutable_type_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.type_and_confidence_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence>(GetArena());
    _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence*>(p);
  }
  return _impl_.type_and_confidence_;
}
inline ::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence* RoadSurfaceCondition::mutable_type_and_confidence() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence* _msg = _internal_mutable_type_and_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.RoadSurfaceCondition.type_and_confidence)
  return _msg;
}
inline void RoadSurfaceCondition::set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence*>(_impl_.type_and_confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.RoadSurfaceCondition.type_and_confidence)
}

// -------------------------------------------------------------------

// RoadObstructionCondition_TypeAndConfidence

// .sensoris.protobuf.categories.trafficevents.RoadObstructionCondition.TypeAndConfidence.Type type = 1;
inline void RoadObstructionCondition_TypeAndConfidence::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
}
inline ::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence_Type RoadObstructionCondition_TypeAndConfidence::type() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.RoadObstructionCondition.TypeAndConfidence.type)
  return _internal_type();
}
inline void RoadObstructionCondition_TypeAndConfidence::set_type(::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.trafficevents.RoadObstructionCondition.TypeAndConfidence.type)
}
inline ::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence_Type RoadObstructionCondition_TypeAndConfidence::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence_Type>(_impl_.type_);
}
inline void RoadObstructionCondition_TypeAndConfidence::_internal_set_type(::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence_Type value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// .sensoris.protobuf.types.base.Confidence confidence = 2;
inline bool RoadObstructionCondition_TypeAndConfidence::has_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.confidence_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Confidence& RoadObstructionCondition_TypeAndConfidence::_internal_confidence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::Confidence* p = _impl_.confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Confidence&>(::sensoris::protobuf::types::base::_Confidence_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Confidence& RoadObstructionCondition_TypeAndConfidence::confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.RoadObstructionCondition.TypeAndConfidence.confidence)
  return _internal_confidence();
}
inline void RoadObstructionCondition_TypeAndConfidence::unsafe_arena_set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }
  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.RoadObstructionCondition.TypeAndConfidence.confidence)
}
inline ::sensoris::protobuf::types::base::Confidence* RoadObstructionCondition_TypeAndConfidence::release_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* released = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::Confidence* RoadObstructionCondition_TypeAndConfidence::unsafe_arena_release_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.RoadObstructionCondition.TypeAndConfidence.confidence)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* temp = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* RoadObstructionCondition_TypeAndConfidence::_internal_mutable_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.confidence_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Confidence>(GetArena());
    _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(p);
  }
  return _impl_.confidence_;
}
inline ::sensoris::protobuf::types::base::Confidence* RoadObstructionCondition_TypeAndConfidence::mutable_confidence() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::Confidence* _msg = _internal_mutable_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.RoadObstructionCondition.TypeAndConfidence.confidence)
  return _msg;
}
inline void RoadObstructionCondition_TypeAndConfidence::set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.RoadObstructionCondition.TypeAndConfidence.confidence)
}

// -------------------------------------------------------------------

// RoadObstructionCondition

// .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
inline bool RoadObstructionCondition::has_envelope() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.envelope_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& RoadObstructionCondition::_internal_envelope() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::EventEnvelope* p = _impl_.envelope_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::EventEnvelope&>(::sensoris::protobuf::types::base::_EventEnvelope_default_instance_);
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& RoadObstructionCondition::envelope() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.RoadObstructionCondition.envelope)
  return _internal_envelope();
}
inline void RoadObstructionCondition::unsafe_arena_set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }
  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.RoadObstructionCondition.envelope)
}
inline ::sensoris::protobuf::types::base::EventEnvelope* RoadObstructionCondition::release_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* released = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* RoadObstructionCondition::unsafe_arena_release_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.RoadObstructionCondition.envelope)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* temp = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* RoadObstructionCondition::_internal_mutable_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.envelope_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::EventEnvelope>(GetArena());
    _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(p);
  }
  return _impl_.envelope_;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* RoadObstructionCondition::mutable_envelope() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::EventEnvelope* _msg = _internal_mutable_envelope();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.RoadObstructionCondition.envelope)
  return _msg;
}
inline void RoadObstructionCondition::set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.RoadObstructionCondition.envelope)
}

// .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 2;
inline bool RoadObstructionCondition::has_detection_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.detection_status_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::EventDetectionStatus& RoadObstructionCondition::_internal_detection_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::EventDetectionStatus* p = _impl_.detection_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::EventDetectionStatus&>(::sensoris::protobuf::types::base::_EventDetectionStatus_default_instance_);
}
inline const ::sensoris::protobuf::types::base::EventDetectionStatus& RoadObstructionCondition::detection_status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.RoadObstructionCondition.detection_status)
  return _internal_detection_status();
}
inline void RoadObstructionCondition::unsafe_arena_set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.detection_status_);
  }
  _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.RoadObstructionCondition.detection_status)
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* RoadObstructionCondition::release_detection_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::EventDetectionStatus* released = _impl_.detection_status_;
  _impl_.detection_status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* RoadObstructionCondition::unsafe_arena_release_detection_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.RoadObstructionCondition.detection_status)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::EventDetectionStatus* temp = _impl_.detection_status_;
  _impl_.detection_status_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* RoadObstructionCondition::_internal_mutable_detection_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.detection_status_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::EventDetectionStatus>(GetArena());
    _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(p);
  }
  return _impl_.detection_status_;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* RoadObstructionCondition::mutable_detection_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::EventDetectionStatus* _msg = _internal_mutable_detection_status();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.RoadObstructionCondition.detection_status)
  return _msg;
}
inline void RoadObstructionCondition::set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.detection_status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.RoadObstructionCondition.detection_status)
}

// .sensoris.protobuf.categories.trafficevents.RoadObstructionCondition.TypeAndConfidence type_and_confidence = 3;
inline bool RoadObstructionCondition::has_type_and_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.type_and_confidence_ != nullptr);
  return value;
}
inline void RoadObstructionCondition::clear_type_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.type_and_confidence_ != nullptr) _impl_.type_and_confidence_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence& RoadObstructionCondition::_internal_type_and_confidence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence* p = _impl_.type_and_confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence&>(::sensoris::protobuf::categories::trafficevents::_RoadObstructionCondition_TypeAndConfidence_default_instance_);
}
inline const ::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence& RoadObstructionCondition::type_and_confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.RoadObstructionCondition.type_and_confidence)
  return _internal_type_and_confidence();
}
inline void RoadObstructionCondition::unsafe_arena_set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.type_and_confidence_);
  }
  _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.RoadObstructionCondition.type_and_confidence)
}
inline ::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence* RoadObstructionCondition::release_type_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence* released = _impl_.type_and_confidence_;
  _impl_.type_and_confidence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence* RoadObstructionCondition::unsafe_arena_release_type_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.RoadObstructionCondition.type_and_confidence)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence* temp = _impl_.type_and_confidence_;
  _impl_.type_and_confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence* RoadObstructionCondition::_internal_mutable_type_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.type_and_confidence_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence>(GetArena());
    _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence*>(p);
  }
  return _impl_.type_and_confidence_;
}
inline ::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence* RoadObstructionCondition::mutable_type_and_confidence() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence* _msg = _internal_mutable_type_and_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.RoadObstructionCondition.type_and_confidence)
  return _msg;
}
inline void RoadObstructionCondition::set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence*>(_impl_.type_and_confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.RoadObstructionCondition.type_and_confidence)
}

// -------------------------------------------------------------------

// VulnerableRoadUserCondition_TypeAndConfidence

// .sensoris.protobuf.categories.trafficevents.VulnerableRoadUserCondition.TypeAndConfidence.Type type = 1;
inline void VulnerableRoadUserCondition_TypeAndConfidence::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
}
inline ::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence_Type VulnerableRoadUserCondition_TypeAndConfidence::type() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.VulnerableRoadUserCondition.TypeAndConfidence.type)
  return _internal_type();
}
inline void VulnerableRoadUserCondition_TypeAndConfidence::set_type(::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.trafficevents.VulnerableRoadUserCondition.TypeAndConfidence.type)
}
inline ::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence_Type VulnerableRoadUserCondition_TypeAndConfidence::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence_Type>(_impl_.type_);
}
inline void VulnerableRoadUserCondition_TypeAndConfidence::_internal_set_type(::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence_Type value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// .sensoris.protobuf.types.base.Confidence confidence = 2;
inline bool VulnerableRoadUserCondition_TypeAndConfidence::has_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.confidence_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Confidence& VulnerableRoadUserCondition_TypeAndConfidence::_internal_confidence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::Confidence* p = _impl_.confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Confidence&>(::sensoris::protobuf::types::base::_Confidence_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Confidence& VulnerableRoadUserCondition_TypeAndConfidence::confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.VulnerableRoadUserCondition.TypeAndConfidence.confidence)
  return _internal_confidence();
}
inline void VulnerableRoadUserCondition_TypeAndConfidence::unsafe_arena_set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }
  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.VulnerableRoadUserCondition.TypeAndConfidence.confidence)
}
inline ::sensoris::protobuf::types::base::Confidence* VulnerableRoadUserCondition_TypeAndConfidence::release_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* released = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::Confidence* VulnerableRoadUserCondition_TypeAndConfidence::unsafe_arena_release_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.VulnerableRoadUserCondition.TypeAndConfidence.confidence)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* temp = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* VulnerableRoadUserCondition_TypeAndConfidence::_internal_mutable_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.confidence_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Confidence>(GetArena());
    _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(p);
  }
  return _impl_.confidence_;
}
inline ::sensoris::protobuf::types::base::Confidence* VulnerableRoadUserCondition_TypeAndConfidence::mutable_confidence() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::Confidence* _msg = _internal_mutable_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.VulnerableRoadUserCondition.TypeAndConfidence.confidence)
  return _msg;
}
inline void VulnerableRoadUserCondition_TypeAndConfidence::set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.VulnerableRoadUserCondition.TypeAndConfidence.confidence)
}

// -------------------------------------------------------------------

// VulnerableRoadUserCondition

// .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
inline bool VulnerableRoadUserCondition::has_envelope() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.envelope_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& VulnerableRoadUserCondition::_internal_envelope() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::EventEnvelope* p = _impl_.envelope_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::EventEnvelope&>(::sensoris::protobuf::types::base::_EventEnvelope_default_instance_);
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& VulnerableRoadUserCondition::envelope() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.VulnerableRoadUserCondition.envelope)
  return _internal_envelope();
}
inline void VulnerableRoadUserCondition::unsafe_arena_set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }
  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.VulnerableRoadUserCondition.envelope)
}
inline ::sensoris::protobuf::types::base::EventEnvelope* VulnerableRoadUserCondition::release_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* released = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* VulnerableRoadUserCondition::unsafe_arena_release_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.VulnerableRoadUserCondition.envelope)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* temp = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* VulnerableRoadUserCondition::_internal_mutable_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.envelope_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::EventEnvelope>(GetArena());
    _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(p);
  }
  return _impl_.envelope_;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* VulnerableRoadUserCondition::mutable_envelope() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::EventEnvelope* _msg = _internal_mutable_envelope();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.VulnerableRoadUserCondition.envelope)
  return _msg;
}
inline void VulnerableRoadUserCondition::set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.VulnerableRoadUserCondition.envelope)
}

// .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 2;
inline bool VulnerableRoadUserCondition::has_detection_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.detection_status_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::EventDetectionStatus& VulnerableRoadUserCondition::_internal_detection_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::EventDetectionStatus* p = _impl_.detection_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::EventDetectionStatus&>(::sensoris::protobuf::types::base::_EventDetectionStatus_default_instance_);
}
inline const ::sensoris::protobuf::types::base::EventDetectionStatus& VulnerableRoadUserCondition::detection_status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.VulnerableRoadUserCondition.detection_status)
  return _internal_detection_status();
}
inline void VulnerableRoadUserCondition::unsafe_arena_set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.detection_status_);
  }
  _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.VulnerableRoadUserCondition.detection_status)
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* VulnerableRoadUserCondition::release_detection_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::EventDetectionStatus* released = _impl_.detection_status_;
  _impl_.detection_status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* VulnerableRoadUserCondition::unsafe_arena_release_detection_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.VulnerableRoadUserCondition.detection_status)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::EventDetectionStatus* temp = _impl_.detection_status_;
  _impl_.detection_status_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* VulnerableRoadUserCondition::_internal_mutable_detection_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.detection_status_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::EventDetectionStatus>(GetArena());
    _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(p);
  }
  return _impl_.detection_status_;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* VulnerableRoadUserCondition::mutable_detection_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::EventDetectionStatus* _msg = _internal_mutable_detection_status();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.VulnerableRoadUserCondition.detection_status)
  return _msg;
}
inline void VulnerableRoadUserCondition::set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.detection_status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.VulnerableRoadUserCondition.detection_status)
}

// .sensoris.protobuf.categories.trafficevents.VulnerableRoadUserCondition.TypeAndConfidence type_and_confidence = 3;
inline bool VulnerableRoadUserCondition::has_type_and_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.type_and_confidence_ != nullptr);
  return value;
}
inline void VulnerableRoadUserCondition::clear_type_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.type_and_confidence_ != nullptr) _impl_.type_and_confidence_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence& VulnerableRoadUserCondition::_internal_type_and_confidence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence* p = _impl_.type_and_confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence&>(::sensoris::protobuf::categories::trafficevents::_VulnerableRoadUserCondition_TypeAndConfidence_default_instance_);
}
inline const ::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence& VulnerableRoadUserCondition::type_and_confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.VulnerableRoadUserCondition.type_and_confidence)
  return _internal_type_and_confidence();
}
inline void VulnerableRoadUserCondition::unsafe_arena_set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.type_and_confidence_);
  }
  _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.VulnerableRoadUserCondition.type_and_confidence)
}
inline ::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence* VulnerableRoadUserCondition::release_type_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence* released = _impl_.type_and_confidence_;
  _impl_.type_and_confidence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence* VulnerableRoadUserCondition::unsafe_arena_release_type_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.VulnerableRoadUserCondition.type_and_confidence)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence* temp = _impl_.type_and_confidence_;
  _impl_.type_and_confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence* VulnerableRoadUserCondition::_internal_mutable_type_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.type_and_confidence_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence>(GetArena());
    _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence*>(p);
  }
  return _impl_.type_and_confidence_;
}
inline ::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence* VulnerableRoadUserCondition::mutable_type_and_confidence() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence* _msg = _internal_mutable_type_and_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.VulnerableRoadUserCondition.type_and_confidence)
  return _msg;
}
inline void VulnerableRoadUserCondition::set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence*>(_impl_.type_and_confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.VulnerableRoadUserCondition.type_and_confidence)
}

// -------------------------------------------------------------------

// ECallStatus

// .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
inline bool ECallStatus::has_envelope() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.envelope_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& ECallStatus::_internal_envelope() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::EventEnvelope* p = _impl_.envelope_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::EventEnvelope&>(::sensoris::protobuf::types::base::_EventEnvelope_default_instance_);
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& ECallStatus::envelope() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.ECallStatus.envelope)
  return _internal_envelope();
}
inline void ECallStatus::unsafe_arena_set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }
  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.ECallStatus.envelope)
}
inline ::sensoris::protobuf::types::base::EventEnvelope* ECallStatus::release_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* released = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* ECallStatus::unsafe_arena_release_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.ECallStatus.envelope)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* temp = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* ECallStatus::_internal_mutable_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.envelope_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::EventEnvelope>(GetArena());
    _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(p);
  }
  return _impl_.envelope_;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* ECallStatus::mutable_envelope() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::EventEnvelope* _msg = _internal_mutable_envelope();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.ECallStatus.envelope)
  return _msg;
}
inline void ECallStatus::set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.ECallStatus.envelope)
}

// .sensoris.protobuf.categories.trafficevents.ECallStatus.ActivationType activation_type = 2;
inline void ECallStatus::clear_activation_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.activation_type_ = 0;
}
inline ::sensoris::protobuf::categories::trafficevents::ECallStatus_ActivationType ECallStatus::activation_type() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.ECallStatus.activation_type)
  return _internal_activation_type();
}
inline void ECallStatus::set_activation_type(::sensoris::protobuf::categories::trafficevents::ECallStatus_ActivationType value) {
  _internal_set_activation_type(value);
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.trafficevents.ECallStatus.activation_type)
}
inline ::sensoris::protobuf::categories::trafficevents::ECallStatus_ActivationType ECallStatus::_internal_activation_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::sensoris::protobuf::categories::trafficevents::ECallStatus_ActivationType>(_impl_.activation_type_);
}
inline void ECallStatus::_internal_set_activation_type(::sensoris::protobuf::categories::trafficevents::ECallStatus_ActivationType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.activation_type_ = value;
}

// .sensoris.protobuf.categories.trafficevents.ECallStatus.Availability availability = 3;
inline void ECallStatus::clear_availability() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.availability_ = 0;
}
inline ::sensoris::protobuf::categories::trafficevents::ECallStatus_Availability ECallStatus::availability() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.ECallStatus.availability)
  return _internal_availability();
}
inline void ECallStatus::set_availability(::sensoris::protobuf::categories::trafficevents::ECallStatus_Availability value) {
  _internal_set_availability(value);
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.trafficevents.ECallStatus.availability)
}
inline ::sensoris::protobuf::categories::trafficevents::ECallStatus_Availability ECallStatus::_internal_availability() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::sensoris::protobuf::categories::trafficevents::ECallStatus_Availability>(_impl_.availability_);
}
inline void ECallStatus::_internal_set_availability(::sensoris::protobuf::categories::trafficevents::ECallStatus_Availability value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.availability_ = value;
}

// -------------------------------------------------------------------

// TrafficEventsCategory

// .sensoris.protobuf.types.base.CategoryEnvelope envelope = 1;
inline bool TrafficEventsCategory::has_envelope() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.envelope_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::CategoryEnvelope& TrafficEventsCategory::_internal_envelope() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::CategoryEnvelope* p = _impl_.envelope_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::CategoryEnvelope&>(::sensoris::protobuf::types::base::_CategoryEnvelope_default_instance_);
}
inline const ::sensoris::protobuf::types::base::CategoryEnvelope& TrafficEventsCategory::envelope() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.envelope)
  return _internal_envelope();
}
inline void TrafficEventsCategory::unsafe_arena_set_allocated_envelope(::sensoris::protobuf::types::base::CategoryEnvelope* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }
  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::CategoryEnvelope*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.envelope)
}
inline ::sensoris::protobuf::types::base::CategoryEnvelope* TrafficEventsCategory::release_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::CategoryEnvelope* released = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::CategoryEnvelope* TrafficEventsCategory::unsafe_arena_release_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.envelope)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::CategoryEnvelope* temp = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::CategoryEnvelope* TrafficEventsCategory::_internal_mutable_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.envelope_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::CategoryEnvelope>(GetArena());
    _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::CategoryEnvelope*>(p);
  }
  return _impl_.envelope_;
}
inline ::sensoris::protobuf::types::base::CategoryEnvelope* TrafficEventsCategory::mutable_envelope() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::CategoryEnvelope* _msg = _internal_mutable_envelope();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.envelope)
  return _msg;
}
inline void TrafficEventsCategory::set_allocated_envelope(::sensoris::protobuf::types::base::CategoryEnvelope* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::CategoryEnvelope*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.envelope)
}

// repeated .sensoris.protobuf.categories.trafficevents.Hazard hazard = 2;
inline int TrafficEventsCategory::_internal_hazard_size() const {
  return _internal_hazard().size();
}
inline int TrafficEventsCategory::hazard_size() const {
  return _internal_hazard_size();
}
inline void TrafficEventsCategory::clear_hazard() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.hazard_.Clear();
}
inline ::sensoris::protobuf::categories::trafficevents::Hazard* TrafficEventsCategory::mutable_hazard(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.hazard)
  return _internal_mutable_hazard()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::Hazard>* TrafficEventsCategory::mutable_hazard()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.hazard)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_hazard();
}
inline const ::sensoris::protobuf::categories::trafficevents::Hazard& TrafficEventsCategory::hazard(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.hazard)
  return _internal_hazard().Get(index);
}
inline ::sensoris::protobuf::categories::trafficevents::Hazard* TrafficEventsCategory::add_hazard() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::sensoris::protobuf::categories::trafficevents::Hazard* _add = _internal_mutable_hazard()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.hazard)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::Hazard>& TrafficEventsCategory::hazard() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.hazard)
  return _internal_hazard();
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::Hazard>&
TrafficEventsCategory::_internal_hazard() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.hazard_;
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::Hazard>*
TrafficEventsCategory::_internal_mutable_hazard() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.hazard_;
}

// repeated .sensoris.protobuf.categories.trafficevents.DangerousSlowDown dangerous_slow_down = 3;
inline int TrafficEventsCategory::_internal_dangerous_slow_down_size() const {
  return _internal_dangerous_slow_down().size();
}
inline int TrafficEventsCategory::dangerous_slow_down_size() const {
  return _internal_dangerous_slow_down_size();
}
inline void TrafficEventsCategory::clear_dangerous_slow_down() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dangerous_slow_down_.Clear();
}
inline ::sensoris::protobuf::categories::trafficevents::DangerousSlowDown* TrafficEventsCategory::mutable_dangerous_slow_down(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.dangerous_slow_down)
  return _internal_mutable_dangerous_slow_down()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::DangerousSlowDown>* TrafficEventsCategory::mutable_dangerous_slow_down()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.dangerous_slow_down)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_dangerous_slow_down();
}
inline const ::sensoris::protobuf::categories::trafficevents::DangerousSlowDown& TrafficEventsCategory::dangerous_slow_down(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.dangerous_slow_down)
  return _internal_dangerous_slow_down().Get(index);
}
inline ::sensoris::protobuf::categories::trafficevents::DangerousSlowDown* TrafficEventsCategory::add_dangerous_slow_down() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::sensoris::protobuf::categories::trafficevents::DangerousSlowDown* _add = _internal_mutable_dangerous_slow_down()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.dangerous_slow_down)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::DangerousSlowDown>& TrafficEventsCategory::dangerous_slow_down() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.dangerous_slow_down)
  return _internal_dangerous_slow_down();
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::DangerousSlowDown>&
TrafficEventsCategory::_internal_dangerous_slow_down() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dangerous_slow_down_;
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::DangerousSlowDown>*
TrafficEventsCategory::_internal_mutable_dangerous_slow_down() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.dangerous_slow_down_;
}

// repeated .sensoris.protobuf.categories.trafficevents.TrafficCondition traffic_condition = 4;
inline int TrafficEventsCategory::_internal_traffic_condition_size() const {
  return _internal_traffic_condition().size();
}
inline int TrafficEventsCategory::traffic_condition_size() const {
  return _internal_traffic_condition_size();
}
inline void TrafficEventsCategory::clear_traffic_condition() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.traffic_condition_.Clear();
}
inline ::sensoris::protobuf::categories::trafficevents::TrafficCondition* TrafficEventsCategory::mutable_traffic_condition(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.traffic_condition)
  return _internal_mutable_traffic_condition()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::TrafficCondition>* TrafficEventsCategory::mutable_traffic_condition()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.traffic_condition)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_traffic_condition();
}
inline const ::sensoris::protobuf::categories::trafficevents::TrafficCondition& TrafficEventsCategory::traffic_condition(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.traffic_condition)
  return _internal_traffic_condition().Get(index);
}
inline ::sensoris::protobuf::categories::trafficevents::TrafficCondition* TrafficEventsCategory::add_traffic_condition() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::sensoris::protobuf::categories::trafficevents::TrafficCondition* _add = _internal_mutable_traffic_condition()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.traffic_condition)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::TrafficCondition>& TrafficEventsCategory::traffic_condition() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.traffic_condition)
  return _internal_traffic_condition();
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::TrafficCondition>&
TrafficEventsCategory::_internal_traffic_condition() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.traffic_condition_;
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::TrafficCondition>*
TrafficEventsCategory::_internal_mutable_traffic_condition() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.traffic_condition_;
}

// repeated .sensoris.protobuf.categories.trafficevents.RoadWorks roadworks = 5;
inline int TrafficEventsCategory::_internal_roadworks_size() const {
  return _internal_roadworks().size();
}
inline int TrafficEventsCategory::roadworks_size() const {
  return _internal_roadworks_size();
}
inline void TrafficEventsCategory::clear_roadworks() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.roadworks_.Clear();
}
inline ::sensoris::protobuf::categories::trafficevents::RoadWorks* TrafficEventsCategory::mutable_roadworks(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.roadworks)
  return _internal_mutable_roadworks()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::RoadWorks>* TrafficEventsCategory::mutable_roadworks()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.roadworks)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_roadworks();
}
inline const ::sensoris::protobuf::categories::trafficevents::RoadWorks& TrafficEventsCategory::roadworks(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.roadworks)
  return _internal_roadworks().Get(index);
}
inline ::sensoris::protobuf::categories::trafficevents::RoadWorks* TrafficEventsCategory::add_roadworks() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::sensoris::protobuf::categories::trafficevents::RoadWorks* _add = _internal_mutable_roadworks()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.roadworks)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::RoadWorks>& TrafficEventsCategory::roadworks() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.roadworks)
  return _internal_roadworks();
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::RoadWorks>&
TrafficEventsCategory::_internal_roadworks() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.roadworks_;
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::RoadWorks>*
TrafficEventsCategory::_internal_mutable_roadworks() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.roadworks_;
}

// repeated .sensoris.protobuf.categories.trafficevents.RoadWeatherCondition road_weather_condition = 6;
inline int TrafficEventsCategory::_internal_road_weather_condition_size() const {
  return _internal_road_weather_condition().size();
}
inline int TrafficEventsCategory::road_weather_condition_size() const {
  return _internal_road_weather_condition_size();
}
inline void TrafficEventsCategory::clear_road_weather_condition() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.road_weather_condition_.Clear();
}
inline ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition* TrafficEventsCategory::mutable_road_weather_condition(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.road_weather_condition)
  return _internal_mutable_road_weather_condition()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition>* TrafficEventsCategory::mutable_road_weather_condition()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.road_weather_condition)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_road_weather_condition();
}
inline const ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition& TrafficEventsCategory::road_weather_condition(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.road_weather_condition)
  return _internal_road_weather_condition().Get(index);
}
inline ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition* TrafficEventsCategory::add_road_weather_condition() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition* _add = _internal_mutable_road_weather_condition()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.road_weather_condition)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition>& TrafficEventsCategory::road_weather_condition() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.road_weather_condition)
  return _internal_road_weather_condition();
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition>&
TrafficEventsCategory::_internal_road_weather_condition() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.road_weather_condition_;
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition>*
TrafficEventsCategory::_internal_mutable_road_weather_condition() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.road_weather_condition_;
}

// repeated .sensoris.protobuf.categories.trafficevents.RoadSurfaceCondition road_surface_condition = 7;
inline int TrafficEventsCategory::_internal_road_surface_condition_size() const {
  return _internal_road_surface_condition().size();
}
inline int TrafficEventsCategory::road_surface_condition_size() const {
  return _internal_road_surface_condition_size();
}
inline void TrafficEventsCategory::clear_road_surface_condition() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.road_surface_condition_.Clear();
}
inline ::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition* TrafficEventsCategory::mutable_road_surface_condition(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.road_surface_condition)
  return _internal_mutable_road_surface_condition()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition>* TrafficEventsCategory::mutable_road_surface_condition()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.road_surface_condition)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_road_surface_condition();
}
inline const ::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition& TrafficEventsCategory::road_surface_condition(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.road_surface_condition)
  return _internal_road_surface_condition().Get(index);
}
inline ::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition* TrafficEventsCategory::add_road_surface_condition() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition* _add = _internal_mutable_road_surface_condition()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.road_surface_condition)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition>& TrafficEventsCategory::road_surface_condition() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.road_surface_condition)
  return _internal_road_surface_condition();
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition>&
TrafficEventsCategory::_internal_road_surface_condition() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.road_surface_condition_;
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition>*
TrafficEventsCategory::_internal_mutable_road_surface_condition() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.road_surface_condition_;
}

// repeated .sensoris.protobuf.categories.trafficevents.RoadObstructionCondition road_obstruction_condition = 8;
inline int TrafficEventsCategory::_internal_road_obstruction_condition_size() const {
  return _internal_road_obstruction_condition().size();
}
inline int TrafficEventsCategory::road_obstruction_condition_size() const {
  return _internal_road_obstruction_condition_size();
}
inline void TrafficEventsCategory::clear_road_obstruction_condition() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.road_obstruction_condition_.Clear();
}
inline ::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition* TrafficEventsCategory::mutable_road_obstruction_condition(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.road_obstruction_condition)
  return _internal_mutable_road_obstruction_condition()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition>* TrafficEventsCategory::mutable_road_obstruction_condition()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.road_obstruction_condition)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_road_obstruction_condition();
}
inline const ::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition& TrafficEventsCategory::road_obstruction_condition(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.road_obstruction_condition)
  return _internal_road_obstruction_condition().Get(index);
}
inline ::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition* TrafficEventsCategory::add_road_obstruction_condition() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition* _add = _internal_mutable_road_obstruction_condition()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.road_obstruction_condition)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition>& TrafficEventsCategory::road_obstruction_condition() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.road_obstruction_condition)
  return _internal_road_obstruction_condition();
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition>&
TrafficEventsCategory::_internal_road_obstruction_condition() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.road_obstruction_condition_;
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition>*
TrafficEventsCategory::_internal_mutable_road_obstruction_condition() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.road_obstruction_condition_;
}

// repeated .sensoris.protobuf.categories.trafficevents.VulnerableRoadUserCondition vulnerable_road_user_condition = 9;
inline int TrafficEventsCategory::_internal_vulnerable_road_user_condition_size() const {
  return _internal_vulnerable_road_user_condition().size();
}
inline int TrafficEventsCategory::vulnerable_road_user_condition_size() const {
  return _internal_vulnerable_road_user_condition_size();
}
inline void TrafficEventsCategory::clear_vulnerable_road_user_condition() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.vulnerable_road_user_condition_.Clear();
}
inline ::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition* TrafficEventsCategory::mutable_vulnerable_road_user_condition(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.vulnerable_road_user_condition)
  return _internal_mutable_vulnerable_road_user_condition()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition>* TrafficEventsCategory::mutable_vulnerable_road_user_condition()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.vulnerable_road_user_condition)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_vulnerable_road_user_condition();
}
inline const ::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition& TrafficEventsCategory::vulnerable_road_user_condition(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.vulnerable_road_user_condition)
  return _internal_vulnerable_road_user_condition().Get(index);
}
inline ::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition* TrafficEventsCategory::add_vulnerable_road_user_condition() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition* _add = _internal_mutable_vulnerable_road_user_condition()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.vulnerable_road_user_condition)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition>& TrafficEventsCategory::vulnerable_road_user_condition() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.vulnerable_road_user_condition)
  return _internal_vulnerable_road_user_condition();
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition>&
TrafficEventsCategory::_internal_vulnerable_road_user_condition() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.vulnerable_road_user_condition_;
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition>*
TrafficEventsCategory::_internal_mutable_vulnerable_road_user_condition() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.vulnerable_road_user_condition_;
}

// repeated .sensoris.protobuf.categories.trafficevents.ECallStatus e_call_status = 10;
inline int TrafficEventsCategory::_internal_e_call_status_size() const {
  return _internal_e_call_status().size();
}
inline int TrafficEventsCategory::e_call_status_size() const {
  return _internal_e_call_status_size();
}
inline void TrafficEventsCategory::clear_e_call_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.e_call_status_.Clear();
}
inline ::sensoris::protobuf::categories::trafficevents::ECallStatus* TrafficEventsCategory::mutable_e_call_status(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.e_call_status)
  return _internal_mutable_e_call_status()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::ECallStatus>* TrafficEventsCategory::mutable_e_call_status()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.e_call_status)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_e_call_status();
}
inline const ::sensoris::protobuf::categories::trafficevents::ECallStatus& TrafficEventsCategory::e_call_status(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.e_call_status)
  return _internal_e_call_status().Get(index);
}
inline ::sensoris::protobuf::categories::trafficevents::ECallStatus* TrafficEventsCategory::add_e_call_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::sensoris::protobuf::categories::trafficevents::ECallStatus* _add = _internal_mutable_e_call_status()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.e_call_status)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::ECallStatus>& TrafficEventsCategory::e_call_status() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.e_call_status)
  return _internal_e_call_status();
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::ECallStatus>&
TrafficEventsCategory::_internal_e_call_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.e_call_status_;
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::trafficevents::ECallStatus>*
TrafficEventsCategory::_internal_mutable_e_call_status() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.e_call_status_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace trafficevents
}  // namespace categories
}  // namespace protobuf
}  // namespace sensoris


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence_Type> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence_Type>() {
  return ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence_Type_descriptor();
}
template <>
struct is_proto_enum<::sensoris::protobuf::categories::trafficevents::Hazard_Direction> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::sensoris::protobuf::categories::trafficevents::Hazard_Direction>() {
  return ::sensoris::protobuf::categories::trafficevents::Hazard_Direction_descriptor();
}
template <>
struct is_proto_enum<::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence_Type> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence_Type>() {
  return ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence_Type_descriptor();
}
template <>
struct is_proto_enum<::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence_Type> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence_Type>() {
  return ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence_Type_descriptor();
}
template <>
struct is_proto_enum<::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence_Type> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence_Type>() {
  return ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence_Type_descriptor();
}
template <>
struct is_proto_enum<::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence_Type> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence_Type>() {
  return ::sensoris::protobuf::categories::trafficevents::RoadSurfaceCondition_TypeAndConfidence_Type_descriptor();
}
template <>
struct is_proto_enum<::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence_Type> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence_Type>() {
  return ::sensoris::protobuf::categories::trafficevents::RoadObstructionCondition_TypeAndConfidence_Type_descriptor();
}
template <>
struct is_proto_enum<::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence_Type> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence_Type>() {
  return ::sensoris::protobuf::categories::trafficevents::VulnerableRoadUserCondition_TypeAndConfidence_Type_descriptor();
}
template <>
struct is_proto_enum<::sensoris::protobuf::categories::trafficevents::ECallStatus_ActivationType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::sensoris::protobuf::categories::trafficevents::ECallStatus_ActivationType>() {
  return ::sensoris::protobuf::categories::trafficevents::ECallStatus_ActivationType_descriptor();
}
template <>
struct is_proto_enum<::sensoris::protobuf::categories::trafficevents::ECallStatus_Availability> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::sensoris::protobuf::categories::trafficevents::ECallStatus_Availability>() {
  return ::sensoris::protobuf::categories::trafficevents::ECallStatus_Availability_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto_2epb_2eh
