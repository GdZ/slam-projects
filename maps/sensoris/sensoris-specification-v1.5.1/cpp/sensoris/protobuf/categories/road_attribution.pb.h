/**
 * Copyright (c) 2017-2022 SENSORIS Innovation Platform hosted by ERTICO - ITS Europe.
 *
 * This program and the accompanying materials are made available under the terms of the Creative Commons Attribution-NoDerivatives 4.0 International license which accompanies this distribution, and is available at https://creativecommons.org/licenses/by-nd/4.0/legalcode.
 */
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sensoris/protobuf/categories/road_attribution.proto
// Protobuf C++ Version: 4.25.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "google/protobuf/wrappers.pb.h"
#include "sensoris/protobuf/types/base.pb.h"
#include "sensoris/protobuf/types/spatial.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto;
namespace sensoris {
namespace protobuf {
namespace categories {
namespace roadattribution {
class InclinationAndCurvature;
struct InclinationAndCurvatureDefaultTypeInternal;
extern InclinationAndCurvatureDefaultTypeInternal _InclinationAndCurvature_default_instance_;
class Lane;
struct LaneDefaultTypeInternal;
extern LaneDefaultTypeInternal _Lane_default_instance_;
class LaneBoundary;
struct LaneBoundaryDefaultTypeInternal;
extern LaneBoundaryDefaultTypeInternal _LaneBoundary_default_instance_;
class LaneBoundaryMergeSplit;
struct LaneBoundaryMergeSplitDefaultTypeInternal;
extern LaneBoundaryMergeSplitDefaultTypeInternal _LaneBoundaryMergeSplit_default_instance_;
class LaneBoundaryMergeSplit_TypeAndConfidence;
struct LaneBoundaryMergeSplit_TypeAndConfidenceDefaultTypeInternal;
extern LaneBoundaryMergeSplit_TypeAndConfidenceDefaultTypeInternal _LaneBoundaryMergeSplit_TypeAndConfidence_default_instance_;
class LaneBoundary_DashStatistics;
struct LaneBoundary_DashStatisticsDefaultTypeInternal;
extern LaneBoundary_DashStatisticsDefaultTypeInternal _LaneBoundary_DashStatistics_default_instance_;
class LaneBoundary_MarkingOffsets;
struct LaneBoundary_MarkingOffsetsDefaultTypeInternal;
extern LaneBoundary_MarkingOffsetsDefaultTypeInternal _LaneBoundary_MarkingOffsets_default_instance_;
class LaneBoundary_MarkingOffsets_TypeAndOffset;
struct LaneBoundary_MarkingOffsets_TypeAndOffsetDefaultTypeInternal;
extern LaneBoundary_MarkingOffsets_TypeAndOffsetDefaultTypeInternal _LaneBoundary_MarkingOffsets_TypeAndOffset_default_instance_;
class LaneBoundary_TypeAndConfidence;
struct LaneBoundary_TypeAndConfidenceDefaultTypeInternal;
extern LaneBoundary_TypeAndConfidenceDefaultTypeInternal _LaneBoundary_TypeAndConfidence_default_instance_;
class LaneCountAndConfidence;
struct LaneCountAndConfidenceDefaultTypeInternal;
extern LaneCountAndConfidenceDefaultTypeInternal _LaneCountAndConfidence_default_instance_;
class MarkingColorAndConfidence;
struct MarkingColorAndConfidenceDefaultTypeInternal;
extern MarkingColorAndConfidenceDefaultTypeInternal _MarkingColorAndConfidence_default_instance_;
class MarkingMaterialAndConfidence;
struct MarkingMaterialAndConfidenceDefaultTypeInternal;
extern MarkingMaterialAndConfidenceDefaultTypeInternal _MarkingMaterialAndConfidence_default_instance_;
class Road;
struct RoadDefaultTypeInternal;
extern RoadDefaultTypeInternal _Road_default_instance_;
class RoadAttribution;
struct RoadAttributionDefaultTypeInternal;
extern RoadAttributionDefaultTypeInternal _RoadAttribution_default_instance_;
class RoadAttributionCategory;
struct RoadAttributionCategoryDefaultTypeInternal;
extern RoadAttributionCategoryDefaultTypeInternal _RoadAttributionCategory_default_instance_;
class RoadAttribution_ChangeTypeAndConfidence;
struct RoadAttribution_ChangeTypeAndConfidenceDefaultTypeInternal;
extern RoadAttribution_ChangeTypeAndConfidenceDefaultTypeInternal _RoadAttribution_ChangeTypeAndConfidence_default_instance_;
class RoadAttribution_TypeAndConfidence;
struct RoadAttribution_TypeAndConfidenceDefaultTypeInternal;
extern RoadAttribution_TypeAndConfidenceDefaultTypeInternal _RoadAttribution_TypeAndConfidence_default_instance_;
class SurfaceAttribution;
struct SurfaceAttributionDefaultTypeInternal;
extern SurfaceAttributionDefaultTypeInternal _SurfaceAttribution_default_instance_;
class SurfaceMarking;
struct SurfaceMarkingDefaultTypeInternal;
extern SurfaceMarkingDefaultTypeInternal _SurfaceMarking_default_instance_;
class SurfaceMarking_TypeAndConfidence;
struct SurfaceMarking_TypeAndConfidenceDefaultTypeInternal;
extern SurfaceMarking_TypeAndConfidenceDefaultTypeInternal _SurfaceMarking_TypeAndConfidence_default_instance_;
class SurfaceMaterialAndConfidence;
struct SurfaceMaterialAndConfidenceDefaultTypeInternal;
extern SurfaceMaterialAndConfidenceDefaultTypeInternal _SurfaceMaterialAndConfidence_default_instance_;
}  // namespace roadattribution
}  // namespace categories
}  // namespace protobuf
}  // namespace sensoris
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace sensoris {
namespace protobuf {
namespace categories {
namespace roadattribution {
enum MarkingColorAndConfidence_Type : int {
  MarkingColorAndConfidence_Type_UNKNOWN_TYPE = 0,
  MarkingColorAndConfidence_Type_WHITE = 1,
  MarkingColorAndConfidence_Type_GRAY = 2,
  MarkingColorAndConfidence_Type_GRAY_LIGHT = 3,
  MarkingColorAndConfidence_Type_GRAY_DARK = 4,
  MarkingColorAndConfidence_Type_BLACK = 5,
  MarkingColorAndConfidence_Type_RED = 6,
  MarkingColorAndConfidence_Type_YELLOW = 7,
  MarkingColorAndConfidence_Type_GREEN = 8,
  MarkingColorAndConfidence_Type_CYAN = 9,
  MarkingColorAndConfidence_Type_BLUE = 10,
  MarkingColorAndConfidence_Type_ORANGE = 11,
  MarkingColorAndConfidence_Type_PINK = 12,
  MarkingColorAndConfidence_Type_PURPLE = 13,
  MarkingColorAndConfidence_Type_MarkingColorAndConfidence_Type_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  MarkingColorAndConfidence_Type_MarkingColorAndConfidence_Type_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool MarkingColorAndConfidence_Type_IsValid(int value);
extern const uint32_t MarkingColorAndConfidence_Type_internal_data_[];
constexpr MarkingColorAndConfidence_Type MarkingColorAndConfidence_Type_Type_MIN = static_cast<MarkingColorAndConfidence_Type>(0);
constexpr MarkingColorAndConfidence_Type MarkingColorAndConfidence_Type_Type_MAX = static_cast<MarkingColorAndConfidence_Type>(13);
constexpr int MarkingColorAndConfidence_Type_Type_ARRAYSIZE = 13 + 1;
const ::google::protobuf::EnumDescriptor*
MarkingColorAndConfidence_Type_descriptor();
template <typename T>
const std::string& MarkingColorAndConfidence_Type_Name(T value) {
  static_assert(std::is_same<T, MarkingColorAndConfidence_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return MarkingColorAndConfidence_Type_Name(static_cast<MarkingColorAndConfidence_Type>(value));
}
template <>
inline const std::string& MarkingColorAndConfidence_Type_Name(MarkingColorAndConfidence_Type value) {
  return ::google::protobuf::internal::NameOfDenseEnum<MarkingColorAndConfidence_Type_descriptor,
                                                 0, 13>(
      static_cast<int>(value));
}
inline bool MarkingColorAndConfidence_Type_Parse(absl::string_view name, MarkingColorAndConfidence_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MarkingColorAndConfidence_Type>(
      MarkingColorAndConfidence_Type_descriptor(), name, value);
}
enum MarkingMaterialAndConfidence_Type : int {
  MarkingMaterialAndConfidence_Type_UNKNOWN_TYPE = 0,
  MarkingMaterialAndConfidence_Type_METAL = 1,
  MarkingMaterialAndConfidence_Type_CONCRETE = 2,
  MarkingMaterialAndConfidence_Type_STONE = 3,
  MarkingMaterialAndConfidence_Type_WOOD = 4,
  MarkingMaterialAndConfidence_Type_PLASTIC = 5,
  MarkingMaterialAndConfidence_Type_TRANSPARENT = 6,
  MarkingMaterialAndConfidence_Type_VIBRATION_MARKINGS = 7,
  MarkingMaterialAndConfidence_Type_PAINT = 8,
  MarkingMaterialAndConfidence_Type_ASPHALT = 9,
  MarkingMaterialAndConfidence_Type_GRAVEL = 10,
  MarkingMaterialAndConfidence_Type_COBBLESTONE = 11,
  MarkingMaterialAndConfidence_Type_MarkingMaterialAndConfidence_Type_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  MarkingMaterialAndConfidence_Type_MarkingMaterialAndConfidence_Type_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool MarkingMaterialAndConfidence_Type_IsValid(int value);
extern const uint32_t MarkingMaterialAndConfidence_Type_internal_data_[];
constexpr MarkingMaterialAndConfidence_Type MarkingMaterialAndConfidence_Type_Type_MIN = static_cast<MarkingMaterialAndConfidence_Type>(0);
constexpr MarkingMaterialAndConfidence_Type MarkingMaterialAndConfidence_Type_Type_MAX = static_cast<MarkingMaterialAndConfidence_Type>(11);
constexpr int MarkingMaterialAndConfidence_Type_Type_ARRAYSIZE = 11 + 1;
const ::google::protobuf::EnumDescriptor*
MarkingMaterialAndConfidence_Type_descriptor();
template <typename T>
const std::string& MarkingMaterialAndConfidence_Type_Name(T value) {
  static_assert(std::is_same<T, MarkingMaterialAndConfidence_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return MarkingMaterialAndConfidence_Type_Name(static_cast<MarkingMaterialAndConfidence_Type>(value));
}
template <>
inline const std::string& MarkingMaterialAndConfidence_Type_Name(MarkingMaterialAndConfidence_Type value) {
  return ::google::protobuf::internal::NameOfDenseEnum<MarkingMaterialAndConfidence_Type_descriptor,
                                                 0, 11>(
      static_cast<int>(value));
}
inline bool MarkingMaterialAndConfidence_Type_Parse(absl::string_view name, MarkingMaterialAndConfidence_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MarkingMaterialAndConfidence_Type>(
      MarkingMaterialAndConfidence_Type_descriptor(), name, value);
}
enum SurfaceMaterialAndConfidence_Type : int {
  SurfaceMaterialAndConfidence_Type_UNKNOWN_TYPE = 0,
  SurfaceMaterialAndConfidence_Type_ASPHALT = 1,
  SurfaceMaterialAndConfidence_Type_CONCRETE = 2,
  SurfaceMaterialAndConfidence_Type_COMPOSITE_PAVEMENT = 3,
  SurfaceMaterialAndConfidence_Type_RECYCLING = 4,
  SurfaceMaterialAndConfidence_Type_GRAVEL = 5,
  SurfaceMaterialAndConfidence_Type_COBBLESTONE = 6,
  SurfaceMaterialAndConfidence_Type_SurfaceMaterialAndConfidence_Type_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  SurfaceMaterialAndConfidence_Type_SurfaceMaterialAndConfidence_Type_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool SurfaceMaterialAndConfidence_Type_IsValid(int value);
extern const uint32_t SurfaceMaterialAndConfidence_Type_internal_data_[];
constexpr SurfaceMaterialAndConfidence_Type SurfaceMaterialAndConfidence_Type_Type_MIN = static_cast<SurfaceMaterialAndConfidence_Type>(0);
constexpr SurfaceMaterialAndConfidence_Type SurfaceMaterialAndConfidence_Type_Type_MAX = static_cast<SurfaceMaterialAndConfidence_Type>(6);
constexpr int SurfaceMaterialAndConfidence_Type_Type_ARRAYSIZE = 6 + 1;
const ::google::protobuf::EnumDescriptor*
SurfaceMaterialAndConfidence_Type_descriptor();
template <typename T>
const std::string& SurfaceMaterialAndConfidence_Type_Name(T value) {
  static_assert(std::is_same<T, SurfaceMaterialAndConfidence_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return SurfaceMaterialAndConfidence_Type_Name(static_cast<SurfaceMaterialAndConfidence_Type>(value));
}
template <>
inline const std::string& SurfaceMaterialAndConfidence_Type_Name(SurfaceMaterialAndConfidence_Type value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SurfaceMaterialAndConfidence_Type_descriptor,
                                                 0, 6>(
      static_cast<int>(value));
}
inline bool SurfaceMaterialAndConfidence_Type_Parse(absl::string_view name, SurfaceMaterialAndConfidence_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SurfaceMaterialAndConfidence_Type>(
      SurfaceMaterialAndConfidence_Type_descriptor(), name, value);
}
enum LaneBoundary_TypeAndConfidence_Type : int {
  LaneBoundary_TypeAndConfidence_Type_UNKNOWN_TYPE = 0,
  LaneBoundary_TypeAndConfidence_Type_LINE = 1,
  LaneBoundary_TypeAndConfidence_Type_LINE_SINGLE = 2,
  LaneBoundary_TypeAndConfidence_Type_LINE_SINGLE_SOLID = 3,
  LaneBoundary_TypeAndConfidence_Type_LINE_SINGLE_DASHED = 4,
  LaneBoundary_TypeAndConfidence_Type_LINE_SINGLE_DASHED_SHORT = 5,
  LaneBoundary_TypeAndConfidence_Type_LINE_SINGLE_DASHED_LONG = 6,
  LaneBoundary_TypeAndConfidence_Type_LINE_DOUBLE = 7,
  LaneBoundary_TypeAndConfidence_Type_LINE_DOUBLE_SOLID = 8,
  LaneBoundary_TypeAndConfidence_Type_LINE_DOUBLE_DASHED = 9,
  LaneBoundary_TypeAndConfidence_Type_LINE_DOUBLE_SOLID_DASHED = 10,
  LaneBoundary_TypeAndConfidence_Type_LINE_DOUBLE_DASHED_SOLID = 11,
  LaneBoundary_TypeAndConfidence_Type_SHADED_AREA_MARKING = 12,
  LaneBoundary_TypeAndConfidence_Type_BLOCKS_DASHED = 13,
  LaneBoundary_TypeAndConfidence_Type_CROSSING_ALERT = 14,
  LaneBoundary_TypeAndConfidence_Type_CURB = 15,
  LaneBoundary_TypeAndConfidence_Type_CURB_TRAVERSABLE = 16,
  LaneBoundary_TypeAndConfidence_Type_CURB_NON_TRAVERSABLE = 17,
  LaneBoundary_TypeAndConfidence_Type_PHYSICAL_DIVIDER = 18,
  LaneBoundary_TypeAndConfidence_Type_WALL = 19,
  LaneBoundary_TypeAndConfidence_Type_WALL_FLAT = 20,
  LaneBoundary_TypeAndConfidence_Type_WALL_CURVED = 21,
  LaneBoundary_TypeAndConfidence_Type_BARRIER = 22,
  LaneBoundary_TypeAndConfidence_Type_BARRIER_JERSEY = 23,
  LaneBoundary_TypeAndConfidence_Type_BARRIER_SOUND = 24,
  LaneBoundary_TypeAndConfidence_Type_BARRIER_CABLE = 25,
  LaneBoundary_TypeAndConfidence_Type_GUARDRAIL = 26,
  LaneBoundary_TypeAndConfidence_Type_FENCE = 27,
  LaneBoundary_TypeAndConfidence_Type_ROAD_EDGE = 28,
  LaneBoundary_TypeAndConfidence_Type_CLIFF = 29,
  LaneBoundary_TypeAndConfidence_Type_DITCH = 30,
  LaneBoundary_TypeAndConfidence_Type_ASPHALT_JOINT = 31,
  LaneBoundary_TypeAndConfidence_Type_LINE_MULTIPLE = 32,
  LaneBoundary_TypeAndConfidence_Type_LINE_MULTIPLE_ALL_DASHED = 33,
  LaneBoundary_TypeAndConfidence_Type_LINE_MULTIPLE_ANY_SOLID = 34,
  LaneBoundary_TypeAndConfidence_Type_PHYSICAL_DIVIDER_CONTINUOUS = 35,
  LaneBoundary_TypeAndConfidence_Type_PHYSICAL_DIVIDER_DISCONTINUOUS = 36,
  LaneBoundary_TypeAndConfidence_Type_LINE_DOUBLE_DASHED_OR_DOUBLE_SOLID_DASHED = 37,
  LaneBoundary_TypeAndConfidence_Type_LINE_DOUBLE_DASHED_OR_DOUBLE_DASHED_SOLID = 38,
  LaneBoundary_TypeAndConfidence_Type_LINE_DOUBLE_SOLID_OR_DOUBLE_SOLID_DASHED = 39,
  LaneBoundary_TypeAndConfidence_Type_LINE_DOUBLE_SOLID_OR_DOUBLE_DASHED_SOLID = 40,
  LaneBoundary_TypeAndConfidence_Type_LaneBoundary_TypeAndConfidence_Type_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  LaneBoundary_TypeAndConfidence_Type_LaneBoundary_TypeAndConfidence_Type_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool LaneBoundary_TypeAndConfidence_Type_IsValid(int value);
extern const uint32_t LaneBoundary_TypeAndConfidence_Type_internal_data_[];
constexpr LaneBoundary_TypeAndConfidence_Type LaneBoundary_TypeAndConfidence_Type_Type_MIN = static_cast<LaneBoundary_TypeAndConfidence_Type>(0);
constexpr LaneBoundary_TypeAndConfidence_Type LaneBoundary_TypeAndConfidence_Type_Type_MAX = static_cast<LaneBoundary_TypeAndConfidence_Type>(40);
constexpr int LaneBoundary_TypeAndConfidence_Type_Type_ARRAYSIZE = 40 + 1;
const ::google::protobuf::EnumDescriptor*
LaneBoundary_TypeAndConfidence_Type_descriptor();
template <typename T>
const std::string& LaneBoundary_TypeAndConfidence_Type_Name(T value) {
  static_assert(std::is_same<T, LaneBoundary_TypeAndConfidence_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return LaneBoundary_TypeAndConfidence_Type_Name(static_cast<LaneBoundary_TypeAndConfidence_Type>(value));
}
template <>
inline const std::string& LaneBoundary_TypeAndConfidence_Type_Name(LaneBoundary_TypeAndConfidence_Type value) {
  return ::google::protobuf::internal::NameOfDenseEnum<LaneBoundary_TypeAndConfidence_Type_descriptor,
                                                 0, 40>(
      static_cast<int>(value));
}
inline bool LaneBoundary_TypeAndConfidence_Type_Parse(absl::string_view name, LaneBoundary_TypeAndConfidence_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LaneBoundary_TypeAndConfidence_Type>(
      LaneBoundary_TypeAndConfidence_Type_descriptor(), name, value);
}
enum LaneBoundary_MarkingOffsets_TypeAndOffset_Type : int {
  LaneBoundary_MarkingOffsets_TypeAndOffset_Type_UNKNOWN_TYPE = 0,
  LaneBoundary_MarkingOffsets_TypeAndOffset_Type_START_OF_MARKING = 1,
  LaneBoundary_MarkingOffsets_TypeAndOffset_Type_END_OF_MARKING = 2,
  LaneBoundary_MarkingOffsets_TypeAndOffset_Type_ON_MARKING = 3,
  LaneBoundary_MarkingOffsets_TypeAndOffset_Type_NO_MARKING = 4,
  LaneBoundary_MarkingOffsets_TypeAndOffset_Type_LaneBoundary_MarkingOffsets_TypeAndOffset_Type_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  LaneBoundary_MarkingOffsets_TypeAndOffset_Type_LaneBoundary_MarkingOffsets_TypeAndOffset_Type_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool LaneBoundary_MarkingOffsets_TypeAndOffset_Type_IsValid(int value);
extern const uint32_t LaneBoundary_MarkingOffsets_TypeAndOffset_Type_internal_data_[];
constexpr LaneBoundary_MarkingOffsets_TypeAndOffset_Type LaneBoundary_MarkingOffsets_TypeAndOffset_Type_Type_MIN = static_cast<LaneBoundary_MarkingOffsets_TypeAndOffset_Type>(0);
constexpr LaneBoundary_MarkingOffsets_TypeAndOffset_Type LaneBoundary_MarkingOffsets_TypeAndOffset_Type_Type_MAX = static_cast<LaneBoundary_MarkingOffsets_TypeAndOffset_Type>(4);
constexpr int LaneBoundary_MarkingOffsets_TypeAndOffset_Type_Type_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
LaneBoundary_MarkingOffsets_TypeAndOffset_Type_descriptor();
template <typename T>
const std::string& LaneBoundary_MarkingOffsets_TypeAndOffset_Type_Name(T value) {
  static_assert(std::is_same<T, LaneBoundary_MarkingOffsets_TypeAndOffset_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return LaneBoundary_MarkingOffsets_TypeAndOffset_Type_Name(static_cast<LaneBoundary_MarkingOffsets_TypeAndOffset_Type>(value));
}
template <>
inline const std::string& LaneBoundary_MarkingOffsets_TypeAndOffset_Type_Name(LaneBoundary_MarkingOffsets_TypeAndOffset_Type value) {
  return ::google::protobuf::internal::NameOfDenseEnum<LaneBoundary_MarkingOffsets_TypeAndOffset_Type_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool LaneBoundary_MarkingOffsets_TypeAndOffset_Type_Parse(absl::string_view name, LaneBoundary_MarkingOffsets_TypeAndOffset_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LaneBoundary_MarkingOffsets_TypeAndOffset_Type>(
      LaneBoundary_MarkingOffsets_TypeAndOffset_Type_descriptor(), name, value);
}
enum LaneBoundary_PositionReference : int {
  LaneBoundary_PositionReference_UNKNOWN_POSITION_REFERENCE = 0,
  LaneBoundary_PositionReference_LEFT_MARKING_BOUNDARY = 1,
  LaneBoundary_PositionReference_CENTER_LINE = 2,
  LaneBoundary_PositionReference_RIGHT_MARKING_BOUNDARY = 3,
  LaneBoundary_PositionReference_LaneBoundary_PositionReference_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  LaneBoundary_PositionReference_LaneBoundary_PositionReference_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool LaneBoundary_PositionReference_IsValid(int value);
extern const uint32_t LaneBoundary_PositionReference_internal_data_[];
constexpr LaneBoundary_PositionReference LaneBoundary_PositionReference_PositionReference_MIN = static_cast<LaneBoundary_PositionReference>(0);
constexpr LaneBoundary_PositionReference LaneBoundary_PositionReference_PositionReference_MAX = static_cast<LaneBoundary_PositionReference>(3);
constexpr int LaneBoundary_PositionReference_PositionReference_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
LaneBoundary_PositionReference_descriptor();
template <typename T>
const std::string& LaneBoundary_PositionReference_Name(T value) {
  static_assert(std::is_same<T, LaneBoundary_PositionReference>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to PositionReference_Name().");
  return LaneBoundary_PositionReference_Name(static_cast<LaneBoundary_PositionReference>(value));
}
template <>
inline const std::string& LaneBoundary_PositionReference_Name(LaneBoundary_PositionReference value) {
  return ::google::protobuf::internal::NameOfDenseEnum<LaneBoundary_PositionReference_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool LaneBoundary_PositionReference_Parse(absl::string_view name, LaneBoundary_PositionReference* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LaneBoundary_PositionReference>(
      LaneBoundary_PositionReference_descriptor(), name, value);
}
enum LaneBoundaryMergeSplit_TypeAndConfidence_Type : int {
  LaneBoundaryMergeSplit_TypeAndConfidence_Type_UNKNOWN_TYPE = 0,
  LaneBoundaryMergeSplit_TypeAndConfidence_Type_MERGE = 1,
  LaneBoundaryMergeSplit_TypeAndConfidence_Type_SPLIT = 2,
  LaneBoundaryMergeSplit_TypeAndConfidence_Type_LaneBoundaryMergeSplit_TypeAndConfidence_Type_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  LaneBoundaryMergeSplit_TypeAndConfidence_Type_LaneBoundaryMergeSplit_TypeAndConfidence_Type_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool LaneBoundaryMergeSplit_TypeAndConfidence_Type_IsValid(int value);
extern const uint32_t LaneBoundaryMergeSplit_TypeAndConfidence_Type_internal_data_[];
constexpr LaneBoundaryMergeSplit_TypeAndConfidence_Type LaneBoundaryMergeSplit_TypeAndConfidence_Type_Type_MIN = static_cast<LaneBoundaryMergeSplit_TypeAndConfidence_Type>(0);
constexpr LaneBoundaryMergeSplit_TypeAndConfidence_Type LaneBoundaryMergeSplit_TypeAndConfidence_Type_Type_MAX = static_cast<LaneBoundaryMergeSplit_TypeAndConfidence_Type>(2);
constexpr int LaneBoundaryMergeSplit_TypeAndConfidence_Type_Type_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
LaneBoundaryMergeSplit_TypeAndConfidence_Type_descriptor();
template <typename T>
const std::string& LaneBoundaryMergeSplit_TypeAndConfidence_Type_Name(T value) {
  static_assert(std::is_same<T, LaneBoundaryMergeSplit_TypeAndConfidence_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return LaneBoundaryMergeSplit_TypeAndConfidence_Type_Name(static_cast<LaneBoundaryMergeSplit_TypeAndConfidence_Type>(value));
}
template <>
inline const std::string& LaneBoundaryMergeSplit_TypeAndConfidence_Type_Name(LaneBoundaryMergeSplit_TypeAndConfidence_Type value) {
  return ::google::protobuf::internal::NameOfDenseEnum<LaneBoundaryMergeSplit_TypeAndConfidence_Type_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool LaneBoundaryMergeSplit_TypeAndConfidence_Type_Parse(absl::string_view name, LaneBoundaryMergeSplit_TypeAndConfidence_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LaneBoundaryMergeSplit_TypeAndConfidence_Type>(
      LaneBoundaryMergeSplit_TypeAndConfidence_Type_descriptor(), name, value);
}
enum SurfaceMarking_TypeAndConfidence_Type : int {
  SurfaceMarking_TypeAndConfidence_Type_UNKNOWN_TYPE = 0,
  SurfaceMarking_TypeAndConfidence_Type_SIGN = 1,
  SurfaceMarking_TypeAndConfidence_Type_TEXT = 2,
  SurfaceMarking_TypeAndConfidence_Type_ICON = 3,
  SurfaceMarking_TypeAndConfidence_Type_PATTERN = 4,
  SurfaceMarking_TypeAndConfidence_Type_PATTERN_CROSSWALK = 5,
  SurfaceMarking_TypeAndConfidence_Type_LINE_ELEMENT = 6,
  SurfaceMarking_TypeAndConfidence_Type_STOP_LINE = 7,
  SurfaceMarking_TypeAndConfidence_Type_SurfaceMarking_TypeAndConfidence_Type_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  SurfaceMarking_TypeAndConfidence_Type_SurfaceMarking_TypeAndConfidence_Type_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool SurfaceMarking_TypeAndConfidence_Type_IsValid(int value);
extern const uint32_t SurfaceMarking_TypeAndConfidence_Type_internal_data_[];
constexpr SurfaceMarking_TypeAndConfidence_Type SurfaceMarking_TypeAndConfidence_Type_Type_MIN = static_cast<SurfaceMarking_TypeAndConfidence_Type>(0);
constexpr SurfaceMarking_TypeAndConfidence_Type SurfaceMarking_TypeAndConfidence_Type_Type_MAX = static_cast<SurfaceMarking_TypeAndConfidence_Type>(7);
constexpr int SurfaceMarking_TypeAndConfidence_Type_Type_ARRAYSIZE = 7 + 1;
const ::google::protobuf::EnumDescriptor*
SurfaceMarking_TypeAndConfidence_Type_descriptor();
template <typename T>
const std::string& SurfaceMarking_TypeAndConfidence_Type_Name(T value) {
  static_assert(std::is_same<T, SurfaceMarking_TypeAndConfidence_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return SurfaceMarking_TypeAndConfidence_Type_Name(static_cast<SurfaceMarking_TypeAndConfidence_Type>(value));
}
template <>
inline const std::string& SurfaceMarking_TypeAndConfidence_Type_Name(SurfaceMarking_TypeAndConfidence_Type value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SurfaceMarking_TypeAndConfidence_Type_descriptor,
                                                 0, 7>(
      static_cast<int>(value));
}
inline bool SurfaceMarking_TypeAndConfidence_Type_Parse(absl::string_view name, SurfaceMarking_TypeAndConfidence_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SurfaceMarking_TypeAndConfidence_Type>(
      SurfaceMarking_TypeAndConfidence_Type_descriptor(), name, value);
}
enum RoadAttribution_TypeAndConfidence_Type : int {
  RoadAttribution_TypeAndConfidence_Type_UNKNOWN_TYPE = 0,
  RoadAttribution_TypeAndConfidence_Type_MOTORWAY = 1,
  RoadAttribution_TypeAndConfidence_Type_ONE_WAY_TRAFFIC = 2,
  RoadAttribution_TypeAndConfidence_Type_TWO_WAY_TRAFFIC = 3,
  RoadAttribution_TypeAndConfidence_Type_OFFROAD = 4,
  RoadAttribution_TypeAndConfidence_Type_TUNNEL = 5,
  RoadAttribution_TypeAndConfidence_Type_BRIDGE = 6,
  RoadAttribution_TypeAndConfidence_Type_ARTIFICIAL_ILLUMINATION = 7,
  RoadAttribution_TypeAndConfidence_Type_ROAD_WORKS_NARROW_LANES = 8,
  RoadAttribution_TypeAndConfidence_Type_LANE_RIGHT = 9,
  RoadAttribution_TypeAndConfidence_Type_LANE_LEFT = 10,
  RoadAttribution_TypeAndConfidence_Type_LANE_SPLIT_MIDDLE = 11,
  RoadAttribution_TypeAndConfidence_Type_LANE_MERGE_MIDDLE = 12,
  RoadAttribution_TypeAndConfidence_Type_CROSSWALK = 13,
  RoadAttribution_TypeAndConfidence_Type_CENTER_TURN_LANE = 14,
  RoadAttribution_TypeAndConfidence_Type_RoadAttribution_TypeAndConfidence_Type_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  RoadAttribution_TypeAndConfidence_Type_RoadAttribution_TypeAndConfidence_Type_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool RoadAttribution_TypeAndConfidence_Type_IsValid(int value);
extern const uint32_t RoadAttribution_TypeAndConfidence_Type_internal_data_[];
constexpr RoadAttribution_TypeAndConfidence_Type RoadAttribution_TypeAndConfidence_Type_Type_MIN = static_cast<RoadAttribution_TypeAndConfidence_Type>(0);
constexpr RoadAttribution_TypeAndConfidence_Type RoadAttribution_TypeAndConfidence_Type_Type_MAX = static_cast<RoadAttribution_TypeAndConfidence_Type>(14);
constexpr int RoadAttribution_TypeAndConfidence_Type_Type_ARRAYSIZE = 14 + 1;
const ::google::protobuf::EnumDescriptor*
RoadAttribution_TypeAndConfidence_Type_descriptor();
template <typename T>
const std::string& RoadAttribution_TypeAndConfidence_Type_Name(T value) {
  static_assert(std::is_same<T, RoadAttribution_TypeAndConfidence_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return RoadAttribution_TypeAndConfidence_Type_Name(static_cast<RoadAttribution_TypeAndConfidence_Type>(value));
}
template <>
inline const std::string& RoadAttribution_TypeAndConfidence_Type_Name(RoadAttribution_TypeAndConfidence_Type value) {
  return ::google::protobuf::internal::NameOfDenseEnum<RoadAttribution_TypeAndConfidence_Type_descriptor,
                                                 0, 14>(
      static_cast<int>(value));
}
inline bool RoadAttribution_TypeAndConfidence_Type_Parse(absl::string_view name, RoadAttribution_TypeAndConfidence_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RoadAttribution_TypeAndConfidence_Type>(
      RoadAttribution_TypeAndConfidence_Type_descriptor(), name, value);
}
enum RoadAttribution_ChangeTypeAndConfidence_Type : int {
  RoadAttribution_ChangeTypeAndConfidence_Type_UNKNOWN_TYPE = 0,
  RoadAttribution_ChangeTypeAndConfidence_Type_DETECTED = 1,
  RoadAttribution_ChangeTypeAndConfidence_Type_START = 2,
  RoadAttribution_ChangeTypeAndConfidence_Type_END = 3,
  RoadAttribution_ChangeTypeAndConfidence_Type_RoadAttribution_ChangeTypeAndConfidence_Type_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  RoadAttribution_ChangeTypeAndConfidence_Type_RoadAttribution_ChangeTypeAndConfidence_Type_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool RoadAttribution_ChangeTypeAndConfidence_Type_IsValid(int value);
extern const uint32_t RoadAttribution_ChangeTypeAndConfidence_Type_internal_data_[];
constexpr RoadAttribution_ChangeTypeAndConfidence_Type RoadAttribution_ChangeTypeAndConfidence_Type_Type_MIN = static_cast<RoadAttribution_ChangeTypeAndConfidence_Type>(0);
constexpr RoadAttribution_ChangeTypeAndConfidence_Type RoadAttribution_ChangeTypeAndConfidence_Type_Type_MAX = static_cast<RoadAttribution_ChangeTypeAndConfidence_Type>(3);
constexpr int RoadAttribution_ChangeTypeAndConfidence_Type_Type_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
RoadAttribution_ChangeTypeAndConfidence_Type_descriptor();
template <typename T>
const std::string& RoadAttribution_ChangeTypeAndConfidence_Type_Name(T value) {
  static_assert(std::is_same<T, RoadAttribution_ChangeTypeAndConfidence_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return RoadAttribution_ChangeTypeAndConfidence_Type_Name(static_cast<RoadAttribution_ChangeTypeAndConfidence_Type>(value));
}
template <>
inline const std::string& RoadAttribution_ChangeTypeAndConfidence_Type_Name(RoadAttribution_ChangeTypeAndConfidence_Type value) {
  return ::google::protobuf::internal::NameOfDenseEnum<RoadAttribution_ChangeTypeAndConfidence_Type_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool RoadAttribution_ChangeTypeAndConfidence_Type_Parse(absl::string_view name, RoadAttribution_ChangeTypeAndConfidence_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RoadAttribution_ChangeTypeAndConfidence_Type>(
      RoadAttribution_ChangeTypeAndConfidence_Type_descriptor(), name, value);
}
enum LaneCountAndConfidence_Type : int {
  LaneCountAndConfidence_Type_UNKNOWN_TYPE = 0,
  LaneCountAndConfidence_Type_TOTAL = 1,
  LaneCountAndConfidence_Type_LEFT_INCLUDING_EGO_LANE = 2,
  LaneCountAndConfidence_Type_RIGHT = 3,
  LaneCountAndConfidence_Type_LaneCountAndConfidence_Type_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  LaneCountAndConfidence_Type_LaneCountAndConfidence_Type_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool LaneCountAndConfidence_Type_IsValid(int value);
extern const uint32_t LaneCountAndConfidence_Type_internal_data_[];
constexpr LaneCountAndConfidence_Type LaneCountAndConfidence_Type_Type_MIN = static_cast<LaneCountAndConfidence_Type>(0);
constexpr LaneCountAndConfidence_Type LaneCountAndConfidence_Type_Type_MAX = static_cast<LaneCountAndConfidence_Type>(3);
constexpr int LaneCountAndConfidence_Type_Type_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
LaneCountAndConfidence_Type_descriptor();
template <typename T>
const std::string& LaneCountAndConfidence_Type_Name(T value) {
  static_assert(std::is_same<T, LaneCountAndConfidence_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return LaneCountAndConfidence_Type_Name(static_cast<LaneCountAndConfidence_Type>(value));
}
template <>
inline const std::string& LaneCountAndConfidence_Type_Name(LaneCountAndConfidence_Type value) {
  return ::google::protobuf::internal::NameOfDenseEnum<LaneCountAndConfidence_Type_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool LaneCountAndConfidence_Type_Parse(absl::string_view name, LaneCountAndConfidence_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LaneCountAndConfidence_Type>(
      LaneCountAndConfidence_Type_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class SurfaceMaterialAndConfidence final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.roadattribution.SurfaceMaterialAndConfidence) */ {
 public:
  inline SurfaceMaterialAndConfidence() : SurfaceMaterialAndConfidence(nullptr) {}
  ~SurfaceMaterialAndConfidence() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SurfaceMaterialAndConfidence(::google::protobuf::internal::ConstantInitialized);

  inline SurfaceMaterialAndConfidence(const SurfaceMaterialAndConfidence& from)
      : SurfaceMaterialAndConfidence(nullptr, from) {}
  SurfaceMaterialAndConfidence(SurfaceMaterialAndConfidence&& from) noexcept
    : SurfaceMaterialAndConfidence() {
    *this = ::std::move(from);
  }

  inline SurfaceMaterialAndConfidence& operator=(const SurfaceMaterialAndConfidence& from) {
    CopyFrom(from);
    return *this;
  }
  inline SurfaceMaterialAndConfidence& operator=(SurfaceMaterialAndConfidence&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SurfaceMaterialAndConfidence& default_instance() {
    return *internal_default_instance();
  }
  static inline const SurfaceMaterialAndConfidence* internal_default_instance() {
    return reinterpret_cast<const SurfaceMaterialAndConfidence*>(
               &_SurfaceMaterialAndConfidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SurfaceMaterialAndConfidence& a, SurfaceMaterialAndConfidence& b) {
    a.Swap(&b);
  }
  inline void Swap(SurfaceMaterialAndConfidence* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SurfaceMaterialAndConfidence* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SurfaceMaterialAndConfidence* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SurfaceMaterialAndConfidence>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SurfaceMaterialAndConfidence& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SurfaceMaterialAndConfidence& from) {
    SurfaceMaterialAndConfidence::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SurfaceMaterialAndConfidence* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.categories.roadattribution.SurfaceMaterialAndConfidence";
  }
  protected:
  explicit SurfaceMaterialAndConfidence(::google::protobuf::Arena* arena);
  SurfaceMaterialAndConfidence(::google::protobuf::Arena* arena, const SurfaceMaterialAndConfidence& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Type = SurfaceMaterialAndConfidence_Type;
  static constexpr Type UNKNOWN_TYPE = SurfaceMaterialAndConfidence_Type_UNKNOWN_TYPE;
  static constexpr Type ASPHALT = SurfaceMaterialAndConfidence_Type_ASPHALT;
  static constexpr Type CONCRETE = SurfaceMaterialAndConfidence_Type_CONCRETE;
  static constexpr Type COMPOSITE_PAVEMENT = SurfaceMaterialAndConfidence_Type_COMPOSITE_PAVEMENT;
  static constexpr Type RECYCLING = SurfaceMaterialAndConfidence_Type_RECYCLING;
  static constexpr Type GRAVEL = SurfaceMaterialAndConfidence_Type_GRAVEL;
  static constexpr Type COBBLESTONE = SurfaceMaterialAndConfidence_Type_COBBLESTONE;
  static inline bool Type_IsValid(int value) {
    return SurfaceMaterialAndConfidence_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = SurfaceMaterialAndConfidence_Type_Type_MIN;
  static constexpr Type Type_MAX = SurfaceMaterialAndConfidence_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = SurfaceMaterialAndConfidence_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Type_descriptor() {
    return SurfaceMaterialAndConfidence_Type_descriptor();
  }
  template <typename T>
  static inline const std::string& Type_Name(T value) {
    return SurfaceMaterialAndConfidence_Type_Name(value);
  }
  static inline bool Type_Parse(absl::string_view name, Type* value) {
    return SurfaceMaterialAndConfidence_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kConfidenceFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // .sensoris.protobuf.types.base.Confidence confidence = 2;
  bool has_confidence() const;
  void clear_confidence() ;
  const ::sensoris::protobuf::types::base::Confidence& confidence() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::Confidence* release_confidence();
  ::sensoris::protobuf::types::base::Confidence* mutable_confidence();
  void set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value);
  void unsafe_arena_set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value);
  ::sensoris::protobuf::types::base::Confidence* unsafe_arena_release_confidence();

  private:
  const ::sensoris::protobuf::types::base::Confidence& _internal_confidence() const;
  ::sensoris::protobuf::types::base::Confidence* _internal_mutable_confidence();

  public:
  // .sensoris.protobuf.categories.roadattribution.SurfaceMaterialAndConfidence.Type type = 1;
  void clear_type() ;
  ::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence_Type type() const;
  void set_type(::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence_Type value);

  private:
  ::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence_Type _internal_type() const;
  void _internal_set_type(::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence_Type value);

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.roadattribution.SurfaceMaterialAndConfidence)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::Confidence* confidence_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto;
};// -------------------------------------------------------------------

class SurfaceMarking_TypeAndConfidence final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.roadattribution.SurfaceMarking.TypeAndConfidence) */ {
 public:
  inline SurfaceMarking_TypeAndConfidence() : SurfaceMarking_TypeAndConfidence(nullptr) {}
  ~SurfaceMarking_TypeAndConfidence() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SurfaceMarking_TypeAndConfidence(::google::protobuf::internal::ConstantInitialized);

  inline SurfaceMarking_TypeAndConfidence(const SurfaceMarking_TypeAndConfidence& from)
      : SurfaceMarking_TypeAndConfidence(nullptr, from) {}
  SurfaceMarking_TypeAndConfidence(SurfaceMarking_TypeAndConfidence&& from) noexcept
    : SurfaceMarking_TypeAndConfidence() {
    *this = ::std::move(from);
  }

  inline SurfaceMarking_TypeAndConfidence& operator=(const SurfaceMarking_TypeAndConfidence& from) {
    CopyFrom(from);
    return *this;
  }
  inline SurfaceMarking_TypeAndConfidence& operator=(SurfaceMarking_TypeAndConfidence&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SurfaceMarking_TypeAndConfidence& default_instance() {
    return *internal_default_instance();
  }
  static inline const SurfaceMarking_TypeAndConfidence* internal_default_instance() {
    return reinterpret_cast<const SurfaceMarking_TypeAndConfidence*>(
               &_SurfaceMarking_TypeAndConfidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(SurfaceMarking_TypeAndConfidence& a, SurfaceMarking_TypeAndConfidence& b) {
    a.Swap(&b);
  }
  inline void Swap(SurfaceMarking_TypeAndConfidence* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SurfaceMarking_TypeAndConfidence* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SurfaceMarking_TypeAndConfidence* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SurfaceMarking_TypeAndConfidence>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SurfaceMarking_TypeAndConfidence& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SurfaceMarking_TypeAndConfidence& from) {
    SurfaceMarking_TypeAndConfidence::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SurfaceMarking_TypeAndConfidence* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.categories.roadattribution.SurfaceMarking.TypeAndConfidence";
  }
  protected:
  explicit SurfaceMarking_TypeAndConfidence(::google::protobuf::Arena* arena);
  SurfaceMarking_TypeAndConfidence(::google::protobuf::Arena* arena, const SurfaceMarking_TypeAndConfidence& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Type = SurfaceMarking_TypeAndConfidence_Type;
  static constexpr Type UNKNOWN_TYPE = SurfaceMarking_TypeAndConfidence_Type_UNKNOWN_TYPE;
  static constexpr Type SIGN = SurfaceMarking_TypeAndConfidence_Type_SIGN;
  static constexpr Type TEXT = SurfaceMarking_TypeAndConfidence_Type_TEXT;
  static constexpr Type ICON = SurfaceMarking_TypeAndConfidence_Type_ICON;
  static constexpr Type PATTERN = SurfaceMarking_TypeAndConfidence_Type_PATTERN;
  static constexpr Type PATTERN_CROSSWALK = SurfaceMarking_TypeAndConfidence_Type_PATTERN_CROSSWALK;
  static constexpr Type LINE_ELEMENT = SurfaceMarking_TypeAndConfidence_Type_LINE_ELEMENT;
  static constexpr Type STOP_LINE = SurfaceMarking_TypeAndConfidence_Type_STOP_LINE;
  static inline bool Type_IsValid(int value) {
    return SurfaceMarking_TypeAndConfidence_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = SurfaceMarking_TypeAndConfidence_Type_Type_MIN;
  static constexpr Type Type_MAX = SurfaceMarking_TypeAndConfidence_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = SurfaceMarking_TypeAndConfidence_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Type_descriptor() {
    return SurfaceMarking_TypeAndConfidence_Type_descriptor();
  }
  template <typename T>
  static inline const std::string& Type_Name(T value) {
    return SurfaceMarking_TypeAndConfidence_Type_Name(value);
  }
  static inline bool Type_Parse(absl::string_view name, Type* value) {
    return SurfaceMarking_TypeAndConfidence_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kConfidenceFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // .sensoris.protobuf.types.base.Confidence confidence = 2;
  bool has_confidence() const;
  void clear_confidence() ;
  const ::sensoris::protobuf::types::base::Confidence& confidence() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::Confidence* release_confidence();
  ::sensoris::protobuf::types::base::Confidence* mutable_confidence();
  void set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value);
  void unsafe_arena_set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value);
  ::sensoris::protobuf::types::base::Confidence* unsafe_arena_release_confidence();

  private:
  const ::sensoris::protobuf::types::base::Confidence& _internal_confidence() const;
  ::sensoris::protobuf::types::base::Confidence* _internal_mutable_confidence();

  public:
  // .sensoris.protobuf.categories.roadattribution.SurfaceMarking.TypeAndConfidence.Type type = 1;
  void clear_type() ;
  ::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence_Type type() const;
  void set_type(::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence_Type value);

  private:
  ::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence_Type _internal_type() const;
  void _internal_set_type(::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence_Type value);

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.roadattribution.SurfaceMarking.TypeAndConfidence)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::Confidence* confidence_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto;
};// -------------------------------------------------------------------

class RoadAttribution_TypeAndConfidence final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.roadattribution.RoadAttribution.TypeAndConfidence) */ {
 public:
  inline RoadAttribution_TypeAndConfidence() : RoadAttribution_TypeAndConfidence(nullptr) {}
  ~RoadAttribution_TypeAndConfidence() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RoadAttribution_TypeAndConfidence(::google::protobuf::internal::ConstantInitialized);

  inline RoadAttribution_TypeAndConfidence(const RoadAttribution_TypeAndConfidence& from)
      : RoadAttribution_TypeAndConfidence(nullptr, from) {}
  RoadAttribution_TypeAndConfidence(RoadAttribution_TypeAndConfidence&& from) noexcept
    : RoadAttribution_TypeAndConfidence() {
    *this = ::std::move(from);
  }

  inline RoadAttribution_TypeAndConfidence& operator=(const RoadAttribution_TypeAndConfidence& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoadAttribution_TypeAndConfidence& operator=(RoadAttribution_TypeAndConfidence&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoadAttribution_TypeAndConfidence& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoadAttribution_TypeAndConfidence* internal_default_instance() {
    return reinterpret_cast<const RoadAttribution_TypeAndConfidence*>(
               &_RoadAttribution_TypeAndConfidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(RoadAttribution_TypeAndConfidence& a, RoadAttribution_TypeAndConfidence& b) {
    a.Swap(&b);
  }
  inline void Swap(RoadAttribution_TypeAndConfidence* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoadAttribution_TypeAndConfidence* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoadAttribution_TypeAndConfidence* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoadAttribution_TypeAndConfidence>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RoadAttribution_TypeAndConfidence& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RoadAttribution_TypeAndConfidence& from) {
    RoadAttribution_TypeAndConfidence::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RoadAttribution_TypeAndConfidence* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.categories.roadattribution.RoadAttribution.TypeAndConfidence";
  }
  protected:
  explicit RoadAttribution_TypeAndConfidence(::google::protobuf::Arena* arena);
  RoadAttribution_TypeAndConfidence(::google::protobuf::Arena* arena, const RoadAttribution_TypeAndConfidence& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Type = RoadAttribution_TypeAndConfidence_Type;
  static constexpr Type UNKNOWN_TYPE = RoadAttribution_TypeAndConfidence_Type_UNKNOWN_TYPE;
  static constexpr Type MOTORWAY = RoadAttribution_TypeAndConfidence_Type_MOTORWAY;
  static constexpr Type ONE_WAY_TRAFFIC = RoadAttribution_TypeAndConfidence_Type_ONE_WAY_TRAFFIC;
  static constexpr Type TWO_WAY_TRAFFIC = RoadAttribution_TypeAndConfidence_Type_TWO_WAY_TRAFFIC;
  static constexpr Type OFFROAD = RoadAttribution_TypeAndConfidence_Type_OFFROAD;
  static constexpr Type TUNNEL = RoadAttribution_TypeAndConfidence_Type_TUNNEL;
  static constexpr Type BRIDGE = RoadAttribution_TypeAndConfidence_Type_BRIDGE;
  static constexpr Type ARTIFICIAL_ILLUMINATION = RoadAttribution_TypeAndConfidence_Type_ARTIFICIAL_ILLUMINATION;
  static constexpr Type ROAD_WORKS_NARROW_LANES = RoadAttribution_TypeAndConfidence_Type_ROAD_WORKS_NARROW_LANES;
  static constexpr Type LANE_RIGHT = RoadAttribution_TypeAndConfidence_Type_LANE_RIGHT;
  static constexpr Type LANE_LEFT = RoadAttribution_TypeAndConfidence_Type_LANE_LEFT;
  static constexpr Type LANE_SPLIT_MIDDLE = RoadAttribution_TypeAndConfidence_Type_LANE_SPLIT_MIDDLE;
  static constexpr Type LANE_MERGE_MIDDLE = RoadAttribution_TypeAndConfidence_Type_LANE_MERGE_MIDDLE;
  static constexpr Type CROSSWALK = RoadAttribution_TypeAndConfidence_Type_CROSSWALK;
  static constexpr Type CENTER_TURN_LANE = RoadAttribution_TypeAndConfidence_Type_CENTER_TURN_LANE;
  static inline bool Type_IsValid(int value) {
    return RoadAttribution_TypeAndConfidence_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = RoadAttribution_TypeAndConfidence_Type_Type_MIN;
  static constexpr Type Type_MAX = RoadAttribution_TypeAndConfidence_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = RoadAttribution_TypeAndConfidence_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Type_descriptor() {
    return RoadAttribution_TypeAndConfidence_Type_descriptor();
  }
  template <typename T>
  static inline const std::string& Type_Name(T value) {
    return RoadAttribution_TypeAndConfidence_Type_Name(value);
  }
  static inline bool Type_Parse(absl::string_view name, Type* value) {
    return RoadAttribution_TypeAndConfidence_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kConfidenceFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // .sensoris.protobuf.types.base.Confidence confidence = 2;
  bool has_confidence() const;
  void clear_confidence() ;
  const ::sensoris::protobuf::types::base::Confidence& confidence() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::Confidence* release_confidence();
  ::sensoris::protobuf::types::base::Confidence* mutable_confidence();
  void set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value);
  void unsafe_arena_set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value);
  ::sensoris::protobuf::types::base::Confidence* unsafe_arena_release_confidence();

  private:
  const ::sensoris::protobuf::types::base::Confidence& _internal_confidence() const;
  ::sensoris::protobuf::types::base::Confidence* _internal_mutable_confidence();

  public:
  // .sensoris.protobuf.categories.roadattribution.RoadAttribution.TypeAndConfidence.Type type = 1;
  void clear_type() ;
  ::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence_Type type() const;
  void set_type(::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence_Type value);

  private:
  ::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence_Type _internal_type() const;
  void _internal_set_type(::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence_Type value);

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.roadattribution.RoadAttribution.TypeAndConfidence)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::Confidence* confidence_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto;
};// -------------------------------------------------------------------

class RoadAttribution_ChangeTypeAndConfidence final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.roadattribution.RoadAttribution.ChangeTypeAndConfidence) */ {
 public:
  inline RoadAttribution_ChangeTypeAndConfidence() : RoadAttribution_ChangeTypeAndConfidence(nullptr) {}
  ~RoadAttribution_ChangeTypeAndConfidence() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RoadAttribution_ChangeTypeAndConfidence(::google::protobuf::internal::ConstantInitialized);

  inline RoadAttribution_ChangeTypeAndConfidence(const RoadAttribution_ChangeTypeAndConfidence& from)
      : RoadAttribution_ChangeTypeAndConfidence(nullptr, from) {}
  RoadAttribution_ChangeTypeAndConfidence(RoadAttribution_ChangeTypeAndConfidence&& from) noexcept
    : RoadAttribution_ChangeTypeAndConfidence() {
    *this = ::std::move(from);
  }

  inline RoadAttribution_ChangeTypeAndConfidence& operator=(const RoadAttribution_ChangeTypeAndConfidence& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoadAttribution_ChangeTypeAndConfidence& operator=(RoadAttribution_ChangeTypeAndConfidence&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoadAttribution_ChangeTypeAndConfidence& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoadAttribution_ChangeTypeAndConfidence* internal_default_instance() {
    return reinterpret_cast<const RoadAttribution_ChangeTypeAndConfidence*>(
               &_RoadAttribution_ChangeTypeAndConfidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(RoadAttribution_ChangeTypeAndConfidence& a, RoadAttribution_ChangeTypeAndConfidence& b) {
    a.Swap(&b);
  }
  inline void Swap(RoadAttribution_ChangeTypeAndConfidence* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoadAttribution_ChangeTypeAndConfidence* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoadAttribution_ChangeTypeAndConfidence* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoadAttribution_ChangeTypeAndConfidence>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RoadAttribution_ChangeTypeAndConfidence& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RoadAttribution_ChangeTypeAndConfidence& from) {
    RoadAttribution_ChangeTypeAndConfidence::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RoadAttribution_ChangeTypeAndConfidence* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.categories.roadattribution.RoadAttribution.ChangeTypeAndConfidence";
  }
  protected:
  explicit RoadAttribution_ChangeTypeAndConfidence(::google::protobuf::Arena* arena);
  RoadAttribution_ChangeTypeAndConfidence(::google::protobuf::Arena* arena, const RoadAttribution_ChangeTypeAndConfidence& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Type = RoadAttribution_ChangeTypeAndConfidence_Type;
  static constexpr Type UNKNOWN_TYPE = RoadAttribution_ChangeTypeAndConfidence_Type_UNKNOWN_TYPE;
  static constexpr Type DETECTED = RoadAttribution_ChangeTypeAndConfidence_Type_DETECTED;
  static constexpr Type START = RoadAttribution_ChangeTypeAndConfidence_Type_START;
  static constexpr Type END = RoadAttribution_ChangeTypeAndConfidence_Type_END;
  static inline bool Type_IsValid(int value) {
    return RoadAttribution_ChangeTypeAndConfidence_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = RoadAttribution_ChangeTypeAndConfidence_Type_Type_MIN;
  static constexpr Type Type_MAX = RoadAttribution_ChangeTypeAndConfidence_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = RoadAttribution_ChangeTypeAndConfidence_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Type_descriptor() {
    return RoadAttribution_ChangeTypeAndConfidence_Type_descriptor();
  }
  template <typename T>
  static inline const std::string& Type_Name(T value) {
    return RoadAttribution_ChangeTypeAndConfidence_Type_Name(value);
  }
  static inline bool Type_Parse(absl::string_view name, Type* value) {
    return RoadAttribution_ChangeTypeAndConfidence_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kConfidenceFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // .sensoris.protobuf.types.base.Confidence confidence = 2;
  bool has_confidence() const;
  void clear_confidence() ;
  const ::sensoris::protobuf::types::base::Confidence& confidence() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::Confidence* release_confidence();
  ::sensoris::protobuf::types::base::Confidence* mutable_confidence();
  void set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value);
  void unsafe_arena_set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value);
  ::sensoris::protobuf::types::base::Confidence* unsafe_arena_release_confidence();

  private:
  const ::sensoris::protobuf::types::base::Confidence& _internal_confidence() const;
  ::sensoris::protobuf::types::base::Confidence* _internal_mutable_confidence();

  public:
  // .sensoris.protobuf.categories.roadattribution.RoadAttribution.ChangeTypeAndConfidence.Type type = 1;
  void clear_type() ;
  ::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence_Type type() const;
  void set_type(::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence_Type value);

  private:
  ::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence_Type _internal_type() const;
  void _internal_set_type(::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence_Type value);

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.roadattribution.RoadAttribution.ChangeTypeAndConfidence)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::Confidence* confidence_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto;
};// -------------------------------------------------------------------

class MarkingMaterialAndConfidence final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.roadattribution.MarkingMaterialAndConfidence) */ {
 public:
  inline MarkingMaterialAndConfidence() : MarkingMaterialAndConfidence(nullptr) {}
  ~MarkingMaterialAndConfidence() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MarkingMaterialAndConfidence(::google::protobuf::internal::ConstantInitialized);

  inline MarkingMaterialAndConfidence(const MarkingMaterialAndConfidence& from)
      : MarkingMaterialAndConfidence(nullptr, from) {}
  MarkingMaterialAndConfidence(MarkingMaterialAndConfidence&& from) noexcept
    : MarkingMaterialAndConfidence() {
    *this = ::std::move(from);
  }

  inline MarkingMaterialAndConfidence& operator=(const MarkingMaterialAndConfidence& from) {
    CopyFrom(from);
    return *this;
  }
  inline MarkingMaterialAndConfidence& operator=(MarkingMaterialAndConfidence&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MarkingMaterialAndConfidence& default_instance() {
    return *internal_default_instance();
  }
  static inline const MarkingMaterialAndConfidence* internal_default_instance() {
    return reinterpret_cast<const MarkingMaterialAndConfidence*>(
               &_MarkingMaterialAndConfidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(MarkingMaterialAndConfidence& a, MarkingMaterialAndConfidence& b) {
    a.Swap(&b);
  }
  inline void Swap(MarkingMaterialAndConfidence* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MarkingMaterialAndConfidence* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MarkingMaterialAndConfidence* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MarkingMaterialAndConfidence>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MarkingMaterialAndConfidence& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MarkingMaterialAndConfidence& from) {
    MarkingMaterialAndConfidence::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MarkingMaterialAndConfidence* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.categories.roadattribution.MarkingMaterialAndConfidence";
  }
  protected:
  explicit MarkingMaterialAndConfidence(::google::protobuf::Arena* arena);
  MarkingMaterialAndConfidence(::google::protobuf::Arena* arena, const MarkingMaterialAndConfidence& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Type = MarkingMaterialAndConfidence_Type;
  static constexpr Type UNKNOWN_TYPE = MarkingMaterialAndConfidence_Type_UNKNOWN_TYPE;
  static constexpr Type METAL = MarkingMaterialAndConfidence_Type_METAL;
  static constexpr Type CONCRETE = MarkingMaterialAndConfidence_Type_CONCRETE;
  static constexpr Type STONE = MarkingMaterialAndConfidence_Type_STONE;
  static constexpr Type WOOD = MarkingMaterialAndConfidence_Type_WOOD;
  static constexpr Type PLASTIC = MarkingMaterialAndConfidence_Type_PLASTIC;
  static constexpr Type TRANSPARENT = MarkingMaterialAndConfidence_Type_TRANSPARENT;
  static constexpr Type VIBRATION_MARKINGS = MarkingMaterialAndConfidence_Type_VIBRATION_MARKINGS;
  static constexpr Type PAINT = MarkingMaterialAndConfidence_Type_PAINT;
  static constexpr Type ASPHALT = MarkingMaterialAndConfidence_Type_ASPHALT;
  static constexpr Type GRAVEL = MarkingMaterialAndConfidence_Type_GRAVEL;
  static constexpr Type COBBLESTONE = MarkingMaterialAndConfidence_Type_COBBLESTONE;
  static inline bool Type_IsValid(int value) {
    return MarkingMaterialAndConfidence_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = MarkingMaterialAndConfidence_Type_Type_MIN;
  static constexpr Type Type_MAX = MarkingMaterialAndConfidence_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = MarkingMaterialAndConfidence_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Type_descriptor() {
    return MarkingMaterialAndConfidence_Type_descriptor();
  }
  template <typename T>
  static inline const std::string& Type_Name(T value) {
    return MarkingMaterialAndConfidence_Type_Name(value);
  }
  static inline bool Type_Parse(absl::string_view name, Type* value) {
    return MarkingMaterialAndConfidence_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kConfidenceFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // .sensoris.protobuf.types.base.Confidence confidence = 2;
  bool has_confidence() const;
  void clear_confidence() ;
  const ::sensoris::protobuf::types::base::Confidence& confidence() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::Confidence* release_confidence();
  ::sensoris::protobuf::types::base::Confidence* mutable_confidence();
  void set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value);
  void unsafe_arena_set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value);
  ::sensoris::protobuf::types::base::Confidence* unsafe_arena_release_confidence();

  private:
  const ::sensoris::protobuf::types::base::Confidence& _internal_confidence() const;
  ::sensoris::protobuf::types::base::Confidence* _internal_mutable_confidence();

  public:
  // .sensoris.protobuf.categories.roadattribution.MarkingMaterialAndConfidence.Type type = 1;
  void clear_type() ;
  ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence_Type type() const;
  void set_type(::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence_Type value);

  private:
  ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence_Type _internal_type() const;
  void _internal_set_type(::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence_Type value);

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.roadattribution.MarkingMaterialAndConfidence)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::Confidence* confidence_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto;
};// -------------------------------------------------------------------

class MarkingColorAndConfidence final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.roadattribution.MarkingColorAndConfidence) */ {
 public:
  inline MarkingColorAndConfidence() : MarkingColorAndConfidence(nullptr) {}
  ~MarkingColorAndConfidence() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MarkingColorAndConfidence(::google::protobuf::internal::ConstantInitialized);

  inline MarkingColorAndConfidence(const MarkingColorAndConfidence& from)
      : MarkingColorAndConfidence(nullptr, from) {}
  MarkingColorAndConfidence(MarkingColorAndConfidence&& from) noexcept
    : MarkingColorAndConfidence() {
    *this = ::std::move(from);
  }

  inline MarkingColorAndConfidence& operator=(const MarkingColorAndConfidence& from) {
    CopyFrom(from);
    return *this;
  }
  inline MarkingColorAndConfidence& operator=(MarkingColorAndConfidence&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MarkingColorAndConfidence& default_instance() {
    return *internal_default_instance();
  }
  static inline const MarkingColorAndConfidence* internal_default_instance() {
    return reinterpret_cast<const MarkingColorAndConfidence*>(
               &_MarkingColorAndConfidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(MarkingColorAndConfidence& a, MarkingColorAndConfidence& b) {
    a.Swap(&b);
  }
  inline void Swap(MarkingColorAndConfidence* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MarkingColorAndConfidence* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MarkingColorAndConfidence* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MarkingColorAndConfidence>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MarkingColorAndConfidence& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MarkingColorAndConfidence& from) {
    MarkingColorAndConfidence::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MarkingColorAndConfidence* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.categories.roadattribution.MarkingColorAndConfidence";
  }
  protected:
  explicit MarkingColorAndConfidence(::google::protobuf::Arena* arena);
  MarkingColorAndConfidence(::google::protobuf::Arena* arena, const MarkingColorAndConfidence& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Type = MarkingColorAndConfidence_Type;
  static constexpr Type UNKNOWN_TYPE = MarkingColorAndConfidence_Type_UNKNOWN_TYPE;
  static constexpr Type WHITE = MarkingColorAndConfidence_Type_WHITE;
  static constexpr Type GRAY = MarkingColorAndConfidence_Type_GRAY;
  static constexpr Type GRAY_LIGHT = MarkingColorAndConfidence_Type_GRAY_LIGHT;
  static constexpr Type GRAY_DARK = MarkingColorAndConfidence_Type_GRAY_DARK;
  static constexpr Type BLACK = MarkingColorAndConfidence_Type_BLACK;
  static constexpr Type RED = MarkingColorAndConfidence_Type_RED;
  static constexpr Type YELLOW = MarkingColorAndConfidence_Type_YELLOW;
  static constexpr Type GREEN = MarkingColorAndConfidence_Type_GREEN;
  static constexpr Type CYAN = MarkingColorAndConfidence_Type_CYAN;
  static constexpr Type BLUE = MarkingColorAndConfidence_Type_BLUE;
  static constexpr Type ORANGE = MarkingColorAndConfidence_Type_ORANGE;
  static constexpr Type PINK = MarkingColorAndConfidence_Type_PINK;
  static constexpr Type PURPLE = MarkingColorAndConfidence_Type_PURPLE;
  static inline bool Type_IsValid(int value) {
    return MarkingColorAndConfidence_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = MarkingColorAndConfidence_Type_Type_MIN;
  static constexpr Type Type_MAX = MarkingColorAndConfidence_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = MarkingColorAndConfidence_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Type_descriptor() {
    return MarkingColorAndConfidence_Type_descriptor();
  }
  template <typename T>
  static inline const std::string& Type_Name(T value) {
    return MarkingColorAndConfidence_Type_Name(value);
  }
  static inline bool Type_Parse(absl::string_view name, Type* value) {
    return MarkingColorAndConfidence_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kConfidenceFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // .sensoris.protobuf.types.base.Confidence confidence = 2;
  bool has_confidence() const;
  void clear_confidence() ;
  const ::sensoris::protobuf::types::base::Confidence& confidence() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::Confidence* release_confidence();
  ::sensoris::protobuf::types::base::Confidence* mutable_confidence();
  void set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value);
  void unsafe_arena_set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value);
  ::sensoris::protobuf::types::base::Confidence* unsafe_arena_release_confidence();

  private:
  const ::sensoris::protobuf::types::base::Confidence& _internal_confidence() const;
  ::sensoris::protobuf::types::base::Confidence* _internal_mutable_confidence();

  public:
  // .sensoris.protobuf.categories.roadattribution.MarkingColorAndConfidence.Type type = 1;
  void clear_type() ;
  ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence_Type type() const;
  void set_type(::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence_Type value);

  private:
  ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence_Type _internal_type() const;
  void _internal_set_type(::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence_Type value);

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.roadattribution.MarkingColorAndConfidence)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::Confidence* confidence_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto;
};// -------------------------------------------------------------------

class LaneBoundaryMergeSplit_TypeAndConfidence final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.TypeAndConfidence) */ {
 public:
  inline LaneBoundaryMergeSplit_TypeAndConfidence() : LaneBoundaryMergeSplit_TypeAndConfidence(nullptr) {}
  ~LaneBoundaryMergeSplit_TypeAndConfidence() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LaneBoundaryMergeSplit_TypeAndConfidence(::google::protobuf::internal::ConstantInitialized);

  inline LaneBoundaryMergeSplit_TypeAndConfidence(const LaneBoundaryMergeSplit_TypeAndConfidence& from)
      : LaneBoundaryMergeSplit_TypeAndConfidence(nullptr, from) {}
  LaneBoundaryMergeSplit_TypeAndConfidence(LaneBoundaryMergeSplit_TypeAndConfidence&& from) noexcept
    : LaneBoundaryMergeSplit_TypeAndConfidence() {
    *this = ::std::move(from);
  }

  inline LaneBoundaryMergeSplit_TypeAndConfidence& operator=(const LaneBoundaryMergeSplit_TypeAndConfidence& from) {
    CopyFrom(from);
    return *this;
  }
  inline LaneBoundaryMergeSplit_TypeAndConfidence& operator=(LaneBoundaryMergeSplit_TypeAndConfidence&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LaneBoundaryMergeSplit_TypeAndConfidence& default_instance() {
    return *internal_default_instance();
  }
  static inline const LaneBoundaryMergeSplit_TypeAndConfidence* internal_default_instance() {
    return reinterpret_cast<const LaneBoundaryMergeSplit_TypeAndConfidence*>(
               &_LaneBoundaryMergeSplit_TypeAndConfidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(LaneBoundaryMergeSplit_TypeAndConfidence& a, LaneBoundaryMergeSplit_TypeAndConfidence& b) {
    a.Swap(&b);
  }
  inline void Swap(LaneBoundaryMergeSplit_TypeAndConfidence* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LaneBoundaryMergeSplit_TypeAndConfidence* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LaneBoundaryMergeSplit_TypeAndConfidence* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LaneBoundaryMergeSplit_TypeAndConfidence>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LaneBoundaryMergeSplit_TypeAndConfidence& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const LaneBoundaryMergeSplit_TypeAndConfidence& from) {
    LaneBoundaryMergeSplit_TypeAndConfidence::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(LaneBoundaryMergeSplit_TypeAndConfidence* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.TypeAndConfidence";
  }
  protected:
  explicit LaneBoundaryMergeSplit_TypeAndConfidence(::google::protobuf::Arena* arena);
  LaneBoundaryMergeSplit_TypeAndConfidence(::google::protobuf::Arena* arena, const LaneBoundaryMergeSplit_TypeAndConfidence& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Type = LaneBoundaryMergeSplit_TypeAndConfidence_Type;
  static constexpr Type UNKNOWN_TYPE = LaneBoundaryMergeSplit_TypeAndConfidence_Type_UNKNOWN_TYPE;
  static constexpr Type MERGE = LaneBoundaryMergeSplit_TypeAndConfidence_Type_MERGE;
  static constexpr Type SPLIT = LaneBoundaryMergeSplit_TypeAndConfidence_Type_SPLIT;
  static inline bool Type_IsValid(int value) {
    return LaneBoundaryMergeSplit_TypeAndConfidence_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = LaneBoundaryMergeSplit_TypeAndConfidence_Type_Type_MIN;
  static constexpr Type Type_MAX = LaneBoundaryMergeSplit_TypeAndConfidence_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = LaneBoundaryMergeSplit_TypeAndConfidence_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Type_descriptor() {
    return LaneBoundaryMergeSplit_TypeAndConfidence_Type_descriptor();
  }
  template <typename T>
  static inline const std::string& Type_Name(T value) {
    return LaneBoundaryMergeSplit_TypeAndConfidence_Type_Name(value);
  }
  static inline bool Type_Parse(absl::string_view name, Type* value) {
    return LaneBoundaryMergeSplit_TypeAndConfidence_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kConfidenceFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // .sensoris.protobuf.types.base.Confidence confidence = 2;
  bool has_confidence() const;
  void clear_confidence() ;
  const ::sensoris::protobuf::types::base::Confidence& confidence() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::Confidence* release_confidence();
  ::sensoris::protobuf::types::base::Confidence* mutable_confidence();
  void set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value);
  void unsafe_arena_set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value);
  ::sensoris::protobuf::types::base::Confidence* unsafe_arena_release_confidence();

  private:
  const ::sensoris::protobuf::types::base::Confidence& _internal_confidence() const;
  ::sensoris::protobuf::types::base::Confidence* _internal_mutable_confidence();

  public:
  // .sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.TypeAndConfidence.Type type = 1;
  void clear_type() ;
  ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence_Type type() const;
  void set_type(::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence_Type value);

  private:
  ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence_Type _internal_type() const;
  void _internal_set_type(::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence_Type value);

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.TypeAndConfidence)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::Confidence* confidence_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto;
};// -------------------------------------------------------------------

class LaneBoundary_TypeAndConfidence final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.roadattribution.LaneBoundary.TypeAndConfidence) */ {
 public:
  inline LaneBoundary_TypeAndConfidence() : LaneBoundary_TypeAndConfidence(nullptr) {}
  ~LaneBoundary_TypeAndConfidence() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LaneBoundary_TypeAndConfidence(::google::protobuf::internal::ConstantInitialized);

  inline LaneBoundary_TypeAndConfidence(const LaneBoundary_TypeAndConfidence& from)
      : LaneBoundary_TypeAndConfidence(nullptr, from) {}
  LaneBoundary_TypeAndConfidence(LaneBoundary_TypeAndConfidence&& from) noexcept
    : LaneBoundary_TypeAndConfidence() {
    *this = ::std::move(from);
  }

  inline LaneBoundary_TypeAndConfidence& operator=(const LaneBoundary_TypeAndConfidence& from) {
    CopyFrom(from);
    return *this;
  }
  inline LaneBoundary_TypeAndConfidence& operator=(LaneBoundary_TypeAndConfidence&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LaneBoundary_TypeAndConfidence& default_instance() {
    return *internal_default_instance();
  }
  static inline const LaneBoundary_TypeAndConfidence* internal_default_instance() {
    return reinterpret_cast<const LaneBoundary_TypeAndConfidence*>(
               &_LaneBoundary_TypeAndConfidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(LaneBoundary_TypeAndConfidence& a, LaneBoundary_TypeAndConfidence& b) {
    a.Swap(&b);
  }
  inline void Swap(LaneBoundary_TypeAndConfidence* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LaneBoundary_TypeAndConfidence* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LaneBoundary_TypeAndConfidence* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LaneBoundary_TypeAndConfidence>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LaneBoundary_TypeAndConfidence& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const LaneBoundary_TypeAndConfidence& from) {
    LaneBoundary_TypeAndConfidence::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(LaneBoundary_TypeAndConfidence* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.categories.roadattribution.LaneBoundary.TypeAndConfidence";
  }
  protected:
  explicit LaneBoundary_TypeAndConfidence(::google::protobuf::Arena* arena);
  LaneBoundary_TypeAndConfidence(::google::protobuf::Arena* arena, const LaneBoundary_TypeAndConfidence& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Type = LaneBoundary_TypeAndConfidence_Type;
  static constexpr Type UNKNOWN_TYPE = LaneBoundary_TypeAndConfidence_Type_UNKNOWN_TYPE;
  static constexpr Type LINE = LaneBoundary_TypeAndConfidence_Type_LINE;
  static constexpr Type LINE_SINGLE = LaneBoundary_TypeAndConfidence_Type_LINE_SINGLE;
  static constexpr Type LINE_SINGLE_SOLID = LaneBoundary_TypeAndConfidence_Type_LINE_SINGLE_SOLID;
  static constexpr Type LINE_SINGLE_DASHED = LaneBoundary_TypeAndConfidence_Type_LINE_SINGLE_DASHED;
  static constexpr Type LINE_SINGLE_DASHED_SHORT = LaneBoundary_TypeAndConfidence_Type_LINE_SINGLE_DASHED_SHORT;
  static constexpr Type LINE_SINGLE_DASHED_LONG = LaneBoundary_TypeAndConfidence_Type_LINE_SINGLE_DASHED_LONG;
  static constexpr Type LINE_DOUBLE = LaneBoundary_TypeAndConfidence_Type_LINE_DOUBLE;
  static constexpr Type LINE_DOUBLE_SOLID = LaneBoundary_TypeAndConfidence_Type_LINE_DOUBLE_SOLID;
  static constexpr Type LINE_DOUBLE_DASHED = LaneBoundary_TypeAndConfidence_Type_LINE_DOUBLE_DASHED;
  static constexpr Type LINE_DOUBLE_SOLID_DASHED = LaneBoundary_TypeAndConfidence_Type_LINE_DOUBLE_SOLID_DASHED;
  static constexpr Type LINE_DOUBLE_DASHED_SOLID = LaneBoundary_TypeAndConfidence_Type_LINE_DOUBLE_DASHED_SOLID;
  static constexpr Type SHADED_AREA_MARKING = LaneBoundary_TypeAndConfidence_Type_SHADED_AREA_MARKING;
  static constexpr Type BLOCKS_DASHED = LaneBoundary_TypeAndConfidence_Type_BLOCKS_DASHED;
  static constexpr Type CROSSING_ALERT = LaneBoundary_TypeAndConfidence_Type_CROSSING_ALERT;
  static constexpr Type CURB = LaneBoundary_TypeAndConfidence_Type_CURB;
  static constexpr Type CURB_TRAVERSABLE = LaneBoundary_TypeAndConfidence_Type_CURB_TRAVERSABLE;
  static constexpr Type CURB_NON_TRAVERSABLE = LaneBoundary_TypeAndConfidence_Type_CURB_NON_TRAVERSABLE;
  static constexpr Type PHYSICAL_DIVIDER = LaneBoundary_TypeAndConfidence_Type_PHYSICAL_DIVIDER;
  static constexpr Type WALL = LaneBoundary_TypeAndConfidence_Type_WALL;
  static constexpr Type WALL_FLAT = LaneBoundary_TypeAndConfidence_Type_WALL_FLAT;
  static constexpr Type WALL_CURVED = LaneBoundary_TypeAndConfidence_Type_WALL_CURVED;
  static constexpr Type BARRIER = LaneBoundary_TypeAndConfidence_Type_BARRIER;
  static constexpr Type BARRIER_JERSEY = LaneBoundary_TypeAndConfidence_Type_BARRIER_JERSEY;
  static constexpr Type BARRIER_SOUND = LaneBoundary_TypeAndConfidence_Type_BARRIER_SOUND;
  static constexpr Type BARRIER_CABLE = LaneBoundary_TypeAndConfidence_Type_BARRIER_CABLE;
  static constexpr Type GUARDRAIL = LaneBoundary_TypeAndConfidence_Type_GUARDRAIL;
  static constexpr Type FENCE = LaneBoundary_TypeAndConfidence_Type_FENCE;
  static constexpr Type ROAD_EDGE = LaneBoundary_TypeAndConfidence_Type_ROAD_EDGE;
  static constexpr Type CLIFF = LaneBoundary_TypeAndConfidence_Type_CLIFF;
  static constexpr Type DITCH = LaneBoundary_TypeAndConfidence_Type_DITCH;
  static constexpr Type ASPHALT_JOINT = LaneBoundary_TypeAndConfidence_Type_ASPHALT_JOINT;
  static constexpr Type LINE_MULTIPLE = LaneBoundary_TypeAndConfidence_Type_LINE_MULTIPLE;
  static constexpr Type LINE_MULTIPLE_ALL_DASHED = LaneBoundary_TypeAndConfidence_Type_LINE_MULTIPLE_ALL_DASHED;
  static constexpr Type LINE_MULTIPLE_ANY_SOLID = LaneBoundary_TypeAndConfidence_Type_LINE_MULTIPLE_ANY_SOLID;
  static constexpr Type PHYSICAL_DIVIDER_CONTINUOUS = LaneBoundary_TypeAndConfidence_Type_PHYSICAL_DIVIDER_CONTINUOUS;
  static constexpr Type PHYSICAL_DIVIDER_DISCONTINUOUS = LaneBoundary_TypeAndConfidence_Type_PHYSICAL_DIVIDER_DISCONTINUOUS;
  static constexpr Type LINE_DOUBLE_DASHED_OR_DOUBLE_SOLID_DASHED = LaneBoundary_TypeAndConfidence_Type_LINE_DOUBLE_DASHED_OR_DOUBLE_SOLID_DASHED;
  static constexpr Type LINE_DOUBLE_DASHED_OR_DOUBLE_DASHED_SOLID = LaneBoundary_TypeAndConfidence_Type_LINE_DOUBLE_DASHED_OR_DOUBLE_DASHED_SOLID;
  static constexpr Type LINE_DOUBLE_SOLID_OR_DOUBLE_SOLID_DASHED = LaneBoundary_TypeAndConfidence_Type_LINE_DOUBLE_SOLID_OR_DOUBLE_SOLID_DASHED;
  static constexpr Type LINE_DOUBLE_SOLID_OR_DOUBLE_DASHED_SOLID = LaneBoundary_TypeAndConfidence_Type_LINE_DOUBLE_SOLID_OR_DOUBLE_DASHED_SOLID;
  static inline bool Type_IsValid(int value) {
    return LaneBoundary_TypeAndConfidence_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = LaneBoundary_TypeAndConfidence_Type_Type_MIN;
  static constexpr Type Type_MAX = LaneBoundary_TypeAndConfidence_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = LaneBoundary_TypeAndConfidence_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Type_descriptor() {
    return LaneBoundary_TypeAndConfidence_Type_descriptor();
  }
  template <typename T>
  static inline const std::string& Type_Name(T value) {
    return LaneBoundary_TypeAndConfidence_Type_Name(value);
  }
  static inline bool Type_Parse(absl::string_view name, Type* value) {
    return LaneBoundary_TypeAndConfidence_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kConfidenceFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // .sensoris.protobuf.types.base.Confidence confidence = 2;
  bool has_confidence() const;
  void clear_confidence() ;
  const ::sensoris::protobuf::types::base::Confidence& confidence() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::Confidence* release_confidence();
  ::sensoris::protobuf::types::base::Confidence* mutable_confidence();
  void set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value);
  void unsafe_arena_set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value);
  ::sensoris::protobuf::types::base::Confidence* unsafe_arena_release_confidence();

  private:
  const ::sensoris::protobuf::types::base::Confidence& _internal_confidence() const;
  ::sensoris::protobuf::types::base::Confidence* _internal_mutable_confidence();

  public:
  // .sensoris.protobuf.categories.roadattribution.LaneBoundary.TypeAndConfidence.Type type = 1;
  void clear_type() ;
  ::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence_Type type() const;
  void set_type(::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence_Type value);

  private:
  ::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence_Type _internal_type() const;
  void _internal_set_type(::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence_Type value);

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.roadattribution.LaneBoundary.TypeAndConfidence)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::Confidence* confidence_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto;
};// -------------------------------------------------------------------

class LaneBoundary_MarkingOffsets_TypeAndOffset final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.roadattribution.LaneBoundary.MarkingOffsets.TypeAndOffset) */ {
 public:
  inline LaneBoundary_MarkingOffsets_TypeAndOffset() : LaneBoundary_MarkingOffsets_TypeAndOffset(nullptr) {}
  ~LaneBoundary_MarkingOffsets_TypeAndOffset() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LaneBoundary_MarkingOffsets_TypeAndOffset(::google::protobuf::internal::ConstantInitialized);

  inline LaneBoundary_MarkingOffsets_TypeAndOffset(const LaneBoundary_MarkingOffsets_TypeAndOffset& from)
      : LaneBoundary_MarkingOffsets_TypeAndOffset(nullptr, from) {}
  LaneBoundary_MarkingOffsets_TypeAndOffset(LaneBoundary_MarkingOffsets_TypeAndOffset&& from) noexcept
    : LaneBoundary_MarkingOffsets_TypeAndOffset() {
    *this = ::std::move(from);
  }

  inline LaneBoundary_MarkingOffsets_TypeAndOffset& operator=(const LaneBoundary_MarkingOffsets_TypeAndOffset& from) {
    CopyFrom(from);
    return *this;
  }
  inline LaneBoundary_MarkingOffsets_TypeAndOffset& operator=(LaneBoundary_MarkingOffsets_TypeAndOffset&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LaneBoundary_MarkingOffsets_TypeAndOffset& default_instance() {
    return *internal_default_instance();
  }
  static inline const LaneBoundary_MarkingOffsets_TypeAndOffset* internal_default_instance() {
    return reinterpret_cast<const LaneBoundary_MarkingOffsets_TypeAndOffset*>(
               &_LaneBoundary_MarkingOffsets_TypeAndOffset_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(LaneBoundary_MarkingOffsets_TypeAndOffset& a, LaneBoundary_MarkingOffsets_TypeAndOffset& b) {
    a.Swap(&b);
  }
  inline void Swap(LaneBoundary_MarkingOffsets_TypeAndOffset* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LaneBoundary_MarkingOffsets_TypeAndOffset* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LaneBoundary_MarkingOffsets_TypeAndOffset* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LaneBoundary_MarkingOffsets_TypeAndOffset>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LaneBoundary_MarkingOffsets_TypeAndOffset& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const LaneBoundary_MarkingOffsets_TypeAndOffset& from) {
    LaneBoundary_MarkingOffsets_TypeAndOffset::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(LaneBoundary_MarkingOffsets_TypeAndOffset* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.categories.roadattribution.LaneBoundary.MarkingOffsets.TypeAndOffset";
  }
  protected:
  explicit LaneBoundary_MarkingOffsets_TypeAndOffset(::google::protobuf::Arena* arena);
  LaneBoundary_MarkingOffsets_TypeAndOffset(::google::protobuf::Arena* arena, const LaneBoundary_MarkingOffsets_TypeAndOffset& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Type = LaneBoundary_MarkingOffsets_TypeAndOffset_Type;
  static constexpr Type UNKNOWN_TYPE = LaneBoundary_MarkingOffsets_TypeAndOffset_Type_UNKNOWN_TYPE;
  static constexpr Type START_OF_MARKING = LaneBoundary_MarkingOffsets_TypeAndOffset_Type_START_OF_MARKING;
  static constexpr Type END_OF_MARKING = LaneBoundary_MarkingOffsets_TypeAndOffset_Type_END_OF_MARKING;
  static constexpr Type ON_MARKING = LaneBoundary_MarkingOffsets_TypeAndOffset_Type_ON_MARKING;
  static constexpr Type NO_MARKING = LaneBoundary_MarkingOffsets_TypeAndOffset_Type_NO_MARKING;
  static inline bool Type_IsValid(int value) {
    return LaneBoundary_MarkingOffsets_TypeAndOffset_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = LaneBoundary_MarkingOffsets_TypeAndOffset_Type_Type_MIN;
  static constexpr Type Type_MAX = LaneBoundary_MarkingOffsets_TypeAndOffset_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = LaneBoundary_MarkingOffsets_TypeAndOffset_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Type_descriptor() {
    return LaneBoundary_MarkingOffsets_TypeAndOffset_Type_descriptor();
  }
  template <typename T>
  static inline const std::string& Type_Name(T value) {
    return LaneBoundary_MarkingOffsets_TypeAndOffset_Type_Name(value);
  }
  static inline bool Type_Parse(absl::string_view name, Type* value) {
    return LaneBoundary_MarkingOffsets_TypeAndOffset_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kOffsetAndAccuracyFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // .sensoris.protobuf.types.base.Int64ValueAndAccuracy offset_and_accuracy = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_offset_and_accuracy() const;
  void clear_offset_and_accuracy() ;
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& offset_and_accuracy() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* release_offset_and_accuracy();
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* mutable_offset_and_accuracy();
  void set_allocated_offset_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* value);
  void unsafe_arena_set_allocated_offset_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* value);
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* unsafe_arena_release_offset_and_accuracy();

  private:
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& _internal_offset_and_accuracy() const;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* _internal_mutable_offset_and_accuracy();

  public:
  // .sensoris.protobuf.categories.roadattribution.LaneBoundary.MarkingOffsets.TypeAndOffset.Type type = 1;
  void clear_type() ;
  ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset_Type type() const;
  void set_type(::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset_Type value);

  private:
  ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset_Type _internal_type() const;
  void _internal_set_type(::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset_Type value);

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.roadattribution.LaneBoundary.MarkingOffsets.TypeAndOffset)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* offset_and_accuracy_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto;
};// -------------------------------------------------------------------

class LaneBoundary_DashStatistics final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.roadattribution.LaneBoundary.DashStatistics) */ {
 public:
  inline LaneBoundary_DashStatistics() : LaneBoundary_DashStatistics(nullptr) {}
  ~LaneBoundary_DashStatistics() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LaneBoundary_DashStatistics(::google::protobuf::internal::ConstantInitialized);

  inline LaneBoundary_DashStatistics(const LaneBoundary_DashStatistics& from)
      : LaneBoundary_DashStatistics(nullptr, from) {}
  LaneBoundary_DashStatistics(LaneBoundary_DashStatistics&& from) noexcept
    : LaneBoundary_DashStatistics() {
    *this = ::std::move(from);
  }

  inline LaneBoundary_DashStatistics& operator=(const LaneBoundary_DashStatistics& from) {
    CopyFrom(from);
    return *this;
  }
  inline LaneBoundary_DashStatistics& operator=(LaneBoundary_DashStatistics&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LaneBoundary_DashStatistics& default_instance() {
    return *internal_default_instance();
  }
  static inline const LaneBoundary_DashStatistics* internal_default_instance() {
    return reinterpret_cast<const LaneBoundary_DashStatistics*>(
               &_LaneBoundary_DashStatistics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(LaneBoundary_DashStatistics& a, LaneBoundary_DashStatistics& b) {
    a.Swap(&b);
  }
  inline void Swap(LaneBoundary_DashStatistics* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LaneBoundary_DashStatistics* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LaneBoundary_DashStatistics* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LaneBoundary_DashStatistics>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LaneBoundary_DashStatistics& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const LaneBoundary_DashStatistics& from) {
    LaneBoundary_DashStatistics::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(LaneBoundary_DashStatistics* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.categories.roadattribution.LaneBoundary.DashStatistics";
  }
  protected:
  explicit LaneBoundary_DashStatistics(::google::protobuf::Arena* arena);
  LaneBoundary_DashStatistics(::google::protobuf::Arena* arena, const LaneBoundary_DashStatistics& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLengthAndAccuracyFieldNumber = 2,
    kDistanceAndAccuracyFieldNumber = 3,
  };
  // .sensoris.protobuf.types.base.Int64ValueAndAccuracy length_and_accuracy = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_length_and_accuracy() const;
  void clear_length_and_accuracy() ;
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& length_and_accuracy() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* release_length_and_accuracy();
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* mutable_length_and_accuracy();
  void set_allocated_length_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* value);
  void unsafe_arena_set_allocated_length_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* value);
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* unsafe_arena_release_length_and_accuracy();

  private:
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& _internal_length_and_accuracy() const;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* _internal_mutable_length_and_accuracy();

  public:
  // .sensoris.protobuf.types.base.Int64ValueAndAccuracy distance_and_accuracy = 3 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_distance_and_accuracy() const;
  void clear_distance_and_accuracy() ;
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& distance_and_accuracy() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* release_distance_and_accuracy();
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* mutable_distance_and_accuracy();
  void set_allocated_distance_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* value);
  void unsafe_arena_set_allocated_distance_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* value);
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* unsafe_arena_release_distance_and_accuracy();

  private:
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& _internal_distance_and_accuracy() const;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* _internal_mutable_distance_and_accuracy();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.roadattribution.LaneBoundary.DashStatistics)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* length_and_accuracy_;
    ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* distance_and_accuracy_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto;
};// -------------------------------------------------------------------

class InclinationAndCurvature final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.roadattribution.InclinationAndCurvature) */ {
 public:
  inline InclinationAndCurvature() : InclinationAndCurvature(nullptr) {}
  ~InclinationAndCurvature() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR InclinationAndCurvature(::google::protobuf::internal::ConstantInitialized);

  inline InclinationAndCurvature(const InclinationAndCurvature& from)
      : InclinationAndCurvature(nullptr, from) {}
  InclinationAndCurvature(InclinationAndCurvature&& from) noexcept
    : InclinationAndCurvature() {
    *this = ::std::move(from);
  }

  inline InclinationAndCurvature& operator=(const InclinationAndCurvature& from) {
    CopyFrom(from);
    return *this;
  }
  inline InclinationAndCurvature& operator=(InclinationAndCurvature&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InclinationAndCurvature& default_instance() {
    return *internal_default_instance();
  }
  static inline const InclinationAndCurvature* internal_default_instance() {
    return reinterpret_cast<const InclinationAndCurvature*>(
               &_InclinationAndCurvature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(InclinationAndCurvature& a, InclinationAndCurvature& b) {
    a.Swap(&b);
  }
  inline void Swap(InclinationAndCurvature* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InclinationAndCurvature* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InclinationAndCurvature* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InclinationAndCurvature>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InclinationAndCurvature& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const InclinationAndCurvature& from) {
    InclinationAndCurvature::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(InclinationAndCurvature* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.categories.roadattribution.InclinationAndCurvature";
  }
  protected:
  explicit InclinationAndCurvature(::google::protobuf::Arena* arena);
  InclinationAndCurvature(::google::protobuf::Arena* arena, const InclinationAndCurvature& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLongitudinalInclinationAndAccuracyFieldNumber = 1,
    kLateralInclinationAndAccuracyFieldNumber = 2,
    kHorizontalCurvatureAndAccuracyFieldNumber = 3,
  };
  // .sensoris.protobuf.types.base.Int64ValueAndAccuracy longitudinal_inclination_and_accuracy = 1 [(.sensoris.protobuf.types.base.exponent) = 2];
  bool has_longitudinal_inclination_and_accuracy() const;
  void clear_longitudinal_inclination_and_accuracy() ;
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& longitudinal_inclination_and_accuracy() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* release_longitudinal_inclination_and_accuracy();
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* mutable_longitudinal_inclination_and_accuracy();
  void set_allocated_longitudinal_inclination_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* value);
  void unsafe_arena_set_allocated_longitudinal_inclination_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* value);
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* unsafe_arena_release_longitudinal_inclination_and_accuracy();

  private:
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& _internal_longitudinal_inclination_and_accuracy() const;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* _internal_mutable_longitudinal_inclination_and_accuracy();

  public:
  // .sensoris.protobuf.types.base.Int64ValueAndAccuracy lateral_inclination_and_accuracy = 2 [(.sensoris.protobuf.types.base.exponent) = 2];
  bool has_lateral_inclination_and_accuracy() const;
  void clear_lateral_inclination_and_accuracy() ;
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& lateral_inclination_and_accuracy() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* release_lateral_inclination_and_accuracy();
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* mutable_lateral_inclination_and_accuracy();
  void set_allocated_lateral_inclination_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* value);
  void unsafe_arena_set_allocated_lateral_inclination_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* value);
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* unsafe_arena_release_lateral_inclination_and_accuracy();

  private:
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& _internal_lateral_inclination_and_accuracy() const;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* _internal_mutable_lateral_inclination_and_accuracy();

  public:
  // .sensoris.protobuf.types.base.Int64ValueAndAccuracy horizontal_curvature_and_accuracy = 3 [(.sensoris.protobuf.types.base.exponent) = 3];
  bool has_horizontal_curvature_and_accuracy() const;
  void clear_horizontal_curvature_and_accuracy() ;
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& horizontal_curvature_and_accuracy() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* release_horizontal_curvature_and_accuracy();
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* mutable_horizontal_curvature_and_accuracy();
  void set_allocated_horizontal_curvature_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* value);
  void unsafe_arena_set_allocated_horizontal_curvature_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* value);
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* unsafe_arena_release_horizontal_curvature_and_accuracy();

  private:
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& _internal_horizontal_curvature_and_accuracy() const;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* _internal_mutable_horizontal_curvature_and_accuracy();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.roadattribution.InclinationAndCurvature)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* longitudinal_inclination_and_accuracy_;
    ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* lateral_inclination_and_accuracy_;
    ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* horizontal_curvature_and_accuracy_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto;
};// -------------------------------------------------------------------

class Road final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.roadattribution.Road) */ {
 public:
  inline Road() : Road(nullptr) {}
  ~Road() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Road(::google::protobuf::internal::ConstantInitialized);

  inline Road(const Road& from)
      : Road(nullptr, from) {}
  Road(Road&& from) noexcept
    : Road() {
    *this = ::std::move(from);
  }

  inline Road& operator=(const Road& from) {
    CopyFrom(from);
    return *this;
  }
  inline Road& operator=(Road&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Road& default_instance() {
    return *internal_default_instance();
  }
  static inline const Road* internal_default_instance() {
    return reinterpret_cast<const Road*>(
               &_Road_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Road& a, Road& b) {
    a.Swap(&b);
  }
  inline void Swap(Road* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Road* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Road* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Road>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Road& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Road& from) {
    Road::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Road* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.categories.roadattribution.Road";
  }
  protected:
  explicit Road(::google::protobuf::Arena* arena);
  Road(::google::protobuf::Arena* arena, const Road& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnvelopeFieldNumber = 1,
    kWidthAndAccuracyFieldNumber = 2,
    kInclinationAndCurvatureFieldNumber = 3,
  };
  // .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
  bool has_envelope() const;
  void clear_envelope() ;
  const ::sensoris::protobuf::types::base::EventEnvelope& envelope() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::EventEnvelope* release_envelope();
  ::sensoris::protobuf::types::base::EventEnvelope* mutable_envelope();
  void set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value);
  void unsafe_arena_set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value);
  ::sensoris::protobuf::types::base::EventEnvelope* unsafe_arena_release_envelope();

  private:
  const ::sensoris::protobuf::types::base::EventEnvelope& _internal_envelope() const;
  ::sensoris::protobuf::types::base::EventEnvelope* _internal_mutable_envelope();

  public:
  // .sensoris.protobuf.types.base.Int64ValueAndAccuracy width_and_accuracy = 2;
  bool has_width_and_accuracy() const;
  void clear_width_and_accuracy() ;
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& width_and_accuracy() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* release_width_and_accuracy();
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* mutable_width_and_accuracy();
  void set_allocated_width_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* value);
  void unsafe_arena_set_allocated_width_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* value);
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* unsafe_arena_release_width_and_accuracy();

  private:
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& _internal_width_and_accuracy() const;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* _internal_mutable_width_and_accuracy();

  public:
  // .sensoris.protobuf.categories.roadattribution.InclinationAndCurvature inclination_and_curvature = 3;
  bool has_inclination_and_curvature() const;
  void clear_inclination_and_curvature() ;
  const ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature& inclination_and_curvature() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* release_inclination_and_curvature();
  ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* mutable_inclination_and_curvature();
  void set_allocated_inclination_and_curvature(::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* value);
  void unsafe_arena_set_allocated_inclination_and_curvature(::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* value);
  ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* unsafe_arena_release_inclination_and_curvature();

  private:
  const ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature& _internal_inclination_and_curvature() const;
  ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* _internal_mutable_inclination_and_curvature();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.roadattribution.Road)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::EventEnvelope* envelope_;
    ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* width_and_accuracy_;
    ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* inclination_and_curvature_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto;
};// -------------------------------------------------------------------

class LaneBoundary_MarkingOffsets final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.roadattribution.LaneBoundary.MarkingOffsets) */ {
 public:
  inline LaneBoundary_MarkingOffsets() : LaneBoundary_MarkingOffsets(nullptr) {}
  ~LaneBoundary_MarkingOffsets() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LaneBoundary_MarkingOffsets(::google::protobuf::internal::ConstantInitialized);

  inline LaneBoundary_MarkingOffsets(const LaneBoundary_MarkingOffsets& from)
      : LaneBoundary_MarkingOffsets(nullptr, from) {}
  LaneBoundary_MarkingOffsets(LaneBoundary_MarkingOffsets&& from) noexcept
    : LaneBoundary_MarkingOffsets() {
    *this = ::std::move(from);
  }

  inline LaneBoundary_MarkingOffsets& operator=(const LaneBoundary_MarkingOffsets& from) {
    CopyFrom(from);
    return *this;
  }
  inline LaneBoundary_MarkingOffsets& operator=(LaneBoundary_MarkingOffsets&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LaneBoundary_MarkingOffsets& default_instance() {
    return *internal_default_instance();
  }
  static inline const LaneBoundary_MarkingOffsets* internal_default_instance() {
    return reinterpret_cast<const LaneBoundary_MarkingOffsets*>(
               &_LaneBoundary_MarkingOffsets_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(LaneBoundary_MarkingOffsets& a, LaneBoundary_MarkingOffsets& b) {
    a.Swap(&b);
  }
  inline void Swap(LaneBoundary_MarkingOffsets* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LaneBoundary_MarkingOffsets* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LaneBoundary_MarkingOffsets* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LaneBoundary_MarkingOffsets>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LaneBoundary_MarkingOffsets& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const LaneBoundary_MarkingOffsets& from) {
    LaneBoundary_MarkingOffsets::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(LaneBoundary_MarkingOffsets* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.categories.roadattribution.LaneBoundary.MarkingOffsets";
  }
  protected:
  explicit LaneBoundary_MarkingOffsets(::google::protobuf::Arena* arena);
  LaneBoundary_MarkingOffsets(::google::protobuf::Arena* arena, const LaneBoundary_MarkingOffsets& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using TypeAndOffset = LaneBoundary_MarkingOffsets_TypeAndOffset;

  // accessors -------------------------------------------------------

  enum : int {
    kTypeAndOffsetFieldNumber = 2,
  };
  // repeated .sensoris.protobuf.categories.roadattribution.LaneBoundary.MarkingOffsets.TypeAndOffset type_and_offset = 2;
  int type_and_offset_size() const;
  private:
  int _internal_type_and_offset_size() const;

  public:
  void clear_type_and_offset() ;
  ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset* mutable_type_and_offset(int index);
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset >*
      mutable_type_and_offset();
  private:
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset>& _internal_type_and_offset() const;
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset>* _internal_mutable_type_and_offset();
  public:
  const ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset& type_and_offset(int index) const;
  ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset* add_type_and_offset();
  const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset >&
      type_and_offset() const;
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.roadattribution.LaneBoundary.MarkingOffsets)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset > type_and_offset_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto;
};// -------------------------------------------------------------------

class Lane final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.roadattribution.Lane) */ {
 public:
  inline Lane() : Lane(nullptr) {}
  ~Lane() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Lane(::google::protobuf::internal::ConstantInitialized);

  inline Lane(const Lane& from)
      : Lane(nullptr, from) {}
  Lane(Lane&& from) noexcept
    : Lane() {
    *this = ::std::move(from);
  }

  inline Lane& operator=(const Lane& from) {
    CopyFrom(from);
    return *this;
  }
  inline Lane& operator=(Lane&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Lane& default_instance() {
    return *internal_default_instance();
  }
  static inline const Lane* internal_default_instance() {
    return reinterpret_cast<const Lane*>(
               &_Lane_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Lane& a, Lane& b) {
    a.Swap(&b);
  }
  inline void Swap(Lane* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Lane* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Lane* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Lane>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Lane& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Lane& from) {
    Lane::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Lane* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.categories.roadattribution.Lane";
  }
  protected:
  explicit Lane(::google::protobuf::Arena* arena);
  Lane(::google::protobuf::Arena* arena, const Lane& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnvelopeFieldNumber = 1,
    kRelativeLaneIdFieldNumber = 2,
    kWidthAndAccuracyFieldNumber = 3,
    kInclinationAndCurvatureFieldNumber = 4,
  };
  // .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
  bool has_envelope() const;
  void clear_envelope() ;
  const ::sensoris::protobuf::types::base::EventEnvelope& envelope() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::EventEnvelope* release_envelope();
  ::sensoris::protobuf::types::base::EventEnvelope* mutable_envelope();
  void set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value);
  void unsafe_arena_set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value);
  ::sensoris::protobuf::types::base::EventEnvelope* unsafe_arena_release_envelope();

  private:
  const ::sensoris::protobuf::types::base::EventEnvelope& _internal_envelope() const;
  ::sensoris::protobuf::types::base::EventEnvelope* _internal_mutable_envelope();

  public:
  // .google.protobuf.Int64Value relative_lane_id = 2;
  bool has_relative_lane_id() const;
  void clear_relative_lane_id() ;
  const ::google::protobuf::Int64Value& relative_lane_id() const;
  PROTOBUF_NODISCARD ::google::protobuf::Int64Value* release_relative_lane_id();
  ::google::protobuf::Int64Value* mutable_relative_lane_id();
  void set_allocated_relative_lane_id(::google::protobuf::Int64Value* value);
  void unsafe_arena_set_allocated_relative_lane_id(::google::protobuf::Int64Value* value);
  ::google::protobuf::Int64Value* unsafe_arena_release_relative_lane_id();

  private:
  const ::google::protobuf::Int64Value& _internal_relative_lane_id() const;
  ::google::protobuf::Int64Value* _internal_mutable_relative_lane_id();

  public:
  // .sensoris.protobuf.types.base.Int64ValueAndAccuracy width_and_accuracy = 3 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_width_and_accuracy() const;
  void clear_width_and_accuracy() ;
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& width_and_accuracy() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* release_width_and_accuracy();
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* mutable_width_and_accuracy();
  void set_allocated_width_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* value);
  void unsafe_arena_set_allocated_width_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* value);
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* unsafe_arena_release_width_and_accuracy();

  private:
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& _internal_width_and_accuracy() const;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* _internal_mutable_width_and_accuracy();

  public:
  // .sensoris.protobuf.categories.roadattribution.InclinationAndCurvature inclination_and_curvature = 4;
  bool has_inclination_and_curvature() const;
  void clear_inclination_and_curvature() ;
  const ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature& inclination_and_curvature() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* release_inclination_and_curvature();
  ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* mutable_inclination_and_curvature();
  void set_allocated_inclination_and_curvature(::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* value);
  void unsafe_arena_set_allocated_inclination_and_curvature(::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* value);
  ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* unsafe_arena_release_inclination_and_curvature();

  private:
  const ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature& _internal_inclination_and_curvature() const;
  ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* _internal_mutable_inclination_and_curvature();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.roadattribution.Lane)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 4,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::EventEnvelope* envelope_;
    ::google::protobuf::Int64Value* relative_lane_id_;
    ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* width_and_accuracy_;
    ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* inclination_and_curvature_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto;
};// -------------------------------------------------------------------

class SurfaceAttribution final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.roadattribution.SurfaceAttribution) */ {
 public:
  inline SurfaceAttribution() : SurfaceAttribution(nullptr) {}
  ~SurfaceAttribution() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SurfaceAttribution(::google::protobuf::internal::ConstantInitialized);

  inline SurfaceAttribution(const SurfaceAttribution& from)
      : SurfaceAttribution(nullptr, from) {}
  SurfaceAttribution(SurfaceAttribution&& from) noexcept
    : SurfaceAttribution() {
    *this = ::std::move(from);
  }

  inline SurfaceAttribution& operator=(const SurfaceAttribution& from) {
    CopyFrom(from);
    return *this;
  }
  inline SurfaceAttribution& operator=(SurfaceAttribution&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SurfaceAttribution& default_instance() {
    return *internal_default_instance();
  }
  static inline const SurfaceAttribution* internal_default_instance() {
    return reinterpret_cast<const SurfaceAttribution*>(
               &_SurfaceAttribution_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(SurfaceAttribution& a, SurfaceAttribution& b) {
    a.Swap(&b);
  }
  inline void Swap(SurfaceAttribution* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SurfaceAttribution* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SurfaceAttribution* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SurfaceAttribution>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SurfaceAttribution& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SurfaceAttribution& from) {
    SurfaceAttribution::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SurfaceAttribution* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.categories.roadattribution.SurfaceAttribution";
  }
  protected:
  explicit SurfaceAttribution(::google::protobuf::Arena* arena);
  SurfaceAttribution(::google::protobuf::Arena* arena, const SurfaceAttribution& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMaterialAndConfidenceFieldNumber = 4,
    kEnvelopeFieldNumber = 1,
    kPositionAndAccuracyFieldNumber = 2,
    kInclinationAndCurvatureFieldNumber = 3,
    kRoadRoughnessAndAccuracyFieldNumber = 5,
  };
  // repeated .sensoris.protobuf.categories.roadattribution.SurfaceMaterialAndConfidence material_and_confidence = 4;
  int material_and_confidence_size() const;
  private:
  int _internal_material_and_confidence_size() const;

  public:
  void clear_material_and_confidence() ;
  ::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence* mutable_material_and_confidence(int index);
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence >*
      mutable_material_and_confidence();
  private:
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence>& _internal_material_and_confidence() const;
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence>* _internal_mutable_material_and_confidence();
  public:
  const ::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence& material_and_confidence(int index) const;
  ::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence* add_material_and_confidence();
  const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence >&
      material_and_confidence() const;
  // .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
  bool has_envelope() const;
  void clear_envelope() ;
  const ::sensoris::protobuf::types::base::EventEnvelope& envelope() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::EventEnvelope* release_envelope();
  ::sensoris::protobuf::types::base::EventEnvelope* mutable_envelope();
  void set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value);
  void unsafe_arena_set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value);
  ::sensoris::protobuf::types::base::EventEnvelope* unsafe_arena_release_envelope();

  private:
  const ::sensoris::protobuf::types::base::EventEnvelope& _internal_envelope() const;
  ::sensoris::protobuf::types::base::EventEnvelope* _internal_mutable_envelope();

  public:
  // .sensoris.protobuf.types.spatial.PositionAndAccuracy position_and_accuracy = 2;
  bool has_position_and_accuracy() const;
  void clear_position_and_accuracy() ;
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& position_and_accuracy() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::spatial::PositionAndAccuracy* release_position_and_accuracy();
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* mutable_position_and_accuracy();
  void set_allocated_position_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* value);
  void unsafe_arena_set_allocated_position_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* value);
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* unsafe_arena_release_position_and_accuracy();

  private:
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& _internal_position_and_accuracy() const;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* _internal_mutable_position_and_accuracy();

  public:
  // .sensoris.protobuf.categories.roadattribution.InclinationAndCurvature inclination_and_curvature = 3;
  bool has_inclination_and_curvature() const;
  void clear_inclination_and_curvature() ;
  const ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature& inclination_and_curvature() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* release_inclination_and_curvature();
  ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* mutable_inclination_and_curvature();
  void set_allocated_inclination_and_curvature(::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* value);
  void unsafe_arena_set_allocated_inclination_and_curvature(::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* value);
  ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* unsafe_arena_release_inclination_and_curvature();

  private:
  const ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature& _internal_inclination_and_curvature() const;
  ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* _internal_mutable_inclination_and_curvature();

  public:
  // .sensoris.protobuf.types.base.Int64ValueAndAccuracy road_roughness_and_accuracy = 5 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_road_roughness_and_accuracy() const;
  void clear_road_roughness_and_accuracy() ;
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& road_roughness_and_accuracy() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* release_road_roughness_and_accuracy();
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* mutable_road_roughness_and_accuracy();
  void set_allocated_road_roughness_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* value);
  void unsafe_arena_set_allocated_road_roughness_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* value);
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* unsafe_arena_release_road_roughness_and_accuracy();

  private:
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& _internal_road_roughness_and_accuracy() const;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* _internal_mutable_road_roughness_and_accuracy();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.roadattribution.SurfaceAttribution)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 5,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence > material_and_confidence_;
    ::sensoris::protobuf::types::base::EventEnvelope* envelope_;
    ::sensoris::protobuf::types::spatial::PositionAndAccuracy* position_and_accuracy_;
    ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* inclination_and_curvature_;
    ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* road_roughness_and_accuracy_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto;
};// -------------------------------------------------------------------

class RoadAttribution final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.roadattribution.RoadAttribution) */ {
 public:
  inline RoadAttribution() : RoadAttribution(nullptr) {}
  ~RoadAttribution() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RoadAttribution(::google::protobuf::internal::ConstantInitialized);

  inline RoadAttribution(const RoadAttribution& from)
      : RoadAttribution(nullptr, from) {}
  RoadAttribution(RoadAttribution&& from) noexcept
    : RoadAttribution() {
    *this = ::std::move(from);
  }

  inline RoadAttribution& operator=(const RoadAttribution& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoadAttribution& operator=(RoadAttribution&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoadAttribution& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoadAttribution* internal_default_instance() {
    return reinterpret_cast<const RoadAttribution*>(
               &_RoadAttribution_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(RoadAttribution& a, RoadAttribution& b) {
    a.Swap(&b);
  }
  inline void Swap(RoadAttribution* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoadAttribution* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoadAttribution* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoadAttribution>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RoadAttribution& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RoadAttribution& from) {
    RoadAttribution::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RoadAttribution* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.categories.roadattribution.RoadAttribution";
  }
  protected:
  explicit RoadAttribution(::google::protobuf::Arena* arena);
  RoadAttribution(::google::protobuf::Arena* arena, const RoadAttribution& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using TypeAndConfidence = RoadAttribution_TypeAndConfidence;
  using ChangeTypeAndConfidence = RoadAttribution_ChangeTypeAndConfidence;

  // accessors -------------------------------------------------------

  enum : int {
    kEnvelopeFieldNumber = 1,
    kDetectionStatusFieldNumber = 2,
    kPositionAndAccuracyFieldNumber = 3,
    kTypeAndConfidenceFieldNumber = 4,
    kChangeTypeAndConfidenceFieldNumber = 5,
  };
  // .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
  bool has_envelope() const;
  void clear_envelope() ;
  const ::sensoris::protobuf::types::base::EventEnvelope& envelope() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::EventEnvelope* release_envelope();
  ::sensoris::protobuf::types::base::EventEnvelope* mutable_envelope();
  void set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value);
  void unsafe_arena_set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value);
  ::sensoris::protobuf::types::base::EventEnvelope* unsafe_arena_release_envelope();

  private:
  const ::sensoris::protobuf::types::base::EventEnvelope& _internal_envelope() const;
  ::sensoris::protobuf::types::base::EventEnvelope* _internal_mutable_envelope();

  public:
  // .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 2;
  bool has_detection_status() const;
  void clear_detection_status() ;
  const ::sensoris::protobuf::types::base::EventDetectionStatus& detection_status() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::EventDetectionStatus* release_detection_status();
  ::sensoris::protobuf::types::base::EventDetectionStatus* mutable_detection_status();
  void set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* value);
  void unsafe_arena_set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* value);
  ::sensoris::protobuf::types::base::EventDetectionStatus* unsafe_arena_release_detection_status();

  private:
  const ::sensoris::protobuf::types::base::EventDetectionStatus& _internal_detection_status() const;
  ::sensoris::protobuf::types::base::EventDetectionStatus* _internal_mutable_detection_status();

  public:
  // .sensoris.protobuf.types.spatial.PositionAndAccuracy position_and_accuracy = 3;
  bool has_position_and_accuracy() const;
  void clear_position_and_accuracy() ;
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& position_and_accuracy() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::spatial::PositionAndAccuracy* release_position_and_accuracy();
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* mutable_position_and_accuracy();
  void set_allocated_position_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* value);
  void unsafe_arena_set_allocated_position_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* value);
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* unsafe_arena_release_position_and_accuracy();

  private:
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& _internal_position_and_accuracy() const;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* _internal_mutable_position_and_accuracy();

  public:
  // .sensoris.protobuf.categories.roadattribution.RoadAttribution.TypeAndConfidence type_and_confidence = 4;
  bool has_type_and_confidence() const;
  void clear_type_and_confidence() ;
  const ::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence& type_and_confidence() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence* release_type_and_confidence();
  ::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence* mutable_type_and_confidence();
  void set_allocated_type_and_confidence(::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence* value);
  void unsafe_arena_set_allocated_type_and_confidence(::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence* value);
  ::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence* unsafe_arena_release_type_and_confidence();

  private:
  const ::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence& _internal_type_and_confidence() const;
  ::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence* _internal_mutable_type_and_confidence();

  public:
  // .sensoris.protobuf.categories.roadattribution.RoadAttribution.ChangeTypeAndConfidence change_type_and_confidence = 5;
  bool has_change_type_and_confidence() const;
  void clear_change_type_and_confidence() ;
  const ::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence& change_type_and_confidence() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence* release_change_type_and_confidence();
  ::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence* mutable_change_type_and_confidence();
  void set_allocated_change_type_and_confidence(::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence* value);
  void unsafe_arena_set_allocated_change_type_and_confidence(::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence* value);
  ::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence* unsafe_arena_release_change_type_and_confidence();

  private:
  const ::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence& _internal_change_type_and_confidence() const;
  ::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence* _internal_mutable_change_type_and_confidence();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.roadattribution.RoadAttribution)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 5,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::EventEnvelope* envelope_;
    ::sensoris::protobuf::types::base::EventDetectionStatus* detection_status_;
    ::sensoris::protobuf::types::spatial::PositionAndAccuracy* position_and_accuracy_;
    ::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence* type_and_confidence_;
    ::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence* change_type_and_confidence_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto;
};// -------------------------------------------------------------------

class LaneCountAndConfidence final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.roadattribution.LaneCountAndConfidence) */ {
 public:
  inline LaneCountAndConfidence() : LaneCountAndConfidence(nullptr) {}
  ~LaneCountAndConfidence() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LaneCountAndConfidence(::google::protobuf::internal::ConstantInitialized);

  inline LaneCountAndConfidence(const LaneCountAndConfidence& from)
      : LaneCountAndConfidence(nullptr, from) {}
  LaneCountAndConfidence(LaneCountAndConfidence&& from) noexcept
    : LaneCountAndConfidence() {
    *this = ::std::move(from);
  }

  inline LaneCountAndConfidence& operator=(const LaneCountAndConfidence& from) {
    CopyFrom(from);
    return *this;
  }
  inline LaneCountAndConfidence& operator=(LaneCountAndConfidence&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LaneCountAndConfidence& default_instance() {
    return *internal_default_instance();
  }
  static inline const LaneCountAndConfidence* internal_default_instance() {
    return reinterpret_cast<const LaneCountAndConfidence*>(
               &_LaneCountAndConfidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(LaneCountAndConfidence& a, LaneCountAndConfidence& b) {
    a.Swap(&b);
  }
  inline void Swap(LaneCountAndConfidence* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LaneCountAndConfidence* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LaneCountAndConfidence* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LaneCountAndConfidence>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LaneCountAndConfidence& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const LaneCountAndConfidence& from) {
    LaneCountAndConfidence::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(LaneCountAndConfidence* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.categories.roadattribution.LaneCountAndConfidence";
  }
  protected:
  explicit LaneCountAndConfidence(::google::protobuf::Arena* arena);
  LaneCountAndConfidence(::google::protobuf::Arena* arena, const LaneCountAndConfidence& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Type = LaneCountAndConfidence_Type;
  static constexpr Type UNKNOWN_TYPE = LaneCountAndConfidence_Type_UNKNOWN_TYPE;
  static constexpr Type TOTAL = LaneCountAndConfidence_Type_TOTAL;
  static constexpr Type LEFT_INCLUDING_EGO_LANE = LaneCountAndConfidence_Type_LEFT_INCLUDING_EGO_LANE;
  static constexpr Type RIGHT = LaneCountAndConfidence_Type_RIGHT;
  static inline bool Type_IsValid(int value) {
    return LaneCountAndConfidence_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = LaneCountAndConfidence_Type_Type_MIN;
  static constexpr Type Type_MAX = LaneCountAndConfidence_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = LaneCountAndConfidence_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Type_descriptor() {
    return LaneCountAndConfidence_Type_descriptor();
  }
  template <typename T>
  static inline const std::string& Type_Name(T value) {
    return LaneCountAndConfidence_Type_Name(value);
  }
  static inline bool Type_Parse(absl::string_view name, Type* value) {
    return LaneCountAndConfidence_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kEnvelopeFieldNumber = 1,
    kPositionAndAccuracyFieldNumber = 2,
    kCountAndConfidenceFieldNumber = 4,
    kTypeFieldNumber = 3,
  };
  // .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
  bool has_envelope() const;
  void clear_envelope() ;
  const ::sensoris::protobuf::types::base::EventEnvelope& envelope() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::EventEnvelope* release_envelope();
  ::sensoris::protobuf::types::base::EventEnvelope* mutable_envelope();
  void set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value);
  void unsafe_arena_set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value);
  ::sensoris::protobuf::types::base::EventEnvelope* unsafe_arena_release_envelope();

  private:
  const ::sensoris::protobuf::types::base::EventEnvelope& _internal_envelope() const;
  ::sensoris::protobuf::types::base::EventEnvelope* _internal_mutable_envelope();

  public:
  // .sensoris.protobuf.types.spatial.PositionAndAccuracy position_and_accuracy = 2;
  bool has_position_and_accuracy() const;
  void clear_position_and_accuracy() ;
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& position_and_accuracy() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::spatial::PositionAndAccuracy* release_position_and_accuracy();
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* mutable_position_and_accuracy();
  void set_allocated_position_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* value);
  void unsafe_arena_set_allocated_position_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* value);
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* unsafe_arena_release_position_and_accuracy();

  private:
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& _internal_position_and_accuracy() const;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* _internal_mutable_position_and_accuracy();

  public:
  // .sensoris.protobuf.types.base.CountAndConfidence count_and_confidence = 4;
  bool has_count_and_confidence() const;
  void clear_count_and_confidence() ;
  const ::sensoris::protobuf::types::base::CountAndConfidence& count_and_confidence() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::CountAndConfidence* release_count_and_confidence();
  ::sensoris::protobuf::types::base::CountAndConfidence* mutable_count_and_confidence();
  void set_allocated_count_and_confidence(::sensoris::protobuf::types::base::CountAndConfidence* value);
  void unsafe_arena_set_allocated_count_and_confidence(::sensoris::protobuf::types::base::CountAndConfidence* value);
  ::sensoris::protobuf::types::base::CountAndConfidence* unsafe_arena_release_count_and_confidence();

  private:
  const ::sensoris::protobuf::types::base::CountAndConfidence& _internal_count_and_confidence() const;
  ::sensoris::protobuf::types::base::CountAndConfidence* _internal_mutable_count_and_confidence();

  public:
  // .sensoris.protobuf.categories.roadattribution.LaneCountAndConfidence.Type type = 3;
  void clear_type() ;
  ::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence_Type type() const;
  void set_type(::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence_Type value);

  private:
  ::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence_Type _internal_type() const;
  void _internal_set_type(::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence_Type value);

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.roadattribution.LaneCountAndConfidence)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::EventEnvelope* envelope_;
    ::sensoris::protobuf::types::spatial::PositionAndAccuracy* position_and_accuracy_;
    ::sensoris::protobuf::types::base::CountAndConfidence* count_and_confidence_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto;
};// -------------------------------------------------------------------

class LaneBoundaryMergeSplit final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit) */ {
 public:
  inline LaneBoundaryMergeSplit() : LaneBoundaryMergeSplit(nullptr) {}
  ~LaneBoundaryMergeSplit() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LaneBoundaryMergeSplit(::google::protobuf::internal::ConstantInitialized);

  inline LaneBoundaryMergeSplit(const LaneBoundaryMergeSplit& from)
      : LaneBoundaryMergeSplit(nullptr, from) {}
  LaneBoundaryMergeSplit(LaneBoundaryMergeSplit&& from) noexcept
    : LaneBoundaryMergeSplit() {
    *this = ::std::move(from);
  }

  inline LaneBoundaryMergeSplit& operator=(const LaneBoundaryMergeSplit& from) {
    CopyFrom(from);
    return *this;
  }
  inline LaneBoundaryMergeSplit& operator=(LaneBoundaryMergeSplit&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LaneBoundaryMergeSplit& default_instance() {
    return *internal_default_instance();
  }
  static inline const LaneBoundaryMergeSplit* internal_default_instance() {
    return reinterpret_cast<const LaneBoundaryMergeSplit*>(
               &_LaneBoundaryMergeSplit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(LaneBoundaryMergeSplit& a, LaneBoundaryMergeSplit& b) {
    a.Swap(&b);
  }
  inline void Swap(LaneBoundaryMergeSplit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LaneBoundaryMergeSplit* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LaneBoundaryMergeSplit* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LaneBoundaryMergeSplit>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LaneBoundaryMergeSplit& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const LaneBoundaryMergeSplit& from) {
    LaneBoundaryMergeSplit::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(LaneBoundaryMergeSplit* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit";
  }
  protected:
  explicit LaneBoundaryMergeSplit(::google::protobuf::Arena* arena);
  LaneBoundaryMergeSplit(::google::protobuf::Arena* arena, const LaneBoundaryMergeSplit& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using TypeAndConfidence = LaneBoundaryMergeSplit_TypeAndConfidence;

  // accessors -------------------------------------------------------

  enum : int {
    kEnvelopeFieldNumber = 1,
    kExistenceConfidenceFieldNumber = 2,
    kDetectionStatusFieldNumber = 3,
    kTypeAndConfidenceFieldNumber = 4,
    kPositionAndAccuracyFieldNumber = 5,
  };
  // .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
  bool has_envelope() const;
  void clear_envelope() ;
  const ::sensoris::protobuf::types::base::EventEnvelope& envelope() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::EventEnvelope* release_envelope();
  ::sensoris::protobuf::types::base::EventEnvelope* mutable_envelope();
  void set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value);
  void unsafe_arena_set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value);
  ::sensoris::protobuf::types::base::EventEnvelope* unsafe_arena_release_envelope();

  private:
  const ::sensoris::protobuf::types::base::EventEnvelope& _internal_envelope() const;
  ::sensoris::protobuf::types::base::EventEnvelope* _internal_mutable_envelope();

  public:
  // .sensoris.protobuf.types.base.Confidence existence_confidence = 2;
  bool has_existence_confidence() const;
  void clear_existence_confidence() ;
  const ::sensoris::protobuf::types::base::Confidence& existence_confidence() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::Confidence* release_existence_confidence();
  ::sensoris::protobuf::types::base::Confidence* mutable_existence_confidence();
  void set_allocated_existence_confidence(::sensoris::protobuf::types::base::Confidence* value);
  void unsafe_arena_set_allocated_existence_confidence(::sensoris::protobuf::types::base::Confidence* value);
  ::sensoris::protobuf::types::base::Confidence* unsafe_arena_release_existence_confidence();

  private:
  const ::sensoris::protobuf::types::base::Confidence& _internal_existence_confidence() const;
  ::sensoris::protobuf::types::base::Confidence* _internal_mutable_existence_confidence();

  public:
  // .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 3;
  bool has_detection_status() const;
  void clear_detection_status() ;
  const ::sensoris::protobuf::types::base::EventDetectionStatus& detection_status() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::EventDetectionStatus* release_detection_status();
  ::sensoris::protobuf::types::base::EventDetectionStatus* mutable_detection_status();
  void set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* value);
  void unsafe_arena_set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* value);
  ::sensoris::protobuf::types::base::EventDetectionStatus* unsafe_arena_release_detection_status();

  private:
  const ::sensoris::protobuf::types::base::EventDetectionStatus& _internal_detection_status() const;
  ::sensoris::protobuf::types::base::EventDetectionStatus* _internal_mutable_detection_status();

  public:
  // .sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.TypeAndConfidence type_and_confidence = 4;
  bool has_type_and_confidence() const;
  void clear_type_and_confidence() ;
  const ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence& type_and_confidence() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence* release_type_and_confidence();
  ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence* mutable_type_and_confidence();
  void set_allocated_type_and_confidence(::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence* value);
  void unsafe_arena_set_allocated_type_and_confidence(::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence* value);
  ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence* unsafe_arena_release_type_and_confidence();

  private:
  const ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence& _internal_type_and_confidence() const;
  ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence* _internal_mutable_type_and_confidence();

  public:
  // .sensoris.protobuf.types.spatial.PositionAndAccuracy position_and_accuracy = 5;
  bool has_position_and_accuracy() const;
  void clear_position_and_accuracy() ;
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& position_and_accuracy() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::spatial::PositionAndAccuracy* release_position_and_accuracy();
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* mutable_position_and_accuracy();
  void set_allocated_position_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* value);
  void unsafe_arena_set_allocated_position_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* value);
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* unsafe_arena_release_position_and_accuracy();

  private:
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& _internal_position_and_accuracy() const;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* _internal_mutable_position_and_accuracy();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 5,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::EventEnvelope* envelope_;
    ::sensoris::protobuf::types::base::Confidence* existence_confidence_;
    ::sensoris::protobuf::types::base::EventDetectionStatus* detection_status_;
    ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence* type_and_confidence_;
    ::sensoris::protobuf::types::spatial::PositionAndAccuracy* position_and_accuracy_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto;
};// -------------------------------------------------------------------

class LaneBoundary final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.roadattribution.LaneBoundary) */ {
 public:
  inline LaneBoundary() : LaneBoundary(nullptr) {}
  ~LaneBoundary() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LaneBoundary(::google::protobuf::internal::ConstantInitialized);

  inline LaneBoundary(const LaneBoundary& from)
      : LaneBoundary(nullptr, from) {}
  LaneBoundary(LaneBoundary&& from) noexcept
    : LaneBoundary() {
    *this = ::std::move(from);
  }

  inline LaneBoundary& operator=(const LaneBoundary& from) {
    CopyFrom(from);
    return *this;
  }
  inline LaneBoundary& operator=(LaneBoundary&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LaneBoundary& default_instance() {
    return *internal_default_instance();
  }
  enum GeometryCase {
    kPolylineAndAccuracy = 9,
    GEOMETRY_NOT_SET = 0,
  };

  enum MarkingsCase {
    kDashStatistics = 13,
    kMarkingOffsets = 14,
    MARKINGS_NOT_SET = 0,
  };

  static inline const LaneBoundary* internal_default_instance() {
    return reinterpret_cast<const LaneBoundary*>(
               &_LaneBoundary_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(LaneBoundary& a, LaneBoundary& b) {
    a.Swap(&b);
  }
  inline void Swap(LaneBoundary* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LaneBoundary* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LaneBoundary* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LaneBoundary>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LaneBoundary& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const LaneBoundary& from) {
    LaneBoundary::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(LaneBoundary* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.categories.roadattribution.LaneBoundary";
  }
  protected:
  explicit LaneBoundary(::google::protobuf::Arena* arena);
  LaneBoundary(::google::protobuf::Arena* arena, const LaneBoundary& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using TypeAndConfidence = LaneBoundary_TypeAndConfidence;
  using DashStatistics = LaneBoundary_DashStatistics;
  using MarkingOffsets = LaneBoundary_MarkingOffsets;

  using PositionReference = LaneBoundary_PositionReference;
  static constexpr PositionReference UNKNOWN_POSITION_REFERENCE = LaneBoundary_PositionReference_UNKNOWN_POSITION_REFERENCE;
  static constexpr PositionReference LEFT_MARKING_BOUNDARY = LaneBoundary_PositionReference_LEFT_MARKING_BOUNDARY;
  static constexpr PositionReference CENTER_LINE = LaneBoundary_PositionReference_CENTER_LINE;
  static constexpr PositionReference RIGHT_MARKING_BOUNDARY = LaneBoundary_PositionReference_RIGHT_MARKING_BOUNDARY;
  static inline bool PositionReference_IsValid(int value) {
    return LaneBoundary_PositionReference_IsValid(value);
  }
  static constexpr PositionReference PositionReference_MIN = LaneBoundary_PositionReference_PositionReference_MIN;
  static constexpr PositionReference PositionReference_MAX = LaneBoundary_PositionReference_PositionReference_MAX;
  static constexpr int PositionReference_ARRAYSIZE = LaneBoundary_PositionReference_PositionReference_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PositionReference_descriptor() {
    return LaneBoundary_PositionReference_descriptor();
  }
  template <typename T>
  static inline const std::string& PositionReference_Name(T value) {
    return LaneBoundary_PositionReference_Name(value);
  }
  static inline bool PositionReference_Parse(absl::string_view name, PositionReference* value) {
    return LaneBoundary_PositionReference_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kEnvelopeFieldNumber = 1,
    kLaneBoundaryIdFieldNumber = 2,
    kExistenceConfidenceFieldNumber = 3,
    kDetectionStatusFieldNumber = 4,
    kTypeAndConfidenceFieldNumber = 5,
    kMaterialAndConfidenceFieldNumber = 6,
    kColorAndConfidenceFieldNumber = 7,
    kWidthAndAccuracyFieldNumber = 10,
    kHeightAndAccuracyFieldNumber = 11,
    kDistanceBetweenDoubleAndAccuracyFieldNumber = 12,
    kPositionReferenceFieldNumber = 8,
    kPolylineAndAccuracyFieldNumber = 9,
    kDashStatisticsFieldNumber = 13,
    kMarkingOffsetsFieldNumber = 14,
  };
  // .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
  bool has_envelope() const;
  void clear_envelope() ;
  const ::sensoris::protobuf::types::base::EventEnvelope& envelope() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::EventEnvelope* release_envelope();
  ::sensoris::protobuf::types::base::EventEnvelope* mutable_envelope();
  void set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value);
  void unsafe_arena_set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value);
  ::sensoris::protobuf::types::base::EventEnvelope* unsafe_arena_release_envelope();

  private:
  const ::sensoris::protobuf::types::base::EventEnvelope& _internal_envelope() const;
  ::sensoris::protobuf::types::base::EventEnvelope* _internal_mutable_envelope();

  public:
  // .google.protobuf.Int64Value lane_boundary_id = 2;
  bool has_lane_boundary_id() const;
  void clear_lane_boundary_id() ;
  const ::google::protobuf::Int64Value& lane_boundary_id() const;
  PROTOBUF_NODISCARD ::google::protobuf::Int64Value* release_lane_boundary_id();
  ::google::protobuf::Int64Value* mutable_lane_boundary_id();
  void set_allocated_lane_boundary_id(::google::protobuf::Int64Value* value);
  void unsafe_arena_set_allocated_lane_boundary_id(::google::protobuf::Int64Value* value);
  ::google::protobuf::Int64Value* unsafe_arena_release_lane_boundary_id();

  private:
  const ::google::protobuf::Int64Value& _internal_lane_boundary_id() const;
  ::google::protobuf::Int64Value* _internal_mutable_lane_boundary_id();

  public:
  // .sensoris.protobuf.types.base.Confidence existence_confidence = 3;
  bool has_existence_confidence() const;
  void clear_existence_confidence() ;
  const ::sensoris::protobuf::types::base::Confidence& existence_confidence() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::Confidence* release_existence_confidence();
  ::sensoris::protobuf::types::base::Confidence* mutable_existence_confidence();
  void set_allocated_existence_confidence(::sensoris::protobuf::types::base::Confidence* value);
  void unsafe_arena_set_allocated_existence_confidence(::sensoris::protobuf::types::base::Confidence* value);
  ::sensoris::protobuf::types::base::Confidence* unsafe_arena_release_existence_confidence();

  private:
  const ::sensoris::protobuf::types::base::Confidence& _internal_existence_confidence() const;
  ::sensoris::protobuf::types::base::Confidence* _internal_mutable_existence_confidence();

  public:
  // .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 4;
  bool has_detection_status() const;
  void clear_detection_status() ;
  const ::sensoris::protobuf::types::base::EventDetectionStatus& detection_status() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::EventDetectionStatus* release_detection_status();
  ::sensoris::protobuf::types::base::EventDetectionStatus* mutable_detection_status();
  void set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* value);
  void unsafe_arena_set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* value);
  ::sensoris::protobuf::types::base::EventDetectionStatus* unsafe_arena_release_detection_status();

  private:
  const ::sensoris::protobuf::types::base::EventDetectionStatus& _internal_detection_status() const;
  ::sensoris::protobuf::types::base::EventDetectionStatus* _internal_mutable_detection_status();

  public:
  // .sensoris.protobuf.categories.roadattribution.LaneBoundary.TypeAndConfidence type_and_confidence = 5;
  bool has_type_and_confidence() const;
  void clear_type_and_confidence() ;
  const ::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence& type_and_confidence() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence* release_type_and_confidence();
  ::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence* mutable_type_and_confidence();
  void set_allocated_type_and_confidence(::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence* value);
  void unsafe_arena_set_allocated_type_and_confidence(::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence* value);
  ::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence* unsafe_arena_release_type_and_confidence();

  private:
  const ::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence& _internal_type_and_confidence() const;
  ::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence* _internal_mutable_type_and_confidence();

  public:
  // .sensoris.protobuf.categories.roadattribution.MarkingMaterialAndConfidence material_and_confidence = 6;
  bool has_material_and_confidence() const;
  void clear_material_and_confidence() ;
  const ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence& material_and_confidence() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence* release_material_and_confidence();
  ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence* mutable_material_and_confidence();
  void set_allocated_material_and_confidence(::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence* value);
  void unsafe_arena_set_allocated_material_and_confidence(::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence* value);
  ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence* unsafe_arena_release_material_and_confidence();

  private:
  const ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence& _internal_material_and_confidence() const;
  ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence* _internal_mutable_material_and_confidence();

  public:
  // .sensoris.protobuf.categories.roadattribution.MarkingColorAndConfidence color_and_confidence = 7;
  bool has_color_and_confidence() const;
  void clear_color_and_confidence() ;
  const ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence& color_and_confidence() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence* release_color_and_confidence();
  ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence* mutable_color_and_confidence();
  void set_allocated_color_and_confidence(::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence* value);
  void unsafe_arena_set_allocated_color_and_confidence(::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence* value);
  ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence* unsafe_arena_release_color_and_confidence();

  private:
  const ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence& _internal_color_and_confidence() const;
  ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence* _internal_mutable_color_and_confidence();

  public:
  // .sensoris.protobuf.types.base.Int64ValueAndAccuracy width_and_accuracy = 10 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_width_and_accuracy() const;
  void clear_width_and_accuracy() ;
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& width_and_accuracy() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* release_width_and_accuracy();
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* mutable_width_and_accuracy();
  void set_allocated_width_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* value);
  void unsafe_arena_set_allocated_width_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* value);
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* unsafe_arena_release_width_and_accuracy();

  private:
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& _internal_width_and_accuracy() const;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* _internal_mutable_width_and_accuracy();

  public:
  // .sensoris.protobuf.types.base.Int64ValueAndAccuracy height_and_accuracy = 11 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_height_and_accuracy() const;
  void clear_height_and_accuracy() ;
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& height_and_accuracy() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* release_height_and_accuracy();
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* mutable_height_and_accuracy();
  void set_allocated_height_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* value);
  void unsafe_arena_set_allocated_height_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* value);
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* unsafe_arena_release_height_and_accuracy();

  private:
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& _internal_height_and_accuracy() const;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* _internal_mutable_height_and_accuracy();

  public:
  // .sensoris.protobuf.types.base.Int64ValueAndAccuracy distance_between_double_and_accuracy = 12 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_distance_between_double_and_accuracy() const;
  void clear_distance_between_double_and_accuracy() ;
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& distance_between_double_and_accuracy() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* release_distance_between_double_and_accuracy();
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* mutable_distance_between_double_and_accuracy();
  void set_allocated_distance_between_double_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* value);
  void unsafe_arena_set_allocated_distance_between_double_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* value);
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* unsafe_arena_release_distance_between_double_and_accuracy();

  private:
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& _internal_distance_between_double_and_accuracy() const;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* _internal_mutable_distance_between_double_and_accuracy();

  public:
  // .sensoris.protobuf.categories.roadattribution.LaneBoundary.PositionReference position_reference = 8;
  void clear_position_reference() ;
  ::sensoris::protobuf::categories::roadattribution::LaneBoundary_PositionReference position_reference() const;
  void set_position_reference(::sensoris::protobuf::categories::roadattribution::LaneBoundary_PositionReference value);

  private:
  ::sensoris::protobuf::categories::roadattribution::LaneBoundary_PositionReference _internal_position_reference() const;
  void _internal_set_position_reference(::sensoris::protobuf::categories::roadattribution::LaneBoundary_PositionReference value);

  public:
  // .sensoris.protobuf.types.spatial.PolylineAndAccuracy polyline_and_accuracy = 9;
  bool has_polyline_and_accuracy() const;
  private:
  bool _internal_has_polyline_and_accuracy() const;

  public:
  void clear_polyline_and_accuracy() ;
  const ::sensoris::protobuf::types::spatial::PolylineAndAccuracy& polyline_and_accuracy() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::spatial::PolylineAndAccuracy* release_polyline_and_accuracy();
  ::sensoris::protobuf::types::spatial::PolylineAndAccuracy* mutable_polyline_and_accuracy();
  void set_allocated_polyline_and_accuracy(::sensoris::protobuf::types::spatial::PolylineAndAccuracy* value);
  void unsafe_arena_set_allocated_polyline_and_accuracy(::sensoris::protobuf::types::spatial::PolylineAndAccuracy* value);
  ::sensoris::protobuf::types::spatial::PolylineAndAccuracy* unsafe_arena_release_polyline_and_accuracy();

  private:
  const ::sensoris::protobuf::types::spatial::PolylineAndAccuracy& _internal_polyline_and_accuracy() const;
  ::sensoris::protobuf::types::spatial::PolylineAndAccuracy* _internal_mutable_polyline_and_accuracy();

  public:
  // .sensoris.protobuf.categories.roadattribution.LaneBoundary.DashStatistics dash_statistics = 13;
  bool has_dash_statistics() const;
  private:
  bool _internal_has_dash_statistics() const;

  public:
  void clear_dash_statistics() ;
  const ::sensoris::protobuf::categories::roadattribution::LaneBoundary_DashStatistics& dash_statistics() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::categories::roadattribution::LaneBoundary_DashStatistics* release_dash_statistics();
  ::sensoris::protobuf::categories::roadattribution::LaneBoundary_DashStatistics* mutable_dash_statistics();
  void set_allocated_dash_statistics(::sensoris::protobuf::categories::roadattribution::LaneBoundary_DashStatistics* value);
  void unsafe_arena_set_allocated_dash_statistics(::sensoris::protobuf::categories::roadattribution::LaneBoundary_DashStatistics* value);
  ::sensoris::protobuf::categories::roadattribution::LaneBoundary_DashStatistics* unsafe_arena_release_dash_statistics();

  private:
  const ::sensoris::protobuf::categories::roadattribution::LaneBoundary_DashStatistics& _internal_dash_statistics() const;
  ::sensoris::protobuf::categories::roadattribution::LaneBoundary_DashStatistics* _internal_mutable_dash_statistics();

  public:
  // .sensoris.protobuf.categories.roadattribution.LaneBoundary.MarkingOffsets marking_offsets = 14;
  bool has_marking_offsets() const;
  private:
  bool _internal_has_marking_offsets() const;

  public:
  void clear_marking_offsets() ;
  const ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets& marking_offsets() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets* release_marking_offsets();
  ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets* mutable_marking_offsets();
  void set_allocated_marking_offsets(::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets* value);
  void unsafe_arena_set_allocated_marking_offsets(::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets* value);
  ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets* unsafe_arena_release_marking_offsets();

  private:
  const ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets& _internal_marking_offsets() const;
  ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets* _internal_mutable_marking_offsets();

  public:
  void clear_geometry();
  GeometryCase geometry_case() const;
  void clear_markings();
  MarkingsCase markings_case() const;
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.roadattribution.LaneBoundary)
 private:
  class _Internal;
  void set_has_polyline_and_accuracy();
  void set_has_dash_statistics();
  void set_has_marking_offsets();

  inline bool has_geometry() const;
  inline void clear_has_geometry();

  inline bool has_markings() const;
  inline void clear_has_markings();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 14, 13,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::EventEnvelope* envelope_;
    ::google::protobuf::Int64Value* lane_boundary_id_;
    ::sensoris::protobuf::types::base::Confidence* existence_confidence_;
    ::sensoris::protobuf::types::base::EventDetectionStatus* detection_status_;
    ::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence* type_and_confidence_;
    ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence* material_and_confidence_;
    ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence* color_and_confidence_;
    ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* width_and_accuracy_;
    ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* height_and_accuracy_;
    ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* distance_between_double_and_accuracy_;
    int position_reference_;
    union GeometryUnion {
      constexpr GeometryUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::sensoris::protobuf::types::spatial::PolylineAndAccuracy* polyline_and_accuracy_;
    } geometry_;
    union MarkingsUnion {
      constexpr MarkingsUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::sensoris::protobuf::categories::roadattribution::LaneBoundary_DashStatistics* dash_statistics_;
      ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets* marking_offsets_;
    } markings_;
    ::uint32_t _oneof_case_[2];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto;
};// -------------------------------------------------------------------

class SurfaceMarking final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.roadattribution.SurfaceMarking) */ {
 public:
  inline SurfaceMarking() : SurfaceMarking(nullptr) {}
  ~SurfaceMarking() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SurfaceMarking(::google::protobuf::internal::ConstantInitialized);

  inline SurfaceMarking(const SurfaceMarking& from)
      : SurfaceMarking(nullptr, from) {}
  SurfaceMarking(SurfaceMarking&& from) noexcept
    : SurfaceMarking() {
    *this = ::std::move(from);
  }

  inline SurfaceMarking& operator=(const SurfaceMarking& from) {
    CopyFrom(from);
    return *this;
  }
  inline SurfaceMarking& operator=(SurfaceMarking&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SurfaceMarking& default_instance() {
    return *internal_default_instance();
  }
  static inline const SurfaceMarking* internal_default_instance() {
    return reinterpret_cast<const SurfaceMarking*>(
               &_SurfaceMarking_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(SurfaceMarking& a, SurfaceMarking& b) {
    a.Swap(&b);
  }
  inline void Swap(SurfaceMarking* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SurfaceMarking* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SurfaceMarking* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SurfaceMarking>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SurfaceMarking& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SurfaceMarking& from) {
    SurfaceMarking::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SurfaceMarking* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.categories.roadattribution.SurfaceMarking";
  }
  protected:
  explicit SurfaceMarking(::google::protobuf::Arena* arena);
  SurfaceMarking(::google::protobuf::Arena* arena, const SurfaceMarking& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using TypeAndConfidence = SurfaceMarking_TypeAndConfidence;

  // accessors -------------------------------------------------------

  enum : int {
    kColorAndConfidenceFieldNumber = 6,
    kMaterialAndConfidenceFieldNumber = 7,
    kEnvelopeFieldNumber = 1,
    kExistenceConfidenceFieldNumber = 2,
    kDetectionStatusFieldNumber = 3,
    kTypeAndConfidenceFieldNumber = 4,
    kTextFieldNumber = 5,
    kRectangularBoxAndAccuracyFieldNumber = 8,
  };
  // repeated .sensoris.protobuf.categories.roadattribution.MarkingColorAndConfidence color_and_confidence = 6;
  int color_and_confidence_size() const;
  private:
  int _internal_color_and_confidence_size() const;

  public:
  void clear_color_and_confidence() ;
  ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence* mutable_color_and_confidence(int index);
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence >*
      mutable_color_and_confidence();
  private:
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence>& _internal_color_and_confidence() const;
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence>* _internal_mutable_color_and_confidence();
  public:
  const ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence& color_and_confidence(int index) const;
  ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence* add_color_and_confidence();
  const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence >&
      color_and_confidence() const;
  // repeated .sensoris.protobuf.categories.roadattribution.MarkingMaterialAndConfidence material_and_confidence = 7;
  int material_and_confidence_size() const;
  private:
  int _internal_material_and_confidence_size() const;

  public:
  void clear_material_and_confidence() ;
  ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence* mutable_material_and_confidence(int index);
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence >*
      mutable_material_and_confidence();
  private:
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence>& _internal_material_and_confidence() const;
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence>* _internal_mutable_material_and_confidence();
  public:
  const ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence& material_and_confidence(int index) const;
  ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence* add_material_and_confidence();
  const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence >&
      material_and_confidence() const;
  // .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
  bool has_envelope() const;
  void clear_envelope() ;
  const ::sensoris::protobuf::types::base::EventEnvelope& envelope() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::EventEnvelope* release_envelope();
  ::sensoris::protobuf::types::base::EventEnvelope* mutable_envelope();
  void set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value);
  void unsafe_arena_set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value);
  ::sensoris::protobuf::types::base::EventEnvelope* unsafe_arena_release_envelope();

  private:
  const ::sensoris::protobuf::types::base::EventEnvelope& _internal_envelope() const;
  ::sensoris::protobuf::types::base::EventEnvelope* _internal_mutable_envelope();

  public:
  // .sensoris.protobuf.types.base.Confidence existence_confidence = 2;
  bool has_existence_confidence() const;
  void clear_existence_confidence() ;
  const ::sensoris::protobuf::types::base::Confidence& existence_confidence() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::Confidence* release_existence_confidence();
  ::sensoris::protobuf::types::base::Confidence* mutable_existence_confidence();
  void set_allocated_existence_confidence(::sensoris::protobuf::types::base::Confidence* value);
  void unsafe_arena_set_allocated_existence_confidence(::sensoris::protobuf::types::base::Confidence* value);
  ::sensoris::protobuf::types::base::Confidence* unsafe_arena_release_existence_confidence();

  private:
  const ::sensoris::protobuf::types::base::Confidence& _internal_existence_confidence() const;
  ::sensoris::protobuf::types::base::Confidence* _internal_mutable_existence_confidence();

  public:
  // .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 3;
  bool has_detection_status() const;
  void clear_detection_status() ;
  const ::sensoris::protobuf::types::base::EventDetectionStatus& detection_status() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::EventDetectionStatus* release_detection_status();
  ::sensoris::protobuf::types::base::EventDetectionStatus* mutable_detection_status();
  void set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* value);
  void unsafe_arena_set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* value);
  ::sensoris::protobuf::types::base::EventDetectionStatus* unsafe_arena_release_detection_status();

  private:
  const ::sensoris::protobuf::types::base::EventDetectionStatus& _internal_detection_status() const;
  ::sensoris::protobuf::types::base::EventDetectionStatus* _internal_mutable_detection_status();

  public:
  // .sensoris.protobuf.categories.roadattribution.SurfaceMarking.TypeAndConfidence type_and_confidence = 4;
  bool has_type_and_confidence() const;
  void clear_type_and_confidence() ;
  const ::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence& type_and_confidence() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence* release_type_and_confidence();
  ::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence* mutable_type_and_confidence();
  void set_allocated_type_and_confidence(::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence* value);
  void unsafe_arena_set_allocated_type_and_confidence(::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence* value);
  ::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence* unsafe_arena_release_type_and_confidence();

  private:
  const ::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence& _internal_type_and_confidence() const;
  ::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence* _internal_mutable_type_and_confidence();

  public:
  // .google.protobuf.StringValue text = 5;
  bool has_text() const;
  void clear_text() ;
  const ::google::protobuf::StringValue& text() const;
  PROTOBUF_NODISCARD ::google::protobuf::StringValue* release_text();
  ::google::protobuf::StringValue* mutable_text();
  void set_allocated_text(::google::protobuf::StringValue* value);
  void unsafe_arena_set_allocated_text(::google::protobuf::StringValue* value);
  ::google::protobuf::StringValue* unsafe_arena_release_text();

  private:
  const ::google::protobuf::StringValue& _internal_text() const;
  ::google::protobuf::StringValue* _internal_mutable_text();

  public:
  // .sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy rectangular_box_and_accuracy = 8;
  bool has_rectangular_box_and_accuracy() const;
  void clear_rectangular_box_and_accuracy() ;
  const ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy& rectangular_box_and_accuracy() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* release_rectangular_box_and_accuracy();
  ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* mutable_rectangular_box_and_accuracy();
  void set_allocated_rectangular_box_and_accuracy(::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* value);
  void unsafe_arena_set_allocated_rectangular_box_and_accuracy(::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* value);
  ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* unsafe_arena_release_rectangular_box_and_accuracy();

  private:
  const ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy& _internal_rectangular_box_and_accuracy() const;
  ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* _internal_mutable_rectangular_box_and_accuracy();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.roadattribution.SurfaceMarking)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 8, 8,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence > color_and_confidence_;
    ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence > material_and_confidence_;
    ::sensoris::protobuf::types::base::EventEnvelope* envelope_;
    ::sensoris::protobuf::types::base::Confidence* existence_confidence_;
    ::sensoris::protobuf::types::base::EventDetectionStatus* detection_status_;
    ::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence* type_and_confidence_;
    ::google::protobuf::StringValue* text_;
    ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* rectangular_box_and_accuracy_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto;
};// -------------------------------------------------------------------

class RoadAttributionCategory final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory) */ {
 public:
  inline RoadAttributionCategory() : RoadAttributionCategory(nullptr) {}
  ~RoadAttributionCategory() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RoadAttributionCategory(::google::protobuf::internal::ConstantInitialized);

  inline RoadAttributionCategory(const RoadAttributionCategory& from)
      : RoadAttributionCategory(nullptr, from) {}
  RoadAttributionCategory(RoadAttributionCategory&& from) noexcept
    : RoadAttributionCategory() {
    *this = ::std::move(from);
  }

  inline RoadAttributionCategory& operator=(const RoadAttributionCategory& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoadAttributionCategory& operator=(RoadAttributionCategory&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoadAttributionCategory& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoadAttributionCategory* internal_default_instance() {
    return reinterpret_cast<const RoadAttributionCategory*>(
               &_RoadAttributionCategory_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(RoadAttributionCategory& a, RoadAttributionCategory& b) {
    a.Swap(&b);
  }
  inline void Swap(RoadAttributionCategory* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoadAttributionCategory* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoadAttributionCategory* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoadAttributionCategory>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RoadAttributionCategory& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RoadAttributionCategory& from) {
    RoadAttributionCategory::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RoadAttributionCategory* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.categories.roadattribution.RoadAttributionCategory";
  }
  protected:
  explicit RoadAttributionCategory(::google::protobuf::Arena* arena);
  RoadAttributionCategory(::google::protobuf::Arena* arena, const RoadAttributionCategory& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLaneBoundaryFieldNumber = 2,
    kLaneBoundaryMergeSplitFieldNumber = 3,
    kLaneFieldNumber = 4,
    kRoadFieldNumber = 5,
    kSurfaceMarkingFieldNumber = 6,
    kSurfaceAttributionFieldNumber = 7,
    kRoadAttributionFieldNumber = 8,
    kDetectedLaneCountAndConfidenceFieldNumber = 9,
    kEstimatedLaneCountAndConfidenceFieldNumber = 10,
    kEnvelopeFieldNumber = 1,
  };
  // repeated .sensoris.protobuf.categories.roadattribution.LaneBoundary lane_boundary = 2;
  int lane_boundary_size() const;
  private:
  int _internal_lane_boundary_size() const;

  public:
  void clear_lane_boundary() ;
  ::sensoris::protobuf::categories::roadattribution::LaneBoundary* mutable_lane_boundary(int index);
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::LaneBoundary >*
      mutable_lane_boundary();
  private:
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::LaneBoundary>& _internal_lane_boundary() const;
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::LaneBoundary>* _internal_mutable_lane_boundary();
  public:
  const ::sensoris::protobuf::categories::roadattribution::LaneBoundary& lane_boundary(int index) const;
  ::sensoris::protobuf::categories::roadattribution::LaneBoundary* add_lane_boundary();
  const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::LaneBoundary >&
      lane_boundary() const;
  // repeated .sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit lane_boundary_merge_split = 3;
  int lane_boundary_merge_split_size() const;
  private:
  int _internal_lane_boundary_merge_split_size() const;

  public:
  void clear_lane_boundary_merge_split() ;
  ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit* mutable_lane_boundary_merge_split(int index);
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit >*
      mutable_lane_boundary_merge_split();
  private:
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit>& _internal_lane_boundary_merge_split() const;
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit>* _internal_mutable_lane_boundary_merge_split();
  public:
  const ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit& lane_boundary_merge_split(int index) const;
  ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit* add_lane_boundary_merge_split();
  const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit >&
      lane_boundary_merge_split() const;
  // repeated .sensoris.protobuf.categories.roadattribution.Lane lane = 4;
  int lane_size() const;
  private:
  int _internal_lane_size() const;

  public:
  void clear_lane() ;
  ::sensoris::protobuf::categories::roadattribution::Lane* mutable_lane(int index);
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::Lane >*
      mutable_lane();
  private:
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::Lane>& _internal_lane() const;
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::Lane>* _internal_mutable_lane();
  public:
  const ::sensoris::protobuf::categories::roadattribution::Lane& lane(int index) const;
  ::sensoris::protobuf::categories::roadattribution::Lane* add_lane();
  const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::Lane >&
      lane() const;
  // repeated .sensoris.protobuf.categories.roadattribution.Road road = 5;
  int road_size() const;
  private:
  int _internal_road_size() const;

  public:
  void clear_road() ;
  ::sensoris::protobuf::categories::roadattribution::Road* mutable_road(int index);
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::Road >*
      mutable_road();
  private:
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::Road>& _internal_road() const;
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::Road>* _internal_mutable_road();
  public:
  const ::sensoris::protobuf::categories::roadattribution::Road& road(int index) const;
  ::sensoris::protobuf::categories::roadattribution::Road* add_road();
  const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::Road >&
      road() const;
  // repeated .sensoris.protobuf.categories.roadattribution.SurfaceMarking surface_marking = 6;
  int surface_marking_size() const;
  private:
  int _internal_surface_marking_size() const;

  public:
  void clear_surface_marking() ;
  ::sensoris::protobuf::categories::roadattribution::SurfaceMarking* mutable_surface_marking(int index);
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::SurfaceMarking >*
      mutable_surface_marking();
  private:
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::SurfaceMarking>& _internal_surface_marking() const;
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::SurfaceMarking>* _internal_mutable_surface_marking();
  public:
  const ::sensoris::protobuf::categories::roadattribution::SurfaceMarking& surface_marking(int index) const;
  ::sensoris::protobuf::categories::roadattribution::SurfaceMarking* add_surface_marking();
  const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::SurfaceMarking >&
      surface_marking() const;
  // repeated .sensoris.protobuf.categories.roadattribution.SurfaceAttribution surface_attribution = 7;
  int surface_attribution_size() const;
  private:
  int _internal_surface_attribution_size() const;

  public:
  void clear_surface_attribution() ;
  ::sensoris::protobuf::categories::roadattribution::SurfaceAttribution* mutable_surface_attribution(int index);
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::SurfaceAttribution >*
      mutable_surface_attribution();
  private:
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::SurfaceAttribution>& _internal_surface_attribution() const;
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::SurfaceAttribution>* _internal_mutable_surface_attribution();
  public:
  const ::sensoris::protobuf::categories::roadattribution::SurfaceAttribution& surface_attribution(int index) const;
  ::sensoris::protobuf::categories::roadattribution::SurfaceAttribution* add_surface_attribution();
  const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::SurfaceAttribution >&
      surface_attribution() const;
  // repeated .sensoris.protobuf.categories.roadattribution.RoadAttribution road_attribution = 8;
  int road_attribution_size() const;
  private:
  int _internal_road_attribution_size() const;

  public:
  void clear_road_attribution() ;
  ::sensoris::protobuf::categories::roadattribution::RoadAttribution* mutable_road_attribution(int index);
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::RoadAttribution >*
      mutable_road_attribution();
  private:
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::RoadAttribution>& _internal_road_attribution() const;
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::RoadAttribution>* _internal_mutable_road_attribution();
  public:
  const ::sensoris::protobuf::categories::roadattribution::RoadAttribution& road_attribution(int index) const;
  ::sensoris::protobuf::categories::roadattribution::RoadAttribution* add_road_attribution();
  const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::RoadAttribution >&
      road_attribution() const;
  // repeated .sensoris.protobuf.categories.roadattribution.LaneCountAndConfidence detected_lane_count_and_confidence = 9;
  int detected_lane_count_and_confidence_size() const;
  private:
  int _internal_detected_lane_count_and_confidence_size() const;

  public:
  void clear_detected_lane_count_and_confidence() ;
  ::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence* mutable_detected_lane_count_and_confidence(int index);
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence >*
      mutable_detected_lane_count_and_confidence();
  private:
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence>& _internal_detected_lane_count_and_confidence() const;
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence>* _internal_mutable_detected_lane_count_and_confidence();
  public:
  const ::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence& detected_lane_count_and_confidence(int index) const;
  ::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence* add_detected_lane_count_and_confidence();
  const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence >&
      detected_lane_count_and_confidence() const;
  // repeated .sensoris.protobuf.categories.roadattribution.LaneCountAndConfidence estimated_lane_count_and_confidence = 10;
  int estimated_lane_count_and_confidence_size() const;
  private:
  int _internal_estimated_lane_count_and_confidence_size() const;

  public:
  void clear_estimated_lane_count_and_confidence() ;
  ::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence* mutable_estimated_lane_count_and_confidence(int index);
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence >*
      mutable_estimated_lane_count_and_confidence();
  private:
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence>& _internal_estimated_lane_count_and_confidence() const;
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence>* _internal_mutable_estimated_lane_count_and_confidence();
  public:
  const ::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence& estimated_lane_count_and_confidence(int index) const;
  ::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence* add_estimated_lane_count_and_confidence();
  const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence >&
      estimated_lane_count_and_confidence() const;
  // .sensoris.protobuf.types.base.CategoryEnvelope envelope = 1;
  bool has_envelope() const;
  void clear_envelope() ;
  const ::sensoris::protobuf::types::base::CategoryEnvelope& envelope() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::CategoryEnvelope* release_envelope();
  ::sensoris::protobuf::types::base::CategoryEnvelope* mutable_envelope();
  void set_allocated_envelope(::sensoris::protobuf::types::base::CategoryEnvelope* value);
  void unsafe_arena_set_allocated_envelope(::sensoris::protobuf::types::base::CategoryEnvelope* value);
  ::sensoris::protobuf::types::base::CategoryEnvelope* unsafe_arena_release_envelope();

  private:
  const ::sensoris::protobuf::types::base::CategoryEnvelope& _internal_envelope() const;
  ::sensoris::protobuf::types::base::CategoryEnvelope* _internal_mutable_envelope();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 10, 10,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::LaneBoundary > lane_boundary_;
    ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit > lane_boundary_merge_split_;
    ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::Lane > lane_;
    ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::Road > road_;
    ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::SurfaceMarking > surface_marking_;
    ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::SurfaceAttribution > surface_attribution_;
    ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::RoadAttribution > road_attribution_;
    ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence > detected_lane_count_and_confidence_;
    ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence > estimated_lane_count_and_confidence_;
    ::sensoris::protobuf::types::base::CategoryEnvelope* envelope_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// MarkingColorAndConfidence

// .sensoris.protobuf.categories.roadattribution.MarkingColorAndConfidence.Type type = 1;
inline void MarkingColorAndConfidence::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
}
inline ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence_Type MarkingColorAndConfidence::type() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.MarkingColorAndConfidence.type)
  return _internal_type();
}
inline void MarkingColorAndConfidence::set_type(::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.roadattribution.MarkingColorAndConfidence.type)
}
inline ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence_Type MarkingColorAndConfidence::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence_Type>(_impl_.type_);
}
inline void MarkingColorAndConfidence::_internal_set_type(::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence_Type value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// .sensoris.protobuf.types.base.Confidence confidence = 2;
inline bool MarkingColorAndConfidence::has_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.confidence_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Confidence& MarkingColorAndConfidence::_internal_confidence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::Confidence* p = _impl_.confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Confidence&>(::sensoris::protobuf::types::base::_Confidence_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Confidence& MarkingColorAndConfidence::confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.MarkingColorAndConfidence.confidence)
  return _internal_confidence();
}
inline void MarkingColorAndConfidence::unsafe_arena_set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }
  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.MarkingColorAndConfidence.confidence)
}
inline ::sensoris::protobuf::types::base::Confidence* MarkingColorAndConfidence::release_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* released = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::Confidence* MarkingColorAndConfidence::unsafe_arena_release_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.MarkingColorAndConfidence.confidence)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* temp = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* MarkingColorAndConfidence::_internal_mutable_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.confidence_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Confidence>(GetArena());
    _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(p);
  }
  return _impl_.confidence_;
}
inline ::sensoris::protobuf::types::base::Confidence* MarkingColorAndConfidence::mutable_confidence() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::Confidence* _msg = _internal_mutable_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.MarkingColorAndConfidence.confidence)
  return _msg;
}
inline void MarkingColorAndConfidence::set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.MarkingColorAndConfidence.confidence)
}

// -------------------------------------------------------------------

// MarkingMaterialAndConfidence

// .sensoris.protobuf.categories.roadattribution.MarkingMaterialAndConfidence.Type type = 1;
inline void MarkingMaterialAndConfidence::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
}
inline ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence_Type MarkingMaterialAndConfidence::type() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.MarkingMaterialAndConfidence.type)
  return _internal_type();
}
inline void MarkingMaterialAndConfidence::set_type(::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.roadattribution.MarkingMaterialAndConfidence.type)
}
inline ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence_Type MarkingMaterialAndConfidence::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence_Type>(_impl_.type_);
}
inline void MarkingMaterialAndConfidence::_internal_set_type(::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence_Type value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// .sensoris.protobuf.types.base.Confidence confidence = 2;
inline bool MarkingMaterialAndConfidence::has_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.confidence_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Confidence& MarkingMaterialAndConfidence::_internal_confidence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::Confidence* p = _impl_.confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Confidence&>(::sensoris::protobuf::types::base::_Confidence_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Confidence& MarkingMaterialAndConfidence::confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.MarkingMaterialAndConfidence.confidence)
  return _internal_confidence();
}
inline void MarkingMaterialAndConfidence::unsafe_arena_set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }
  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.MarkingMaterialAndConfidence.confidence)
}
inline ::sensoris::protobuf::types::base::Confidence* MarkingMaterialAndConfidence::release_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* released = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::Confidence* MarkingMaterialAndConfidence::unsafe_arena_release_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.MarkingMaterialAndConfidence.confidence)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* temp = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* MarkingMaterialAndConfidence::_internal_mutable_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.confidence_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Confidence>(GetArena());
    _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(p);
  }
  return _impl_.confidence_;
}
inline ::sensoris::protobuf::types::base::Confidence* MarkingMaterialAndConfidence::mutable_confidence() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::Confidence* _msg = _internal_mutable_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.MarkingMaterialAndConfidence.confidence)
  return _msg;
}
inline void MarkingMaterialAndConfidence::set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.MarkingMaterialAndConfidence.confidence)
}

// -------------------------------------------------------------------

// SurfaceMaterialAndConfidence

// .sensoris.protobuf.categories.roadattribution.SurfaceMaterialAndConfidence.Type type = 1;
inline void SurfaceMaterialAndConfidence::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
}
inline ::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence_Type SurfaceMaterialAndConfidence::type() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.SurfaceMaterialAndConfidence.type)
  return _internal_type();
}
inline void SurfaceMaterialAndConfidence::set_type(::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.roadattribution.SurfaceMaterialAndConfidence.type)
}
inline ::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence_Type SurfaceMaterialAndConfidence::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence_Type>(_impl_.type_);
}
inline void SurfaceMaterialAndConfidence::_internal_set_type(::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence_Type value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// .sensoris.protobuf.types.base.Confidence confidence = 2;
inline bool SurfaceMaterialAndConfidence::has_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.confidence_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Confidence& SurfaceMaterialAndConfidence::_internal_confidence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::Confidence* p = _impl_.confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Confidence&>(::sensoris::protobuf::types::base::_Confidence_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Confidence& SurfaceMaterialAndConfidence::confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.SurfaceMaterialAndConfidence.confidence)
  return _internal_confidence();
}
inline void SurfaceMaterialAndConfidence::unsafe_arena_set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }
  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.SurfaceMaterialAndConfidence.confidence)
}
inline ::sensoris::protobuf::types::base::Confidence* SurfaceMaterialAndConfidence::release_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* released = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::Confidence* SurfaceMaterialAndConfidence::unsafe_arena_release_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.SurfaceMaterialAndConfidence.confidence)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* temp = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* SurfaceMaterialAndConfidence::_internal_mutable_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.confidence_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Confidence>(GetArena());
    _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(p);
  }
  return _impl_.confidence_;
}
inline ::sensoris::protobuf::types::base::Confidence* SurfaceMaterialAndConfidence::mutable_confidence() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::Confidence* _msg = _internal_mutable_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.SurfaceMaterialAndConfidence.confidence)
  return _msg;
}
inline void SurfaceMaterialAndConfidence::set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.SurfaceMaterialAndConfidence.confidence)
}

// -------------------------------------------------------------------

// InclinationAndCurvature

// .sensoris.protobuf.types.base.Int64ValueAndAccuracy longitudinal_inclination_and_accuracy = 1 [(.sensoris.protobuf.types.base.exponent) = 2];
inline bool InclinationAndCurvature::has_longitudinal_inclination_and_accuracy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.longitudinal_inclination_and_accuracy_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& InclinationAndCurvature::_internal_longitudinal_inclination_and_accuracy() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* p = _impl_.longitudinal_inclination_and_accuracy_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy&>(::sensoris::protobuf::types::base::_Int64ValueAndAccuracy_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& InclinationAndCurvature::longitudinal_inclination_and_accuracy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.InclinationAndCurvature.longitudinal_inclination_and_accuracy)
  return _internal_longitudinal_inclination_and_accuracy();
}
inline void InclinationAndCurvature::unsafe_arena_set_allocated_longitudinal_inclination_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.longitudinal_inclination_and_accuracy_);
  }
  _impl_.longitudinal_inclination_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.InclinationAndCurvature.longitudinal_inclination_and_accuracy)
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* InclinationAndCurvature::release_longitudinal_inclination_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* released = _impl_.longitudinal_inclination_and_accuracy_;
  _impl_.longitudinal_inclination_and_accuracy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* InclinationAndCurvature::unsafe_arena_release_longitudinal_inclination_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.InclinationAndCurvature.longitudinal_inclination_and_accuracy)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* temp = _impl_.longitudinal_inclination_and_accuracy_;
  _impl_.longitudinal_inclination_and_accuracy_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* InclinationAndCurvature::_internal_mutable_longitudinal_inclination_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.longitudinal_inclination_and_accuracy_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64ValueAndAccuracy>(GetArena());
    _impl_.longitudinal_inclination_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(p);
  }
  return _impl_.longitudinal_inclination_and_accuracy_;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* InclinationAndCurvature::mutable_longitudinal_inclination_and_accuracy() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* _msg = _internal_mutable_longitudinal_inclination_and_accuracy();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.InclinationAndCurvature.longitudinal_inclination_and_accuracy)
  return _msg;
}
inline void InclinationAndCurvature::set_allocated_longitudinal_inclination_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.longitudinal_inclination_and_accuracy_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.longitudinal_inclination_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.InclinationAndCurvature.longitudinal_inclination_and_accuracy)
}

// .sensoris.protobuf.types.base.Int64ValueAndAccuracy lateral_inclination_and_accuracy = 2 [(.sensoris.protobuf.types.base.exponent) = 2];
inline bool InclinationAndCurvature::has_lateral_inclination_and_accuracy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.lateral_inclination_and_accuracy_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& InclinationAndCurvature::_internal_lateral_inclination_and_accuracy() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* p = _impl_.lateral_inclination_and_accuracy_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy&>(::sensoris::protobuf::types::base::_Int64ValueAndAccuracy_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& InclinationAndCurvature::lateral_inclination_and_accuracy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.InclinationAndCurvature.lateral_inclination_and_accuracy)
  return _internal_lateral_inclination_and_accuracy();
}
inline void InclinationAndCurvature::unsafe_arena_set_allocated_lateral_inclination_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.lateral_inclination_and_accuracy_);
  }
  _impl_.lateral_inclination_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.InclinationAndCurvature.lateral_inclination_and_accuracy)
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* InclinationAndCurvature::release_lateral_inclination_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* released = _impl_.lateral_inclination_and_accuracy_;
  _impl_.lateral_inclination_and_accuracy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* InclinationAndCurvature::unsafe_arena_release_lateral_inclination_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.InclinationAndCurvature.lateral_inclination_and_accuracy)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* temp = _impl_.lateral_inclination_and_accuracy_;
  _impl_.lateral_inclination_and_accuracy_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* InclinationAndCurvature::_internal_mutable_lateral_inclination_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.lateral_inclination_and_accuracy_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64ValueAndAccuracy>(GetArena());
    _impl_.lateral_inclination_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(p);
  }
  return _impl_.lateral_inclination_and_accuracy_;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* InclinationAndCurvature::mutable_lateral_inclination_and_accuracy() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* _msg = _internal_mutable_lateral_inclination_and_accuracy();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.InclinationAndCurvature.lateral_inclination_and_accuracy)
  return _msg;
}
inline void InclinationAndCurvature::set_allocated_lateral_inclination_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.lateral_inclination_and_accuracy_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.lateral_inclination_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.InclinationAndCurvature.lateral_inclination_and_accuracy)
}

// .sensoris.protobuf.types.base.Int64ValueAndAccuracy horizontal_curvature_and_accuracy = 3 [(.sensoris.protobuf.types.base.exponent) = 3];
inline bool InclinationAndCurvature::has_horizontal_curvature_and_accuracy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.horizontal_curvature_and_accuracy_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& InclinationAndCurvature::_internal_horizontal_curvature_and_accuracy() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* p = _impl_.horizontal_curvature_and_accuracy_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy&>(::sensoris::protobuf::types::base::_Int64ValueAndAccuracy_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& InclinationAndCurvature::horizontal_curvature_and_accuracy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.InclinationAndCurvature.horizontal_curvature_and_accuracy)
  return _internal_horizontal_curvature_and_accuracy();
}
inline void InclinationAndCurvature::unsafe_arena_set_allocated_horizontal_curvature_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.horizontal_curvature_and_accuracy_);
  }
  _impl_.horizontal_curvature_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.InclinationAndCurvature.horizontal_curvature_and_accuracy)
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* InclinationAndCurvature::release_horizontal_curvature_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* released = _impl_.horizontal_curvature_and_accuracy_;
  _impl_.horizontal_curvature_and_accuracy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* InclinationAndCurvature::unsafe_arena_release_horizontal_curvature_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.InclinationAndCurvature.horizontal_curvature_and_accuracy)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* temp = _impl_.horizontal_curvature_and_accuracy_;
  _impl_.horizontal_curvature_and_accuracy_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* InclinationAndCurvature::_internal_mutable_horizontal_curvature_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.horizontal_curvature_and_accuracy_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64ValueAndAccuracy>(GetArena());
    _impl_.horizontal_curvature_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(p);
  }
  return _impl_.horizontal_curvature_and_accuracy_;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* InclinationAndCurvature::mutable_horizontal_curvature_and_accuracy() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* _msg = _internal_mutable_horizontal_curvature_and_accuracy();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.InclinationAndCurvature.horizontal_curvature_and_accuracy)
  return _msg;
}
inline void InclinationAndCurvature::set_allocated_horizontal_curvature_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.horizontal_curvature_and_accuracy_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.horizontal_curvature_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.InclinationAndCurvature.horizontal_curvature_and_accuracy)
}

// -------------------------------------------------------------------

// LaneBoundary_TypeAndConfidence

// .sensoris.protobuf.categories.roadattribution.LaneBoundary.TypeAndConfidence.Type type = 1;
inline void LaneBoundary_TypeAndConfidence::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence_Type LaneBoundary_TypeAndConfidence::type() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundary.TypeAndConfidence.type)
  return _internal_type();
}
inline void LaneBoundary_TypeAndConfidence::set_type(::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.roadattribution.LaneBoundary.TypeAndConfidence.type)
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence_Type LaneBoundary_TypeAndConfidence::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence_Type>(_impl_.type_);
}
inline void LaneBoundary_TypeAndConfidence::_internal_set_type(::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence_Type value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// .sensoris.protobuf.types.base.Confidence confidence = 2;
inline bool LaneBoundary_TypeAndConfidence::has_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.confidence_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Confidence& LaneBoundary_TypeAndConfidence::_internal_confidence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::Confidence* p = _impl_.confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Confidence&>(::sensoris::protobuf::types::base::_Confidence_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Confidence& LaneBoundary_TypeAndConfidence::confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundary.TypeAndConfidence.confidence)
  return _internal_confidence();
}
inline void LaneBoundary_TypeAndConfidence::unsafe_arena_set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }
  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.TypeAndConfidence.confidence)
}
inline ::sensoris::protobuf::types::base::Confidence* LaneBoundary_TypeAndConfidence::release_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* released = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::Confidence* LaneBoundary_TypeAndConfidence::unsafe_arena_release_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneBoundary.TypeAndConfidence.confidence)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* temp = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* LaneBoundary_TypeAndConfidence::_internal_mutable_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.confidence_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Confidence>(GetArena());
    _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(p);
  }
  return _impl_.confidence_;
}
inline ::sensoris::protobuf::types::base::Confidence* LaneBoundary_TypeAndConfidence::mutable_confidence() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::Confidence* _msg = _internal_mutable_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneBoundary.TypeAndConfidence.confidence)
  return _msg;
}
inline void LaneBoundary_TypeAndConfidence::set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.TypeAndConfidence.confidence)
}

// -------------------------------------------------------------------

// LaneBoundary_DashStatistics

// .sensoris.protobuf.types.base.Int64ValueAndAccuracy length_and_accuracy = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool LaneBoundary_DashStatistics::has_length_and_accuracy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.length_and_accuracy_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& LaneBoundary_DashStatistics::_internal_length_and_accuracy() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* p = _impl_.length_and_accuracy_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy&>(::sensoris::protobuf::types::base::_Int64ValueAndAccuracy_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& LaneBoundary_DashStatistics::length_and_accuracy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundary.DashStatistics.length_and_accuracy)
  return _internal_length_and_accuracy();
}
inline void LaneBoundary_DashStatistics::unsafe_arena_set_allocated_length_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.length_and_accuracy_);
  }
  _impl_.length_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.DashStatistics.length_and_accuracy)
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* LaneBoundary_DashStatistics::release_length_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* released = _impl_.length_and_accuracy_;
  _impl_.length_and_accuracy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* LaneBoundary_DashStatistics::unsafe_arena_release_length_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneBoundary.DashStatistics.length_and_accuracy)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* temp = _impl_.length_and_accuracy_;
  _impl_.length_and_accuracy_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* LaneBoundary_DashStatistics::_internal_mutable_length_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.length_and_accuracy_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64ValueAndAccuracy>(GetArena());
    _impl_.length_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(p);
  }
  return _impl_.length_and_accuracy_;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* LaneBoundary_DashStatistics::mutable_length_and_accuracy() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* _msg = _internal_mutable_length_and_accuracy();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneBoundary.DashStatistics.length_and_accuracy)
  return _msg;
}
inline void LaneBoundary_DashStatistics::set_allocated_length_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.length_and_accuracy_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.length_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.DashStatistics.length_and_accuracy)
}

// .sensoris.protobuf.types.base.Int64ValueAndAccuracy distance_and_accuracy = 3 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool LaneBoundary_DashStatistics::has_distance_and_accuracy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.distance_and_accuracy_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& LaneBoundary_DashStatistics::_internal_distance_and_accuracy() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* p = _impl_.distance_and_accuracy_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy&>(::sensoris::protobuf::types::base::_Int64ValueAndAccuracy_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& LaneBoundary_DashStatistics::distance_and_accuracy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundary.DashStatistics.distance_and_accuracy)
  return _internal_distance_and_accuracy();
}
inline void LaneBoundary_DashStatistics::unsafe_arena_set_allocated_distance_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.distance_and_accuracy_);
  }
  _impl_.distance_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.DashStatistics.distance_and_accuracy)
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* LaneBoundary_DashStatistics::release_distance_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* released = _impl_.distance_and_accuracy_;
  _impl_.distance_and_accuracy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* LaneBoundary_DashStatistics::unsafe_arena_release_distance_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneBoundary.DashStatistics.distance_and_accuracy)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* temp = _impl_.distance_and_accuracy_;
  _impl_.distance_and_accuracy_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* LaneBoundary_DashStatistics::_internal_mutable_distance_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.distance_and_accuracy_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64ValueAndAccuracy>(GetArena());
    _impl_.distance_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(p);
  }
  return _impl_.distance_and_accuracy_;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* LaneBoundary_DashStatistics::mutable_distance_and_accuracy() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* _msg = _internal_mutable_distance_and_accuracy();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneBoundary.DashStatistics.distance_and_accuracy)
  return _msg;
}
inline void LaneBoundary_DashStatistics::set_allocated_distance_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.distance_and_accuracy_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.distance_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.DashStatistics.distance_and_accuracy)
}

// -------------------------------------------------------------------

// LaneBoundary_MarkingOffsets_TypeAndOffset

// .sensoris.protobuf.categories.roadattribution.LaneBoundary.MarkingOffsets.TypeAndOffset.Type type = 1;
inline void LaneBoundary_MarkingOffsets_TypeAndOffset::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset_Type LaneBoundary_MarkingOffsets_TypeAndOffset::type() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundary.MarkingOffsets.TypeAndOffset.type)
  return _internal_type();
}
inline void LaneBoundary_MarkingOffsets_TypeAndOffset::set_type(::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.roadattribution.LaneBoundary.MarkingOffsets.TypeAndOffset.type)
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset_Type LaneBoundary_MarkingOffsets_TypeAndOffset::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset_Type>(_impl_.type_);
}
inline void LaneBoundary_MarkingOffsets_TypeAndOffset::_internal_set_type(::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset_Type value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// .sensoris.protobuf.types.base.Int64ValueAndAccuracy offset_and_accuracy = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool LaneBoundary_MarkingOffsets_TypeAndOffset::has_offset_and_accuracy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.offset_and_accuracy_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& LaneBoundary_MarkingOffsets_TypeAndOffset::_internal_offset_and_accuracy() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* p = _impl_.offset_and_accuracy_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy&>(::sensoris::protobuf::types::base::_Int64ValueAndAccuracy_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& LaneBoundary_MarkingOffsets_TypeAndOffset::offset_and_accuracy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundary.MarkingOffsets.TypeAndOffset.offset_and_accuracy)
  return _internal_offset_and_accuracy();
}
inline void LaneBoundary_MarkingOffsets_TypeAndOffset::unsafe_arena_set_allocated_offset_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.offset_and_accuracy_);
  }
  _impl_.offset_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.MarkingOffsets.TypeAndOffset.offset_and_accuracy)
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* LaneBoundary_MarkingOffsets_TypeAndOffset::release_offset_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* released = _impl_.offset_and_accuracy_;
  _impl_.offset_and_accuracy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* LaneBoundary_MarkingOffsets_TypeAndOffset::unsafe_arena_release_offset_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneBoundary.MarkingOffsets.TypeAndOffset.offset_and_accuracy)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* temp = _impl_.offset_and_accuracy_;
  _impl_.offset_and_accuracy_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* LaneBoundary_MarkingOffsets_TypeAndOffset::_internal_mutable_offset_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.offset_and_accuracy_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64ValueAndAccuracy>(GetArena());
    _impl_.offset_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(p);
  }
  return _impl_.offset_and_accuracy_;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* LaneBoundary_MarkingOffsets_TypeAndOffset::mutable_offset_and_accuracy() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* _msg = _internal_mutable_offset_and_accuracy();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneBoundary.MarkingOffsets.TypeAndOffset.offset_and_accuracy)
  return _msg;
}
inline void LaneBoundary_MarkingOffsets_TypeAndOffset::set_allocated_offset_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.offset_and_accuracy_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.offset_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.MarkingOffsets.TypeAndOffset.offset_and_accuracy)
}

// -------------------------------------------------------------------

// LaneBoundary_MarkingOffsets

// repeated .sensoris.protobuf.categories.roadattribution.LaneBoundary.MarkingOffsets.TypeAndOffset type_and_offset = 2;
inline int LaneBoundary_MarkingOffsets::_internal_type_and_offset_size() const {
  return _internal_type_and_offset().size();
}
inline int LaneBoundary_MarkingOffsets::type_and_offset_size() const {
  return _internal_type_and_offset_size();
}
inline void LaneBoundary_MarkingOffsets::clear_type_and_offset() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_and_offset_.Clear();
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset* LaneBoundary_MarkingOffsets::mutable_type_and_offset(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneBoundary.MarkingOffsets.type_and_offset)
  return _internal_mutable_type_and_offset()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset>* LaneBoundary_MarkingOffsets::mutable_type_and_offset()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.roadattribution.LaneBoundary.MarkingOffsets.type_and_offset)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_type_and_offset();
}
inline const ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset& LaneBoundary_MarkingOffsets::type_and_offset(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundary.MarkingOffsets.type_and_offset)
  return _internal_type_and_offset().Get(index);
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset* LaneBoundary_MarkingOffsets::add_type_and_offset() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset* _add = _internal_mutable_type_and_offset()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.roadattribution.LaneBoundary.MarkingOffsets.type_and_offset)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset>& LaneBoundary_MarkingOffsets::type_and_offset() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.roadattribution.LaneBoundary.MarkingOffsets.type_and_offset)
  return _internal_type_and_offset();
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset>&
LaneBoundary_MarkingOffsets::_internal_type_and_offset() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.type_and_offset_;
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset>*
LaneBoundary_MarkingOffsets::_internal_mutable_type_and_offset() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.type_and_offset_;
}

// -------------------------------------------------------------------

// LaneBoundary

// .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
inline bool LaneBoundary::has_envelope() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.envelope_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& LaneBoundary::_internal_envelope() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::EventEnvelope* p = _impl_.envelope_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::EventEnvelope&>(::sensoris::protobuf::types::base::_EventEnvelope_default_instance_);
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& LaneBoundary::envelope() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundary.envelope)
  return _internal_envelope();
}
inline void LaneBoundary::unsafe_arena_set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }
  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.envelope)
}
inline ::sensoris::protobuf::types::base::EventEnvelope* LaneBoundary::release_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* released = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* LaneBoundary::unsafe_arena_release_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneBoundary.envelope)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* temp = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* LaneBoundary::_internal_mutable_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.envelope_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::EventEnvelope>(GetArena());
    _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(p);
  }
  return _impl_.envelope_;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* LaneBoundary::mutable_envelope() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::EventEnvelope* _msg = _internal_mutable_envelope();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneBoundary.envelope)
  return _msg;
}
inline void LaneBoundary::set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.envelope)
}

// .google.protobuf.Int64Value lane_boundary_id = 2;
inline bool LaneBoundary::has_lane_boundary_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.lane_boundary_id_ != nullptr);
  return value;
}
inline const ::google::protobuf::Int64Value& LaneBoundary::_internal_lane_boundary_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Int64Value* p = _impl_.lane_boundary_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Int64Value&>(::google::protobuf::_Int64Value_default_instance_);
}
inline const ::google::protobuf::Int64Value& LaneBoundary::lane_boundary_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundary.lane_boundary_id)
  return _internal_lane_boundary_id();
}
inline void LaneBoundary::unsafe_arena_set_allocated_lane_boundary_id(::google::protobuf::Int64Value* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.lane_boundary_id_);
  }
  _impl_.lane_boundary_id_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.lane_boundary_id)
}
inline ::google::protobuf::Int64Value* LaneBoundary::release_lane_boundary_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Int64Value* released = _impl_.lane_boundary_id_;
  _impl_.lane_boundary_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Int64Value* LaneBoundary::unsafe_arena_release_lane_boundary_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneBoundary.lane_boundary_id)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Int64Value* temp = _impl_.lane_boundary_id_;
  _impl_.lane_boundary_id_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int64Value* LaneBoundary::_internal_mutable_lane_boundary_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.lane_boundary_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int64Value>(GetArena());
    _impl_.lane_boundary_id_ = reinterpret_cast<::google::protobuf::Int64Value*>(p);
  }
  return _impl_.lane_boundary_id_;
}
inline ::google::protobuf::Int64Value* LaneBoundary::mutable_lane_boundary_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Int64Value* _msg = _internal_mutable_lane_boundary_id();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneBoundary.lane_boundary_id)
  return _msg;
}
inline void LaneBoundary::set_allocated_lane_boundary_id(::google::protobuf::Int64Value* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.lane_boundary_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.lane_boundary_id_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.lane_boundary_id)
}

// .sensoris.protobuf.types.base.Confidence existence_confidence = 3;
inline bool LaneBoundary::has_existence_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.existence_confidence_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Confidence& LaneBoundary::_internal_existence_confidence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::Confidence* p = _impl_.existence_confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Confidence&>(::sensoris::protobuf::types::base::_Confidence_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Confidence& LaneBoundary::existence_confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundary.existence_confidence)
  return _internal_existence_confidence();
}
inline void LaneBoundary::unsafe_arena_set_allocated_existence_confidence(::sensoris::protobuf::types::base::Confidence* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.existence_confidence_);
  }
  _impl_.existence_confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.existence_confidence)
}
inline ::sensoris::protobuf::types::base::Confidence* LaneBoundary::release_existence_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::types::base::Confidence* released = _impl_.existence_confidence_;
  _impl_.existence_confidence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::Confidence* LaneBoundary::unsafe_arena_release_existence_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneBoundary.existence_confidence)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::types::base::Confidence* temp = _impl_.existence_confidence_;
  _impl_.existence_confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* LaneBoundary::_internal_mutable_existence_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.existence_confidence_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Confidence>(GetArena());
    _impl_.existence_confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(p);
  }
  return _impl_.existence_confidence_;
}
inline ::sensoris::protobuf::types::base::Confidence* LaneBoundary::mutable_existence_confidence() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::Confidence* _msg = _internal_mutable_existence_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneBoundary.existence_confidence)
  return _msg;
}
inline void LaneBoundary::set_allocated_existence_confidence(::sensoris::protobuf::types::base::Confidence* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.existence_confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.existence_confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.existence_confidence)
}

// .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 4;
inline bool LaneBoundary::has_detection_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.detection_status_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::EventDetectionStatus& LaneBoundary::_internal_detection_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::EventDetectionStatus* p = _impl_.detection_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::EventDetectionStatus&>(::sensoris::protobuf::types::base::_EventDetectionStatus_default_instance_);
}
inline const ::sensoris::protobuf::types::base::EventDetectionStatus& LaneBoundary::detection_status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundary.detection_status)
  return _internal_detection_status();
}
inline void LaneBoundary::unsafe_arena_set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.detection_status_);
  }
  _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.detection_status)
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* LaneBoundary::release_detection_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::sensoris::protobuf::types::base::EventDetectionStatus* released = _impl_.detection_status_;
  _impl_.detection_status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* LaneBoundary::unsafe_arena_release_detection_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneBoundary.detection_status)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::sensoris::protobuf::types::base::EventDetectionStatus* temp = _impl_.detection_status_;
  _impl_.detection_status_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* LaneBoundary::_internal_mutable_detection_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.detection_status_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::EventDetectionStatus>(GetArena());
    _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(p);
  }
  return _impl_.detection_status_;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* LaneBoundary::mutable_detection_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::EventDetectionStatus* _msg = _internal_mutable_detection_status();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneBoundary.detection_status)
  return _msg;
}
inline void LaneBoundary::set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.detection_status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.detection_status)
}

// .sensoris.protobuf.categories.roadattribution.LaneBoundary.TypeAndConfidence type_and_confidence = 5;
inline bool LaneBoundary::has_type_and_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.type_and_confidence_ != nullptr);
  return value;
}
inline void LaneBoundary::clear_type_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.type_and_confidence_ != nullptr) _impl_.type_and_confidence_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence& LaneBoundary::_internal_type_and_confidence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence* p = _impl_.type_and_confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence&>(::sensoris::protobuf::categories::roadattribution::_LaneBoundary_TypeAndConfidence_default_instance_);
}
inline const ::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence& LaneBoundary::type_and_confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundary.type_and_confidence)
  return _internal_type_and_confidence();
}
inline void LaneBoundary::unsafe_arena_set_allocated_type_and_confidence(::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.type_and_confidence_);
  }
  _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.type_and_confidence)
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence* LaneBoundary::release_type_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence* released = _impl_.type_and_confidence_;
  _impl_.type_and_confidence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence* LaneBoundary::unsafe_arena_release_type_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneBoundary.type_and_confidence)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence* temp = _impl_.type_and_confidence_;
  _impl_.type_and_confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence* LaneBoundary::_internal_mutable_type_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.type_and_confidence_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence>(GetArena());
    _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence*>(p);
  }
  return _impl_.type_and_confidence_;
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence* LaneBoundary::mutable_type_and_confidence() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence* _msg = _internal_mutable_type_and_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneBoundary.type_and_confidence)
  return _msg;
}
inline void LaneBoundary::set_allocated_type_and_confidence(::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence*>(_impl_.type_and_confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.type_and_confidence)
}

// .sensoris.protobuf.categories.roadattribution.MarkingMaterialAndConfidence material_and_confidence = 6;
inline bool LaneBoundary::has_material_and_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.material_and_confidence_ != nullptr);
  return value;
}
inline void LaneBoundary::clear_material_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.material_and_confidence_ != nullptr) _impl_.material_and_confidence_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence& LaneBoundary::_internal_material_and_confidence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence* p = _impl_.material_and_confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence&>(::sensoris::protobuf::categories::roadattribution::_MarkingMaterialAndConfidence_default_instance_);
}
inline const ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence& LaneBoundary::material_and_confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundary.material_and_confidence)
  return _internal_material_and_confidence();
}
inline void LaneBoundary::unsafe_arena_set_allocated_material_and_confidence(::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.material_and_confidence_);
  }
  _impl_.material_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.material_and_confidence)
}
inline ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence* LaneBoundary::release_material_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence* released = _impl_.material_and_confidence_;
  _impl_.material_and_confidence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence* LaneBoundary::unsafe_arena_release_material_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneBoundary.material_and_confidence)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence* temp = _impl_.material_and_confidence_;
  _impl_.material_and_confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence* LaneBoundary::_internal_mutable_material_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.material_and_confidence_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence>(GetArena());
    _impl_.material_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence*>(p);
  }
  return _impl_.material_and_confidence_;
}
inline ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence* LaneBoundary::mutable_material_and_confidence() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence* _msg = _internal_mutable_material_and_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneBoundary.material_and_confidence)
  return _msg;
}
inline void LaneBoundary::set_allocated_material_and_confidence(::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence*>(_impl_.material_and_confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.material_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.material_and_confidence)
}

// .sensoris.protobuf.categories.roadattribution.MarkingColorAndConfidence color_and_confidence = 7;
inline bool LaneBoundary::has_color_and_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.color_and_confidence_ != nullptr);
  return value;
}
inline void LaneBoundary::clear_color_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.color_and_confidence_ != nullptr) _impl_.color_and_confidence_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence& LaneBoundary::_internal_color_and_confidence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence* p = _impl_.color_and_confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence&>(::sensoris::protobuf::categories::roadattribution::_MarkingColorAndConfidence_default_instance_);
}
inline const ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence& LaneBoundary::color_and_confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundary.color_and_confidence)
  return _internal_color_and_confidence();
}
inline void LaneBoundary::unsafe_arena_set_allocated_color_and_confidence(::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.color_and_confidence_);
  }
  _impl_.color_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.color_and_confidence)
}
inline ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence* LaneBoundary::release_color_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence* released = _impl_.color_and_confidence_;
  _impl_.color_and_confidence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence* LaneBoundary::unsafe_arena_release_color_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneBoundary.color_and_confidence)

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence* temp = _impl_.color_and_confidence_;
  _impl_.color_and_confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence* LaneBoundary::_internal_mutable_color_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.color_and_confidence_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence>(GetArena());
    _impl_.color_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence*>(p);
  }
  return _impl_.color_and_confidence_;
}
inline ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence* LaneBoundary::mutable_color_and_confidence() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence* _msg = _internal_mutable_color_and_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneBoundary.color_and_confidence)
  return _msg;
}
inline void LaneBoundary::set_allocated_color_and_confidence(::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence*>(_impl_.color_and_confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }

  _impl_.color_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.color_and_confidence)
}

// .sensoris.protobuf.categories.roadattribution.LaneBoundary.PositionReference position_reference = 8;
inline void LaneBoundary::clear_position_reference() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.position_reference_ = 0;
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundary_PositionReference LaneBoundary::position_reference() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundary.position_reference)
  return _internal_position_reference();
}
inline void LaneBoundary::set_position_reference(::sensoris::protobuf::categories::roadattribution::LaneBoundary_PositionReference value) {
  _internal_set_position_reference(value);
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.roadattribution.LaneBoundary.position_reference)
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundary_PositionReference LaneBoundary::_internal_position_reference() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::sensoris::protobuf::categories::roadattribution::LaneBoundary_PositionReference>(_impl_.position_reference_);
}
inline void LaneBoundary::_internal_set_position_reference(::sensoris::protobuf::categories::roadattribution::LaneBoundary_PositionReference value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.position_reference_ = value;
}

// .sensoris.protobuf.types.spatial.PolylineAndAccuracy polyline_and_accuracy = 9;
inline bool LaneBoundary::has_polyline_and_accuracy() const {
  return geometry_case() == kPolylineAndAccuracy;
}
inline bool LaneBoundary::_internal_has_polyline_and_accuracy() const {
  return geometry_case() == kPolylineAndAccuracy;
}
inline void LaneBoundary::set_has_polyline_and_accuracy() {
  _impl_._oneof_case_[0] = kPolylineAndAccuracy;
}
inline ::sensoris::protobuf::types::spatial::PolylineAndAccuracy* LaneBoundary::release_polyline_and_accuracy() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneBoundary.polyline_and_accuracy)
  if (geometry_case() == kPolylineAndAccuracy) {
    clear_has_geometry();
    auto* temp = _impl_.geometry_.polyline_and_accuracy_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.geometry_.polyline_and_accuracy_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensoris::protobuf::types::spatial::PolylineAndAccuracy& LaneBoundary::_internal_polyline_and_accuracy() const {
  return geometry_case() == kPolylineAndAccuracy ? *_impl_.geometry_.polyline_and_accuracy_ : reinterpret_cast<::sensoris::protobuf::types::spatial::PolylineAndAccuracy&>(::sensoris::protobuf::types::spatial::_PolylineAndAccuracy_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::PolylineAndAccuracy& LaneBoundary::polyline_and_accuracy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundary.polyline_and_accuracy)
  return _internal_polyline_and_accuracy();
}
inline ::sensoris::protobuf::types::spatial::PolylineAndAccuracy* LaneBoundary::unsafe_arena_release_polyline_and_accuracy() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.roadattribution.LaneBoundary.polyline_and_accuracy)
  if (geometry_case() == kPolylineAndAccuracy) {
    clear_has_geometry();
    auto* temp = _impl_.geometry_.polyline_and_accuracy_;
    _impl_.geometry_.polyline_and_accuracy_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LaneBoundary::unsafe_arena_set_allocated_polyline_and_accuracy(::sensoris::protobuf::types::spatial::PolylineAndAccuracy* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_geometry();
  if (value) {
    set_has_polyline_and_accuracy();
    _impl_.geometry_.polyline_and_accuracy_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.polyline_and_accuracy)
}
inline ::sensoris::protobuf::types::spatial::PolylineAndAccuracy* LaneBoundary::_internal_mutable_polyline_and_accuracy() {
  if (geometry_case() != kPolylineAndAccuracy) {
    clear_geometry();
    set_has_polyline_and_accuracy();
    _impl_.geometry_.polyline_and_accuracy_ = CreateMaybeMessage<::sensoris::protobuf::types::spatial::PolylineAndAccuracy>(GetArena());
  }
  return _impl_.geometry_.polyline_and_accuracy_;
}
inline ::sensoris::protobuf::types::spatial::PolylineAndAccuracy* LaneBoundary::mutable_polyline_and_accuracy() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::spatial::PolylineAndAccuracy* _msg = _internal_mutable_polyline_and_accuracy();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneBoundary.polyline_and_accuracy)
  return _msg;
}

// .sensoris.protobuf.types.base.Int64ValueAndAccuracy width_and_accuracy = 10 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool LaneBoundary::has_width_and_accuracy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.width_and_accuracy_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& LaneBoundary::_internal_width_and_accuracy() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* p = _impl_.width_and_accuracy_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy&>(::sensoris::protobuf::types::base::_Int64ValueAndAccuracy_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& LaneBoundary::width_and_accuracy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundary.width_and_accuracy)
  return _internal_width_and_accuracy();
}
inline void LaneBoundary::unsafe_arena_set_allocated_width_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.width_and_accuracy_);
  }
  _impl_.width_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.width_and_accuracy)
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* LaneBoundary::release_width_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* released = _impl_.width_and_accuracy_;
  _impl_.width_and_accuracy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* LaneBoundary::unsafe_arena_release_width_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneBoundary.width_and_accuracy)

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* temp = _impl_.width_and_accuracy_;
  _impl_.width_and_accuracy_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* LaneBoundary::_internal_mutable_width_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.width_and_accuracy_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64ValueAndAccuracy>(GetArena());
    _impl_.width_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(p);
  }
  return _impl_.width_and_accuracy_;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* LaneBoundary::mutable_width_and_accuracy() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* _msg = _internal_mutable_width_and_accuracy();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneBoundary.width_and_accuracy)
  return _msg;
}
inline void LaneBoundary::set_allocated_width_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.width_and_accuracy_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }

  _impl_.width_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.width_and_accuracy)
}

// .sensoris.protobuf.types.base.Int64ValueAndAccuracy height_and_accuracy = 11 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool LaneBoundary::has_height_and_accuracy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.height_and_accuracy_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& LaneBoundary::_internal_height_and_accuracy() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* p = _impl_.height_and_accuracy_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy&>(::sensoris::protobuf::types::base::_Int64ValueAndAccuracy_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& LaneBoundary::height_and_accuracy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundary.height_and_accuracy)
  return _internal_height_and_accuracy();
}
inline void LaneBoundary::unsafe_arena_set_allocated_height_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.height_and_accuracy_);
  }
  _impl_.height_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.height_and_accuracy)
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* LaneBoundary::release_height_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000100u;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* released = _impl_.height_and_accuracy_;
  _impl_.height_and_accuracy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* LaneBoundary::unsafe_arena_release_height_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneBoundary.height_and_accuracy)

  _impl_._has_bits_[0] &= ~0x00000100u;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* temp = _impl_.height_and_accuracy_;
  _impl_.height_and_accuracy_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* LaneBoundary::_internal_mutable_height_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000100u;
  if (_impl_.height_and_accuracy_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64ValueAndAccuracy>(GetArena());
    _impl_.height_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(p);
  }
  return _impl_.height_and_accuracy_;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* LaneBoundary::mutable_height_and_accuracy() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* _msg = _internal_mutable_height_and_accuracy();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneBoundary.height_and_accuracy)
  return _msg;
}
inline void LaneBoundary::set_allocated_height_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.height_and_accuracy_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }

  _impl_.height_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.height_and_accuracy)
}

// .sensoris.protobuf.types.base.Int64ValueAndAccuracy distance_between_double_and_accuracy = 12 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool LaneBoundary::has_distance_between_double_and_accuracy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.distance_between_double_and_accuracy_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& LaneBoundary::_internal_distance_between_double_and_accuracy() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* p = _impl_.distance_between_double_and_accuracy_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy&>(::sensoris::protobuf::types::base::_Int64ValueAndAccuracy_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& LaneBoundary::distance_between_double_and_accuracy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundary.distance_between_double_and_accuracy)
  return _internal_distance_between_double_and_accuracy();
}
inline void LaneBoundary::unsafe_arena_set_allocated_distance_between_double_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.distance_between_double_and_accuracy_);
  }
  _impl_.distance_between_double_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.distance_between_double_and_accuracy)
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* LaneBoundary::release_distance_between_double_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000200u;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* released = _impl_.distance_between_double_and_accuracy_;
  _impl_.distance_between_double_and_accuracy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* LaneBoundary::unsafe_arena_release_distance_between_double_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneBoundary.distance_between_double_and_accuracy)

  _impl_._has_bits_[0] &= ~0x00000200u;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* temp = _impl_.distance_between_double_and_accuracy_;
  _impl_.distance_between_double_and_accuracy_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* LaneBoundary::_internal_mutable_distance_between_double_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000200u;
  if (_impl_.distance_between_double_and_accuracy_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64ValueAndAccuracy>(GetArena());
    _impl_.distance_between_double_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(p);
  }
  return _impl_.distance_between_double_and_accuracy_;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* LaneBoundary::mutable_distance_between_double_and_accuracy() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* _msg = _internal_mutable_distance_between_double_and_accuracy();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneBoundary.distance_between_double_and_accuracy)
  return _msg;
}
inline void LaneBoundary::set_allocated_distance_between_double_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.distance_between_double_and_accuracy_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }

  _impl_.distance_between_double_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.distance_between_double_and_accuracy)
}

// .sensoris.protobuf.categories.roadattribution.LaneBoundary.DashStatistics dash_statistics = 13;
inline bool LaneBoundary::has_dash_statistics() const {
  return markings_case() == kDashStatistics;
}
inline bool LaneBoundary::_internal_has_dash_statistics() const {
  return markings_case() == kDashStatistics;
}
inline void LaneBoundary::set_has_dash_statistics() {
  _impl_._oneof_case_[1] = kDashStatistics;
}
inline void LaneBoundary::clear_dash_statistics() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (markings_case() == kDashStatistics) {
    if (GetArena() == nullptr) {
      delete _impl_.markings_.dash_statistics_;
    }
    clear_has_markings();
  }
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundary_DashStatistics* LaneBoundary::release_dash_statistics() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneBoundary.dash_statistics)
  if (markings_case() == kDashStatistics) {
    clear_has_markings();
    auto* temp = _impl_.markings_.dash_statistics_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.markings_.dash_statistics_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensoris::protobuf::categories::roadattribution::LaneBoundary_DashStatistics& LaneBoundary::_internal_dash_statistics() const {
  return markings_case() == kDashStatistics ? *_impl_.markings_.dash_statistics_ : reinterpret_cast<::sensoris::protobuf::categories::roadattribution::LaneBoundary_DashStatistics&>(::sensoris::protobuf::categories::roadattribution::_LaneBoundary_DashStatistics_default_instance_);
}
inline const ::sensoris::protobuf::categories::roadattribution::LaneBoundary_DashStatistics& LaneBoundary::dash_statistics() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundary.dash_statistics)
  return _internal_dash_statistics();
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundary_DashStatistics* LaneBoundary::unsafe_arena_release_dash_statistics() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.roadattribution.LaneBoundary.dash_statistics)
  if (markings_case() == kDashStatistics) {
    clear_has_markings();
    auto* temp = _impl_.markings_.dash_statistics_;
    _impl_.markings_.dash_statistics_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LaneBoundary::unsafe_arena_set_allocated_dash_statistics(::sensoris::protobuf::categories::roadattribution::LaneBoundary_DashStatistics* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_markings();
  if (value) {
    set_has_dash_statistics();
    _impl_.markings_.dash_statistics_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.dash_statistics)
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundary_DashStatistics* LaneBoundary::_internal_mutable_dash_statistics() {
  if (markings_case() != kDashStatistics) {
    clear_markings();
    set_has_dash_statistics();
    _impl_.markings_.dash_statistics_ = CreateMaybeMessage<::sensoris::protobuf::categories::roadattribution::LaneBoundary_DashStatistics>(GetArena());
  }
  return _impl_.markings_.dash_statistics_;
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundary_DashStatistics* LaneBoundary::mutable_dash_statistics() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::categories::roadattribution::LaneBoundary_DashStatistics* _msg = _internal_mutable_dash_statistics();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneBoundary.dash_statistics)
  return _msg;
}

// .sensoris.protobuf.categories.roadattribution.LaneBoundary.MarkingOffsets marking_offsets = 14;
inline bool LaneBoundary::has_marking_offsets() const {
  return markings_case() == kMarkingOffsets;
}
inline bool LaneBoundary::_internal_has_marking_offsets() const {
  return markings_case() == kMarkingOffsets;
}
inline void LaneBoundary::set_has_marking_offsets() {
  _impl_._oneof_case_[1] = kMarkingOffsets;
}
inline void LaneBoundary::clear_marking_offsets() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (markings_case() == kMarkingOffsets) {
    if (GetArena() == nullptr) {
      delete _impl_.markings_.marking_offsets_;
    }
    clear_has_markings();
  }
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets* LaneBoundary::release_marking_offsets() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneBoundary.marking_offsets)
  if (markings_case() == kMarkingOffsets) {
    clear_has_markings();
    auto* temp = _impl_.markings_.marking_offsets_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.markings_.marking_offsets_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets& LaneBoundary::_internal_marking_offsets() const {
  return markings_case() == kMarkingOffsets ? *_impl_.markings_.marking_offsets_ : reinterpret_cast<::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets&>(::sensoris::protobuf::categories::roadattribution::_LaneBoundary_MarkingOffsets_default_instance_);
}
inline const ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets& LaneBoundary::marking_offsets() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundary.marking_offsets)
  return _internal_marking_offsets();
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets* LaneBoundary::unsafe_arena_release_marking_offsets() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.roadattribution.LaneBoundary.marking_offsets)
  if (markings_case() == kMarkingOffsets) {
    clear_has_markings();
    auto* temp = _impl_.markings_.marking_offsets_;
    _impl_.markings_.marking_offsets_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LaneBoundary::unsafe_arena_set_allocated_marking_offsets(::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_markings();
  if (value) {
    set_has_marking_offsets();
    _impl_.markings_.marking_offsets_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.marking_offsets)
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets* LaneBoundary::_internal_mutable_marking_offsets() {
  if (markings_case() != kMarkingOffsets) {
    clear_markings();
    set_has_marking_offsets();
    _impl_.markings_.marking_offsets_ = CreateMaybeMessage<::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets>(GetArena());
  }
  return _impl_.markings_.marking_offsets_;
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets* LaneBoundary::mutable_marking_offsets() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets* _msg = _internal_mutable_marking_offsets();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneBoundary.marking_offsets)
  return _msg;
}

inline bool LaneBoundary::has_geometry() const {
  return geometry_case() != GEOMETRY_NOT_SET;
}
inline void LaneBoundary::clear_has_geometry() {
  _impl_._oneof_case_[0] = GEOMETRY_NOT_SET;
}
inline bool LaneBoundary::has_markings() const {
  return markings_case() != MARKINGS_NOT_SET;
}
inline void LaneBoundary::clear_has_markings() {
  _impl_._oneof_case_[1] = MARKINGS_NOT_SET;
}
inline LaneBoundary::GeometryCase LaneBoundary::geometry_case() const {
  return LaneBoundary::GeometryCase(_impl_._oneof_case_[0]);
}
inline LaneBoundary::MarkingsCase LaneBoundary::markings_case() const {
  return LaneBoundary::MarkingsCase(_impl_._oneof_case_[1]);
}
// -------------------------------------------------------------------

// LaneBoundaryMergeSplit_TypeAndConfidence

// .sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.TypeAndConfidence.Type type = 1;
inline void LaneBoundaryMergeSplit_TypeAndConfidence::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence_Type LaneBoundaryMergeSplit_TypeAndConfidence::type() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.TypeAndConfidence.type)
  return _internal_type();
}
inline void LaneBoundaryMergeSplit_TypeAndConfidence::set_type(::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.TypeAndConfidence.type)
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence_Type LaneBoundaryMergeSplit_TypeAndConfidence::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence_Type>(_impl_.type_);
}
inline void LaneBoundaryMergeSplit_TypeAndConfidence::_internal_set_type(::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence_Type value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// .sensoris.protobuf.types.base.Confidence confidence = 2;
inline bool LaneBoundaryMergeSplit_TypeAndConfidence::has_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.confidence_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Confidence& LaneBoundaryMergeSplit_TypeAndConfidence::_internal_confidence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::Confidence* p = _impl_.confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Confidence&>(::sensoris::protobuf::types::base::_Confidence_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Confidence& LaneBoundaryMergeSplit_TypeAndConfidence::confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.TypeAndConfidence.confidence)
  return _internal_confidence();
}
inline void LaneBoundaryMergeSplit_TypeAndConfidence::unsafe_arena_set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }
  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.TypeAndConfidence.confidence)
}
inline ::sensoris::protobuf::types::base::Confidence* LaneBoundaryMergeSplit_TypeAndConfidence::release_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* released = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::Confidence* LaneBoundaryMergeSplit_TypeAndConfidence::unsafe_arena_release_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.TypeAndConfidence.confidence)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* temp = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* LaneBoundaryMergeSplit_TypeAndConfidence::_internal_mutable_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.confidence_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Confidence>(GetArena());
    _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(p);
  }
  return _impl_.confidence_;
}
inline ::sensoris::protobuf::types::base::Confidence* LaneBoundaryMergeSplit_TypeAndConfidence::mutable_confidence() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::Confidence* _msg = _internal_mutable_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.TypeAndConfidence.confidence)
  return _msg;
}
inline void LaneBoundaryMergeSplit_TypeAndConfidence::set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.TypeAndConfidence.confidence)
}

// -------------------------------------------------------------------

// LaneBoundaryMergeSplit

// .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
inline bool LaneBoundaryMergeSplit::has_envelope() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.envelope_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& LaneBoundaryMergeSplit::_internal_envelope() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::EventEnvelope* p = _impl_.envelope_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::EventEnvelope&>(::sensoris::protobuf::types::base::_EventEnvelope_default_instance_);
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& LaneBoundaryMergeSplit::envelope() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.envelope)
  return _internal_envelope();
}
inline void LaneBoundaryMergeSplit::unsafe_arena_set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }
  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.envelope)
}
inline ::sensoris::protobuf::types::base::EventEnvelope* LaneBoundaryMergeSplit::release_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* released = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* LaneBoundaryMergeSplit::unsafe_arena_release_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.envelope)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* temp = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* LaneBoundaryMergeSplit::_internal_mutable_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.envelope_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::EventEnvelope>(GetArena());
    _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(p);
  }
  return _impl_.envelope_;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* LaneBoundaryMergeSplit::mutable_envelope() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::EventEnvelope* _msg = _internal_mutable_envelope();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.envelope)
  return _msg;
}
inline void LaneBoundaryMergeSplit::set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.envelope)
}

// .sensoris.protobuf.types.base.Confidence existence_confidence = 2;
inline bool LaneBoundaryMergeSplit::has_existence_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.existence_confidence_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Confidence& LaneBoundaryMergeSplit::_internal_existence_confidence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::Confidence* p = _impl_.existence_confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Confidence&>(::sensoris::protobuf::types::base::_Confidence_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Confidence& LaneBoundaryMergeSplit::existence_confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.existence_confidence)
  return _internal_existence_confidence();
}
inline void LaneBoundaryMergeSplit::unsafe_arena_set_allocated_existence_confidence(::sensoris::protobuf::types::base::Confidence* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.existence_confidence_);
  }
  _impl_.existence_confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.existence_confidence)
}
inline ::sensoris::protobuf::types::base::Confidence* LaneBoundaryMergeSplit::release_existence_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::Confidence* released = _impl_.existence_confidence_;
  _impl_.existence_confidence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::Confidence* LaneBoundaryMergeSplit::unsafe_arena_release_existence_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.existence_confidence)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::Confidence* temp = _impl_.existence_confidence_;
  _impl_.existence_confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* LaneBoundaryMergeSplit::_internal_mutable_existence_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.existence_confidence_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Confidence>(GetArena());
    _impl_.existence_confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(p);
  }
  return _impl_.existence_confidence_;
}
inline ::sensoris::protobuf::types::base::Confidence* LaneBoundaryMergeSplit::mutable_existence_confidence() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::Confidence* _msg = _internal_mutable_existence_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.existence_confidence)
  return _msg;
}
inline void LaneBoundaryMergeSplit::set_allocated_existence_confidence(::sensoris::protobuf::types::base::Confidence* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.existence_confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.existence_confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.existence_confidence)
}

// .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 3;
inline bool LaneBoundaryMergeSplit::has_detection_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.detection_status_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::EventDetectionStatus& LaneBoundaryMergeSplit::_internal_detection_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::EventDetectionStatus* p = _impl_.detection_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::EventDetectionStatus&>(::sensoris::protobuf::types::base::_EventDetectionStatus_default_instance_);
}
inline const ::sensoris::protobuf::types::base::EventDetectionStatus& LaneBoundaryMergeSplit::detection_status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.detection_status)
  return _internal_detection_status();
}
inline void LaneBoundaryMergeSplit::unsafe_arena_set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.detection_status_);
  }
  _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.detection_status)
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* LaneBoundaryMergeSplit::release_detection_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::types::base::EventDetectionStatus* released = _impl_.detection_status_;
  _impl_.detection_status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* LaneBoundaryMergeSplit::unsafe_arena_release_detection_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.detection_status)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::types::base::EventDetectionStatus* temp = _impl_.detection_status_;
  _impl_.detection_status_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* LaneBoundaryMergeSplit::_internal_mutable_detection_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.detection_status_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::EventDetectionStatus>(GetArena());
    _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(p);
  }
  return _impl_.detection_status_;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* LaneBoundaryMergeSplit::mutable_detection_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::EventDetectionStatus* _msg = _internal_mutable_detection_status();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.detection_status)
  return _msg;
}
inline void LaneBoundaryMergeSplit::set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.detection_status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.detection_status)
}

// .sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.TypeAndConfidence type_and_confidence = 4;
inline bool LaneBoundaryMergeSplit::has_type_and_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.type_and_confidence_ != nullptr);
  return value;
}
inline void LaneBoundaryMergeSplit::clear_type_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.type_and_confidence_ != nullptr) _impl_.type_and_confidence_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence& LaneBoundaryMergeSplit::_internal_type_and_confidence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence* p = _impl_.type_and_confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence&>(::sensoris::protobuf::categories::roadattribution::_LaneBoundaryMergeSplit_TypeAndConfidence_default_instance_);
}
inline const ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence& LaneBoundaryMergeSplit::type_and_confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.type_and_confidence)
  return _internal_type_and_confidence();
}
inline void LaneBoundaryMergeSplit::unsafe_arena_set_allocated_type_and_confidence(::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.type_and_confidence_);
  }
  _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.type_and_confidence)
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence* LaneBoundaryMergeSplit::release_type_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence* released = _impl_.type_and_confidence_;
  _impl_.type_and_confidence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence* LaneBoundaryMergeSplit::unsafe_arena_release_type_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.type_and_confidence)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence* temp = _impl_.type_and_confidence_;
  _impl_.type_and_confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence* LaneBoundaryMergeSplit::_internal_mutable_type_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.type_and_confidence_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence>(GetArena());
    _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence*>(p);
  }
  return _impl_.type_and_confidence_;
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence* LaneBoundaryMergeSplit::mutable_type_and_confidence() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence* _msg = _internal_mutable_type_and_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.type_and_confidence)
  return _msg;
}
inline void LaneBoundaryMergeSplit::set_allocated_type_and_confidence(::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence*>(_impl_.type_and_confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.type_and_confidence)
}

// .sensoris.protobuf.types.spatial.PositionAndAccuracy position_and_accuracy = 5;
inline bool LaneBoundaryMergeSplit::has_position_and_accuracy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_and_accuracy_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& LaneBoundaryMergeSplit::_internal_position_and_accuracy() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy* p = _impl_.position_and_accuracy_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::spatial::PositionAndAccuracy&>(::sensoris::protobuf::types::spatial::_PositionAndAccuracy_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& LaneBoundaryMergeSplit::position_and_accuracy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.position_and_accuracy)
  return _internal_position_and_accuracy();
}
inline void LaneBoundaryMergeSplit::unsafe_arena_set_allocated_position_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_and_accuracy_);
  }
  _impl_.position_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.position_and_accuracy)
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* LaneBoundaryMergeSplit::release_position_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* released = _impl_.position_and_accuracy_;
  _impl_.position_and_accuracy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* LaneBoundaryMergeSplit::unsafe_arena_release_position_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.position_and_accuracy)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* temp = _impl_.position_and_accuracy_;
  _impl_.position_and_accuracy_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* LaneBoundaryMergeSplit::_internal_mutable_position_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.position_and_accuracy_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::spatial::PositionAndAccuracy>(GetArena());
    _impl_.position_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(p);
  }
  return _impl_.position_and_accuracy_;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* LaneBoundaryMergeSplit::mutable_position_and_accuracy() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* _msg = _internal_mutable_position_and_accuracy();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.position_and_accuracy)
  return _msg;
}
inline void LaneBoundaryMergeSplit::set_allocated_position_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_and_accuracy_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.position_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.position_and_accuracy)
}

// -------------------------------------------------------------------

// Lane

// .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
inline bool Lane::has_envelope() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.envelope_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& Lane::_internal_envelope() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::EventEnvelope* p = _impl_.envelope_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::EventEnvelope&>(::sensoris::protobuf::types::base::_EventEnvelope_default_instance_);
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& Lane::envelope() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.Lane.envelope)
  return _internal_envelope();
}
inline void Lane::unsafe_arena_set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }
  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.Lane.envelope)
}
inline ::sensoris::protobuf::types::base::EventEnvelope* Lane::release_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* released = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* Lane::unsafe_arena_release_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.Lane.envelope)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* temp = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* Lane::_internal_mutable_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.envelope_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::EventEnvelope>(GetArena());
    _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(p);
  }
  return _impl_.envelope_;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* Lane::mutable_envelope() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::EventEnvelope* _msg = _internal_mutable_envelope();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.Lane.envelope)
  return _msg;
}
inline void Lane::set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.Lane.envelope)
}

// .google.protobuf.Int64Value relative_lane_id = 2;
inline bool Lane::has_relative_lane_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.relative_lane_id_ != nullptr);
  return value;
}
inline const ::google::protobuf::Int64Value& Lane::_internal_relative_lane_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Int64Value* p = _impl_.relative_lane_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Int64Value&>(::google::protobuf::_Int64Value_default_instance_);
}
inline const ::google::protobuf::Int64Value& Lane::relative_lane_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.Lane.relative_lane_id)
  return _internal_relative_lane_id();
}
inline void Lane::unsafe_arena_set_allocated_relative_lane_id(::google::protobuf::Int64Value* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.relative_lane_id_);
  }
  _impl_.relative_lane_id_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.Lane.relative_lane_id)
}
inline ::google::protobuf::Int64Value* Lane::release_relative_lane_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Int64Value* released = _impl_.relative_lane_id_;
  _impl_.relative_lane_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Int64Value* Lane::unsafe_arena_release_relative_lane_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.Lane.relative_lane_id)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Int64Value* temp = _impl_.relative_lane_id_;
  _impl_.relative_lane_id_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int64Value* Lane::_internal_mutable_relative_lane_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.relative_lane_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int64Value>(GetArena());
    _impl_.relative_lane_id_ = reinterpret_cast<::google::protobuf::Int64Value*>(p);
  }
  return _impl_.relative_lane_id_;
}
inline ::google::protobuf::Int64Value* Lane::mutable_relative_lane_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Int64Value* _msg = _internal_mutable_relative_lane_id();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.Lane.relative_lane_id)
  return _msg;
}
inline void Lane::set_allocated_relative_lane_id(::google::protobuf::Int64Value* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.relative_lane_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.relative_lane_id_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.Lane.relative_lane_id)
}

// .sensoris.protobuf.types.base.Int64ValueAndAccuracy width_and_accuracy = 3 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool Lane::has_width_and_accuracy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.width_and_accuracy_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& Lane::_internal_width_and_accuracy() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* p = _impl_.width_and_accuracy_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy&>(::sensoris::protobuf::types::base::_Int64ValueAndAccuracy_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& Lane::width_and_accuracy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.Lane.width_and_accuracy)
  return _internal_width_and_accuracy();
}
inline void Lane::unsafe_arena_set_allocated_width_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.width_and_accuracy_);
  }
  _impl_.width_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.Lane.width_and_accuracy)
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* Lane::release_width_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* released = _impl_.width_and_accuracy_;
  _impl_.width_and_accuracy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* Lane::unsafe_arena_release_width_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.Lane.width_and_accuracy)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* temp = _impl_.width_and_accuracy_;
  _impl_.width_and_accuracy_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* Lane::_internal_mutable_width_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.width_and_accuracy_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64ValueAndAccuracy>(GetArena());
    _impl_.width_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(p);
  }
  return _impl_.width_and_accuracy_;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* Lane::mutable_width_and_accuracy() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* _msg = _internal_mutable_width_and_accuracy();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.Lane.width_and_accuracy)
  return _msg;
}
inline void Lane::set_allocated_width_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.width_and_accuracy_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.width_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.Lane.width_and_accuracy)
}

// .sensoris.protobuf.categories.roadattribution.InclinationAndCurvature inclination_and_curvature = 4;
inline bool Lane::has_inclination_and_curvature() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.inclination_and_curvature_ != nullptr);
  return value;
}
inline void Lane::clear_inclination_and_curvature() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.inclination_and_curvature_ != nullptr) _impl_.inclination_and_curvature_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature& Lane::_internal_inclination_and_curvature() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* p = _impl_.inclination_and_curvature_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature&>(::sensoris::protobuf::categories::roadattribution::_InclinationAndCurvature_default_instance_);
}
inline const ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature& Lane::inclination_and_curvature() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.Lane.inclination_and_curvature)
  return _internal_inclination_and_curvature();
}
inline void Lane::unsafe_arena_set_allocated_inclination_and_curvature(::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.inclination_and_curvature_);
  }
  _impl_.inclination_and_curvature_ = reinterpret_cast<::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.Lane.inclination_and_curvature)
}
inline ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* Lane::release_inclination_and_curvature() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* released = _impl_.inclination_and_curvature_;
  _impl_.inclination_and_curvature_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* Lane::unsafe_arena_release_inclination_and_curvature() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.Lane.inclination_and_curvature)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* temp = _impl_.inclination_and_curvature_;
  _impl_.inclination_and_curvature_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* Lane::_internal_mutable_inclination_and_curvature() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.inclination_and_curvature_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature>(GetArena());
    _impl_.inclination_and_curvature_ = reinterpret_cast<::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature*>(p);
  }
  return _impl_.inclination_and_curvature_;
}
inline ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* Lane::mutable_inclination_and_curvature() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* _msg = _internal_mutable_inclination_and_curvature();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.Lane.inclination_and_curvature)
  return _msg;
}
inline void Lane::set_allocated_inclination_and_curvature(::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature*>(_impl_.inclination_and_curvature_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.inclination_and_curvature_ = reinterpret_cast<::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.Lane.inclination_and_curvature)
}

// -------------------------------------------------------------------

// Road

// .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
inline bool Road::has_envelope() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.envelope_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& Road::_internal_envelope() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::EventEnvelope* p = _impl_.envelope_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::EventEnvelope&>(::sensoris::protobuf::types::base::_EventEnvelope_default_instance_);
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& Road::envelope() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.Road.envelope)
  return _internal_envelope();
}
inline void Road::unsafe_arena_set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }
  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.Road.envelope)
}
inline ::sensoris::protobuf::types::base::EventEnvelope* Road::release_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* released = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* Road::unsafe_arena_release_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.Road.envelope)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* temp = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* Road::_internal_mutable_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.envelope_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::EventEnvelope>(GetArena());
    _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(p);
  }
  return _impl_.envelope_;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* Road::mutable_envelope() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::EventEnvelope* _msg = _internal_mutable_envelope();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.Road.envelope)
  return _msg;
}
inline void Road::set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.Road.envelope)
}

// .sensoris.protobuf.types.base.Int64ValueAndAccuracy width_and_accuracy = 2;
inline bool Road::has_width_and_accuracy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.width_and_accuracy_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& Road::_internal_width_and_accuracy() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* p = _impl_.width_and_accuracy_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy&>(::sensoris::protobuf::types::base::_Int64ValueAndAccuracy_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& Road::width_and_accuracy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.Road.width_and_accuracy)
  return _internal_width_and_accuracy();
}
inline void Road::unsafe_arena_set_allocated_width_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.width_and_accuracy_);
  }
  _impl_.width_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.Road.width_and_accuracy)
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* Road::release_width_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* released = _impl_.width_and_accuracy_;
  _impl_.width_and_accuracy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* Road::unsafe_arena_release_width_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.Road.width_and_accuracy)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* temp = _impl_.width_and_accuracy_;
  _impl_.width_and_accuracy_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* Road::_internal_mutable_width_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.width_and_accuracy_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64ValueAndAccuracy>(GetArena());
    _impl_.width_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(p);
  }
  return _impl_.width_and_accuracy_;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* Road::mutable_width_and_accuracy() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* _msg = _internal_mutable_width_and_accuracy();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.Road.width_and_accuracy)
  return _msg;
}
inline void Road::set_allocated_width_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.width_and_accuracy_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.width_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.Road.width_and_accuracy)
}

// .sensoris.protobuf.categories.roadattribution.InclinationAndCurvature inclination_and_curvature = 3;
inline bool Road::has_inclination_and_curvature() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.inclination_and_curvature_ != nullptr);
  return value;
}
inline void Road::clear_inclination_and_curvature() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.inclination_and_curvature_ != nullptr) _impl_.inclination_and_curvature_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature& Road::_internal_inclination_and_curvature() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* p = _impl_.inclination_and_curvature_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature&>(::sensoris::protobuf::categories::roadattribution::_InclinationAndCurvature_default_instance_);
}
inline const ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature& Road::inclination_and_curvature() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.Road.inclination_and_curvature)
  return _internal_inclination_and_curvature();
}
inline void Road::unsafe_arena_set_allocated_inclination_and_curvature(::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.inclination_and_curvature_);
  }
  _impl_.inclination_and_curvature_ = reinterpret_cast<::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.Road.inclination_and_curvature)
}
inline ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* Road::release_inclination_and_curvature() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* released = _impl_.inclination_and_curvature_;
  _impl_.inclination_and_curvature_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* Road::unsafe_arena_release_inclination_and_curvature() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.Road.inclination_and_curvature)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* temp = _impl_.inclination_and_curvature_;
  _impl_.inclination_and_curvature_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* Road::_internal_mutable_inclination_and_curvature() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.inclination_and_curvature_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature>(GetArena());
    _impl_.inclination_and_curvature_ = reinterpret_cast<::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature*>(p);
  }
  return _impl_.inclination_and_curvature_;
}
inline ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* Road::mutable_inclination_and_curvature() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* _msg = _internal_mutable_inclination_and_curvature();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.Road.inclination_and_curvature)
  return _msg;
}
inline void Road::set_allocated_inclination_and_curvature(::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature*>(_impl_.inclination_and_curvature_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.inclination_and_curvature_ = reinterpret_cast<::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.Road.inclination_and_curvature)
}

// -------------------------------------------------------------------

// SurfaceMarking_TypeAndConfidence

// .sensoris.protobuf.categories.roadattribution.SurfaceMarking.TypeAndConfidence.Type type = 1;
inline void SurfaceMarking_TypeAndConfidence::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
}
inline ::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence_Type SurfaceMarking_TypeAndConfidence::type() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.SurfaceMarking.TypeAndConfidence.type)
  return _internal_type();
}
inline void SurfaceMarking_TypeAndConfidence::set_type(::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.roadattribution.SurfaceMarking.TypeAndConfidence.type)
}
inline ::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence_Type SurfaceMarking_TypeAndConfidence::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence_Type>(_impl_.type_);
}
inline void SurfaceMarking_TypeAndConfidence::_internal_set_type(::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence_Type value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// .sensoris.protobuf.types.base.Confidence confidence = 2;
inline bool SurfaceMarking_TypeAndConfidence::has_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.confidence_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Confidence& SurfaceMarking_TypeAndConfidence::_internal_confidence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::Confidence* p = _impl_.confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Confidence&>(::sensoris::protobuf::types::base::_Confidence_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Confidence& SurfaceMarking_TypeAndConfidence::confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.SurfaceMarking.TypeAndConfidence.confidence)
  return _internal_confidence();
}
inline void SurfaceMarking_TypeAndConfidence::unsafe_arena_set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }
  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.SurfaceMarking.TypeAndConfidence.confidence)
}
inline ::sensoris::protobuf::types::base::Confidence* SurfaceMarking_TypeAndConfidence::release_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* released = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::Confidence* SurfaceMarking_TypeAndConfidence::unsafe_arena_release_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.SurfaceMarking.TypeAndConfidence.confidence)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* temp = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* SurfaceMarking_TypeAndConfidence::_internal_mutable_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.confidence_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Confidence>(GetArena());
    _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(p);
  }
  return _impl_.confidence_;
}
inline ::sensoris::protobuf::types::base::Confidence* SurfaceMarking_TypeAndConfidence::mutable_confidence() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::Confidence* _msg = _internal_mutable_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.SurfaceMarking.TypeAndConfidence.confidence)
  return _msg;
}
inline void SurfaceMarking_TypeAndConfidence::set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.SurfaceMarking.TypeAndConfidence.confidence)
}

// -------------------------------------------------------------------

// SurfaceMarking

// .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
inline bool SurfaceMarking::has_envelope() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.envelope_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& SurfaceMarking::_internal_envelope() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::EventEnvelope* p = _impl_.envelope_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::EventEnvelope&>(::sensoris::protobuf::types::base::_EventEnvelope_default_instance_);
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& SurfaceMarking::envelope() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.SurfaceMarking.envelope)
  return _internal_envelope();
}
inline void SurfaceMarking::unsafe_arena_set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }
  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.SurfaceMarking.envelope)
}
inline ::sensoris::protobuf::types::base::EventEnvelope* SurfaceMarking::release_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* released = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* SurfaceMarking::unsafe_arena_release_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.SurfaceMarking.envelope)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* temp = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* SurfaceMarking::_internal_mutable_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.envelope_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::EventEnvelope>(GetArena());
    _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(p);
  }
  return _impl_.envelope_;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* SurfaceMarking::mutable_envelope() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::EventEnvelope* _msg = _internal_mutable_envelope();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.SurfaceMarking.envelope)
  return _msg;
}
inline void SurfaceMarking::set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.SurfaceMarking.envelope)
}

// .sensoris.protobuf.types.base.Confidence existence_confidence = 2;
inline bool SurfaceMarking::has_existence_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.existence_confidence_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Confidence& SurfaceMarking::_internal_existence_confidence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::Confidence* p = _impl_.existence_confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Confidence&>(::sensoris::protobuf::types::base::_Confidence_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Confidence& SurfaceMarking::existence_confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.SurfaceMarking.existence_confidence)
  return _internal_existence_confidence();
}
inline void SurfaceMarking::unsafe_arena_set_allocated_existence_confidence(::sensoris::protobuf::types::base::Confidence* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.existence_confidence_);
  }
  _impl_.existence_confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.SurfaceMarking.existence_confidence)
}
inline ::sensoris::protobuf::types::base::Confidence* SurfaceMarking::release_existence_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::Confidence* released = _impl_.existence_confidence_;
  _impl_.existence_confidence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::Confidence* SurfaceMarking::unsafe_arena_release_existence_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.SurfaceMarking.existence_confidence)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::Confidence* temp = _impl_.existence_confidence_;
  _impl_.existence_confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* SurfaceMarking::_internal_mutable_existence_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.existence_confidence_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Confidence>(GetArena());
    _impl_.existence_confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(p);
  }
  return _impl_.existence_confidence_;
}
inline ::sensoris::protobuf::types::base::Confidence* SurfaceMarking::mutable_existence_confidence() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::Confidence* _msg = _internal_mutable_existence_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.SurfaceMarking.existence_confidence)
  return _msg;
}
inline void SurfaceMarking::set_allocated_existence_confidence(::sensoris::protobuf::types::base::Confidence* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.existence_confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.existence_confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.SurfaceMarking.existence_confidence)
}

// .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 3;
inline bool SurfaceMarking::has_detection_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.detection_status_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::EventDetectionStatus& SurfaceMarking::_internal_detection_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::EventDetectionStatus* p = _impl_.detection_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::EventDetectionStatus&>(::sensoris::protobuf::types::base::_EventDetectionStatus_default_instance_);
}
inline const ::sensoris::protobuf::types::base::EventDetectionStatus& SurfaceMarking::detection_status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.SurfaceMarking.detection_status)
  return _internal_detection_status();
}
inline void SurfaceMarking::unsafe_arena_set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.detection_status_);
  }
  _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.SurfaceMarking.detection_status)
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* SurfaceMarking::release_detection_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::types::base::EventDetectionStatus* released = _impl_.detection_status_;
  _impl_.detection_status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* SurfaceMarking::unsafe_arena_release_detection_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.SurfaceMarking.detection_status)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::types::base::EventDetectionStatus* temp = _impl_.detection_status_;
  _impl_.detection_status_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* SurfaceMarking::_internal_mutable_detection_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.detection_status_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::EventDetectionStatus>(GetArena());
    _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(p);
  }
  return _impl_.detection_status_;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* SurfaceMarking::mutable_detection_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::EventDetectionStatus* _msg = _internal_mutable_detection_status();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.SurfaceMarking.detection_status)
  return _msg;
}
inline void SurfaceMarking::set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.detection_status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.SurfaceMarking.detection_status)
}

// .sensoris.protobuf.categories.roadattribution.SurfaceMarking.TypeAndConfidence type_and_confidence = 4;
inline bool SurfaceMarking::has_type_and_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.type_and_confidence_ != nullptr);
  return value;
}
inline void SurfaceMarking::clear_type_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.type_and_confidence_ != nullptr) _impl_.type_and_confidence_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence& SurfaceMarking::_internal_type_and_confidence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence* p = _impl_.type_and_confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence&>(::sensoris::protobuf::categories::roadattribution::_SurfaceMarking_TypeAndConfidence_default_instance_);
}
inline const ::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence& SurfaceMarking::type_and_confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.SurfaceMarking.type_and_confidence)
  return _internal_type_and_confidence();
}
inline void SurfaceMarking::unsafe_arena_set_allocated_type_and_confidence(::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.type_and_confidence_);
  }
  _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.SurfaceMarking.type_and_confidence)
}
inline ::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence* SurfaceMarking::release_type_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence* released = _impl_.type_and_confidence_;
  _impl_.type_and_confidence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence* SurfaceMarking::unsafe_arena_release_type_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.SurfaceMarking.type_and_confidence)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence* temp = _impl_.type_and_confidence_;
  _impl_.type_and_confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence* SurfaceMarking::_internal_mutable_type_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.type_and_confidence_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence>(GetArena());
    _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence*>(p);
  }
  return _impl_.type_and_confidence_;
}
inline ::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence* SurfaceMarking::mutable_type_and_confidence() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence* _msg = _internal_mutable_type_and_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.SurfaceMarking.type_and_confidence)
  return _msg;
}
inline void SurfaceMarking::set_allocated_type_and_confidence(::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence*>(_impl_.type_and_confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.SurfaceMarking.type_and_confidence)
}

// .google.protobuf.StringValue text = 5;
inline bool SurfaceMarking::has_text() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.text_ != nullptr);
  return value;
}
inline const ::google::protobuf::StringValue& SurfaceMarking::_internal_text() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::StringValue* p = _impl_.text_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::StringValue&>(::google::protobuf::_StringValue_default_instance_);
}
inline const ::google::protobuf::StringValue& SurfaceMarking::text() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.SurfaceMarking.text)
  return _internal_text();
}
inline void SurfaceMarking::unsafe_arena_set_allocated_text(::google::protobuf::StringValue* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.text_);
  }
  _impl_.text_ = reinterpret_cast<::google::protobuf::StringValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.SurfaceMarking.text)
}
inline ::google::protobuf::StringValue* SurfaceMarking::release_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::google::protobuf::StringValue* released = _impl_.text_;
  _impl_.text_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::StringValue* SurfaceMarking::unsafe_arena_release_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.SurfaceMarking.text)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::google::protobuf::StringValue* temp = _impl_.text_;
  _impl_.text_ = nullptr;
  return temp;
}
inline ::google::protobuf::StringValue* SurfaceMarking::_internal_mutable_text() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.text_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::StringValue>(GetArena());
    _impl_.text_ = reinterpret_cast<::google::protobuf::StringValue*>(p);
  }
  return _impl_.text_;
}
inline ::google::protobuf::StringValue* SurfaceMarking::mutable_text() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::StringValue* _msg = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.SurfaceMarking.text)
  return _msg;
}
inline void SurfaceMarking::set_allocated_text(::google::protobuf::StringValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.text_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.text_ = reinterpret_cast<::google::protobuf::StringValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.SurfaceMarking.text)
}

// repeated .sensoris.protobuf.categories.roadattribution.MarkingColorAndConfidence color_and_confidence = 6;
inline int SurfaceMarking::_internal_color_and_confidence_size() const {
  return _internal_color_and_confidence().size();
}
inline int SurfaceMarking::color_and_confidence_size() const {
  return _internal_color_and_confidence_size();
}
inline void SurfaceMarking::clear_color_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.color_and_confidence_.Clear();
}
inline ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence* SurfaceMarking::mutable_color_and_confidence(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.SurfaceMarking.color_and_confidence)
  return _internal_mutable_color_and_confidence()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence>* SurfaceMarking::mutable_color_and_confidence()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.roadattribution.SurfaceMarking.color_and_confidence)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_color_and_confidence();
}
inline const ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence& SurfaceMarking::color_and_confidence(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.SurfaceMarking.color_and_confidence)
  return _internal_color_and_confidence().Get(index);
}
inline ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence* SurfaceMarking::add_color_and_confidence() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence* _add = _internal_mutable_color_and_confidence()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.roadattribution.SurfaceMarking.color_and_confidence)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence>& SurfaceMarking::color_and_confidence() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.roadattribution.SurfaceMarking.color_and_confidence)
  return _internal_color_and_confidence();
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence>&
SurfaceMarking::_internal_color_and_confidence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.color_and_confidence_;
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence>*
SurfaceMarking::_internal_mutable_color_and_confidence() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.color_and_confidence_;
}

// repeated .sensoris.protobuf.categories.roadattribution.MarkingMaterialAndConfidence material_and_confidence = 7;
inline int SurfaceMarking::_internal_material_and_confidence_size() const {
  return _internal_material_and_confidence().size();
}
inline int SurfaceMarking::material_and_confidence_size() const {
  return _internal_material_and_confidence_size();
}
inline void SurfaceMarking::clear_material_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.material_and_confidence_.Clear();
}
inline ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence* SurfaceMarking::mutable_material_and_confidence(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.SurfaceMarking.material_and_confidence)
  return _internal_mutable_material_and_confidence()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence>* SurfaceMarking::mutable_material_and_confidence()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.roadattribution.SurfaceMarking.material_and_confidence)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_material_and_confidence();
}
inline const ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence& SurfaceMarking::material_and_confidence(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.SurfaceMarking.material_and_confidence)
  return _internal_material_and_confidence().Get(index);
}
inline ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence* SurfaceMarking::add_material_and_confidence() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence* _add = _internal_mutable_material_and_confidence()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.roadattribution.SurfaceMarking.material_and_confidence)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence>& SurfaceMarking::material_and_confidence() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.roadattribution.SurfaceMarking.material_and_confidence)
  return _internal_material_and_confidence();
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence>&
SurfaceMarking::_internal_material_and_confidence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.material_and_confidence_;
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence>*
SurfaceMarking::_internal_mutable_material_and_confidence() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.material_and_confidence_;
}

// .sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy rectangular_box_and_accuracy = 8;
inline bool SurfaceMarking::has_rectangular_box_and_accuracy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rectangular_box_and_accuracy_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy& SurfaceMarking::_internal_rectangular_box_and_accuracy() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* p = _impl_.rectangular_box_and_accuracy_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy&>(::sensoris::protobuf::types::spatial::_RectangularBoxAndAccuracy_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy& SurfaceMarking::rectangular_box_and_accuracy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.SurfaceMarking.rectangular_box_and_accuracy)
  return _internal_rectangular_box_and_accuracy();
}
inline void SurfaceMarking::unsafe_arena_set_allocated_rectangular_box_and_accuracy(::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.rectangular_box_and_accuracy_);
  }
  _impl_.rectangular_box_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.SurfaceMarking.rectangular_box_and_accuracy)
}
inline ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* SurfaceMarking::release_rectangular_box_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* released = _impl_.rectangular_box_and_accuracy_;
  _impl_.rectangular_box_and_accuracy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* SurfaceMarking::unsafe_arena_release_rectangular_box_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.SurfaceMarking.rectangular_box_and_accuracy)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* temp = _impl_.rectangular_box_and_accuracy_;
  _impl_.rectangular_box_and_accuracy_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* SurfaceMarking::_internal_mutable_rectangular_box_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.rectangular_box_and_accuracy_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy>(GetArena());
    _impl_.rectangular_box_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy*>(p);
  }
  return _impl_.rectangular_box_and_accuracy_;
}
inline ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* SurfaceMarking::mutable_rectangular_box_and_accuracy() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* _msg = _internal_mutable_rectangular_box_and_accuracy();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.SurfaceMarking.rectangular_box_and_accuracy)
  return _msg;
}
inline void SurfaceMarking::set_allocated_rectangular_box_and_accuracy(::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.rectangular_box_and_accuracy_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.rectangular_box_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.SurfaceMarking.rectangular_box_and_accuracy)
}

// -------------------------------------------------------------------

// SurfaceAttribution

// .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
inline bool SurfaceAttribution::has_envelope() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.envelope_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& SurfaceAttribution::_internal_envelope() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::EventEnvelope* p = _impl_.envelope_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::EventEnvelope&>(::sensoris::protobuf::types::base::_EventEnvelope_default_instance_);
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& SurfaceAttribution::envelope() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.SurfaceAttribution.envelope)
  return _internal_envelope();
}
inline void SurfaceAttribution::unsafe_arena_set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }
  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.SurfaceAttribution.envelope)
}
inline ::sensoris::protobuf::types::base::EventEnvelope* SurfaceAttribution::release_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* released = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* SurfaceAttribution::unsafe_arena_release_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.SurfaceAttribution.envelope)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* temp = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* SurfaceAttribution::_internal_mutable_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.envelope_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::EventEnvelope>(GetArena());
    _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(p);
  }
  return _impl_.envelope_;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* SurfaceAttribution::mutable_envelope() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::EventEnvelope* _msg = _internal_mutable_envelope();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.SurfaceAttribution.envelope)
  return _msg;
}
inline void SurfaceAttribution::set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.SurfaceAttribution.envelope)
}

// .sensoris.protobuf.types.spatial.PositionAndAccuracy position_and_accuracy = 2;
inline bool SurfaceAttribution::has_position_and_accuracy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_and_accuracy_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& SurfaceAttribution::_internal_position_and_accuracy() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy* p = _impl_.position_and_accuracy_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::spatial::PositionAndAccuracy&>(::sensoris::protobuf::types::spatial::_PositionAndAccuracy_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& SurfaceAttribution::position_and_accuracy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.SurfaceAttribution.position_and_accuracy)
  return _internal_position_and_accuracy();
}
inline void SurfaceAttribution::unsafe_arena_set_allocated_position_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_and_accuracy_);
  }
  _impl_.position_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.SurfaceAttribution.position_and_accuracy)
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* SurfaceAttribution::release_position_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* released = _impl_.position_and_accuracy_;
  _impl_.position_and_accuracy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* SurfaceAttribution::unsafe_arena_release_position_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.SurfaceAttribution.position_and_accuracy)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* temp = _impl_.position_and_accuracy_;
  _impl_.position_and_accuracy_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* SurfaceAttribution::_internal_mutable_position_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.position_and_accuracy_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::spatial::PositionAndAccuracy>(GetArena());
    _impl_.position_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(p);
  }
  return _impl_.position_and_accuracy_;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* SurfaceAttribution::mutable_position_and_accuracy() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* _msg = _internal_mutable_position_and_accuracy();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.SurfaceAttribution.position_and_accuracy)
  return _msg;
}
inline void SurfaceAttribution::set_allocated_position_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_and_accuracy_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.position_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.SurfaceAttribution.position_and_accuracy)
}

// .sensoris.protobuf.categories.roadattribution.InclinationAndCurvature inclination_and_curvature = 3;
inline bool SurfaceAttribution::has_inclination_and_curvature() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.inclination_and_curvature_ != nullptr);
  return value;
}
inline void SurfaceAttribution::clear_inclination_and_curvature() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.inclination_and_curvature_ != nullptr) _impl_.inclination_and_curvature_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature& SurfaceAttribution::_internal_inclination_and_curvature() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* p = _impl_.inclination_and_curvature_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature&>(::sensoris::protobuf::categories::roadattribution::_InclinationAndCurvature_default_instance_);
}
inline const ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature& SurfaceAttribution::inclination_and_curvature() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.SurfaceAttribution.inclination_and_curvature)
  return _internal_inclination_and_curvature();
}
inline void SurfaceAttribution::unsafe_arena_set_allocated_inclination_and_curvature(::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.inclination_and_curvature_);
  }
  _impl_.inclination_and_curvature_ = reinterpret_cast<::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.SurfaceAttribution.inclination_and_curvature)
}
inline ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* SurfaceAttribution::release_inclination_and_curvature() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* released = _impl_.inclination_and_curvature_;
  _impl_.inclination_and_curvature_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* SurfaceAttribution::unsafe_arena_release_inclination_and_curvature() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.SurfaceAttribution.inclination_and_curvature)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* temp = _impl_.inclination_and_curvature_;
  _impl_.inclination_and_curvature_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* SurfaceAttribution::_internal_mutable_inclination_and_curvature() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.inclination_and_curvature_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature>(GetArena());
    _impl_.inclination_and_curvature_ = reinterpret_cast<::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature*>(p);
  }
  return _impl_.inclination_and_curvature_;
}
inline ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* SurfaceAttribution::mutable_inclination_and_curvature() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* _msg = _internal_mutable_inclination_and_curvature();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.SurfaceAttribution.inclination_and_curvature)
  return _msg;
}
inline void SurfaceAttribution::set_allocated_inclination_and_curvature(::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature*>(_impl_.inclination_and_curvature_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.inclination_and_curvature_ = reinterpret_cast<::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.SurfaceAttribution.inclination_and_curvature)
}

// repeated .sensoris.protobuf.categories.roadattribution.SurfaceMaterialAndConfidence material_and_confidence = 4;
inline int SurfaceAttribution::_internal_material_and_confidence_size() const {
  return _internal_material_and_confidence().size();
}
inline int SurfaceAttribution::material_and_confidence_size() const {
  return _internal_material_and_confidence_size();
}
inline void SurfaceAttribution::clear_material_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.material_and_confidence_.Clear();
}
inline ::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence* SurfaceAttribution::mutable_material_and_confidence(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.SurfaceAttribution.material_and_confidence)
  return _internal_mutable_material_and_confidence()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence>* SurfaceAttribution::mutable_material_and_confidence()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.roadattribution.SurfaceAttribution.material_and_confidence)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_material_and_confidence();
}
inline const ::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence& SurfaceAttribution::material_and_confidence(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.SurfaceAttribution.material_and_confidence)
  return _internal_material_and_confidence().Get(index);
}
inline ::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence* SurfaceAttribution::add_material_and_confidence() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence* _add = _internal_mutable_material_and_confidence()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.roadattribution.SurfaceAttribution.material_and_confidence)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence>& SurfaceAttribution::material_and_confidence() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.roadattribution.SurfaceAttribution.material_and_confidence)
  return _internal_material_and_confidence();
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence>&
SurfaceAttribution::_internal_material_and_confidence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.material_and_confidence_;
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence>*
SurfaceAttribution::_internal_mutable_material_and_confidence() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.material_and_confidence_;
}

// .sensoris.protobuf.types.base.Int64ValueAndAccuracy road_roughness_and_accuracy = 5 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool SurfaceAttribution::has_road_roughness_and_accuracy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.road_roughness_and_accuracy_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& SurfaceAttribution::_internal_road_roughness_and_accuracy() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* p = _impl_.road_roughness_and_accuracy_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy&>(::sensoris::protobuf::types::base::_Int64ValueAndAccuracy_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& SurfaceAttribution::road_roughness_and_accuracy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.SurfaceAttribution.road_roughness_and_accuracy)
  return _internal_road_roughness_and_accuracy();
}
inline void SurfaceAttribution::unsafe_arena_set_allocated_road_roughness_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.road_roughness_and_accuracy_);
  }
  _impl_.road_roughness_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.SurfaceAttribution.road_roughness_and_accuracy)
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* SurfaceAttribution::release_road_roughness_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* released = _impl_.road_roughness_and_accuracy_;
  _impl_.road_roughness_and_accuracy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* SurfaceAttribution::unsafe_arena_release_road_roughness_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.SurfaceAttribution.road_roughness_and_accuracy)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* temp = _impl_.road_roughness_and_accuracy_;
  _impl_.road_roughness_and_accuracy_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* SurfaceAttribution::_internal_mutable_road_roughness_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.road_roughness_and_accuracy_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64ValueAndAccuracy>(GetArena());
    _impl_.road_roughness_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(p);
  }
  return _impl_.road_roughness_and_accuracy_;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* SurfaceAttribution::mutable_road_roughness_and_accuracy() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* _msg = _internal_mutable_road_roughness_and_accuracy();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.SurfaceAttribution.road_roughness_and_accuracy)
  return _msg;
}
inline void SurfaceAttribution::set_allocated_road_roughness_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.road_roughness_and_accuracy_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.road_roughness_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.SurfaceAttribution.road_roughness_and_accuracy)
}

// -------------------------------------------------------------------

// RoadAttribution_TypeAndConfidence

// .sensoris.protobuf.categories.roadattribution.RoadAttribution.TypeAndConfidence.Type type = 1;
inline void RoadAttribution_TypeAndConfidence::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
}
inline ::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence_Type RoadAttribution_TypeAndConfidence::type() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.RoadAttribution.TypeAndConfidence.type)
  return _internal_type();
}
inline void RoadAttribution_TypeAndConfidence::set_type(::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.roadattribution.RoadAttribution.TypeAndConfidence.type)
}
inline ::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence_Type RoadAttribution_TypeAndConfidence::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence_Type>(_impl_.type_);
}
inline void RoadAttribution_TypeAndConfidence::_internal_set_type(::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence_Type value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// .sensoris.protobuf.types.base.Confidence confidence = 2;
inline bool RoadAttribution_TypeAndConfidence::has_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.confidence_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Confidence& RoadAttribution_TypeAndConfidence::_internal_confidence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::Confidence* p = _impl_.confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Confidence&>(::sensoris::protobuf::types::base::_Confidence_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Confidence& RoadAttribution_TypeAndConfidence::confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.RoadAttribution.TypeAndConfidence.confidence)
  return _internal_confidence();
}
inline void RoadAttribution_TypeAndConfidence::unsafe_arena_set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }
  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.RoadAttribution.TypeAndConfidence.confidence)
}
inline ::sensoris::protobuf::types::base::Confidence* RoadAttribution_TypeAndConfidence::release_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* released = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::Confidence* RoadAttribution_TypeAndConfidence::unsafe_arena_release_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.RoadAttribution.TypeAndConfidence.confidence)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* temp = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* RoadAttribution_TypeAndConfidence::_internal_mutable_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.confidence_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Confidence>(GetArena());
    _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(p);
  }
  return _impl_.confidence_;
}
inline ::sensoris::protobuf::types::base::Confidence* RoadAttribution_TypeAndConfidence::mutable_confidence() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::Confidence* _msg = _internal_mutable_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.RoadAttribution.TypeAndConfidence.confidence)
  return _msg;
}
inline void RoadAttribution_TypeAndConfidence::set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.RoadAttribution.TypeAndConfidence.confidence)
}

// -------------------------------------------------------------------

// RoadAttribution_ChangeTypeAndConfidence

// .sensoris.protobuf.categories.roadattribution.RoadAttribution.ChangeTypeAndConfidence.Type type = 1;
inline void RoadAttribution_ChangeTypeAndConfidence::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
}
inline ::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence_Type RoadAttribution_ChangeTypeAndConfidence::type() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.RoadAttribution.ChangeTypeAndConfidence.type)
  return _internal_type();
}
inline void RoadAttribution_ChangeTypeAndConfidence::set_type(::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.roadattribution.RoadAttribution.ChangeTypeAndConfidence.type)
}
inline ::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence_Type RoadAttribution_ChangeTypeAndConfidence::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence_Type>(_impl_.type_);
}
inline void RoadAttribution_ChangeTypeAndConfidence::_internal_set_type(::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence_Type value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// .sensoris.protobuf.types.base.Confidence confidence = 2;
inline bool RoadAttribution_ChangeTypeAndConfidence::has_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.confidence_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Confidence& RoadAttribution_ChangeTypeAndConfidence::_internal_confidence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::Confidence* p = _impl_.confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Confidence&>(::sensoris::protobuf::types::base::_Confidence_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Confidence& RoadAttribution_ChangeTypeAndConfidence::confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.RoadAttribution.ChangeTypeAndConfidence.confidence)
  return _internal_confidence();
}
inline void RoadAttribution_ChangeTypeAndConfidence::unsafe_arena_set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }
  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.RoadAttribution.ChangeTypeAndConfidence.confidence)
}
inline ::sensoris::protobuf::types::base::Confidence* RoadAttribution_ChangeTypeAndConfidence::release_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* released = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::Confidence* RoadAttribution_ChangeTypeAndConfidence::unsafe_arena_release_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.RoadAttribution.ChangeTypeAndConfidence.confidence)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Confidence* temp = _impl_.confidence_;
  _impl_.confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* RoadAttribution_ChangeTypeAndConfidence::_internal_mutable_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.confidence_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Confidence>(GetArena());
    _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(p);
  }
  return _impl_.confidence_;
}
inline ::sensoris::protobuf::types::base::Confidence* RoadAttribution_ChangeTypeAndConfidence::mutable_confidence() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::Confidence* _msg = _internal_mutable_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.RoadAttribution.ChangeTypeAndConfidence.confidence)
  return _msg;
}
inline void RoadAttribution_ChangeTypeAndConfidence::set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::Confidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.RoadAttribution.ChangeTypeAndConfidence.confidence)
}

// -------------------------------------------------------------------

// RoadAttribution

// .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
inline bool RoadAttribution::has_envelope() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.envelope_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& RoadAttribution::_internal_envelope() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::EventEnvelope* p = _impl_.envelope_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::EventEnvelope&>(::sensoris::protobuf::types::base::_EventEnvelope_default_instance_);
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& RoadAttribution::envelope() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.RoadAttribution.envelope)
  return _internal_envelope();
}
inline void RoadAttribution::unsafe_arena_set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }
  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.RoadAttribution.envelope)
}
inline ::sensoris::protobuf::types::base::EventEnvelope* RoadAttribution::release_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* released = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* RoadAttribution::unsafe_arena_release_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.RoadAttribution.envelope)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* temp = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* RoadAttribution::_internal_mutable_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.envelope_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::EventEnvelope>(GetArena());
    _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(p);
  }
  return _impl_.envelope_;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* RoadAttribution::mutable_envelope() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::EventEnvelope* _msg = _internal_mutable_envelope();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.RoadAttribution.envelope)
  return _msg;
}
inline void RoadAttribution::set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.RoadAttribution.envelope)
}

// .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 2;
inline bool RoadAttribution::has_detection_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.detection_status_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::EventDetectionStatus& RoadAttribution::_internal_detection_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::EventDetectionStatus* p = _impl_.detection_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::EventDetectionStatus&>(::sensoris::protobuf::types::base::_EventDetectionStatus_default_instance_);
}
inline const ::sensoris::protobuf::types::base::EventDetectionStatus& RoadAttribution::detection_status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.RoadAttribution.detection_status)
  return _internal_detection_status();
}
inline void RoadAttribution::unsafe_arena_set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.detection_status_);
  }
  _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.RoadAttribution.detection_status)
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* RoadAttribution::release_detection_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::EventDetectionStatus* released = _impl_.detection_status_;
  _impl_.detection_status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* RoadAttribution::unsafe_arena_release_detection_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.RoadAttribution.detection_status)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::EventDetectionStatus* temp = _impl_.detection_status_;
  _impl_.detection_status_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* RoadAttribution::_internal_mutable_detection_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.detection_status_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::EventDetectionStatus>(GetArena());
    _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(p);
  }
  return _impl_.detection_status_;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* RoadAttribution::mutable_detection_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::EventDetectionStatus* _msg = _internal_mutable_detection_status();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.RoadAttribution.detection_status)
  return _msg;
}
inline void RoadAttribution::set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.detection_status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.detection_status_ = reinterpret_cast<::sensoris::protobuf::types::base::EventDetectionStatus*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.RoadAttribution.detection_status)
}

// .sensoris.protobuf.types.spatial.PositionAndAccuracy position_and_accuracy = 3;
inline bool RoadAttribution::has_position_and_accuracy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_and_accuracy_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& RoadAttribution::_internal_position_and_accuracy() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy* p = _impl_.position_and_accuracy_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::spatial::PositionAndAccuracy&>(::sensoris::protobuf::types::spatial::_PositionAndAccuracy_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& RoadAttribution::position_and_accuracy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.RoadAttribution.position_and_accuracy)
  return _internal_position_and_accuracy();
}
inline void RoadAttribution::unsafe_arena_set_allocated_position_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_and_accuracy_);
  }
  _impl_.position_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.RoadAttribution.position_and_accuracy)
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* RoadAttribution::release_position_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* released = _impl_.position_and_accuracy_;
  _impl_.position_and_accuracy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* RoadAttribution::unsafe_arena_release_position_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.RoadAttribution.position_and_accuracy)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* temp = _impl_.position_and_accuracy_;
  _impl_.position_and_accuracy_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* RoadAttribution::_internal_mutable_position_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.position_and_accuracy_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::spatial::PositionAndAccuracy>(GetArena());
    _impl_.position_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(p);
  }
  return _impl_.position_and_accuracy_;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* RoadAttribution::mutable_position_and_accuracy() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* _msg = _internal_mutable_position_and_accuracy();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.RoadAttribution.position_and_accuracy)
  return _msg;
}
inline void RoadAttribution::set_allocated_position_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_and_accuracy_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.position_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.RoadAttribution.position_and_accuracy)
}

// .sensoris.protobuf.categories.roadattribution.RoadAttribution.TypeAndConfidence type_and_confidence = 4;
inline bool RoadAttribution::has_type_and_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.type_and_confidence_ != nullptr);
  return value;
}
inline void RoadAttribution::clear_type_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.type_and_confidence_ != nullptr) _impl_.type_and_confidence_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence& RoadAttribution::_internal_type_and_confidence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence* p = _impl_.type_and_confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence&>(::sensoris::protobuf::categories::roadattribution::_RoadAttribution_TypeAndConfidence_default_instance_);
}
inline const ::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence& RoadAttribution::type_and_confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.RoadAttribution.type_and_confidence)
  return _internal_type_and_confidence();
}
inline void RoadAttribution::unsafe_arena_set_allocated_type_and_confidence(::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.type_and_confidence_);
  }
  _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.RoadAttribution.type_and_confidence)
}
inline ::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence* RoadAttribution::release_type_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence* released = _impl_.type_and_confidence_;
  _impl_.type_and_confidence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence* RoadAttribution::unsafe_arena_release_type_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.RoadAttribution.type_and_confidence)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence* temp = _impl_.type_and_confidence_;
  _impl_.type_and_confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence* RoadAttribution::_internal_mutable_type_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.type_and_confidence_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence>(GetArena());
    _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence*>(p);
  }
  return _impl_.type_and_confidence_;
}
inline ::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence* RoadAttribution::mutable_type_and_confidence() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence* _msg = _internal_mutable_type_and_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.RoadAttribution.type_and_confidence)
  return _msg;
}
inline void RoadAttribution::set_allocated_type_and_confidence(::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence*>(_impl_.type_and_confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.RoadAttribution.type_and_confidence)
}

// .sensoris.protobuf.categories.roadattribution.RoadAttribution.ChangeTypeAndConfidence change_type_and_confidence = 5;
inline bool RoadAttribution::has_change_type_and_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.change_type_and_confidence_ != nullptr);
  return value;
}
inline void RoadAttribution::clear_change_type_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.change_type_and_confidence_ != nullptr) _impl_.change_type_and_confidence_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence& RoadAttribution::_internal_change_type_and_confidence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence* p = _impl_.change_type_and_confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence&>(::sensoris::protobuf::categories::roadattribution::_RoadAttribution_ChangeTypeAndConfidence_default_instance_);
}
inline const ::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence& RoadAttribution::change_type_and_confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.RoadAttribution.change_type_and_confidence)
  return _internal_change_type_and_confidence();
}
inline void RoadAttribution::unsafe_arena_set_allocated_change_type_and_confidence(::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.change_type_and_confidence_);
  }
  _impl_.change_type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.RoadAttribution.change_type_and_confidence)
}
inline ::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence* RoadAttribution::release_change_type_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence* released = _impl_.change_type_and_confidence_;
  _impl_.change_type_and_confidence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence* RoadAttribution::unsafe_arena_release_change_type_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.RoadAttribution.change_type_and_confidence)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence* temp = _impl_.change_type_and_confidence_;
  _impl_.change_type_and_confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence* RoadAttribution::_internal_mutable_change_type_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.change_type_and_confidence_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence>(GetArena());
    _impl_.change_type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence*>(p);
  }
  return _impl_.change_type_and_confidence_;
}
inline ::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence* RoadAttribution::mutable_change_type_and_confidence() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence* _msg = _internal_mutable_change_type_and_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.RoadAttribution.change_type_and_confidence)
  return _msg;
}
inline void RoadAttribution::set_allocated_change_type_and_confidence(::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence*>(_impl_.change_type_and_confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.change_type_and_confidence_ = reinterpret_cast<::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.RoadAttribution.change_type_and_confidence)
}

// -------------------------------------------------------------------

// LaneCountAndConfidence

// .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
inline bool LaneCountAndConfidence::has_envelope() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.envelope_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& LaneCountAndConfidence::_internal_envelope() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::EventEnvelope* p = _impl_.envelope_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::EventEnvelope&>(::sensoris::protobuf::types::base::_EventEnvelope_default_instance_);
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& LaneCountAndConfidence::envelope() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneCountAndConfidence.envelope)
  return _internal_envelope();
}
inline void LaneCountAndConfidence::unsafe_arena_set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }
  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.LaneCountAndConfidence.envelope)
}
inline ::sensoris::protobuf::types::base::EventEnvelope* LaneCountAndConfidence::release_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* released = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* LaneCountAndConfidence::unsafe_arena_release_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneCountAndConfidence.envelope)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::EventEnvelope* temp = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* LaneCountAndConfidence::_internal_mutable_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.envelope_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::EventEnvelope>(GetArena());
    _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(p);
  }
  return _impl_.envelope_;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* LaneCountAndConfidence::mutable_envelope() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::EventEnvelope* _msg = _internal_mutable_envelope();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneCountAndConfidence.envelope)
  return _msg;
}
inline void LaneCountAndConfidence::set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::EventEnvelope*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.LaneCountAndConfidence.envelope)
}

// .sensoris.protobuf.types.spatial.PositionAndAccuracy position_and_accuracy = 2;
inline bool LaneCountAndConfidence::has_position_and_accuracy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_and_accuracy_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& LaneCountAndConfidence::_internal_position_and_accuracy() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy* p = _impl_.position_and_accuracy_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::spatial::PositionAndAccuracy&>(::sensoris::protobuf::types::spatial::_PositionAndAccuracy_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& LaneCountAndConfidence::position_and_accuracy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneCountAndConfidence.position_and_accuracy)
  return _internal_position_and_accuracy();
}
inline void LaneCountAndConfidence::unsafe_arena_set_allocated_position_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_and_accuracy_);
  }
  _impl_.position_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.LaneCountAndConfidence.position_and_accuracy)
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* LaneCountAndConfidence::release_position_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* released = _impl_.position_and_accuracy_;
  _impl_.position_and_accuracy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* LaneCountAndConfidence::unsafe_arena_release_position_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneCountAndConfidence.position_and_accuracy)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* temp = _impl_.position_and_accuracy_;
  _impl_.position_and_accuracy_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* LaneCountAndConfidence::_internal_mutable_position_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.position_and_accuracy_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::spatial::PositionAndAccuracy>(GetArena());
    _impl_.position_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(p);
  }
  return _impl_.position_and_accuracy_;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* LaneCountAndConfidence::mutable_position_and_accuracy() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* _msg = _internal_mutable_position_and_accuracy();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneCountAndConfidence.position_and_accuracy)
  return _msg;
}
inline void LaneCountAndConfidence::set_allocated_position_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_and_accuracy_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.position_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.LaneCountAndConfidence.position_and_accuracy)
}

// .sensoris.protobuf.categories.roadattribution.LaneCountAndConfidence.Type type = 3;
inline void LaneCountAndConfidence::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
}
inline ::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence_Type LaneCountAndConfidence::type() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneCountAndConfidence.type)
  return _internal_type();
}
inline void LaneCountAndConfidence::set_type(::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.roadattribution.LaneCountAndConfidence.type)
}
inline ::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence_Type LaneCountAndConfidence::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence_Type>(_impl_.type_);
}
inline void LaneCountAndConfidence::_internal_set_type(::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence_Type value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// .sensoris.protobuf.types.base.CountAndConfidence count_and_confidence = 4;
inline bool LaneCountAndConfidence::has_count_and_confidence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.count_and_confidence_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::CountAndConfidence& LaneCountAndConfidence::_internal_count_and_confidence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::CountAndConfidence* p = _impl_.count_and_confidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::CountAndConfidence&>(::sensoris::protobuf::types::base::_CountAndConfidence_default_instance_);
}
inline const ::sensoris::protobuf::types::base::CountAndConfidence& LaneCountAndConfidence::count_and_confidence() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneCountAndConfidence.count_and_confidence)
  return _internal_count_and_confidence();
}
inline void LaneCountAndConfidence::unsafe_arena_set_allocated_count_and_confidence(::sensoris::protobuf::types::base::CountAndConfidence* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.count_and_confidence_);
  }
  _impl_.count_and_confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::CountAndConfidence*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.LaneCountAndConfidence.count_and_confidence)
}
inline ::sensoris::protobuf::types::base::CountAndConfidence* LaneCountAndConfidence::release_count_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::types::base::CountAndConfidence* released = _impl_.count_and_confidence_;
  _impl_.count_and_confidence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::CountAndConfidence* LaneCountAndConfidence::unsafe_arena_release_count_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneCountAndConfidence.count_and_confidence)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::types::base::CountAndConfidence* temp = _impl_.count_and_confidence_;
  _impl_.count_and_confidence_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::CountAndConfidence* LaneCountAndConfidence::_internal_mutable_count_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.count_and_confidence_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::CountAndConfidence>(GetArena());
    _impl_.count_and_confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::CountAndConfidence*>(p);
  }
  return _impl_.count_and_confidence_;
}
inline ::sensoris::protobuf::types::base::CountAndConfidence* LaneCountAndConfidence::mutable_count_and_confidence() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::CountAndConfidence* _msg = _internal_mutable_count_and_confidence();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneCountAndConfidence.count_and_confidence)
  return _msg;
}
inline void LaneCountAndConfidence::set_allocated_count_and_confidence(::sensoris::protobuf::types::base::CountAndConfidence* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.count_and_confidence_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.count_and_confidence_ = reinterpret_cast<::sensoris::protobuf::types::base::CountAndConfidence*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.LaneCountAndConfidence.count_and_confidence)
}

// -------------------------------------------------------------------

// RoadAttributionCategory

// .sensoris.protobuf.types.base.CategoryEnvelope envelope = 1;
inline bool RoadAttributionCategory::has_envelope() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.envelope_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::CategoryEnvelope& RoadAttributionCategory::_internal_envelope() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::CategoryEnvelope* p = _impl_.envelope_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::CategoryEnvelope&>(::sensoris::protobuf::types::base::_CategoryEnvelope_default_instance_);
}
inline const ::sensoris::protobuf::types::base::CategoryEnvelope& RoadAttributionCategory::envelope() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.envelope)
  return _internal_envelope();
}
inline void RoadAttributionCategory::unsafe_arena_set_allocated_envelope(::sensoris::protobuf::types::base::CategoryEnvelope* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }
  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::CategoryEnvelope*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.envelope)
}
inline ::sensoris::protobuf::types::base::CategoryEnvelope* RoadAttributionCategory::release_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::CategoryEnvelope* released = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::CategoryEnvelope* RoadAttributionCategory::unsafe_arena_release_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.envelope)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::CategoryEnvelope* temp = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::CategoryEnvelope* RoadAttributionCategory::_internal_mutable_envelope() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.envelope_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::CategoryEnvelope>(GetArena());
    _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::CategoryEnvelope*>(p);
  }
  return _impl_.envelope_;
}
inline ::sensoris::protobuf::types::base::CategoryEnvelope* RoadAttributionCategory::mutable_envelope() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::CategoryEnvelope* _msg = _internal_mutable_envelope();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.envelope)
  return _msg;
}
inline void RoadAttributionCategory::set_allocated_envelope(::sensoris::protobuf::types::base::CategoryEnvelope* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.envelope_ = reinterpret_cast<::sensoris::protobuf::types::base::CategoryEnvelope*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.envelope)
}

// repeated .sensoris.protobuf.categories.roadattribution.LaneBoundary lane_boundary = 2;
inline int RoadAttributionCategory::_internal_lane_boundary_size() const {
  return _internal_lane_boundary().size();
}
inline int RoadAttributionCategory::lane_boundary_size() const {
  return _internal_lane_boundary_size();
}
inline void RoadAttributionCategory::clear_lane_boundary() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.lane_boundary_.Clear();
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundary* RoadAttributionCategory::mutable_lane_boundary(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.lane_boundary)
  return _internal_mutable_lane_boundary()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::LaneBoundary>* RoadAttributionCategory::mutable_lane_boundary()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.lane_boundary)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_lane_boundary();
}
inline const ::sensoris::protobuf::categories::roadattribution::LaneBoundary& RoadAttributionCategory::lane_boundary(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.lane_boundary)
  return _internal_lane_boundary().Get(index);
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundary* RoadAttributionCategory::add_lane_boundary() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::sensoris::protobuf::categories::roadattribution::LaneBoundary* _add = _internal_mutable_lane_boundary()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.lane_boundary)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::LaneBoundary>& RoadAttributionCategory::lane_boundary() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.lane_boundary)
  return _internal_lane_boundary();
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::LaneBoundary>&
RoadAttributionCategory::_internal_lane_boundary() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.lane_boundary_;
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::LaneBoundary>*
RoadAttributionCategory::_internal_mutable_lane_boundary() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.lane_boundary_;
}

// repeated .sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit lane_boundary_merge_split = 3;
inline int RoadAttributionCategory::_internal_lane_boundary_merge_split_size() const {
  return _internal_lane_boundary_merge_split().size();
}
inline int RoadAttributionCategory::lane_boundary_merge_split_size() const {
  return _internal_lane_boundary_merge_split_size();
}
inline void RoadAttributionCategory::clear_lane_boundary_merge_split() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.lane_boundary_merge_split_.Clear();
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit* RoadAttributionCategory::mutable_lane_boundary_merge_split(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.lane_boundary_merge_split)
  return _internal_mutable_lane_boundary_merge_split()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit>* RoadAttributionCategory::mutable_lane_boundary_merge_split()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.lane_boundary_merge_split)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_lane_boundary_merge_split();
}
inline const ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit& RoadAttributionCategory::lane_boundary_merge_split(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.lane_boundary_merge_split)
  return _internal_lane_boundary_merge_split().Get(index);
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit* RoadAttributionCategory::add_lane_boundary_merge_split() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit* _add = _internal_mutable_lane_boundary_merge_split()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.lane_boundary_merge_split)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit>& RoadAttributionCategory::lane_boundary_merge_split() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.lane_boundary_merge_split)
  return _internal_lane_boundary_merge_split();
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit>&
RoadAttributionCategory::_internal_lane_boundary_merge_split() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.lane_boundary_merge_split_;
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit>*
RoadAttributionCategory::_internal_mutable_lane_boundary_merge_split() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.lane_boundary_merge_split_;
}

// repeated .sensoris.protobuf.categories.roadattribution.Lane lane = 4;
inline int RoadAttributionCategory::_internal_lane_size() const {
  return _internal_lane().size();
}
inline int RoadAttributionCategory::lane_size() const {
  return _internal_lane_size();
}
inline void RoadAttributionCategory::clear_lane() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.lane_.Clear();
}
inline ::sensoris::protobuf::categories::roadattribution::Lane* RoadAttributionCategory::mutable_lane(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.lane)
  return _internal_mutable_lane()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::Lane>* RoadAttributionCategory::mutable_lane()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.lane)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_lane();
}
inline const ::sensoris::protobuf::categories::roadattribution::Lane& RoadAttributionCategory::lane(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.lane)
  return _internal_lane().Get(index);
}
inline ::sensoris::protobuf::categories::roadattribution::Lane* RoadAttributionCategory::add_lane() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::sensoris::protobuf::categories::roadattribution::Lane* _add = _internal_mutable_lane()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.lane)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::Lane>& RoadAttributionCategory::lane() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.lane)
  return _internal_lane();
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::Lane>&
RoadAttributionCategory::_internal_lane() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.lane_;
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::Lane>*
RoadAttributionCategory::_internal_mutable_lane() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.lane_;
}

// repeated .sensoris.protobuf.categories.roadattribution.Road road = 5;
inline int RoadAttributionCategory::_internal_road_size() const {
  return _internal_road().size();
}
inline int RoadAttributionCategory::road_size() const {
  return _internal_road_size();
}
inline void RoadAttributionCategory::clear_road() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.road_.Clear();
}
inline ::sensoris::protobuf::categories::roadattribution::Road* RoadAttributionCategory::mutable_road(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.road)
  return _internal_mutable_road()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::Road>* RoadAttributionCategory::mutable_road()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.road)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_road();
}
inline const ::sensoris::protobuf::categories::roadattribution::Road& RoadAttributionCategory::road(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.road)
  return _internal_road().Get(index);
}
inline ::sensoris::protobuf::categories::roadattribution::Road* RoadAttributionCategory::add_road() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::sensoris::protobuf::categories::roadattribution::Road* _add = _internal_mutable_road()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.road)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::Road>& RoadAttributionCategory::road() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.road)
  return _internal_road();
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::Road>&
RoadAttributionCategory::_internal_road() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.road_;
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::Road>*
RoadAttributionCategory::_internal_mutable_road() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.road_;
}

// repeated .sensoris.protobuf.categories.roadattribution.SurfaceMarking surface_marking = 6;
inline int RoadAttributionCategory::_internal_surface_marking_size() const {
  return _internal_surface_marking().size();
}
inline int RoadAttributionCategory::surface_marking_size() const {
  return _internal_surface_marking_size();
}
inline void RoadAttributionCategory::clear_surface_marking() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.surface_marking_.Clear();
}
inline ::sensoris::protobuf::categories::roadattribution::SurfaceMarking* RoadAttributionCategory::mutable_surface_marking(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.surface_marking)
  return _internal_mutable_surface_marking()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::SurfaceMarking>* RoadAttributionCategory::mutable_surface_marking()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.surface_marking)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_surface_marking();
}
inline const ::sensoris::protobuf::categories::roadattribution::SurfaceMarking& RoadAttributionCategory::surface_marking(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.surface_marking)
  return _internal_surface_marking().Get(index);
}
inline ::sensoris::protobuf::categories::roadattribution::SurfaceMarking* RoadAttributionCategory::add_surface_marking() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::sensoris::protobuf::categories::roadattribution::SurfaceMarking* _add = _internal_mutable_surface_marking()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.surface_marking)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::SurfaceMarking>& RoadAttributionCategory::surface_marking() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.surface_marking)
  return _internal_surface_marking();
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::SurfaceMarking>&
RoadAttributionCategory::_internal_surface_marking() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.surface_marking_;
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::SurfaceMarking>*
RoadAttributionCategory::_internal_mutable_surface_marking() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.surface_marking_;
}

// repeated .sensoris.protobuf.categories.roadattribution.SurfaceAttribution surface_attribution = 7;
inline int RoadAttributionCategory::_internal_surface_attribution_size() const {
  return _internal_surface_attribution().size();
}
inline int RoadAttributionCategory::surface_attribution_size() const {
  return _internal_surface_attribution_size();
}
inline void RoadAttributionCategory::clear_surface_attribution() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.surface_attribution_.Clear();
}
inline ::sensoris::protobuf::categories::roadattribution::SurfaceAttribution* RoadAttributionCategory::mutable_surface_attribution(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.surface_attribution)
  return _internal_mutable_surface_attribution()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::SurfaceAttribution>* RoadAttributionCategory::mutable_surface_attribution()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.surface_attribution)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_surface_attribution();
}
inline const ::sensoris::protobuf::categories::roadattribution::SurfaceAttribution& RoadAttributionCategory::surface_attribution(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.surface_attribution)
  return _internal_surface_attribution().Get(index);
}
inline ::sensoris::protobuf::categories::roadattribution::SurfaceAttribution* RoadAttributionCategory::add_surface_attribution() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::sensoris::protobuf::categories::roadattribution::SurfaceAttribution* _add = _internal_mutable_surface_attribution()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.surface_attribution)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::SurfaceAttribution>& RoadAttributionCategory::surface_attribution() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.surface_attribution)
  return _internal_surface_attribution();
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::SurfaceAttribution>&
RoadAttributionCategory::_internal_surface_attribution() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.surface_attribution_;
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::SurfaceAttribution>*
RoadAttributionCategory::_internal_mutable_surface_attribution() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.surface_attribution_;
}

// repeated .sensoris.protobuf.categories.roadattribution.RoadAttribution road_attribution = 8;
inline int RoadAttributionCategory::_internal_road_attribution_size() const {
  return _internal_road_attribution().size();
}
inline int RoadAttributionCategory::road_attribution_size() const {
  return _internal_road_attribution_size();
}
inline void RoadAttributionCategory::clear_road_attribution() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.road_attribution_.Clear();
}
inline ::sensoris::protobuf::categories::roadattribution::RoadAttribution* RoadAttributionCategory::mutable_road_attribution(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.road_attribution)
  return _internal_mutable_road_attribution()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::RoadAttribution>* RoadAttributionCategory::mutable_road_attribution()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.road_attribution)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_road_attribution();
}
inline const ::sensoris::protobuf::categories::roadattribution::RoadAttribution& RoadAttributionCategory::road_attribution(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.road_attribution)
  return _internal_road_attribution().Get(index);
}
inline ::sensoris::protobuf::categories::roadattribution::RoadAttribution* RoadAttributionCategory::add_road_attribution() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::sensoris::protobuf::categories::roadattribution::RoadAttribution* _add = _internal_mutable_road_attribution()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.road_attribution)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::RoadAttribution>& RoadAttributionCategory::road_attribution() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.road_attribution)
  return _internal_road_attribution();
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::RoadAttribution>&
RoadAttributionCategory::_internal_road_attribution() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.road_attribution_;
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::RoadAttribution>*
RoadAttributionCategory::_internal_mutable_road_attribution() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.road_attribution_;
}

// repeated .sensoris.protobuf.categories.roadattribution.LaneCountAndConfidence detected_lane_count_and_confidence = 9;
inline int RoadAttributionCategory::_internal_detected_lane_count_and_confidence_size() const {
  return _internal_detected_lane_count_and_confidence().size();
}
inline int RoadAttributionCategory::detected_lane_count_and_confidence_size() const {
  return _internal_detected_lane_count_and_confidence_size();
}
inline void RoadAttributionCategory::clear_detected_lane_count_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.detected_lane_count_and_confidence_.Clear();
}
inline ::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence* RoadAttributionCategory::mutable_detected_lane_count_and_confidence(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.detected_lane_count_and_confidence)
  return _internal_mutable_detected_lane_count_and_confidence()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence>* RoadAttributionCategory::mutable_detected_lane_count_and_confidence()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.detected_lane_count_and_confidence)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_detected_lane_count_and_confidence();
}
inline const ::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence& RoadAttributionCategory::detected_lane_count_and_confidence(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.detected_lane_count_and_confidence)
  return _internal_detected_lane_count_and_confidence().Get(index);
}
inline ::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence* RoadAttributionCategory::add_detected_lane_count_and_confidence() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence* _add = _internal_mutable_detected_lane_count_and_confidence()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.detected_lane_count_and_confidence)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence>& RoadAttributionCategory::detected_lane_count_and_confidence() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.detected_lane_count_and_confidence)
  return _internal_detected_lane_count_and_confidence();
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence>&
RoadAttributionCategory::_internal_detected_lane_count_and_confidence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.detected_lane_count_and_confidence_;
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence>*
RoadAttributionCategory::_internal_mutable_detected_lane_count_and_confidence() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.detected_lane_count_and_confidence_;
}

// repeated .sensoris.protobuf.categories.roadattribution.LaneCountAndConfidence estimated_lane_count_and_confidence = 10;
inline int RoadAttributionCategory::_internal_estimated_lane_count_and_confidence_size() const {
  return _internal_estimated_lane_count_and_confidence().size();
}
inline int RoadAttributionCategory::estimated_lane_count_and_confidence_size() const {
  return _internal_estimated_lane_count_and_confidence_size();
}
inline void RoadAttributionCategory::clear_estimated_lane_count_and_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.estimated_lane_count_and_confidence_.Clear();
}
inline ::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence* RoadAttributionCategory::mutable_estimated_lane_count_and_confidence(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.estimated_lane_count_and_confidence)
  return _internal_mutable_estimated_lane_count_and_confidence()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence>* RoadAttributionCategory::mutable_estimated_lane_count_and_confidence()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.estimated_lane_count_and_confidence)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_estimated_lane_count_and_confidence();
}
inline const ::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence& RoadAttributionCategory::estimated_lane_count_and_confidence(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.estimated_lane_count_and_confidence)
  return _internal_estimated_lane_count_and_confidence().Get(index);
}
inline ::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence* RoadAttributionCategory::add_estimated_lane_count_and_confidence() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence* _add = _internal_mutable_estimated_lane_count_and_confidence()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.estimated_lane_count_and_confidence)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence>& RoadAttributionCategory::estimated_lane_count_and_confidence() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.estimated_lane_count_and_confidence)
  return _internal_estimated_lane_count_and_confidence();
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence>&
RoadAttributionCategory::_internal_estimated_lane_count_and_confidence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.estimated_lane_count_and_confidence_;
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence>*
RoadAttributionCategory::_internal_mutable_estimated_lane_count_and_confidence() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.estimated_lane_count_and_confidence_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace roadattribution
}  // namespace categories
}  // namespace protobuf
}  // namespace sensoris


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence_Type> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence_Type>() {
  return ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence_Type_descriptor();
}
template <>
struct is_proto_enum<::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence_Type> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence_Type>() {
  return ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence_Type_descriptor();
}
template <>
struct is_proto_enum<::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence_Type> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence_Type>() {
  return ::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence_Type_descriptor();
}
template <>
struct is_proto_enum<::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence_Type> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence_Type>() {
  return ::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence_Type_descriptor();
}
template <>
struct is_proto_enum<::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset_Type> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset_Type>() {
  return ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset_Type_descriptor();
}
template <>
struct is_proto_enum<::sensoris::protobuf::categories::roadattribution::LaneBoundary_PositionReference> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::sensoris::protobuf::categories::roadattribution::LaneBoundary_PositionReference>() {
  return ::sensoris::protobuf::categories::roadattribution::LaneBoundary_PositionReference_descriptor();
}
template <>
struct is_proto_enum<::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence_Type> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence_Type>() {
  return ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence_Type_descriptor();
}
template <>
struct is_proto_enum<::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence_Type> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence_Type>() {
  return ::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence_Type_descriptor();
}
template <>
struct is_proto_enum<::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence_Type> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence_Type>() {
  return ::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence_Type_descriptor();
}
template <>
struct is_proto_enum<::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence_Type> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence_Type>() {
  return ::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence_Type_descriptor();
}
template <>
struct is_proto_enum<::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence_Type> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence_Type>() {
  return ::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence_Type_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto_2epb_2eh
