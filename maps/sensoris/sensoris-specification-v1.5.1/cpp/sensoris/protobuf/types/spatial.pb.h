/**
 * Copyright (c) 2017-2022 SENSORIS Innovation Platform hosted by ERTICO - ITS Europe.
 *
 * This program and the accompanying materials are made available under the terms of the Creative Commons Attribution-NoDerivatives 4.0 International license which accompanies this distribution, and is available at https://creativecommons.org/licenses/by-nd/4.0/legalcode.
 */
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sensoris/protobuf/types/spatial.proto
// Protobuf C++ Version: 4.25.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "google/protobuf/any.pb.h"
#include "google/protobuf/wrappers.pb.h"
#include "sensoris/protobuf/types/base.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto;
namespace sensoris {
namespace protobuf {
namespace types {
namespace spatial {
class CircleAndAccuracy;
struct CircleAndAccuracyDefaultTypeInternal;
extern CircleAndAccuracyDefaultTypeInternal _CircleAndAccuracy_default_instance_;
class DirectedPolylineCorridor;
struct DirectedPolylineCorridorDefaultTypeInternal;
extern DirectedPolylineCorridorDefaultTypeInternal _DirectedPolylineCorridor_default_instance_;
class MapLocationReference;
struct MapLocationReferenceDefaultTypeInternal;
extern MapLocationReferenceDefaultTypeInternal _MapLocationReference_default_instance_;
class MapLocationReference_TileIdLinkIdOffset;
struct MapLocationReference_TileIdLinkIdOffsetDefaultTypeInternal;
extern MapLocationReference_TileIdLinkIdOffsetDefaultTypeInternal _MapLocationReference_TileIdLinkIdOffset_default_instance_;
class MapLocationReference_TileIdObjectId;
struct MapLocationReference_TileIdObjectIdDefaultTypeInternal;
extern MapLocationReference_TileIdObjectIdDefaultTypeInternal _MapLocationReference_TileIdObjectId_default_instance_;
class PolygonAndAccuracy;
struct PolygonAndAccuracyDefaultTypeInternal;
extern PolygonAndAccuracyDefaultTypeInternal _PolygonAndAccuracy_default_instance_;
class PolylineAndAccuracy;
struct PolylineAndAccuracyDefaultTypeInternal;
extern PolylineAndAccuracyDefaultTypeInternal _PolylineAndAccuracy_default_instance_;
class PolylineCorridorAndAccuracy;
struct PolylineCorridorAndAccuracyDefaultTypeInternal;
extern PolylineCorridorAndAccuracyDefaultTypeInternal _PolylineCorridorAndAccuracy_default_instance_;
class PositionAndAccuracy;
struct PositionAndAccuracyDefaultTypeInternal;
extern PositionAndAccuracyDefaultTypeInternal _PositionAndAccuracy_default_instance_;
class PositionAndAccuracy_Geographic;
struct PositionAndAccuracy_GeographicDefaultTypeInternal;
extern PositionAndAccuracy_GeographicDefaultTypeInternal _PositionAndAccuracy_Geographic_default_instance_;
class PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev;
struct PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDevDefaultTypeInternal;
extern PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDevDefaultTypeInternal _PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev_default_instance_;
class PositionAndAccuracy_HorizontalVerticalStdDev;
struct PositionAndAccuracy_HorizontalVerticalStdDevDefaultTypeInternal;
extern PositionAndAccuracy_HorizontalVerticalStdDevDefaultTypeInternal _PositionAndAccuracy_HorizontalVerticalStdDev_default_instance_;
class PositionAndAccuracy_Metric;
struct PositionAndAccuracy_MetricDefaultTypeInternal;
extern PositionAndAccuracy_MetricDefaultTypeInternal _PositionAndAccuracy_Metric_default_instance_;
class RectangleAndAccuracy;
struct RectangleAndAccuracyDefaultTypeInternal;
extern RectangleAndAccuracyDefaultTypeInternal _RectangleAndAccuracy_default_instance_;
class RectangularBoxAndAccuracy;
struct RectangularBoxAndAccuracyDefaultTypeInternal;
extern RectangularBoxAndAccuracyDefaultTypeInternal _RectangularBoxAndAccuracy_default_instance_;
class RectangularBoxAndAccuracy_CenterOrientationSize;
struct RectangularBoxAndAccuracy_CenterOrientationSizeDefaultTypeInternal;
extern RectangularBoxAndAccuracy_CenterOrientationSizeDefaultTypeInternal _RectangularBoxAndAccuracy_CenterOrientationSize_default_instance_;
class RectangularBoxAndAccuracy_CornerVectors;
struct RectangularBoxAndAccuracy_CornerVectorsDefaultTypeInternal;
extern RectangularBoxAndAccuracy_CornerVectorsDefaultTypeInternal _RectangularBoxAndAccuracy_CornerVectors_default_instance_;
class RotationAndAccuracy;
struct RotationAndAccuracyDefaultTypeInternal;
extern RotationAndAccuracyDefaultTypeInternal _RotationAndAccuracy_default_instance_;
class RotationAndAccuracy_Euler;
struct RotationAndAccuracy_EulerDefaultTypeInternal;
extern RotationAndAccuracy_EulerDefaultTypeInternal _RotationAndAccuracy_Euler_default_instance_;
class RotationAndAccuracy_Quaternion;
struct RotationAndAccuracy_QuaternionDefaultTypeInternal;
extern RotationAndAccuracy_QuaternionDefaultTypeInternal _RotationAndAccuracy_Quaternion_default_instance_;
class RotationAndAccuracy_StdDev;
struct RotationAndAccuracy_StdDevDefaultTypeInternal;
extern RotationAndAccuracy_StdDevDefaultTypeInternal _RotationAndAccuracy_StdDev_default_instance_;
class RotationRateAndAccuracy;
struct RotationRateAndAccuracyDefaultTypeInternal;
extern RotationRateAndAccuracyDefaultTypeInternal _RotationRateAndAccuracy_default_instance_;
class RotationRateAndAccuracy_StdDev;
struct RotationRateAndAccuracy_StdDevDefaultTypeInternal;
extern RotationRateAndAccuracy_StdDevDefaultTypeInternal _RotationRateAndAccuracy_StdDev_default_instance_;
class XyzVectorAndAccuracy;
struct XyzVectorAndAccuracyDefaultTypeInternal;
extern XyzVectorAndAccuracyDefaultTypeInternal _XyzVectorAndAccuracy_default_instance_;
class XyzVectorAndAccuracy_Metric;
struct XyzVectorAndAccuracy_MetricDefaultTypeInternal;
extern XyzVectorAndAccuracy_MetricDefaultTypeInternal _XyzVectorAndAccuracy_Metric_default_instance_;
class XyzVectorAndAccuracy_StdDev;
struct XyzVectorAndAccuracy_StdDevDefaultTypeInternal;
extern XyzVectorAndAccuracy_StdDevDefaultTypeInternal _XyzVectorAndAccuracy_StdDev_default_instance_;
}  // namespace spatial
}  // namespace types
}  // namespace protobuf
}  // namespace sensoris
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace sensoris {
namespace protobuf {
namespace types {
namespace spatial {

// ===================================================================


// -------------------------------------------------------------------

class XyzVectorAndAccuracy_StdDev final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev) */ {
 public:
  inline XyzVectorAndAccuracy_StdDev() : XyzVectorAndAccuracy_StdDev(nullptr) {}
  ~XyzVectorAndAccuracy_StdDev() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR XyzVectorAndAccuracy_StdDev(::google::protobuf::internal::ConstantInitialized);

  inline XyzVectorAndAccuracy_StdDev(const XyzVectorAndAccuracy_StdDev& from)
      : XyzVectorAndAccuracy_StdDev(nullptr, from) {}
  XyzVectorAndAccuracy_StdDev(XyzVectorAndAccuracy_StdDev&& from) noexcept
    : XyzVectorAndAccuracy_StdDev() {
    *this = ::std::move(from);
  }

  inline XyzVectorAndAccuracy_StdDev& operator=(const XyzVectorAndAccuracy_StdDev& from) {
    CopyFrom(from);
    return *this;
  }
  inline XyzVectorAndAccuracy_StdDev& operator=(XyzVectorAndAccuracy_StdDev&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const XyzVectorAndAccuracy_StdDev& default_instance() {
    return *internal_default_instance();
  }
  static inline const XyzVectorAndAccuracy_StdDev* internal_default_instance() {
    return reinterpret_cast<const XyzVectorAndAccuracy_StdDev*>(
               &_XyzVectorAndAccuracy_StdDev_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(XyzVectorAndAccuracy_StdDev& a, XyzVectorAndAccuracy_StdDev& b) {
    a.Swap(&b);
  }
  inline void Swap(XyzVectorAndAccuracy_StdDev* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(XyzVectorAndAccuracy_StdDev* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  XyzVectorAndAccuracy_StdDev* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<XyzVectorAndAccuracy_StdDev>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const XyzVectorAndAccuracy_StdDev& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const XyzVectorAndAccuracy_StdDev& from) {
    XyzVectorAndAccuracy_StdDev::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(XyzVectorAndAccuracy_StdDev* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev";
  }
  protected:
  explicit XyzVectorAndAccuracy_StdDev(::google::protobuf::Arena* arena);
  XyzVectorAndAccuracy_StdDev(::google::protobuf::Arena* arena, const XyzVectorAndAccuracy_StdDev& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // .google.protobuf.Int64Value x = 1;
  bool has_x() const;
  void clear_x() ;
  const ::google::protobuf::Int64Value& x() const;
  PROTOBUF_NODISCARD ::google::protobuf::Int64Value* release_x();
  ::google::protobuf::Int64Value* mutable_x();
  void set_allocated_x(::google::protobuf::Int64Value* value);
  void unsafe_arena_set_allocated_x(::google::protobuf::Int64Value* value);
  ::google::protobuf::Int64Value* unsafe_arena_release_x();

  private:
  const ::google::protobuf::Int64Value& _internal_x() const;
  ::google::protobuf::Int64Value* _internal_mutable_x();

  public:
  // .google.protobuf.Int64Value y = 2;
  bool has_y() const;
  void clear_y() ;
  const ::google::protobuf::Int64Value& y() const;
  PROTOBUF_NODISCARD ::google::protobuf::Int64Value* release_y();
  ::google::protobuf::Int64Value* mutable_y();
  void set_allocated_y(::google::protobuf::Int64Value* value);
  void unsafe_arena_set_allocated_y(::google::protobuf::Int64Value* value);
  ::google::protobuf::Int64Value* unsafe_arena_release_y();

  private:
  const ::google::protobuf::Int64Value& _internal_y() const;
  ::google::protobuf::Int64Value* _internal_mutable_y();

  public:
  // .google.protobuf.Int64Value z = 3;
  bool has_z() const;
  void clear_z() ;
  const ::google::protobuf::Int64Value& z() const;
  PROTOBUF_NODISCARD ::google::protobuf::Int64Value* release_z();
  ::google::protobuf::Int64Value* mutable_z();
  void set_allocated_z(::google::protobuf::Int64Value* value);
  void unsafe_arena_set_allocated_z(::google::protobuf::Int64Value* value);
  ::google::protobuf::Int64Value* unsafe_arena_release_z();

  private:
  const ::google::protobuf::Int64Value& _internal_z() const;
  ::google::protobuf::Int64Value* _internal_mutable_z();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::Int64Value* x_;
    ::google::protobuf::Int64Value* y_;
    ::google::protobuf::Int64Value* z_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto;
};// -------------------------------------------------------------------

class RotationRateAndAccuracy_StdDev final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev) */ {
 public:
  inline RotationRateAndAccuracy_StdDev() : RotationRateAndAccuracy_StdDev(nullptr) {}
  ~RotationRateAndAccuracy_StdDev() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RotationRateAndAccuracy_StdDev(::google::protobuf::internal::ConstantInitialized);

  inline RotationRateAndAccuracy_StdDev(const RotationRateAndAccuracy_StdDev& from)
      : RotationRateAndAccuracy_StdDev(nullptr, from) {}
  RotationRateAndAccuracy_StdDev(RotationRateAndAccuracy_StdDev&& from) noexcept
    : RotationRateAndAccuracy_StdDev() {
    *this = ::std::move(from);
  }

  inline RotationRateAndAccuracy_StdDev& operator=(const RotationRateAndAccuracy_StdDev& from) {
    CopyFrom(from);
    return *this;
  }
  inline RotationRateAndAccuracy_StdDev& operator=(RotationRateAndAccuracy_StdDev&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RotationRateAndAccuracy_StdDev& default_instance() {
    return *internal_default_instance();
  }
  static inline const RotationRateAndAccuracy_StdDev* internal_default_instance() {
    return reinterpret_cast<const RotationRateAndAccuracy_StdDev*>(
               &_RotationRateAndAccuracy_StdDev_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(RotationRateAndAccuracy_StdDev& a, RotationRateAndAccuracy_StdDev& b) {
    a.Swap(&b);
  }
  inline void Swap(RotationRateAndAccuracy_StdDev* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RotationRateAndAccuracy_StdDev* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RotationRateAndAccuracy_StdDev* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RotationRateAndAccuracy_StdDev>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RotationRateAndAccuracy_StdDev& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RotationRateAndAccuracy_StdDev& from) {
    RotationRateAndAccuracy_StdDev::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RotationRateAndAccuracy_StdDev* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev";
  }
  protected:
  explicit RotationRateAndAccuracy_StdDev(::google::protobuf::Arena* arena);
  RotationRateAndAccuracy_StdDev(::google::protobuf::Arena* arena, const RotationRateAndAccuracy_StdDev& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kYawFieldNumber = 1,
    kPitchFieldNumber = 2,
    kRollFieldNumber = 3,
  };
  // .google.protobuf.Int64Value yaw = 1 [(.sensoris.protobuf.types.base.exponent) = 2];
  bool has_yaw() const;
  void clear_yaw() ;
  const ::google::protobuf::Int64Value& yaw() const;
  PROTOBUF_NODISCARD ::google::protobuf::Int64Value* release_yaw();
  ::google::protobuf::Int64Value* mutable_yaw();
  void set_allocated_yaw(::google::protobuf::Int64Value* value);
  void unsafe_arena_set_allocated_yaw(::google::protobuf::Int64Value* value);
  ::google::protobuf::Int64Value* unsafe_arena_release_yaw();

  private:
  const ::google::protobuf::Int64Value& _internal_yaw() const;
  ::google::protobuf::Int64Value* _internal_mutable_yaw();

  public:
  // .google.protobuf.Int64Value pitch = 2 [(.sensoris.protobuf.types.base.exponent) = 2];
  bool has_pitch() const;
  void clear_pitch() ;
  const ::google::protobuf::Int64Value& pitch() const;
  PROTOBUF_NODISCARD ::google::protobuf::Int64Value* release_pitch();
  ::google::protobuf::Int64Value* mutable_pitch();
  void set_allocated_pitch(::google::protobuf::Int64Value* value);
  void unsafe_arena_set_allocated_pitch(::google::protobuf::Int64Value* value);
  ::google::protobuf::Int64Value* unsafe_arena_release_pitch();

  private:
  const ::google::protobuf::Int64Value& _internal_pitch() const;
  ::google::protobuf::Int64Value* _internal_mutable_pitch();

  public:
  // .google.protobuf.Int64Value roll = 3 [(.sensoris.protobuf.types.base.exponent) = 2];
  bool has_roll() const;
  void clear_roll() ;
  const ::google::protobuf::Int64Value& roll() const;
  PROTOBUF_NODISCARD ::google::protobuf::Int64Value* release_roll();
  ::google::protobuf::Int64Value* mutable_roll();
  void set_allocated_roll(::google::protobuf::Int64Value* value);
  void unsafe_arena_set_allocated_roll(::google::protobuf::Int64Value* value);
  ::google::protobuf::Int64Value* unsafe_arena_release_roll();

  private:
  const ::google::protobuf::Int64Value& _internal_roll() const;
  ::google::protobuf::Int64Value* _internal_mutable_roll();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::Int64Value* yaw_;
    ::google::protobuf::Int64Value* pitch_;
    ::google::protobuf::Int64Value* roll_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto;
};// -------------------------------------------------------------------

class RotationAndAccuracy_StdDev final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev) */ {
 public:
  inline RotationAndAccuracy_StdDev() : RotationAndAccuracy_StdDev(nullptr) {}
  ~RotationAndAccuracy_StdDev() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RotationAndAccuracy_StdDev(::google::protobuf::internal::ConstantInitialized);

  inline RotationAndAccuracy_StdDev(const RotationAndAccuracy_StdDev& from)
      : RotationAndAccuracy_StdDev(nullptr, from) {}
  RotationAndAccuracy_StdDev(RotationAndAccuracy_StdDev&& from) noexcept
    : RotationAndAccuracy_StdDev() {
    *this = ::std::move(from);
  }

  inline RotationAndAccuracy_StdDev& operator=(const RotationAndAccuracy_StdDev& from) {
    CopyFrom(from);
    return *this;
  }
  inline RotationAndAccuracy_StdDev& operator=(RotationAndAccuracy_StdDev&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RotationAndAccuracy_StdDev& default_instance() {
    return *internal_default_instance();
  }
  static inline const RotationAndAccuracy_StdDev* internal_default_instance() {
    return reinterpret_cast<const RotationAndAccuracy_StdDev*>(
               &_RotationAndAccuracy_StdDev_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(RotationAndAccuracy_StdDev& a, RotationAndAccuracy_StdDev& b) {
    a.Swap(&b);
  }
  inline void Swap(RotationAndAccuracy_StdDev* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RotationAndAccuracy_StdDev* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RotationAndAccuracy_StdDev* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RotationAndAccuracy_StdDev>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RotationAndAccuracy_StdDev& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RotationAndAccuracy_StdDev& from) {
    RotationAndAccuracy_StdDev::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RotationAndAccuracy_StdDev* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev";
  }
  protected:
  explicit RotationAndAccuracy_StdDev(::google::protobuf::Arena* arena);
  RotationAndAccuracy_StdDev(::google::protobuf::Arena* arena, const RotationAndAccuracy_StdDev& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kYawFieldNumber = 1,
    kPitchFieldNumber = 2,
    kRollFieldNumber = 3,
  };
  // .google.protobuf.Int64Value yaw = 1 [(.sensoris.protobuf.types.base.exponent) = 2];
  bool has_yaw() const;
  void clear_yaw() ;
  const ::google::protobuf::Int64Value& yaw() const;
  PROTOBUF_NODISCARD ::google::protobuf::Int64Value* release_yaw();
  ::google::protobuf::Int64Value* mutable_yaw();
  void set_allocated_yaw(::google::protobuf::Int64Value* value);
  void unsafe_arena_set_allocated_yaw(::google::protobuf::Int64Value* value);
  ::google::protobuf::Int64Value* unsafe_arena_release_yaw();

  private:
  const ::google::protobuf::Int64Value& _internal_yaw() const;
  ::google::protobuf::Int64Value* _internal_mutable_yaw();

  public:
  // .google.protobuf.Int64Value pitch = 2 [(.sensoris.protobuf.types.base.exponent) = 2];
  bool has_pitch() const;
  void clear_pitch() ;
  const ::google::protobuf::Int64Value& pitch() const;
  PROTOBUF_NODISCARD ::google::protobuf::Int64Value* release_pitch();
  ::google::protobuf::Int64Value* mutable_pitch();
  void set_allocated_pitch(::google::protobuf::Int64Value* value);
  void unsafe_arena_set_allocated_pitch(::google::protobuf::Int64Value* value);
  ::google::protobuf::Int64Value* unsafe_arena_release_pitch();

  private:
  const ::google::protobuf::Int64Value& _internal_pitch() const;
  ::google::protobuf::Int64Value* _internal_mutable_pitch();

  public:
  // .google.protobuf.Int64Value roll = 3 [(.sensoris.protobuf.types.base.exponent) = 2];
  bool has_roll() const;
  void clear_roll() ;
  const ::google::protobuf::Int64Value& roll() const;
  PROTOBUF_NODISCARD ::google::protobuf::Int64Value* release_roll();
  ::google::protobuf::Int64Value* mutable_roll();
  void set_allocated_roll(::google::protobuf::Int64Value* value);
  void unsafe_arena_set_allocated_roll(::google::protobuf::Int64Value* value);
  ::google::protobuf::Int64Value* unsafe_arena_release_roll();

  private:
  const ::google::protobuf::Int64Value& _internal_roll() const;
  ::google::protobuf::Int64Value* _internal_mutable_roll();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::Int64Value* yaw_;
    ::google::protobuf::Int64Value* pitch_;
    ::google::protobuf::Int64Value* roll_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto;
};// -------------------------------------------------------------------

class PositionAndAccuracy_HorizontalVerticalStdDev final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalVerticalStdDev) */ {
 public:
  inline PositionAndAccuracy_HorizontalVerticalStdDev() : PositionAndAccuracy_HorizontalVerticalStdDev(nullptr) {}
  ~PositionAndAccuracy_HorizontalVerticalStdDev() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PositionAndAccuracy_HorizontalVerticalStdDev(::google::protobuf::internal::ConstantInitialized);

  inline PositionAndAccuracy_HorizontalVerticalStdDev(const PositionAndAccuracy_HorizontalVerticalStdDev& from)
      : PositionAndAccuracy_HorizontalVerticalStdDev(nullptr, from) {}
  PositionAndAccuracy_HorizontalVerticalStdDev(PositionAndAccuracy_HorizontalVerticalStdDev&& from) noexcept
    : PositionAndAccuracy_HorizontalVerticalStdDev() {
    *this = ::std::move(from);
  }

  inline PositionAndAccuracy_HorizontalVerticalStdDev& operator=(const PositionAndAccuracy_HorizontalVerticalStdDev& from) {
    CopyFrom(from);
    return *this;
  }
  inline PositionAndAccuracy_HorizontalVerticalStdDev& operator=(PositionAndAccuracy_HorizontalVerticalStdDev&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PositionAndAccuracy_HorizontalVerticalStdDev& default_instance() {
    return *internal_default_instance();
  }
  static inline const PositionAndAccuracy_HorizontalVerticalStdDev* internal_default_instance() {
    return reinterpret_cast<const PositionAndAccuracy_HorizontalVerticalStdDev*>(
               &_PositionAndAccuracy_HorizontalVerticalStdDev_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(PositionAndAccuracy_HorizontalVerticalStdDev& a, PositionAndAccuracy_HorizontalVerticalStdDev& b) {
    a.Swap(&b);
  }
  inline void Swap(PositionAndAccuracy_HorizontalVerticalStdDev* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PositionAndAccuracy_HorizontalVerticalStdDev* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PositionAndAccuracy_HorizontalVerticalStdDev* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PositionAndAccuracy_HorizontalVerticalStdDev>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PositionAndAccuracy_HorizontalVerticalStdDev& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PositionAndAccuracy_HorizontalVerticalStdDev& from) {
    PositionAndAccuracy_HorizontalVerticalStdDev::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PositionAndAccuracy_HorizontalVerticalStdDev* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalVerticalStdDev";
  }
  protected:
  explicit PositionAndAccuracy_HorizontalVerticalStdDev(::google::protobuf::Arena* arena);
  PositionAndAccuracy_HorizontalVerticalStdDev(::google::protobuf::Arena* arena, const PositionAndAccuracy_HorizontalVerticalStdDev& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHorizontalFieldNumber = 1,
    kVerticalFieldNumber = 2,
  };
  // .google.protobuf.Int64Value horizontal = 1 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_horizontal() const;
  void clear_horizontal() ;
  const ::google::protobuf::Int64Value& horizontal() const;
  PROTOBUF_NODISCARD ::google::protobuf::Int64Value* release_horizontal();
  ::google::protobuf::Int64Value* mutable_horizontal();
  void set_allocated_horizontal(::google::protobuf::Int64Value* value);
  void unsafe_arena_set_allocated_horizontal(::google::protobuf::Int64Value* value);
  ::google::protobuf::Int64Value* unsafe_arena_release_horizontal();

  private:
  const ::google::protobuf::Int64Value& _internal_horizontal() const;
  ::google::protobuf::Int64Value* _internal_mutable_horizontal();

  public:
  // .google.protobuf.Int64Value vertical = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_vertical() const;
  void clear_vertical() ;
  const ::google::protobuf::Int64Value& vertical() const;
  PROTOBUF_NODISCARD ::google::protobuf::Int64Value* release_vertical();
  ::google::protobuf::Int64Value* mutable_vertical();
  void set_allocated_vertical(::google::protobuf::Int64Value* value);
  void unsafe_arena_set_allocated_vertical(::google::protobuf::Int64Value* value);
  ::google::protobuf::Int64Value* unsafe_arena_release_vertical();

  private:
  const ::google::protobuf::Int64Value& _internal_vertical() const;
  ::google::protobuf::Int64Value* _internal_mutable_vertical();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalVerticalStdDev)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::Int64Value* horizontal_;
    ::google::protobuf::Int64Value* vertical_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto;
};// -------------------------------------------------------------------

class PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev) */ {
 public:
  inline PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev() : PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev(nullptr) {}
  ~PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev(::google::protobuf::internal::ConstantInitialized);

  inline PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev(const PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev& from)
      : PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev(nullptr, from) {}
  PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev(PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev&& from) noexcept
    : PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev() {
    *this = ::std::move(from);
  }

  inline PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev& operator=(const PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev& from) {
    CopyFrom(from);
    return *this;
  }
  inline PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev& operator=(PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev& default_instance() {
    return *internal_default_instance();
  }
  static inline const PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev* internal_default_instance() {
    return reinterpret_cast<const PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev*>(
               &_PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev& a, PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev& b) {
    a.Swap(&b);
  }
  inline void Swap(PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev& from) {
    PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev";
  }
  protected:
  explicit PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev(::google::protobuf::Arena* arena);
  PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev(::google::protobuf::Arena* arena, const PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHorizontalEllipseMajorFieldNumber = 1,
    kHorizontalEllipseMinorFieldNumber = 2,
    kHorizontalEllipseMajorHeadingFieldNumber = 3,
    kVerticalFieldNumber = 4,
  };
  // .google.protobuf.Int64Value horizontal_ellipse_major = 1 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_horizontal_ellipse_major() const;
  void clear_horizontal_ellipse_major() ;
  const ::google::protobuf::Int64Value& horizontal_ellipse_major() const;
  PROTOBUF_NODISCARD ::google::protobuf::Int64Value* release_horizontal_ellipse_major();
  ::google::protobuf::Int64Value* mutable_horizontal_ellipse_major();
  void set_allocated_horizontal_ellipse_major(::google::protobuf::Int64Value* value);
  void unsafe_arena_set_allocated_horizontal_ellipse_major(::google::protobuf::Int64Value* value);
  ::google::protobuf::Int64Value* unsafe_arena_release_horizontal_ellipse_major();

  private:
  const ::google::protobuf::Int64Value& _internal_horizontal_ellipse_major() const;
  ::google::protobuf::Int64Value* _internal_mutable_horizontal_ellipse_major();

  public:
  // .google.protobuf.Int64Value horizontal_ellipse_minor = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_horizontal_ellipse_minor() const;
  void clear_horizontal_ellipse_minor() ;
  const ::google::protobuf::Int64Value& horizontal_ellipse_minor() const;
  PROTOBUF_NODISCARD ::google::protobuf::Int64Value* release_horizontal_ellipse_minor();
  ::google::protobuf::Int64Value* mutable_horizontal_ellipse_minor();
  void set_allocated_horizontal_ellipse_minor(::google::protobuf::Int64Value* value);
  void unsafe_arena_set_allocated_horizontal_ellipse_minor(::google::protobuf::Int64Value* value);
  ::google::protobuf::Int64Value* unsafe_arena_release_horizontal_ellipse_minor();

  private:
  const ::google::protobuf::Int64Value& _internal_horizontal_ellipse_minor() const;
  ::google::protobuf::Int64Value* _internal_mutable_horizontal_ellipse_minor();

  public:
  // .google.protobuf.Int64Value horizontal_ellipse_major_heading = 3 [(.sensoris.protobuf.types.base.exponent) = 2];
  bool has_horizontal_ellipse_major_heading() const;
  void clear_horizontal_ellipse_major_heading() ;
  const ::google::protobuf::Int64Value& horizontal_ellipse_major_heading() const;
  PROTOBUF_NODISCARD ::google::protobuf::Int64Value* release_horizontal_ellipse_major_heading();
  ::google::protobuf::Int64Value* mutable_horizontal_ellipse_major_heading();
  void set_allocated_horizontal_ellipse_major_heading(::google::protobuf::Int64Value* value);
  void unsafe_arena_set_allocated_horizontal_ellipse_major_heading(::google::protobuf::Int64Value* value);
  ::google::protobuf::Int64Value* unsafe_arena_release_horizontal_ellipse_major_heading();

  private:
  const ::google::protobuf::Int64Value& _internal_horizontal_ellipse_major_heading() const;
  ::google::protobuf::Int64Value* _internal_mutable_horizontal_ellipse_major_heading();

  public:
  // .google.protobuf.Int64Value vertical = 4 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_vertical() const;
  void clear_vertical() ;
  const ::google::protobuf::Int64Value& vertical() const;
  PROTOBUF_NODISCARD ::google::protobuf::Int64Value* release_vertical();
  ::google::protobuf::Int64Value* mutable_vertical();
  void set_allocated_vertical(::google::protobuf::Int64Value* value);
  void unsafe_arena_set_allocated_vertical(::google::protobuf::Int64Value* value);
  ::google::protobuf::Int64Value* unsafe_arena_release_vertical();

  private:
  const ::google::protobuf::Int64Value& _internal_vertical() const;
  ::google::protobuf::Int64Value* _internal_mutable_vertical();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 4,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::Int64Value* horizontal_ellipse_major_;
    ::google::protobuf::Int64Value* horizontal_ellipse_minor_;
    ::google::protobuf::Int64Value* horizontal_ellipse_major_heading_;
    ::google::protobuf::Int64Value* vertical_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto;
};// -------------------------------------------------------------------

class MapLocationReference_TileIdObjectId final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId) */ {
 public:
  inline MapLocationReference_TileIdObjectId() : MapLocationReference_TileIdObjectId(nullptr) {}
  ~MapLocationReference_TileIdObjectId() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MapLocationReference_TileIdObjectId(::google::protobuf::internal::ConstantInitialized);

  inline MapLocationReference_TileIdObjectId(const MapLocationReference_TileIdObjectId& from)
      : MapLocationReference_TileIdObjectId(nullptr, from) {}
  MapLocationReference_TileIdObjectId(MapLocationReference_TileIdObjectId&& from) noexcept
    : MapLocationReference_TileIdObjectId() {
    *this = ::std::move(from);
  }

  inline MapLocationReference_TileIdObjectId& operator=(const MapLocationReference_TileIdObjectId& from) {
    CopyFrom(from);
    return *this;
  }
  inline MapLocationReference_TileIdObjectId& operator=(MapLocationReference_TileIdObjectId&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MapLocationReference_TileIdObjectId& default_instance() {
    return *internal_default_instance();
  }
  static inline const MapLocationReference_TileIdObjectId* internal_default_instance() {
    return reinterpret_cast<const MapLocationReference_TileIdObjectId*>(
               &_MapLocationReference_TileIdObjectId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(MapLocationReference_TileIdObjectId& a, MapLocationReference_TileIdObjectId& b) {
    a.Swap(&b);
  }
  inline void Swap(MapLocationReference_TileIdObjectId* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MapLocationReference_TileIdObjectId* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MapLocationReference_TileIdObjectId* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MapLocationReference_TileIdObjectId>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MapLocationReference_TileIdObjectId& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MapLocationReference_TileIdObjectId& from) {
    MapLocationReference_TileIdObjectId::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MapLocationReference_TileIdObjectId* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId";
  }
  protected:
  explicit MapLocationReference_TileIdObjectId(::google::protobuf::Arena* arena);
  MapLocationReference_TileIdObjectId(::google::protobuf::Arena* arena, const MapLocationReference_TileIdObjectId& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExtensionFieldNumber = 15,
    kTileIdFieldNumber = 1,
    kObjectIdFieldNumber = 2,
  };
  // repeated .google.protobuf.Any extension = 15;
  int extension_size() const;
  private:
  int _internal_extension_size() const;

  public:
  void clear_extension() ;
  ::google::protobuf::Any* mutable_extension(int index);
  ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >*
      mutable_extension();
  private:
  const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& _internal_extension() const;
  ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* _internal_mutable_extension();
  public:
  const ::google::protobuf::Any& extension(int index) const;
  ::google::protobuf::Any* add_extension();
  const ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >&
      extension() const;
  // .google.protobuf.Int64Value tile_id = 1;
  bool has_tile_id() const;
  void clear_tile_id() ;
  const ::google::protobuf::Int64Value& tile_id() const;
  PROTOBUF_NODISCARD ::google::protobuf::Int64Value* release_tile_id();
  ::google::protobuf::Int64Value* mutable_tile_id();
  void set_allocated_tile_id(::google::protobuf::Int64Value* value);
  void unsafe_arena_set_allocated_tile_id(::google::protobuf::Int64Value* value);
  ::google::protobuf::Int64Value* unsafe_arena_release_tile_id();

  private:
  const ::google::protobuf::Int64Value& _internal_tile_id() const;
  ::google::protobuf::Int64Value* _internal_mutable_tile_id();

  public:
  // .google.protobuf.Int64Value object_id = 2;
  bool has_object_id() const;
  void clear_object_id() ;
  const ::google::protobuf::Int64Value& object_id() const;
  PROTOBUF_NODISCARD ::google::protobuf::Int64Value* release_object_id();
  ::google::protobuf::Int64Value* mutable_object_id();
  void set_allocated_object_id(::google::protobuf::Int64Value* value);
  void unsafe_arena_set_allocated_object_id(::google::protobuf::Int64Value* value);
  ::google::protobuf::Int64Value* unsafe_arena_release_object_id();

  private:
  const ::google::protobuf::Int64Value& _internal_object_id() const;
  ::google::protobuf::Int64Value* _internal_mutable_object_id();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any > extension_;
    ::google::protobuf::Int64Value* tile_id_;
    ::google::protobuf::Int64Value* object_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto;
};// -------------------------------------------------------------------

class MapLocationReference_TileIdLinkIdOffset final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset) */ {
 public:
  inline MapLocationReference_TileIdLinkIdOffset() : MapLocationReference_TileIdLinkIdOffset(nullptr) {}
  ~MapLocationReference_TileIdLinkIdOffset() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MapLocationReference_TileIdLinkIdOffset(::google::protobuf::internal::ConstantInitialized);

  inline MapLocationReference_TileIdLinkIdOffset(const MapLocationReference_TileIdLinkIdOffset& from)
      : MapLocationReference_TileIdLinkIdOffset(nullptr, from) {}
  MapLocationReference_TileIdLinkIdOffset(MapLocationReference_TileIdLinkIdOffset&& from) noexcept
    : MapLocationReference_TileIdLinkIdOffset() {
    *this = ::std::move(from);
  }

  inline MapLocationReference_TileIdLinkIdOffset& operator=(const MapLocationReference_TileIdLinkIdOffset& from) {
    CopyFrom(from);
    return *this;
  }
  inline MapLocationReference_TileIdLinkIdOffset& operator=(MapLocationReference_TileIdLinkIdOffset&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MapLocationReference_TileIdLinkIdOffset& default_instance() {
    return *internal_default_instance();
  }
  static inline const MapLocationReference_TileIdLinkIdOffset* internal_default_instance() {
    return reinterpret_cast<const MapLocationReference_TileIdLinkIdOffset*>(
               &_MapLocationReference_TileIdLinkIdOffset_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(MapLocationReference_TileIdLinkIdOffset& a, MapLocationReference_TileIdLinkIdOffset& b) {
    a.Swap(&b);
  }
  inline void Swap(MapLocationReference_TileIdLinkIdOffset* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MapLocationReference_TileIdLinkIdOffset* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MapLocationReference_TileIdLinkIdOffset* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MapLocationReference_TileIdLinkIdOffset>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MapLocationReference_TileIdLinkIdOffset& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MapLocationReference_TileIdLinkIdOffset& from) {
    MapLocationReference_TileIdLinkIdOffset::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MapLocationReference_TileIdLinkIdOffset* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset";
  }
  protected:
  explicit MapLocationReference_TileIdLinkIdOffset(::google::protobuf::Arena* arena);
  MapLocationReference_TileIdLinkIdOffset(::google::protobuf::Arena* arena, const MapLocationReference_TileIdLinkIdOffset& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExtensionFieldNumber = 15,
    kTileIdFieldNumber = 1,
    kLinkIdFieldNumber = 2,
    kOffsetFieldNumber = 3,
  };
  // repeated .google.protobuf.Any extension = 15;
  int extension_size() const;
  private:
  int _internal_extension_size() const;

  public:
  void clear_extension() ;
  ::google::protobuf::Any* mutable_extension(int index);
  ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >*
      mutable_extension();
  private:
  const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& _internal_extension() const;
  ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* _internal_mutable_extension();
  public:
  const ::google::protobuf::Any& extension(int index) const;
  ::google::protobuf::Any* add_extension();
  const ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >&
      extension() const;
  // .google.protobuf.Int64Value tile_id = 1;
  bool has_tile_id() const;
  void clear_tile_id() ;
  const ::google::protobuf::Int64Value& tile_id() const;
  PROTOBUF_NODISCARD ::google::protobuf::Int64Value* release_tile_id();
  ::google::protobuf::Int64Value* mutable_tile_id();
  void set_allocated_tile_id(::google::protobuf::Int64Value* value);
  void unsafe_arena_set_allocated_tile_id(::google::protobuf::Int64Value* value);
  ::google::protobuf::Int64Value* unsafe_arena_release_tile_id();

  private:
  const ::google::protobuf::Int64Value& _internal_tile_id() const;
  ::google::protobuf::Int64Value* _internal_mutable_tile_id();

  public:
  // .google.protobuf.Int64Value link_id = 2;
  bool has_link_id() const;
  void clear_link_id() ;
  const ::google::protobuf::Int64Value& link_id() const;
  PROTOBUF_NODISCARD ::google::protobuf::Int64Value* release_link_id();
  ::google::protobuf::Int64Value* mutable_link_id();
  void set_allocated_link_id(::google::protobuf::Int64Value* value);
  void unsafe_arena_set_allocated_link_id(::google::protobuf::Int64Value* value);
  ::google::protobuf::Int64Value* unsafe_arena_release_link_id();

  private:
  const ::google::protobuf::Int64Value& _internal_link_id() const;
  ::google::protobuf::Int64Value* _internal_mutable_link_id();

  public:
  // .google.protobuf.Int64Value offset = 3 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_offset() const;
  void clear_offset() ;
  const ::google::protobuf::Int64Value& offset() const;
  PROTOBUF_NODISCARD ::google::protobuf::Int64Value* release_offset();
  ::google::protobuf::Int64Value* mutable_offset();
  void set_allocated_offset(::google::protobuf::Int64Value* value);
  void unsafe_arena_set_allocated_offset(::google::protobuf::Int64Value* value);
  ::google::protobuf::Int64Value* unsafe_arena_release_offset();

  private:
  const ::google::protobuf::Int64Value& _internal_offset() const;
  ::google::protobuf::Int64Value* _internal_mutable_offset();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 4, 4,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any > extension_;
    ::google::protobuf::Int64Value* tile_id_;
    ::google::protobuf::Int64Value* link_id_;
    ::google::protobuf::Int64Value* offset_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto;
};// -------------------------------------------------------------------

class XyzVectorAndAccuracy_Metric final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric) */ {
 public:
  inline XyzVectorAndAccuracy_Metric() : XyzVectorAndAccuracy_Metric(nullptr) {}
  ~XyzVectorAndAccuracy_Metric() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR XyzVectorAndAccuracy_Metric(::google::protobuf::internal::ConstantInitialized);

  inline XyzVectorAndAccuracy_Metric(const XyzVectorAndAccuracy_Metric& from)
      : XyzVectorAndAccuracy_Metric(nullptr, from) {}
  XyzVectorAndAccuracy_Metric(XyzVectorAndAccuracy_Metric&& from) noexcept
    : XyzVectorAndAccuracy_Metric() {
    *this = ::std::move(from);
  }

  inline XyzVectorAndAccuracy_Metric& operator=(const XyzVectorAndAccuracy_Metric& from) {
    CopyFrom(from);
    return *this;
  }
  inline XyzVectorAndAccuracy_Metric& operator=(XyzVectorAndAccuracy_Metric&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const XyzVectorAndAccuracy_Metric& default_instance() {
    return *internal_default_instance();
  }
  static inline const XyzVectorAndAccuracy_Metric* internal_default_instance() {
    return reinterpret_cast<const XyzVectorAndAccuracy_Metric*>(
               &_XyzVectorAndAccuracy_Metric_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(XyzVectorAndAccuracy_Metric& a, XyzVectorAndAccuracy_Metric& b) {
    a.Swap(&b);
  }
  inline void Swap(XyzVectorAndAccuracy_Metric* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(XyzVectorAndAccuracy_Metric* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  XyzVectorAndAccuracy_Metric* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<XyzVectorAndAccuracy_Metric>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const XyzVectorAndAccuracy_Metric& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const XyzVectorAndAccuracy_Metric& from) {
    XyzVectorAndAccuracy_Metric::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(XyzVectorAndAccuracy_Metric* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric";
  }
  protected:
  explicit XyzVectorAndAccuracy_Metric(::google::protobuf::Arena* arena);
  XyzVectorAndAccuracy_Metric(::google::protobuf::Arena* arena, const XyzVectorAndAccuracy_Metric& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // .sensoris.protobuf.types.base.Int64Value x = 1;
  bool has_x() const;
  void clear_x() ;
  const ::sensoris::protobuf::types::base::Int64Value& x() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::Int64Value* release_x();
  ::sensoris::protobuf::types::base::Int64Value* mutable_x();
  void set_allocated_x(::sensoris::protobuf::types::base::Int64Value* value);
  void unsafe_arena_set_allocated_x(::sensoris::protobuf::types::base::Int64Value* value);
  ::sensoris::protobuf::types::base::Int64Value* unsafe_arena_release_x();

  private:
  const ::sensoris::protobuf::types::base::Int64Value& _internal_x() const;
  ::sensoris::protobuf::types::base::Int64Value* _internal_mutable_x();

  public:
  // .sensoris.protobuf.types.base.Int64Value y = 2;
  bool has_y() const;
  void clear_y() ;
  const ::sensoris::protobuf::types::base::Int64Value& y() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::Int64Value* release_y();
  ::sensoris::protobuf::types::base::Int64Value* mutable_y();
  void set_allocated_y(::sensoris::protobuf::types::base::Int64Value* value);
  void unsafe_arena_set_allocated_y(::sensoris::protobuf::types::base::Int64Value* value);
  ::sensoris::protobuf::types::base::Int64Value* unsafe_arena_release_y();

  private:
  const ::sensoris::protobuf::types::base::Int64Value& _internal_y() const;
  ::sensoris::protobuf::types::base::Int64Value* _internal_mutable_y();

  public:
  // .sensoris.protobuf.types.base.Int64Value z = 3;
  bool has_z() const;
  void clear_z() ;
  const ::sensoris::protobuf::types::base::Int64Value& z() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::Int64Value* release_z();
  ::sensoris::protobuf::types::base::Int64Value* mutable_z();
  void set_allocated_z(::sensoris::protobuf::types::base::Int64Value* value);
  void unsafe_arena_set_allocated_z(::sensoris::protobuf::types::base::Int64Value* value);
  ::sensoris::protobuf::types::base::Int64Value* unsafe_arena_release_z();

  private:
  const ::sensoris::protobuf::types::base::Int64Value& _internal_z() const;
  ::sensoris::protobuf::types::base::Int64Value* _internal_mutable_z();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::Int64Value* x_;
    ::sensoris::protobuf::types::base::Int64Value* y_;
    ::sensoris::protobuf::types::base::Int64Value* z_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto;
};// -------------------------------------------------------------------

class RotationRateAndAccuracy final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.spatial.RotationRateAndAccuracy) */ {
 public:
  inline RotationRateAndAccuracy() : RotationRateAndAccuracy(nullptr) {}
  ~RotationRateAndAccuracy() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RotationRateAndAccuracy(::google::protobuf::internal::ConstantInitialized);

  inline RotationRateAndAccuracy(const RotationRateAndAccuracy& from)
      : RotationRateAndAccuracy(nullptr, from) {}
  RotationRateAndAccuracy(RotationRateAndAccuracy&& from) noexcept
    : RotationRateAndAccuracy() {
    *this = ::std::move(from);
  }

  inline RotationRateAndAccuracy& operator=(const RotationRateAndAccuracy& from) {
    CopyFrom(from);
    return *this;
  }
  inline RotationRateAndAccuracy& operator=(RotationRateAndAccuracy&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RotationRateAndAccuracy& default_instance() {
    return *internal_default_instance();
  }
  enum AccuracyCase {
    kCombinedStdDev = 4,
    kStdDev = 5,
    kCovariance = 6,
    ACCURACY_NOT_SET = 0,
  };

  static inline const RotationRateAndAccuracy* internal_default_instance() {
    return reinterpret_cast<const RotationRateAndAccuracy*>(
               &_RotationRateAndAccuracy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(RotationRateAndAccuracy& a, RotationRateAndAccuracy& b) {
    a.Swap(&b);
  }
  inline void Swap(RotationRateAndAccuracy* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RotationRateAndAccuracy* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RotationRateAndAccuracy* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RotationRateAndAccuracy>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RotationRateAndAccuracy& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RotationRateAndAccuracy& from) {
    RotationRateAndAccuracy::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RotationRateAndAccuracy* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.types.spatial.RotationRateAndAccuracy";
  }
  protected:
  explicit RotationRateAndAccuracy(::google::protobuf::Arena* arena);
  RotationRateAndAccuracy(::google::protobuf::Arena* arena, const RotationRateAndAccuracy& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using StdDev = RotationRateAndAccuracy_StdDev;

  // accessors -------------------------------------------------------

  enum : int {
    kExtensionFieldNumber = 15,
    kYawFieldNumber = 1,
    kPitchFieldNumber = 2,
    kRollFieldNumber = 3,
    kCombinedStdDevFieldNumber = 4,
    kStdDevFieldNumber = 5,
    kCovarianceFieldNumber = 6,
  };
  // repeated .google.protobuf.Any extension = 15;
  int extension_size() const;
  private:
  int _internal_extension_size() const;

  public:
  void clear_extension() ;
  ::google::protobuf::Any* mutable_extension(int index);
  ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >*
      mutable_extension();
  private:
  const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& _internal_extension() const;
  ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* _internal_mutable_extension();
  public:
  const ::google::protobuf::Any& extension(int index) const;
  ::google::protobuf::Any* add_extension();
  const ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >&
      extension() const;
  // .sensoris.protobuf.types.base.Int64Value yaw = 1 [(.sensoris.protobuf.types.base.exponent) = 2];
  bool has_yaw() const;
  void clear_yaw() ;
  const ::sensoris::protobuf::types::base::Int64Value& yaw() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::Int64Value* release_yaw();
  ::sensoris::protobuf::types::base::Int64Value* mutable_yaw();
  void set_allocated_yaw(::sensoris::protobuf::types::base::Int64Value* value);
  void unsafe_arena_set_allocated_yaw(::sensoris::protobuf::types::base::Int64Value* value);
  ::sensoris::protobuf::types::base::Int64Value* unsafe_arena_release_yaw();

  private:
  const ::sensoris::protobuf::types::base::Int64Value& _internal_yaw() const;
  ::sensoris::protobuf::types::base::Int64Value* _internal_mutable_yaw();

  public:
  // .sensoris.protobuf.types.base.Int64Value pitch = 2 [(.sensoris.protobuf.types.base.exponent) = 2];
  bool has_pitch() const;
  void clear_pitch() ;
  const ::sensoris::protobuf::types::base::Int64Value& pitch() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::Int64Value* release_pitch();
  ::sensoris::protobuf::types::base::Int64Value* mutable_pitch();
  void set_allocated_pitch(::sensoris::protobuf::types::base::Int64Value* value);
  void unsafe_arena_set_allocated_pitch(::sensoris::protobuf::types::base::Int64Value* value);
  ::sensoris::protobuf::types::base::Int64Value* unsafe_arena_release_pitch();

  private:
  const ::sensoris::protobuf::types::base::Int64Value& _internal_pitch() const;
  ::sensoris::protobuf::types::base::Int64Value* _internal_mutable_pitch();

  public:
  // .sensoris.protobuf.types.base.Int64Value roll = 3 [(.sensoris.protobuf.types.base.exponent) = 2];
  bool has_roll() const;
  void clear_roll() ;
  const ::sensoris::protobuf::types::base::Int64Value& roll() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::Int64Value* release_roll();
  ::sensoris::protobuf::types::base::Int64Value* mutable_roll();
  void set_allocated_roll(::sensoris::protobuf::types::base::Int64Value* value);
  void unsafe_arena_set_allocated_roll(::sensoris::protobuf::types::base::Int64Value* value);
  ::sensoris::protobuf::types::base::Int64Value* unsafe_arena_release_roll();

  private:
  const ::sensoris::protobuf::types::base::Int64Value& _internal_roll() const;
  ::sensoris::protobuf::types::base::Int64Value* _internal_mutable_roll();

  public:
  // .google.protobuf.Int64Value combined_std_dev = 4 [(.sensoris.protobuf.types.base.exponent) = 2];
  bool has_combined_std_dev() const;
  private:
  bool _internal_has_combined_std_dev() const;

  public:
  void clear_combined_std_dev() ;
  const ::google::protobuf::Int64Value& combined_std_dev() const;
  PROTOBUF_NODISCARD ::google::protobuf::Int64Value* release_combined_std_dev();
  ::google::protobuf::Int64Value* mutable_combined_std_dev();
  void set_allocated_combined_std_dev(::google::protobuf::Int64Value* value);
  void unsafe_arena_set_allocated_combined_std_dev(::google::protobuf::Int64Value* value);
  ::google::protobuf::Int64Value* unsafe_arena_release_combined_std_dev();

  private:
  const ::google::protobuf::Int64Value& _internal_combined_std_dev() const;
  ::google::protobuf::Int64Value* _internal_mutable_combined_std_dev();

  public:
  // .sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev std_dev = 5;
  bool has_std_dev() const;
  private:
  bool _internal_has_std_dev() const;

  public:
  void clear_std_dev() ;
  const ::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev& std_dev() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev* release_std_dev();
  ::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev* mutable_std_dev();
  void set_allocated_std_dev(::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev* value);
  void unsafe_arena_set_allocated_std_dev(::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev* value);
  ::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev* unsafe_arena_release_std_dev();

  private:
  const ::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev& _internal_std_dev() const;
  ::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev* _internal_mutable_std_dev();

  public:
  // .sensoris.protobuf.types.base.Int64Matrix3x3 covariance = 6 [(.sensoris.protobuf.types.base.exponent) = 2];
  bool has_covariance() const;
  private:
  bool _internal_has_covariance() const;

  public:
  void clear_covariance() ;
  const ::sensoris::protobuf::types::base::Int64Matrix3x3& covariance() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::Int64Matrix3x3* release_covariance();
  ::sensoris::protobuf::types::base::Int64Matrix3x3* mutable_covariance();
  void set_allocated_covariance(::sensoris::protobuf::types::base::Int64Matrix3x3* value);
  void unsafe_arena_set_allocated_covariance(::sensoris::protobuf::types::base::Int64Matrix3x3* value);
  ::sensoris::protobuf::types::base::Int64Matrix3x3* unsafe_arena_release_covariance();

  private:
  const ::sensoris::protobuf::types::base::Int64Matrix3x3& _internal_covariance() const;
  ::sensoris::protobuf::types::base::Int64Matrix3x3* _internal_mutable_covariance();

  public:
  void clear_accuracy();
  AccuracyCase accuracy_case() const;
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.spatial.RotationRateAndAccuracy)
 private:
  class _Internal;
  void set_has_combined_std_dev();
  void set_has_std_dev();
  void set_has_covariance();

  inline bool has_accuracy() const;
  inline void clear_has_accuracy();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 7,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any > extension_;
    ::sensoris::protobuf::types::base::Int64Value* yaw_;
    ::sensoris::protobuf::types::base::Int64Value* pitch_;
    ::sensoris::protobuf::types::base::Int64Value* roll_;
    union AccuracyUnion {
      constexpr AccuracyUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::Int64Value* combined_std_dev_;
      ::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev* std_dev_;
      ::sensoris::protobuf::types::base::Int64Matrix3x3* covariance_;
    } accuracy_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto;
};// -------------------------------------------------------------------

class RotationAndAccuracy_Quaternion final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion) */ {
 public:
  inline RotationAndAccuracy_Quaternion() : RotationAndAccuracy_Quaternion(nullptr) {}
  ~RotationAndAccuracy_Quaternion() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RotationAndAccuracy_Quaternion(::google::protobuf::internal::ConstantInitialized);

  inline RotationAndAccuracy_Quaternion(const RotationAndAccuracy_Quaternion& from)
      : RotationAndAccuracy_Quaternion(nullptr, from) {}
  RotationAndAccuracy_Quaternion(RotationAndAccuracy_Quaternion&& from) noexcept
    : RotationAndAccuracy_Quaternion() {
    *this = ::std::move(from);
  }

  inline RotationAndAccuracy_Quaternion& operator=(const RotationAndAccuracy_Quaternion& from) {
    CopyFrom(from);
    return *this;
  }
  inline RotationAndAccuracy_Quaternion& operator=(RotationAndAccuracy_Quaternion&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RotationAndAccuracy_Quaternion& default_instance() {
    return *internal_default_instance();
  }
  static inline const RotationAndAccuracy_Quaternion* internal_default_instance() {
    return reinterpret_cast<const RotationAndAccuracy_Quaternion*>(
               &_RotationAndAccuracy_Quaternion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(RotationAndAccuracy_Quaternion& a, RotationAndAccuracy_Quaternion& b) {
    a.Swap(&b);
  }
  inline void Swap(RotationAndAccuracy_Quaternion* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RotationAndAccuracy_Quaternion* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RotationAndAccuracy_Quaternion* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RotationAndAccuracy_Quaternion>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RotationAndAccuracy_Quaternion& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RotationAndAccuracy_Quaternion& from) {
    RotationAndAccuracy_Quaternion::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RotationAndAccuracy_Quaternion* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion";
  }
  protected:
  explicit RotationAndAccuracy_Quaternion(::google::protobuf::Arena* arena);
  RotationAndAccuracy_Quaternion(::google::protobuf::Arena* arena, const RotationAndAccuracy_Quaternion& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
    kWFieldNumber = 4,
  };
  // .sensoris.protobuf.types.base.Int64Value x = 1 [(.sensoris.protobuf.types.base.exponent) = 3];
  bool has_x() const;
  void clear_x() ;
  const ::sensoris::protobuf::types::base::Int64Value& x() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::Int64Value* release_x();
  ::sensoris::protobuf::types::base::Int64Value* mutable_x();
  void set_allocated_x(::sensoris::protobuf::types::base::Int64Value* value);
  void unsafe_arena_set_allocated_x(::sensoris::protobuf::types::base::Int64Value* value);
  ::sensoris::protobuf::types::base::Int64Value* unsafe_arena_release_x();

  private:
  const ::sensoris::protobuf::types::base::Int64Value& _internal_x() const;
  ::sensoris::protobuf::types::base::Int64Value* _internal_mutable_x();

  public:
  // .sensoris.protobuf.types.base.Int64Value y = 2 [(.sensoris.protobuf.types.base.exponent) = 3];
  bool has_y() const;
  void clear_y() ;
  const ::sensoris::protobuf::types::base::Int64Value& y() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::Int64Value* release_y();
  ::sensoris::protobuf::types::base::Int64Value* mutable_y();
  void set_allocated_y(::sensoris::protobuf::types::base::Int64Value* value);
  void unsafe_arena_set_allocated_y(::sensoris::protobuf::types::base::Int64Value* value);
  ::sensoris::protobuf::types::base::Int64Value* unsafe_arena_release_y();

  private:
  const ::sensoris::protobuf::types::base::Int64Value& _internal_y() const;
  ::sensoris::protobuf::types::base::Int64Value* _internal_mutable_y();

  public:
  // .sensoris.protobuf.types.base.Int64Value z = 3 [(.sensoris.protobuf.types.base.exponent) = 3];
  bool has_z() const;
  void clear_z() ;
  const ::sensoris::protobuf::types::base::Int64Value& z() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::Int64Value* release_z();
  ::sensoris::protobuf::types::base::Int64Value* mutable_z();
  void set_allocated_z(::sensoris::protobuf::types::base::Int64Value* value);
  void unsafe_arena_set_allocated_z(::sensoris::protobuf::types::base::Int64Value* value);
  ::sensoris::protobuf::types::base::Int64Value* unsafe_arena_release_z();

  private:
  const ::sensoris::protobuf::types::base::Int64Value& _internal_z() const;
  ::sensoris::protobuf::types::base::Int64Value* _internal_mutable_z();

  public:
  // .sensoris.protobuf.types.base.Int64Value w = 4 [(.sensoris.protobuf.types.base.exponent) = 3];
  bool has_w() const;
  void clear_w() ;
  const ::sensoris::protobuf::types::base::Int64Value& w() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::Int64Value* release_w();
  ::sensoris::protobuf::types::base::Int64Value* mutable_w();
  void set_allocated_w(::sensoris::protobuf::types::base::Int64Value* value);
  void unsafe_arena_set_allocated_w(::sensoris::protobuf::types::base::Int64Value* value);
  ::sensoris::protobuf::types::base::Int64Value* unsafe_arena_release_w();

  private:
  const ::sensoris::protobuf::types::base::Int64Value& _internal_w() const;
  ::sensoris::protobuf::types::base::Int64Value* _internal_mutable_w();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 4,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::Int64Value* x_;
    ::sensoris::protobuf::types::base::Int64Value* y_;
    ::sensoris::protobuf::types::base::Int64Value* z_;
    ::sensoris::protobuf::types::base::Int64Value* w_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto;
};// -------------------------------------------------------------------

class RotationAndAccuracy_Euler final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler) */ {
 public:
  inline RotationAndAccuracy_Euler() : RotationAndAccuracy_Euler(nullptr) {}
  ~RotationAndAccuracy_Euler() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RotationAndAccuracy_Euler(::google::protobuf::internal::ConstantInitialized);

  inline RotationAndAccuracy_Euler(const RotationAndAccuracy_Euler& from)
      : RotationAndAccuracy_Euler(nullptr, from) {}
  RotationAndAccuracy_Euler(RotationAndAccuracy_Euler&& from) noexcept
    : RotationAndAccuracy_Euler() {
    *this = ::std::move(from);
  }

  inline RotationAndAccuracy_Euler& operator=(const RotationAndAccuracy_Euler& from) {
    CopyFrom(from);
    return *this;
  }
  inline RotationAndAccuracy_Euler& operator=(RotationAndAccuracy_Euler&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RotationAndAccuracy_Euler& default_instance() {
    return *internal_default_instance();
  }
  static inline const RotationAndAccuracy_Euler* internal_default_instance() {
    return reinterpret_cast<const RotationAndAccuracy_Euler*>(
               &_RotationAndAccuracy_Euler_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(RotationAndAccuracy_Euler& a, RotationAndAccuracy_Euler& b) {
    a.Swap(&b);
  }
  inline void Swap(RotationAndAccuracy_Euler* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RotationAndAccuracy_Euler* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RotationAndAccuracy_Euler* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RotationAndAccuracy_Euler>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RotationAndAccuracy_Euler& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RotationAndAccuracy_Euler& from) {
    RotationAndAccuracy_Euler::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RotationAndAccuracy_Euler* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler";
  }
  protected:
  explicit RotationAndAccuracy_Euler(::google::protobuf::Arena* arena);
  RotationAndAccuracy_Euler(::google::protobuf::Arena* arena, const RotationAndAccuracy_Euler& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kYawFieldNumber = 1,
    kPitchFieldNumber = 2,
    kRollFieldNumber = 3,
  };
  // .sensoris.protobuf.types.base.Int64Value yaw = 1 [(.sensoris.protobuf.types.base.exponent) = 2];
  bool has_yaw() const;
  void clear_yaw() ;
  const ::sensoris::protobuf::types::base::Int64Value& yaw() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::Int64Value* release_yaw();
  ::sensoris::protobuf::types::base::Int64Value* mutable_yaw();
  void set_allocated_yaw(::sensoris::protobuf::types::base::Int64Value* value);
  void unsafe_arena_set_allocated_yaw(::sensoris::protobuf::types::base::Int64Value* value);
  ::sensoris::protobuf::types::base::Int64Value* unsafe_arena_release_yaw();

  private:
  const ::sensoris::protobuf::types::base::Int64Value& _internal_yaw() const;
  ::sensoris::protobuf::types::base::Int64Value* _internal_mutable_yaw();

  public:
  // .sensoris.protobuf.types.base.Int64Value pitch = 2 [(.sensoris.protobuf.types.base.exponent) = 2];
  bool has_pitch() const;
  void clear_pitch() ;
  const ::sensoris::protobuf::types::base::Int64Value& pitch() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::Int64Value* release_pitch();
  ::sensoris::protobuf::types::base::Int64Value* mutable_pitch();
  void set_allocated_pitch(::sensoris::protobuf::types::base::Int64Value* value);
  void unsafe_arena_set_allocated_pitch(::sensoris::protobuf::types::base::Int64Value* value);
  ::sensoris::protobuf::types::base::Int64Value* unsafe_arena_release_pitch();

  private:
  const ::sensoris::protobuf::types::base::Int64Value& _internal_pitch() const;
  ::sensoris::protobuf::types::base::Int64Value* _internal_mutable_pitch();

  public:
  // .sensoris.protobuf.types.base.Int64Value roll = 3 [(.sensoris.protobuf.types.base.exponent) = 2];
  bool has_roll() const;
  void clear_roll() ;
  const ::sensoris::protobuf::types::base::Int64Value& roll() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::Int64Value* release_roll();
  ::sensoris::protobuf::types::base::Int64Value* mutable_roll();
  void set_allocated_roll(::sensoris::protobuf::types::base::Int64Value* value);
  void unsafe_arena_set_allocated_roll(::sensoris::protobuf::types::base::Int64Value* value);
  ::sensoris::protobuf::types::base::Int64Value* unsafe_arena_release_roll();

  private:
  const ::sensoris::protobuf::types::base::Int64Value& _internal_roll() const;
  ::sensoris::protobuf::types::base::Int64Value* _internal_mutable_roll();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::Int64Value* yaw_;
    ::sensoris::protobuf::types::base::Int64Value* pitch_;
    ::sensoris::protobuf::types::base::Int64Value* roll_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto;
};// -------------------------------------------------------------------

class PositionAndAccuracy_Metric final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric) */ {
 public:
  inline PositionAndAccuracy_Metric() : PositionAndAccuracy_Metric(nullptr) {}
  ~PositionAndAccuracy_Metric() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PositionAndAccuracy_Metric(::google::protobuf::internal::ConstantInitialized);

  inline PositionAndAccuracy_Metric(const PositionAndAccuracy_Metric& from)
      : PositionAndAccuracy_Metric(nullptr, from) {}
  PositionAndAccuracy_Metric(PositionAndAccuracy_Metric&& from) noexcept
    : PositionAndAccuracy_Metric() {
    *this = ::std::move(from);
  }

  inline PositionAndAccuracy_Metric& operator=(const PositionAndAccuracy_Metric& from) {
    CopyFrom(from);
    return *this;
  }
  inline PositionAndAccuracy_Metric& operator=(PositionAndAccuracy_Metric&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PositionAndAccuracy_Metric& default_instance() {
    return *internal_default_instance();
  }
  static inline const PositionAndAccuracy_Metric* internal_default_instance() {
    return reinterpret_cast<const PositionAndAccuracy_Metric*>(
               &_PositionAndAccuracy_Metric_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(PositionAndAccuracy_Metric& a, PositionAndAccuracy_Metric& b) {
    a.Swap(&b);
  }
  inline void Swap(PositionAndAccuracy_Metric* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PositionAndAccuracy_Metric* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PositionAndAccuracy_Metric* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PositionAndAccuracy_Metric>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PositionAndAccuracy_Metric& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PositionAndAccuracy_Metric& from) {
    PositionAndAccuracy_Metric::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PositionAndAccuracy_Metric* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric";
  }
  protected:
  explicit PositionAndAccuracy_Metric(::google::protobuf::Arena* arena);
  PositionAndAccuracy_Metric(::google::protobuf::Arena* arena, const PositionAndAccuracy_Metric& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // .sensoris.protobuf.types.base.Int64Value x = 1 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_x() const;
  void clear_x() ;
  const ::sensoris::protobuf::types::base::Int64Value& x() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::Int64Value* release_x();
  ::sensoris::protobuf::types::base::Int64Value* mutable_x();
  void set_allocated_x(::sensoris::protobuf::types::base::Int64Value* value);
  void unsafe_arena_set_allocated_x(::sensoris::protobuf::types::base::Int64Value* value);
  ::sensoris::protobuf::types::base::Int64Value* unsafe_arena_release_x();

  private:
  const ::sensoris::protobuf::types::base::Int64Value& _internal_x() const;
  ::sensoris::protobuf::types::base::Int64Value* _internal_mutable_x();

  public:
  // .sensoris.protobuf.types.base.Int64Value y = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_y() const;
  void clear_y() ;
  const ::sensoris::protobuf::types::base::Int64Value& y() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::Int64Value* release_y();
  ::sensoris::protobuf::types::base::Int64Value* mutable_y();
  void set_allocated_y(::sensoris::protobuf::types::base::Int64Value* value);
  void unsafe_arena_set_allocated_y(::sensoris::protobuf::types::base::Int64Value* value);
  ::sensoris::protobuf::types::base::Int64Value* unsafe_arena_release_y();

  private:
  const ::sensoris::protobuf::types::base::Int64Value& _internal_y() const;
  ::sensoris::protobuf::types::base::Int64Value* _internal_mutable_y();

  public:
  // .sensoris.protobuf.types.base.Int64Value z = 3 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_z() const;
  void clear_z() ;
  const ::sensoris::protobuf::types::base::Int64Value& z() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::Int64Value* release_z();
  ::sensoris::protobuf::types::base::Int64Value* mutable_z();
  void set_allocated_z(::sensoris::protobuf::types::base::Int64Value* value);
  void unsafe_arena_set_allocated_z(::sensoris::protobuf::types::base::Int64Value* value);
  ::sensoris::protobuf::types::base::Int64Value* unsafe_arena_release_z();

  private:
  const ::sensoris::protobuf::types::base::Int64Value& _internal_z() const;
  ::sensoris::protobuf::types::base::Int64Value* _internal_mutable_z();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::Int64Value* x_;
    ::sensoris::protobuf::types::base::Int64Value* y_;
    ::sensoris::protobuf::types::base::Int64Value* z_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto;
};// -------------------------------------------------------------------

class PositionAndAccuracy_Geographic final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic) */ {
 public:
  inline PositionAndAccuracy_Geographic() : PositionAndAccuracy_Geographic(nullptr) {}
  ~PositionAndAccuracy_Geographic() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PositionAndAccuracy_Geographic(::google::protobuf::internal::ConstantInitialized);

  inline PositionAndAccuracy_Geographic(const PositionAndAccuracy_Geographic& from)
      : PositionAndAccuracy_Geographic(nullptr, from) {}
  PositionAndAccuracy_Geographic(PositionAndAccuracy_Geographic&& from) noexcept
    : PositionAndAccuracy_Geographic() {
    *this = ::std::move(from);
  }

  inline PositionAndAccuracy_Geographic& operator=(const PositionAndAccuracy_Geographic& from) {
    CopyFrom(from);
    return *this;
  }
  inline PositionAndAccuracy_Geographic& operator=(PositionAndAccuracy_Geographic&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PositionAndAccuracy_Geographic& default_instance() {
    return *internal_default_instance();
  }
  static inline const PositionAndAccuracy_Geographic* internal_default_instance() {
    return reinterpret_cast<const PositionAndAccuracy_Geographic*>(
               &_PositionAndAccuracy_Geographic_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(PositionAndAccuracy_Geographic& a, PositionAndAccuracy_Geographic& b) {
    a.Swap(&b);
  }
  inline void Swap(PositionAndAccuracy_Geographic* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PositionAndAccuracy_Geographic* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PositionAndAccuracy_Geographic* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PositionAndAccuracy_Geographic>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PositionAndAccuracy_Geographic& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PositionAndAccuracy_Geographic& from) {
    PositionAndAccuracy_Geographic::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PositionAndAccuracy_Geographic* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic";
  }
  protected:
  explicit PositionAndAccuracy_Geographic(::google::protobuf::Arena* arena);
  PositionAndAccuracy_Geographic(::google::protobuf::Arena* arena, const PositionAndAccuracy_Geographic& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLongitudeFieldNumber = 1,
    kLatitudeFieldNumber = 2,
    kAltitudeFieldNumber = 3,
  };
  // .sensoris.protobuf.types.base.Int64Value longitude = 1 [(.sensoris.protobuf.types.base.exponent) = 8];
  bool has_longitude() const;
  void clear_longitude() ;
  const ::sensoris::protobuf::types::base::Int64Value& longitude() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::Int64Value* release_longitude();
  ::sensoris::protobuf::types::base::Int64Value* mutable_longitude();
  void set_allocated_longitude(::sensoris::protobuf::types::base::Int64Value* value);
  void unsafe_arena_set_allocated_longitude(::sensoris::protobuf::types::base::Int64Value* value);
  ::sensoris::protobuf::types::base::Int64Value* unsafe_arena_release_longitude();

  private:
  const ::sensoris::protobuf::types::base::Int64Value& _internal_longitude() const;
  ::sensoris::protobuf::types::base::Int64Value* _internal_mutable_longitude();

  public:
  // .sensoris.protobuf.types.base.Int64Value latitude = 2 [(.sensoris.protobuf.types.base.exponent) = 8];
  bool has_latitude() const;
  void clear_latitude() ;
  const ::sensoris::protobuf::types::base::Int64Value& latitude() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::Int64Value* release_latitude();
  ::sensoris::protobuf::types::base::Int64Value* mutable_latitude();
  void set_allocated_latitude(::sensoris::protobuf::types::base::Int64Value* value);
  void unsafe_arena_set_allocated_latitude(::sensoris::protobuf::types::base::Int64Value* value);
  ::sensoris::protobuf::types::base::Int64Value* unsafe_arena_release_latitude();

  private:
  const ::sensoris::protobuf::types::base::Int64Value& _internal_latitude() const;
  ::sensoris::protobuf::types::base::Int64Value* _internal_mutable_latitude();

  public:
  // .sensoris.protobuf.types.base.Int64Value altitude = 3 [(.sensoris.protobuf.types.base.exponent) = 3];
  bool has_altitude() const;
  void clear_altitude() ;
  const ::sensoris::protobuf::types::base::Int64Value& altitude() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::Int64Value* release_altitude();
  ::sensoris::protobuf::types::base::Int64Value* mutable_altitude();
  void set_allocated_altitude(::sensoris::protobuf::types::base::Int64Value* value);
  void unsafe_arena_set_allocated_altitude(::sensoris::protobuf::types::base::Int64Value* value);
  ::sensoris::protobuf::types::base::Int64Value* unsafe_arena_release_altitude();

  private:
  const ::sensoris::protobuf::types::base::Int64Value& _internal_altitude() const;
  ::sensoris::protobuf::types::base::Int64Value* _internal_mutable_altitude();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::base::Int64Value* longitude_;
    ::sensoris::protobuf::types::base::Int64Value* latitude_;
    ::sensoris::protobuf::types::base::Int64Value* altitude_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto;
};// -------------------------------------------------------------------

class XyzVectorAndAccuracy final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy) */ {
 public:
  inline XyzVectorAndAccuracy() : XyzVectorAndAccuracy(nullptr) {}
  ~XyzVectorAndAccuracy() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR XyzVectorAndAccuracy(::google::protobuf::internal::ConstantInitialized);

  inline XyzVectorAndAccuracy(const XyzVectorAndAccuracy& from)
      : XyzVectorAndAccuracy(nullptr, from) {}
  XyzVectorAndAccuracy(XyzVectorAndAccuracy&& from) noexcept
    : XyzVectorAndAccuracy() {
    *this = ::std::move(from);
  }

  inline XyzVectorAndAccuracy& operator=(const XyzVectorAndAccuracy& from) {
    CopyFrom(from);
    return *this;
  }
  inline XyzVectorAndAccuracy& operator=(XyzVectorAndAccuracy&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const XyzVectorAndAccuracy& default_instance() {
    return *internal_default_instance();
  }
  enum GeometryCase {
    kMetricVehicle = 1,
    kMetricEventGroup = 2,
    kMetricOrigin = 3,
    GEOMETRY_NOT_SET = 0,
  };

  enum AccuracyCase {
    kCombinedStdDev = 4,
    kStdDev = 5,
    kCovariance = 6,
    ACCURACY_NOT_SET = 0,
  };

  static inline const XyzVectorAndAccuracy* internal_default_instance() {
    return reinterpret_cast<const XyzVectorAndAccuracy*>(
               &_XyzVectorAndAccuracy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(XyzVectorAndAccuracy& a, XyzVectorAndAccuracy& b) {
    a.Swap(&b);
  }
  inline void Swap(XyzVectorAndAccuracy* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(XyzVectorAndAccuracy* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  XyzVectorAndAccuracy* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<XyzVectorAndAccuracy>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const XyzVectorAndAccuracy& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const XyzVectorAndAccuracy& from) {
    XyzVectorAndAccuracy::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(XyzVectorAndAccuracy* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.types.spatial.XyzVectorAndAccuracy";
  }
  protected:
  explicit XyzVectorAndAccuracy(::google::protobuf::Arena* arena);
  XyzVectorAndAccuracy(::google::protobuf::Arena* arena, const XyzVectorAndAccuracy& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using StdDev = XyzVectorAndAccuracy_StdDev;
  using Metric = XyzVectorAndAccuracy_Metric;

  // accessors -------------------------------------------------------

  enum : int {
    kExtensionFieldNumber = 15,
    kMetricVehicleFieldNumber = 1,
    kMetricEventGroupFieldNumber = 2,
    kMetricOriginFieldNumber = 3,
    kCombinedStdDevFieldNumber = 4,
    kStdDevFieldNumber = 5,
    kCovarianceFieldNumber = 6,
  };
  // repeated .google.protobuf.Any extension = 15;
  int extension_size() const;
  private:
  int _internal_extension_size() const;

  public:
  void clear_extension() ;
  ::google::protobuf::Any* mutable_extension(int index);
  ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >*
      mutable_extension();
  private:
  const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& _internal_extension() const;
  ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* _internal_mutable_extension();
  public:
  const ::google::protobuf::Any& extension(int index) const;
  ::google::protobuf::Any* add_extension();
  const ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >&
      extension() const;
  // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric metric_vehicle = 1;
  bool has_metric_vehicle() const;
  private:
  bool _internal_has_metric_vehicle() const;

  public:
  void clear_metric_vehicle() ;
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric& metric_vehicle() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* release_metric_vehicle();
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* mutable_metric_vehicle();
  void set_allocated_metric_vehicle(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* value);
  void unsafe_arena_set_allocated_metric_vehicle(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* value);
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* unsafe_arena_release_metric_vehicle();

  private:
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric& _internal_metric_vehicle() const;
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* _internal_mutable_metric_vehicle();

  public:
  // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric metric_event_group = 2;
  bool has_metric_event_group() const;
  private:
  bool _internal_has_metric_event_group() const;

  public:
  void clear_metric_event_group() ;
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric& metric_event_group() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* release_metric_event_group();
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* mutable_metric_event_group();
  void set_allocated_metric_event_group(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* value);
  void unsafe_arena_set_allocated_metric_event_group(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* value);
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* unsafe_arena_release_metric_event_group();

  private:
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric& _internal_metric_event_group() const;
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* _internal_mutable_metric_event_group();

  public:
  // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric metric_origin = 3;
  bool has_metric_origin() const;
  private:
  bool _internal_has_metric_origin() const;

  public:
  void clear_metric_origin() ;
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric& metric_origin() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* release_metric_origin();
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* mutable_metric_origin();
  void set_allocated_metric_origin(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* value);
  void unsafe_arena_set_allocated_metric_origin(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* value);
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* unsafe_arena_release_metric_origin();

  private:
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric& _internal_metric_origin() const;
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* _internal_mutable_metric_origin();

  public:
  // .google.protobuf.Int64Value combined_std_dev = 4;
  bool has_combined_std_dev() const;
  private:
  bool _internal_has_combined_std_dev() const;

  public:
  void clear_combined_std_dev() ;
  const ::google::protobuf::Int64Value& combined_std_dev() const;
  PROTOBUF_NODISCARD ::google::protobuf::Int64Value* release_combined_std_dev();
  ::google::protobuf::Int64Value* mutable_combined_std_dev();
  void set_allocated_combined_std_dev(::google::protobuf::Int64Value* value);
  void unsafe_arena_set_allocated_combined_std_dev(::google::protobuf::Int64Value* value);
  ::google::protobuf::Int64Value* unsafe_arena_release_combined_std_dev();

  private:
  const ::google::protobuf::Int64Value& _internal_combined_std_dev() const;
  ::google::protobuf::Int64Value* _internal_mutable_combined_std_dev();

  public:
  // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev std_dev = 5;
  bool has_std_dev() const;
  private:
  bool _internal_has_std_dev() const;

  public:
  void clear_std_dev() ;
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev& std_dev() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev* release_std_dev();
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev* mutable_std_dev();
  void set_allocated_std_dev(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev* value);
  void unsafe_arena_set_allocated_std_dev(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev* value);
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev* unsafe_arena_release_std_dev();

  private:
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev& _internal_std_dev() const;
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev* _internal_mutable_std_dev();

  public:
  // .sensoris.protobuf.types.base.Int64Matrix3x3 covariance = 6;
  bool has_covariance() const;
  private:
  bool _internal_has_covariance() const;

  public:
  void clear_covariance() ;
  const ::sensoris::protobuf::types::base::Int64Matrix3x3& covariance() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::Int64Matrix3x3* release_covariance();
  ::sensoris::protobuf::types::base::Int64Matrix3x3* mutable_covariance();
  void set_allocated_covariance(::sensoris::protobuf::types::base::Int64Matrix3x3* value);
  void unsafe_arena_set_allocated_covariance(::sensoris::protobuf::types::base::Int64Matrix3x3* value);
  ::sensoris::protobuf::types::base::Int64Matrix3x3* unsafe_arena_release_covariance();

  private:
  const ::sensoris::protobuf::types::base::Int64Matrix3x3& _internal_covariance() const;
  ::sensoris::protobuf::types::base::Int64Matrix3x3* _internal_mutable_covariance();

  public:
  void clear_geometry();
  GeometryCase geometry_case() const;
  void clear_accuracy();
  AccuracyCase accuracy_case() const;
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy)
 private:
  class _Internal;
  void set_has_metric_vehicle();
  void set_has_metric_event_group();
  void set_has_metric_origin();
  void set_has_combined_std_dev();
  void set_has_std_dev();
  void set_has_covariance();

  inline bool has_geometry() const;
  inline void clear_has_geometry();

  inline bool has_accuracy() const;
  inline void clear_has_accuracy();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 7, 7,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any > extension_;
    union GeometryUnion {
      constexpr GeometryUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* metric_vehicle_;
      ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* metric_event_group_;
      ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* metric_origin_;
    } geometry_;
    union AccuracyUnion {
      constexpr AccuracyUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::Int64Value* combined_std_dev_;
      ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev* std_dev_;
      ::sensoris::protobuf::types::base::Int64Matrix3x3* covariance_;
    } accuracy_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[2];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto;
};// -------------------------------------------------------------------

class RotationAndAccuracy final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.spatial.RotationAndAccuracy) */ {
 public:
  inline RotationAndAccuracy() : RotationAndAccuracy(nullptr) {}
  ~RotationAndAccuracy() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RotationAndAccuracy(::google::protobuf::internal::ConstantInitialized);

  inline RotationAndAccuracy(const RotationAndAccuracy& from)
      : RotationAndAccuracy(nullptr, from) {}
  RotationAndAccuracy(RotationAndAccuracy&& from) noexcept
    : RotationAndAccuracy() {
    *this = ::std::move(from);
  }

  inline RotationAndAccuracy& operator=(const RotationAndAccuracy& from) {
    CopyFrom(from);
    return *this;
  }
  inline RotationAndAccuracy& operator=(RotationAndAccuracy&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RotationAndAccuracy& default_instance() {
    return *internal_default_instance();
  }
  enum EulerQuaternionCase {
    kEulerVehicle = 1,
    kEulerEventGroup = 2,
    kQuaternionVehicle = 3,
    kQuaternionEventGroup = 4,
    EULER_QUATERNION_NOT_SET = 0,
  };

  enum AccuracyCase {
    kCombinedStdDev = 5,
    kStdDev = 6,
    kCovariance = 7,
    ACCURACY_NOT_SET = 0,
  };

  static inline const RotationAndAccuracy* internal_default_instance() {
    return reinterpret_cast<const RotationAndAccuracy*>(
               &_RotationAndAccuracy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(RotationAndAccuracy& a, RotationAndAccuracy& b) {
    a.Swap(&b);
  }
  inline void Swap(RotationAndAccuracy* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RotationAndAccuracy* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RotationAndAccuracy* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RotationAndAccuracy>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RotationAndAccuracy& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RotationAndAccuracy& from) {
    RotationAndAccuracy::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RotationAndAccuracy* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.types.spatial.RotationAndAccuracy";
  }
  protected:
  explicit RotationAndAccuracy(::google::protobuf::Arena* arena);
  RotationAndAccuracy(::google::protobuf::Arena* arena, const RotationAndAccuracy& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Euler = RotationAndAccuracy_Euler;
  using Quaternion = RotationAndAccuracy_Quaternion;
  using StdDev = RotationAndAccuracy_StdDev;

  // accessors -------------------------------------------------------

  enum : int {
    kExtensionFieldNumber = 15,
    kEulerVehicleFieldNumber = 1,
    kEulerEventGroupFieldNumber = 2,
    kQuaternionVehicleFieldNumber = 3,
    kQuaternionEventGroupFieldNumber = 4,
    kCombinedStdDevFieldNumber = 5,
    kStdDevFieldNumber = 6,
    kCovarianceFieldNumber = 7,
  };
  // repeated .google.protobuf.Any extension = 15;
  int extension_size() const;
  private:
  int _internal_extension_size() const;

  public:
  void clear_extension() ;
  ::google::protobuf::Any* mutable_extension(int index);
  ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >*
      mutable_extension();
  private:
  const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& _internal_extension() const;
  ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* _internal_mutable_extension();
  public:
  const ::google::protobuf::Any& extension(int index) const;
  ::google::protobuf::Any* add_extension();
  const ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >&
      extension() const;
  // .sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler euler_vehicle = 1;
  bool has_euler_vehicle() const;
  private:
  bool _internal_has_euler_vehicle() const;

  public:
  void clear_euler_vehicle() ;
  const ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler& euler_vehicle() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* release_euler_vehicle();
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* mutable_euler_vehicle();
  void set_allocated_euler_vehicle(::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* value);
  void unsafe_arena_set_allocated_euler_vehicle(::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* value);
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* unsafe_arena_release_euler_vehicle();

  private:
  const ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler& _internal_euler_vehicle() const;
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* _internal_mutable_euler_vehicle();

  public:
  // .sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler euler_event_group = 2;
  bool has_euler_event_group() const;
  private:
  bool _internal_has_euler_event_group() const;

  public:
  void clear_euler_event_group() ;
  const ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler& euler_event_group() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* release_euler_event_group();
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* mutable_euler_event_group();
  void set_allocated_euler_event_group(::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* value);
  void unsafe_arena_set_allocated_euler_event_group(::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* value);
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* unsafe_arena_release_euler_event_group();

  private:
  const ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler& _internal_euler_event_group() const;
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* _internal_mutable_euler_event_group();

  public:
  // .sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion quaternion_vehicle = 3;
  bool has_quaternion_vehicle() const;
  private:
  bool _internal_has_quaternion_vehicle() const;

  public:
  void clear_quaternion_vehicle() ;
  const ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion& quaternion_vehicle() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* release_quaternion_vehicle();
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* mutable_quaternion_vehicle();
  void set_allocated_quaternion_vehicle(::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* value);
  void unsafe_arena_set_allocated_quaternion_vehicle(::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* value);
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* unsafe_arena_release_quaternion_vehicle();

  private:
  const ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion& _internal_quaternion_vehicle() const;
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* _internal_mutable_quaternion_vehicle();

  public:
  // .sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion quaternion_event_group = 4;
  bool has_quaternion_event_group() const;
  private:
  bool _internal_has_quaternion_event_group() const;

  public:
  void clear_quaternion_event_group() ;
  const ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion& quaternion_event_group() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* release_quaternion_event_group();
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* mutable_quaternion_event_group();
  void set_allocated_quaternion_event_group(::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* value);
  void unsafe_arena_set_allocated_quaternion_event_group(::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* value);
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* unsafe_arena_release_quaternion_event_group();

  private:
  const ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion& _internal_quaternion_event_group() const;
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* _internal_mutable_quaternion_event_group();

  public:
  // .google.protobuf.Int64Value combined_std_dev = 5 [(.sensoris.protobuf.types.base.exponent) = 2];
  bool has_combined_std_dev() const;
  private:
  bool _internal_has_combined_std_dev() const;

  public:
  void clear_combined_std_dev() ;
  const ::google::protobuf::Int64Value& combined_std_dev() const;
  PROTOBUF_NODISCARD ::google::protobuf::Int64Value* release_combined_std_dev();
  ::google::protobuf::Int64Value* mutable_combined_std_dev();
  void set_allocated_combined_std_dev(::google::protobuf::Int64Value* value);
  void unsafe_arena_set_allocated_combined_std_dev(::google::protobuf::Int64Value* value);
  ::google::protobuf::Int64Value* unsafe_arena_release_combined_std_dev();

  private:
  const ::google::protobuf::Int64Value& _internal_combined_std_dev() const;
  ::google::protobuf::Int64Value* _internal_mutable_combined_std_dev();

  public:
  // .sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev std_dev = 6;
  bool has_std_dev() const;
  private:
  bool _internal_has_std_dev() const;

  public:
  void clear_std_dev() ;
  const ::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev& std_dev() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev* release_std_dev();
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev* mutable_std_dev();
  void set_allocated_std_dev(::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev* value);
  void unsafe_arena_set_allocated_std_dev(::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev* value);
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev* unsafe_arena_release_std_dev();

  private:
  const ::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev& _internal_std_dev() const;
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev* _internal_mutable_std_dev();

  public:
  // .sensoris.protobuf.types.base.Int64Matrix3x3 covariance = 7 [(.sensoris.protobuf.types.base.exponent) = 2];
  bool has_covariance() const;
  private:
  bool _internal_has_covariance() const;

  public:
  void clear_covariance() ;
  const ::sensoris::protobuf::types::base::Int64Matrix3x3& covariance() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::Int64Matrix3x3* release_covariance();
  ::sensoris::protobuf::types::base::Int64Matrix3x3* mutable_covariance();
  void set_allocated_covariance(::sensoris::protobuf::types::base::Int64Matrix3x3* value);
  void unsafe_arena_set_allocated_covariance(::sensoris::protobuf::types::base::Int64Matrix3x3* value);
  ::sensoris::protobuf::types::base::Int64Matrix3x3* unsafe_arena_release_covariance();

  private:
  const ::sensoris::protobuf::types::base::Int64Matrix3x3& _internal_covariance() const;
  ::sensoris::protobuf::types::base::Int64Matrix3x3* _internal_mutable_covariance();

  public:
  void clear_euler_quaternion();
  EulerQuaternionCase euler_quaternion_case() const;
  void clear_accuracy();
  AccuracyCase accuracy_case() const;
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.spatial.RotationAndAccuracy)
 private:
  class _Internal;
  void set_has_euler_vehicle();
  void set_has_euler_event_group();
  void set_has_quaternion_vehicle();
  void set_has_quaternion_event_group();
  void set_has_combined_std_dev();
  void set_has_std_dev();
  void set_has_covariance();

  inline bool has_euler_quaternion() const;
  inline void clear_has_euler_quaternion();

  inline bool has_accuracy() const;
  inline void clear_has_accuracy();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 8, 8,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any > extension_;
    union EulerQuaternionUnion {
      constexpr EulerQuaternionUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* euler_vehicle_;
      ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* euler_event_group_;
      ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* quaternion_vehicle_;
      ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* quaternion_event_group_;
    } euler_quaternion_;
    union AccuracyUnion {
      constexpr AccuracyUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::Int64Value* combined_std_dev_;
      ::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev* std_dev_;
      ::sensoris::protobuf::types::base::Int64Matrix3x3* covariance_;
    } accuracy_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[2];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto;
};// -------------------------------------------------------------------

class PositionAndAccuracy final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.spatial.PositionAndAccuracy) */ {
 public:
  inline PositionAndAccuracy() : PositionAndAccuracy(nullptr) {}
  ~PositionAndAccuracy() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PositionAndAccuracy(::google::protobuf::internal::ConstantInitialized);

  inline PositionAndAccuracy(const PositionAndAccuracy& from)
      : PositionAndAccuracy(nullptr, from) {}
  PositionAndAccuracy(PositionAndAccuracy&& from) noexcept
    : PositionAndAccuracy() {
    *this = ::std::move(from);
  }

  inline PositionAndAccuracy& operator=(const PositionAndAccuracy& from) {
    CopyFrom(from);
    return *this;
  }
  inline PositionAndAccuracy& operator=(PositionAndAccuracy&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PositionAndAccuracy& default_instance() {
    return *internal_default_instance();
  }
  enum GeographicMetricCase {
    kGeographicWgs84 = 1,
    kMetricVehicle = 2,
    kMetricEventGroup = 3,
    kMetricEcef = 4,
    GEOGRAPHIC_METRIC_NOT_SET = 0,
  };

  enum AccuracyCase {
    kCombinedStdDev = 5,
    kStdDev = 6,
    kHorizontalConfidenceEllipseVerticalStdDev = 7,
    kCovariance = 8,
    ACCURACY_NOT_SET = 0,
  };

  static inline const PositionAndAccuracy* internal_default_instance() {
    return reinterpret_cast<const PositionAndAccuracy*>(
               &_PositionAndAccuracy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(PositionAndAccuracy& a, PositionAndAccuracy& b) {
    a.Swap(&b);
  }
  inline void Swap(PositionAndAccuracy* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PositionAndAccuracy* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PositionAndAccuracy* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PositionAndAccuracy>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PositionAndAccuracy& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PositionAndAccuracy& from) {
    PositionAndAccuracy::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PositionAndAccuracy* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.types.spatial.PositionAndAccuracy";
  }
  protected:
  explicit PositionAndAccuracy(::google::protobuf::Arena* arena);
  PositionAndAccuracy(::google::protobuf::Arena* arena, const PositionAndAccuracy& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Geographic = PositionAndAccuracy_Geographic;
  using Metric = PositionAndAccuracy_Metric;
  using HorizontalVerticalStdDev = PositionAndAccuracy_HorizontalVerticalStdDev;
  using HorizontalConfidenceEllipseVerticalStdDev = PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev;

  // accessors -------------------------------------------------------

  enum : int {
    kExtensionFieldNumber = 15,
    kGeographicWgs84FieldNumber = 1,
    kMetricVehicleFieldNumber = 2,
    kMetricEventGroupFieldNumber = 3,
    kMetricEcefFieldNumber = 4,
    kCombinedStdDevFieldNumber = 5,
    kStdDevFieldNumber = 6,
    kHorizontalConfidenceEllipseVerticalStdDevFieldNumber = 7,
    kCovarianceFieldNumber = 8,
  };
  // repeated .google.protobuf.Any extension = 15;
  int extension_size() const;
  private:
  int _internal_extension_size() const;

  public:
  void clear_extension() ;
  ::google::protobuf::Any* mutable_extension(int index);
  ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >*
      mutable_extension();
  private:
  const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& _internal_extension() const;
  ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* _internal_mutable_extension();
  public:
  const ::google::protobuf::Any& extension(int index) const;
  ::google::protobuf::Any* add_extension();
  const ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >&
      extension() const;
  // .sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic geographic_wgs84 = 1;
  bool has_geographic_wgs84() const;
  private:
  bool _internal_has_geographic_wgs84() const;

  public:
  void clear_geographic_wgs84() ;
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic& geographic_wgs84() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic* release_geographic_wgs84();
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic* mutable_geographic_wgs84();
  void set_allocated_geographic_wgs84(::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic* value);
  void unsafe_arena_set_allocated_geographic_wgs84(::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic* value);
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic* unsafe_arena_release_geographic_wgs84();

  private:
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic& _internal_geographic_wgs84() const;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic* _internal_mutable_geographic_wgs84();

  public:
  // .sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric metric_vehicle = 2;
  bool has_metric_vehicle() const;
  private:
  bool _internal_has_metric_vehicle() const;

  public:
  void clear_metric_vehicle() ;
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric& metric_vehicle() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* release_metric_vehicle();
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* mutable_metric_vehicle();
  void set_allocated_metric_vehicle(::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* value);
  void unsafe_arena_set_allocated_metric_vehicle(::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* value);
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* unsafe_arena_release_metric_vehicle();

  private:
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric& _internal_metric_vehicle() const;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* _internal_mutable_metric_vehicle();

  public:
  // .sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric metric_event_group = 3;
  bool has_metric_event_group() const;
  private:
  bool _internal_has_metric_event_group() const;

  public:
  void clear_metric_event_group() ;
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric& metric_event_group() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* release_metric_event_group();
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* mutable_metric_event_group();
  void set_allocated_metric_event_group(::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* value);
  void unsafe_arena_set_allocated_metric_event_group(::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* value);
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* unsafe_arena_release_metric_event_group();

  private:
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric& _internal_metric_event_group() const;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* _internal_mutable_metric_event_group();

  public:
  // .sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric metric_ecef = 4;
  bool has_metric_ecef() const;
  private:
  bool _internal_has_metric_ecef() const;

  public:
  void clear_metric_ecef() ;
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric& metric_ecef() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* release_metric_ecef();
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* mutable_metric_ecef();
  void set_allocated_metric_ecef(::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* value);
  void unsafe_arena_set_allocated_metric_ecef(::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* value);
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* unsafe_arena_release_metric_ecef();

  private:
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric& _internal_metric_ecef() const;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* _internal_mutable_metric_ecef();

  public:
  // .google.protobuf.Int64Value combined_std_dev = 5 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_combined_std_dev() const;
  private:
  bool _internal_has_combined_std_dev() const;

  public:
  void clear_combined_std_dev() ;
  const ::google::protobuf::Int64Value& combined_std_dev() const;
  PROTOBUF_NODISCARD ::google::protobuf::Int64Value* release_combined_std_dev();
  ::google::protobuf::Int64Value* mutable_combined_std_dev();
  void set_allocated_combined_std_dev(::google::protobuf::Int64Value* value);
  void unsafe_arena_set_allocated_combined_std_dev(::google::protobuf::Int64Value* value);
  ::google::protobuf::Int64Value* unsafe_arena_release_combined_std_dev();

  private:
  const ::google::protobuf::Int64Value& _internal_combined_std_dev() const;
  ::google::protobuf::Int64Value* _internal_mutable_combined_std_dev();

  public:
  // .sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalVerticalStdDev std_dev = 6;
  bool has_std_dev() const;
  private:
  bool _internal_has_std_dev() const;

  public:
  void clear_std_dev() ;
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev& std_dev() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev* release_std_dev();
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev* mutable_std_dev();
  void set_allocated_std_dev(::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev* value);
  void unsafe_arena_set_allocated_std_dev(::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev* value);
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev* unsafe_arena_release_std_dev();

  private:
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev& _internal_std_dev() const;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev* _internal_mutable_std_dev();

  public:
  // .sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev horizontal_confidence_ellipse_vertical_std_dev = 7;
  bool has_horizontal_confidence_ellipse_vertical_std_dev() const;
  private:
  bool _internal_has_horizontal_confidence_ellipse_vertical_std_dev() const;

  public:
  void clear_horizontal_confidence_ellipse_vertical_std_dev() ;
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev& horizontal_confidence_ellipse_vertical_std_dev() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev* release_horizontal_confidence_ellipse_vertical_std_dev();
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev* mutable_horizontal_confidence_ellipse_vertical_std_dev();
  void set_allocated_horizontal_confidence_ellipse_vertical_std_dev(::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev* value);
  void unsafe_arena_set_allocated_horizontal_confidence_ellipse_vertical_std_dev(::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev* value);
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev* unsafe_arena_release_horizontal_confidence_ellipse_vertical_std_dev();

  private:
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev& _internal_horizontal_confidence_ellipse_vertical_std_dev() const;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev* _internal_mutable_horizontal_confidence_ellipse_vertical_std_dev();

  public:
  // .sensoris.protobuf.types.base.Int64Matrix3x3 covariance = 8 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_covariance() const;
  private:
  bool _internal_has_covariance() const;

  public:
  void clear_covariance() ;
  const ::sensoris::protobuf::types::base::Int64Matrix3x3& covariance() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::Int64Matrix3x3* release_covariance();
  ::sensoris::protobuf::types::base::Int64Matrix3x3* mutable_covariance();
  void set_allocated_covariance(::sensoris::protobuf::types::base::Int64Matrix3x3* value);
  void unsafe_arena_set_allocated_covariance(::sensoris::protobuf::types::base::Int64Matrix3x3* value);
  ::sensoris::protobuf::types::base::Int64Matrix3x3* unsafe_arena_release_covariance();

  private:
  const ::sensoris::protobuf::types::base::Int64Matrix3x3& _internal_covariance() const;
  ::sensoris::protobuf::types::base::Int64Matrix3x3* _internal_mutable_covariance();

  public:
  void clear_geographic_metric();
  GeographicMetricCase geographic_metric_case() const;
  void clear_accuracy();
  AccuracyCase accuracy_case() const;
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.spatial.PositionAndAccuracy)
 private:
  class _Internal;
  void set_has_geographic_wgs84();
  void set_has_metric_vehicle();
  void set_has_metric_event_group();
  void set_has_metric_ecef();
  void set_has_combined_std_dev();
  void set_has_std_dev();
  void set_has_horizontal_confidence_ellipse_vertical_std_dev();
  void set_has_covariance();

  inline bool has_geographic_metric() const;
  inline void clear_has_geographic_metric();

  inline bool has_accuracy() const;
  inline void clear_has_accuracy();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 9, 9,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any > extension_;
    union GeographicMetricUnion {
      constexpr GeographicMetricUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic* geographic_wgs84_;
      ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* metric_vehicle_;
      ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* metric_event_group_;
      ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* metric_ecef_;
    } geographic_metric_;
    union AccuracyUnion {
      constexpr AccuracyUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::Int64Value* combined_std_dev_;
      ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev* std_dev_;
      ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev* horizontal_confidence_ellipse_vertical_std_dev_;
      ::sensoris::protobuf::types::base::Int64Matrix3x3* covariance_;
    } accuracy_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[2];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto;
};// -------------------------------------------------------------------

class RectangularBoxAndAccuracy_CornerVectors final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors) */ {
 public:
  inline RectangularBoxAndAccuracy_CornerVectors() : RectangularBoxAndAccuracy_CornerVectors(nullptr) {}
  ~RectangularBoxAndAccuracy_CornerVectors() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RectangularBoxAndAccuracy_CornerVectors(::google::protobuf::internal::ConstantInitialized);

  inline RectangularBoxAndAccuracy_CornerVectors(const RectangularBoxAndAccuracy_CornerVectors& from)
      : RectangularBoxAndAccuracy_CornerVectors(nullptr, from) {}
  RectangularBoxAndAccuracy_CornerVectors(RectangularBoxAndAccuracy_CornerVectors&& from) noexcept
    : RectangularBoxAndAccuracy_CornerVectors() {
    *this = ::std::move(from);
  }

  inline RectangularBoxAndAccuracy_CornerVectors& operator=(const RectangularBoxAndAccuracy_CornerVectors& from) {
    CopyFrom(from);
    return *this;
  }
  inline RectangularBoxAndAccuracy_CornerVectors& operator=(RectangularBoxAndAccuracy_CornerVectors&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RectangularBoxAndAccuracy_CornerVectors& default_instance() {
    return *internal_default_instance();
  }
  static inline const RectangularBoxAndAccuracy_CornerVectors* internal_default_instance() {
    return reinterpret_cast<const RectangularBoxAndAccuracy_CornerVectors*>(
               &_RectangularBoxAndAccuracy_CornerVectors_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(RectangularBoxAndAccuracy_CornerVectors& a, RectangularBoxAndAccuracy_CornerVectors& b) {
    a.Swap(&b);
  }
  inline void Swap(RectangularBoxAndAccuracy_CornerVectors* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RectangularBoxAndAccuracy_CornerVectors* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RectangularBoxAndAccuracy_CornerVectors* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RectangularBoxAndAccuracy_CornerVectors>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RectangularBoxAndAccuracy_CornerVectors& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RectangularBoxAndAccuracy_CornerVectors& from) {
    RectangularBoxAndAccuracy_CornerVectors::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RectangularBoxAndAccuracy_CornerVectors* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors";
  }
  protected:
  explicit RectangularBoxAndAccuracy_CornerVectors(::google::protobuf::Arena* arena);
  RectangularBoxAndAccuracy_CornerVectors(::google::protobuf::Arena* arena, const RectangularBoxAndAccuracy_CornerVectors& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFirstAndAccuracyFieldNumber = 1,
    kSecondAndAccuracyFieldNumber = 2,
    kThirdAndAccuracyFieldNumber = 3,
  };
  // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy first_and_accuracy = 1 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_first_and_accuracy() const;
  void clear_first_and_accuracy() ;
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& first_and_accuracy() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* release_first_and_accuracy();
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* mutable_first_and_accuracy();
  void set_allocated_first_and_accuracy(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* value);
  void unsafe_arena_set_allocated_first_and_accuracy(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* value);
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* unsafe_arena_release_first_and_accuracy();

  private:
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& _internal_first_and_accuracy() const;
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* _internal_mutable_first_and_accuracy();

  public:
  // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy second_and_accuracy = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_second_and_accuracy() const;
  void clear_second_and_accuracy() ;
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& second_and_accuracy() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* release_second_and_accuracy();
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* mutable_second_and_accuracy();
  void set_allocated_second_and_accuracy(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* value);
  void unsafe_arena_set_allocated_second_and_accuracy(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* value);
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* unsafe_arena_release_second_and_accuracy();

  private:
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& _internal_second_and_accuracy() const;
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* _internal_mutable_second_and_accuracy();

  public:
  // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy third_and_accuracy = 3 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_third_and_accuracy() const;
  void clear_third_and_accuracy() ;
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& third_and_accuracy() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* release_third_and_accuracy();
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* mutable_third_and_accuracy();
  void set_allocated_third_and_accuracy(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* value);
  void unsafe_arena_set_allocated_third_and_accuracy(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* value);
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* unsafe_arena_release_third_and_accuracy();

  private:
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& _internal_third_and_accuracy() const;
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* _internal_mutable_third_and_accuracy();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* first_and_accuracy_;
    ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* second_and_accuracy_;
    ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* third_and_accuracy_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto;
};// -------------------------------------------------------------------

class RectangularBoxAndAccuracy_CenterOrientationSize final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize) */ {
 public:
  inline RectangularBoxAndAccuracy_CenterOrientationSize() : RectangularBoxAndAccuracy_CenterOrientationSize(nullptr) {}
  ~RectangularBoxAndAccuracy_CenterOrientationSize() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RectangularBoxAndAccuracy_CenterOrientationSize(::google::protobuf::internal::ConstantInitialized);

  inline RectangularBoxAndAccuracy_CenterOrientationSize(const RectangularBoxAndAccuracy_CenterOrientationSize& from)
      : RectangularBoxAndAccuracy_CenterOrientationSize(nullptr, from) {}
  RectangularBoxAndAccuracy_CenterOrientationSize(RectangularBoxAndAccuracy_CenterOrientationSize&& from) noexcept
    : RectangularBoxAndAccuracy_CenterOrientationSize() {
    *this = ::std::move(from);
  }

  inline RectangularBoxAndAccuracy_CenterOrientationSize& operator=(const RectangularBoxAndAccuracy_CenterOrientationSize& from) {
    CopyFrom(from);
    return *this;
  }
  inline RectangularBoxAndAccuracy_CenterOrientationSize& operator=(RectangularBoxAndAccuracy_CenterOrientationSize&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RectangularBoxAndAccuracy_CenterOrientationSize& default_instance() {
    return *internal_default_instance();
  }
  static inline const RectangularBoxAndAccuracy_CenterOrientationSize* internal_default_instance() {
    return reinterpret_cast<const RectangularBoxAndAccuracy_CenterOrientationSize*>(
               &_RectangularBoxAndAccuracy_CenterOrientationSize_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(RectangularBoxAndAccuracy_CenterOrientationSize& a, RectangularBoxAndAccuracy_CenterOrientationSize& b) {
    a.Swap(&b);
  }
  inline void Swap(RectangularBoxAndAccuracy_CenterOrientationSize* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RectangularBoxAndAccuracy_CenterOrientationSize* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RectangularBoxAndAccuracy_CenterOrientationSize* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RectangularBoxAndAccuracy_CenterOrientationSize>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RectangularBoxAndAccuracy_CenterOrientationSize& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RectangularBoxAndAccuracy_CenterOrientationSize& from) {
    RectangularBoxAndAccuracy_CenterOrientationSize::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RectangularBoxAndAccuracy_CenterOrientationSize* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize";
  }
  protected:
  explicit RectangularBoxAndAccuracy_CenterOrientationSize(::google::protobuf::Arena* arena);
  RectangularBoxAndAccuracy_CenterOrientationSize(::google::protobuf::Arena* arena, const RectangularBoxAndAccuracy_CenterOrientationSize& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCenterPositionAndAccuracyFieldNumber = 1,
    kOrientationAndAccuracyFieldNumber = 2,
    kSizeAndAccuracyFieldNumber = 3,
  };
  // .sensoris.protobuf.types.spatial.PositionAndAccuracy center_position_and_accuracy = 1;
  bool has_center_position_and_accuracy() const;
  void clear_center_position_and_accuracy() ;
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& center_position_and_accuracy() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::spatial::PositionAndAccuracy* release_center_position_and_accuracy();
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* mutable_center_position_and_accuracy();
  void set_allocated_center_position_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* value);
  void unsafe_arena_set_allocated_center_position_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* value);
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* unsafe_arena_release_center_position_and_accuracy();

  private:
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& _internal_center_position_and_accuracy() const;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* _internal_mutable_center_position_and_accuracy();

  public:
  // .sensoris.protobuf.types.spatial.RotationAndAccuracy orientation_and_accuracy = 2;
  bool has_orientation_and_accuracy() const;
  void clear_orientation_and_accuracy() ;
  const ::sensoris::protobuf::types::spatial::RotationAndAccuracy& orientation_and_accuracy() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::spatial::RotationAndAccuracy* release_orientation_and_accuracy();
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy* mutable_orientation_and_accuracy();
  void set_allocated_orientation_and_accuracy(::sensoris::protobuf::types::spatial::RotationAndAccuracy* value);
  void unsafe_arena_set_allocated_orientation_and_accuracy(::sensoris::protobuf::types::spatial::RotationAndAccuracy* value);
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy* unsafe_arena_release_orientation_and_accuracy();

  private:
  const ::sensoris::protobuf::types::spatial::RotationAndAccuracy& _internal_orientation_and_accuracy() const;
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy* _internal_mutable_orientation_and_accuracy();

  public:
  // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy size_and_accuracy = 3 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_size_and_accuracy() const;
  void clear_size_and_accuracy() ;
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& size_and_accuracy() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* release_size_and_accuracy();
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* mutable_size_and_accuracy();
  void set_allocated_size_and_accuracy(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* value);
  void unsafe_arena_set_allocated_size_and_accuracy(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* value);
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* unsafe_arena_release_size_and_accuracy();

  private:
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& _internal_size_and_accuracy() const;
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* _internal_mutable_size_and_accuracy();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::sensoris::protobuf::types::spatial::PositionAndAccuracy* center_position_and_accuracy_;
    ::sensoris::protobuf::types::spatial::RotationAndAccuracy* orientation_and_accuracy_;
    ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* size_and_accuracy_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto;
};// -------------------------------------------------------------------

class RectangleAndAccuracy final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.spatial.RectangleAndAccuracy) */ {
 public:
  inline RectangleAndAccuracy() : RectangleAndAccuracy(nullptr) {}
  ~RectangleAndAccuracy() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RectangleAndAccuracy(::google::protobuf::internal::ConstantInitialized);

  inline RectangleAndAccuracy(const RectangleAndAccuracy& from)
      : RectangleAndAccuracy(nullptr, from) {}
  RectangleAndAccuracy(RectangleAndAccuracy&& from) noexcept
    : RectangleAndAccuracy() {
    *this = ::std::move(from);
  }

  inline RectangleAndAccuracy& operator=(const RectangleAndAccuracy& from) {
    CopyFrom(from);
    return *this;
  }
  inline RectangleAndAccuracy& operator=(RectangleAndAccuracy&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RectangleAndAccuracy& default_instance() {
    return *internal_default_instance();
  }
  static inline const RectangleAndAccuracy* internal_default_instance() {
    return reinterpret_cast<const RectangleAndAccuracy*>(
               &_RectangleAndAccuracy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(RectangleAndAccuracy& a, RectangleAndAccuracy& b) {
    a.Swap(&b);
  }
  inline void Swap(RectangleAndAccuracy* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RectangleAndAccuracy* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RectangleAndAccuracy* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RectangleAndAccuracy>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RectangleAndAccuracy& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RectangleAndAccuracy& from) {
    RectangleAndAccuracy::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RectangleAndAccuracy* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.types.spatial.RectangleAndAccuracy";
  }
  protected:
  explicit RectangleAndAccuracy(::google::protobuf::Arena* arena);
  RectangleAndAccuracy(::google::protobuf::Arena* arena, const RectangleAndAccuracy& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExtensionFieldNumber = 15,
    kMinimumPositionAndAccuracyFieldNumber = 1,
    kMaximumPositionAndAccuracyFieldNumber = 2,
  };
  // repeated .google.protobuf.Any extension = 15;
  int extension_size() const;
  private:
  int _internal_extension_size() const;

  public:
  void clear_extension() ;
  ::google::protobuf::Any* mutable_extension(int index);
  ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >*
      mutable_extension();
  private:
  const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& _internal_extension() const;
  ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* _internal_mutable_extension();
  public:
  const ::google::protobuf::Any& extension(int index) const;
  ::google::protobuf::Any* add_extension();
  const ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >&
      extension() const;
  // .sensoris.protobuf.types.spatial.PositionAndAccuracy minimum_position_and_accuracy = 1;
  bool has_minimum_position_and_accuracy() const;
  void clear_minimum_position_and_accuracy() ;
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& minimum_position_and_accuracy() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::spatial::PositionAndAccuracy* release_minimum_position_and_accuracy();
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* mutable_minimum_position_and_accuracy();
  void set_allocated_minimum_position_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* value);
  void unsafe_arena_set_allocated_minimum_position_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* value);
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* unsafe_arena_release_minimum_position_and_accuracy();

  private:
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& _internal_minimum_position_and_accuracy() const;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* _internal_mutable_minimum_position_and_accuracy();

  public:
  // .sensoris.protobuf.types.spatial.PositionAndAccuracy maximum_position_and_accuracy = 2;
  bool has_maximum_position_and_accuracy() const;
  void clear_maximum_position_and_accuracy() ;
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& maximum_position_and_accuracy() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::spatial::PositionAndAccuracy* release_maximum_position_and_accuracy();
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* mutable_maximum_position_and_accuracy();
  void set_allocated_maximum_position_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* value);
  void unsafe_arena_set_allocated_maximum_position_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* value);
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* unsafe_arena_release_maximum_position_and_accuracy();

  private:
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& _internal_maximum_position_and_accuracy() const;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* _internal_mutable_maximum_position_and_accuracy();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.spatial.RectangleAndAccuracy)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any > extension_;
    ::sensoris::protobuf::types::spatial::PositionAndAccuracy* minimum_position_and_accuracy_;
    ::sensoris::protobuf::types::spatial::PositionAndAccuracy* maximum_position_and_accuracy_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto;
};// -------------------------------------------------------------------

class PolylineAndAccuracy final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.spatial.PolylineAndAccuracy) */ {
 public:
  inline PolylineAndAccuracy() : PolylineAndAccuracy(nullptr) {}
  ~PolylineAndAccuracy() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PolylineAndAccuracy(::google::protobuf::internal::ConstantInitialized);

  inline PolylineAndAccuracy(const PolylineAndAccuracy& from)
      : PolylineAndAccuracy(nullptr, from) {}
  PolylineAndAccuracy(PolylineAndAccuracy&& from) noexcept
    : PolylineAndAccuracy() {
    *this = ::std::move(from);
  }

  inline PolylineAndAccuracy& operator=(const PolylineAndAccuracy& from) {
    CopyFrom(from);
    return *this;
  }
  inline PolylineAndAccuracy& operator=(PolylineAndAccuracy&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PolylineAndAccuracy& default_instance() {
    return *internal_default_instance();
  }
  static inline const PolylineAndAccuracy* internal_default_instance() {
    return reinterpret_cast<const PolylineAndAccuracy*>(
               &_PolylineAndAccuracy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(PolylineAndAccuracy& a, PolylineAndAccuracy& b) {
    a.Swap(&b);
  }
  inline void Swap(PolylineAndAccuracy* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PolylineAndAccuracy* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PolylineAndAccuracy* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PolylineAndAccuracy>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PolylineAndAccuracy& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PolylineAndAccuracy& from) {
    PolylineAndAccuracy::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PolylineAndAccuracy* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.types.spatial.PolylineAndAccuracy";
  }
  protected:
  explicit PolylineAndAccuracy(::google::protobuf::Arena* arena);
  PolylineAndAccuracy(::google::protobuf::Arena* arena, const PolylineAndAccuracy& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionAndAccuracyFieldNumber = 1,
    kExtensionFieldNumber = 15,
  };
  // repeated .sensoris.protobuf.types.spatial.PositionAndAccuracy position_and_accuracy = 1;
  int position_and_accuracy_size() const;
  private:
  int _internal_position_and_accuracy_size() const;

  public:
  void clear_position_and_accuracy() ;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* mutable_position_and_accuracy(int index);
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::types::spatial::PositionAndAccuracy >*
      mutable_position_and_accuracy();
  private:
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::types::spatial::PositionAndAccuracy>& _internal_position_and_accuracy() const;
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::types::spatial::PositionAndAccuracy>* _internal_mutable_position_and_accuracy();
  public:
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& position_and_accuracy(int index) const;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* add_position_and_accuracy();
  const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::types::spatial::PositionAndAccuracy >&
      position_and_accuracy() const;
  // repeated .google.protobuf.Any extension = 15;
  int extension_size() const;
  private:
  int _internal_extension_size() const;

  public:
  void clear_extension() ;
  ::google::protobuf::Any* mutable_extension(int index);
  ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >*
      mutable_extension();
  private:
  const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& _internal_extension() const;
  ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* _internal_mutable_extension();
  public:
  const ::google::protobuf::Any& extension(int index) const;
  ::google::protobuf::Any* add_extension();
  const ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >&
      extension() const;
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.spatial.PolylineAndAccuracy)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::types::spatial::PositionAndAccuracy > position_and_accuracy_;
    ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any > extension_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto;
};// -------------------------------------------------------------------

class PolygonAndAccuracy final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.spatial.PolygonAndAccuracy) */ {
 public:
  inline PolygonAndAccuracy() : PolygonAndAccuracy(nullptr) {}
  ~PolygonAndAccuracy() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PolygonAndAccuracy(::google::protobuf::internal::ConstantInitialized);

  inline PolygonAndAccuracy(const PolygonAndAccuracy& from)
      : PolygonAndAccuracy(nullptr, from) {}
  PolygonAndAccuracy(PolygonAndAccuracy&& from) noexcept
    : PolygonAndAccuracy() {
    *this = ::std::move(from);
  }

  inline PolygonAndAccuracy& operator=(const PolygonAndAccuracy& from) {
    CopyFrom(from);
    return *this;
  }
  inline PolygonAndAccuracy& operator=(PolygonAndAccuracy&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PolygonAndAccuracy& default_instance() {
    return *internal_default_instance();
  }
  static inline const PolygonAndAccuracy* internal_default_instance() {
    return reinterpret_cast<const PolygonAndAccuracy*>(
               &_PolygonAndAccuracy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(PolygonAndAccuracy& a, PolygonAndAccuracy& b) {
    a.Swap(&b);
  }
  inline void Swap(PolygonAndAccuracy* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PolygonAndAccuracy* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PolygonAndAccuracy* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PolygonAndAccuracy>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PolygonAndAccuracy& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PolygonAndAccuracy& from) {
    PolygonAndAccuracy::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PolygonAndAccuracy* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.types.spatial.PolygonAndAccuracy";
  }
  protected:
  explicit PolygonAndAccuracy(::google::protobuf::Arena* arena);
  PolygonAndAccuracy(::google::protobuf::Arena* arena, const PolygonAndAccuracy& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionAndAccuracyFieldNumber = 1,
    kExtensionFieldNumber = 15,
  };
  // repeated .sensoris.protobuf.types.spatial.PositionAndAccuracy position_and_accuracy = 1;
  int position_and_accuracy_size() const;
  private:
  int _internal_position_and_accuracy_size() const;

  public:
  void clear_position_and_accuracy() ;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* mutable_position_and_accuracy(int index);
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::types::spatial::PositionAndAccuracy >*
      mutable_position_and_accuracy();
  private:
  const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::types::spatial::PositionAndAccuracy>& _internal_position_and_accuracy() const;
  ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::types::spatial::PositionAndAccuracy>* _internal_mutable_position_and_accuracy();
  public:
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& position_and_accuracy(int index) const;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* add_position_and_accuracy();
  const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::types::spatial::PositionAndAccuracy >&
      position_and_accuracy() const;
  // repeated .google.protobuf.Any extension = 15;
  int extension_size() const;
  private:
  int _internal_extension_size() const;

  public:
  void clear_extension() ;
  ::google::protobuf::Any* mutable_extension(int index);
  ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >*
      mutable_extension();
  private:
  const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& _internal_extension() const;
  ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* _internal_mutable_extension();
  public:
  const ::google::protobuf::Any& extension(int index) const;
  ::google::protobuf::Any* add_extension();
  const ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >&
      extension() const;
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.spatial.PolygonAndAccuracy)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::types::spatial::PositionAndAccuracy > position_and_accuracy_;
    ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any > extension_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto;
};// -------------------------------------------------------------------

class MapLocationReference final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.spatial.MapLocationReference) */ {
 public:
  inline MapLocationReference() : MapLocationReference(nullptr) {}
  ~MapLocationReference() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MapLocationReference(::google::protobuf::internal::ConstantInitialized);

  inline MapLocationReference(const MapLocationReference& from)
      : MapLocationReference(nullptr, from) {}
  MapLocationReference(MapLocationReference&& from) noexcept
    : MapLocationReference() {
    *this = ::std::move(from);
  }

  inline MapLocationReference& operator=(const MapLocationReference& from) {
    CopyFrom(from);
    return *this;
  }
  inline MapLocationReference& operator=(MapLocationReference&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MapLocationReference& default_instance() {
    return *internal_default_instance();
  }
  enum MapBasedReferenceCase {
    kTileLinkOffsetReference = 3,
    kMapObjectId = 4,
    MAP_BASED_REFERENCE_NOT_SET = 0,
  };

  static inline const MapLocationReference* internal_default_instance() {
    return reinterpret_cast<const MapLocationReference*>(
               &_MapLocationReference_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(MapLocationReference& a, MapLocationReference& b) {
    a.Swap(&b);
  }
  inline void Swap(MapLocationReference* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MapLocationReference* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MapLocationReference* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MapLocationReference>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MapLocationReference& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MapLocationReference& from) {
    MapLocationReference::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MapLocationReference* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.types.spatial.MapLocationReference";
  }
  protected:
  explicit MapLocationReference(::google::protobuf::Arena* arena);
  MapLocationReference(::google::protobuf::Arena* arena, const MapLocationReference& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using TileIdLinkIdOffset = MapLocationReference_TileIdLinkIdOffset;
  using TileIdObjectId = MapLocationReference_TileIdObjectId;

  // accessors -------------------------------------------------------

  enum : int {
    kExtensionFieldNumber = 15,
    kPositionAndAccuracyFieldNumber = 1,
    kZLevelFieldNumber = 2,
    kTileLinkOffsetReferenceFieldNumber = 3,
    kMapObjectIdFieldNumber = 4,
  };
  // repeated .google.protobuf.Any extension = 15;
  int extension_size() const;
  private:
  int _internal_extension_size() const;

  public:
  void clear_extension() ;
  ::google::protobuf::Any* mutable_extension(int index);
  ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >*
      mutable_extension();
  private:
  const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& _internal_extension() const;
  ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* _internal_mutable_extension();
  public:
  const ::google::protobuf::Any& extension(int index) const;
  ::google::protobuf::Any* add_extension();
  const ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >&
      extension() const;
  // .sensoris.protobuf.types.spatial.PositionAndAccuracy position_and_accuracy = 1;
  bool has_position_and_accuracy() const;
  void clear_position_and_accuracy() ;
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& position_and_accuracy() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::spatial::PositionAndAccuracy* release_position_and_accuracy();
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* mutable_position_and_accuracy();
  void set_allocated_position_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* value);
  void unsafe_arena_set_allocated_position_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* value);
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* unsafe_arena_release_position_and_accuracy();

  private:
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& _internal_position_and_accuracy() const;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* _internal_mutable_position_and_accuracy();

  public:
  // .google.protobuf.Int64Value z_level = 2;
  bool has_z_level() const;
  void clear_z_level() ;
  const ::google::protobuf::Int64Value& z_level() const;
  PROTOBUF_NODISCARD ::google::protobuf::Int64Value* release_z_level();
  ::google::protobuf::Int64Value* mutable_z_level();
  void set_allocated_z_level(::google::protobuf::Int64Value* value);
  void unsafe_arena_set_allocated_z_level(::google::protobuf::Int64Value* value);
  ::google::protobuf::Int64Value* unsafe_arena_release_z_level();

  private:
  const ::google::protobuf::Int64Value& _internal_z_level() const;
  ::google::protobuf::Int64Value* _internal_mutable_z_level();

  public:
  // .sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset tile_link_offset_reference = 3;
  bool has_tile_link_offset_reference() const;
  private:
  bool _internal_has_tile_link_offset_reference() const;

  public:
  void clear_tile_link_offset_reference() ;
  const ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset& tile_link_offset_reference() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset* release_tile_link_offset_reference();
  ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset* mutable_tile_link_offset_reference();
  void set_allocated_tile_link_offset_reference(::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset* value);
  void unsafe_arena_set_allocated_tile_link_offset_reference(::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset* value);
  ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset* unsafe_arena_release_tile_link_offset_reference();

  private:
  const ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset& _internal_tile_link_offset_reference() const;
  ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset* _internal_mutable_tile_link_offset_reference();

  public:
  // .sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId map_object_id = 4;
  bool has_map_object_id() const;
  private:
  bool _internal_has_map_object_id() const;

  public:
  void clear_map_object_id() ;
  const ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId& map_object_id() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId* release_map_object_id();
  ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId* mutable_map_object_id();
  void set_allocated_map_object_id(::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId* value);
  void unsafe_arena_set_allocated_map_object_id(::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId* value);
  ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId* unsafe_arena_release_map_object_id();

  private:
  const ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId& _internal_map_object_id() const;
  ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId* _internal_mutable_map_object_id();

  public:
  void clear_map_based_reference();
  MapBasedReferenceCase map_based_reference_case() const;
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.spatial.MapLocationReference)
 private:
  class _Internal;
  void set_has_tile_link_offset_reference();
  void set_has_map_object_id();

  inline bool has_map_based_reference() const;
  inline void clear_has_map_based_reference();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 5, 5,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any > extension_;
    ::sensoris::protobuf::types::spatial::PositionAndAccuracy* position_and_accuracy_;
    ::google::protobuf::Int64Value* z_level_;
    union MapBasedReferenceUnion {
      constexpr MapBasedReferenceUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset* tile_link_offset_reference_;
      ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId* map_object_id_;
    } map_based_reference_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto;
};// -------------------------------------------------------------------

class CircleAndAccuracy final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.spatial.CircleAndAccuracy) */ {
 public:
  inline CircleAndAccuracy() : CircleAndAccuracy(nullptr) {}
  ~CircleAndAccuracy() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CircleAndAccuracy(::google::protobuf::internal::ConstantInitialized);

  inline CircleAndAccuracy(const CircleAndAccuracy& from)
      : CircleAndAccuracy(nullptr, from) {}
  CircleAndAccuracy(CircleAndAccuracy&& from) noexcept
    : CircleAndAccuracy() {
    *this = ::std::move(from);
  }

  inline CircleAndAccuracy& operator=(const CircleAndAccuracy& from) {
    CopyFrom(from);
    return *this;
  }
  inline CircleAndAccuracy& operator=(CircleAndAccuracy&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CircleAndAccuracy& default_instance() {
    return *internal_default_instance();
  }
  static inline const CircleAndAccuracy* internal_default_instance() {
    return reinterpret_cast<const CircleAndAccuracy*>(
               &_CircleAndAccuracy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(CircleAndAccuracy& a, CircleAndAccuracy& b) {
    a.Swap(&b);
  }
  inline void Swap(CircleAndAccuracy* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CircleAndAccuracy* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CircleAndAccuracy* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CircleAndAccuracy>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CircleAndAccuracy& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CircleAndAccuracy& from) {
    CircleAndAccuracy::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CircleAndAccuracy* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.types.spatial.CircleAndAccuracy";
  }
  protected:
  explicit CircleAndAccuracy(::google::protobuf::Arena* arena);
  CircleAndAccuracy(::google::protobuf::Arena* arena, const CircleAndAccuracy& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExtensionFieldNumber = 15,
    kCenterPositionAndAccuracyFieldNumber = 1,
    kRadiusAndAccuracyFieldNumber = 2,
  };
  // repeated .google.protobuf.Any extension = 15;
  int extension_size() const;
  private:
  int _internal_extension_size() const;

  public:
  void clear_extension() ;
  ::google::protobuf::Any* mutable_extension(int index);
  ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >*
      mutable_extension();
  private:
  const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& _internal_extension() const;
  ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* _internal_mutable_extension();
  public:
  const ::google::protobuf::Any& extension(int index) const;
  ::google::protobuf::Any* add_extension();
  const ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >&
      extension() const;
  // .sensoris.protobuf.types.spatial.PositionAndAccuracy center_position_and_accuracy = 1;
  bool has_center_position_and_accuracy() const;
  void clear_center_position_and_accuracy() ;
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& center_position_and_accuracy() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::spatial::PositionAndAccuracy* release_center_position_and_accuracy();
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* mutable_center_position_and_accuracy();
  void set_allocated_center_position_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* value);
  void unsafe_arena_set_allocated_center_position_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* value);
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* unsafe_arena_release_center_position_and_accuracy();

  private:
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& _internal_center_position_and_accuracy() const;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* _internal_mutable_center_position_and_accuracy();

  public:
  // .sensoris.protobuf.types.base.Int64ValueAndAccuracy radius_and_accuracy = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_radius_and_accuracy() const;
  void clear_radius_and_accuracy() ;
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& radius_and_accuracy() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* release_radius_and_accuracy();
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* mutable_radius_and_accuracy();
  void set_allocated_radius_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* value);
  void unsafe_arena_set_allocated_radius_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* value);
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* unsafe_arena_release_radius_and_accuracy();

  private:
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& _internal_radius_and_accuracy() const;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* _internal_mutable_radius_and_accuracy();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.spatial.CircleAndAccuracy)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any > extension_;
    ::sensoris::protobuf::types::spatial::PositionAndAccuracy* center_position_and_accuracy_;
    ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* radius_and_accuracy_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto;
};// -------------------------------------------------------------------

class RectangularBoxAndAccuracy final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy) */ {
 public:
  inline RectangularBoxAndAccuracy() : RectangularBoxAndAccuracy(nullptr) {}
  ~RectangularBoxAndAccuracy() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RectangularBoxAndAccuracy(::google::protobuf::internal::ConstantInitialized);

  inline RectangularBoxAndAccuracy(const RectangularBoxAndAccuracy& from)
      : RectangularBoxAndAccuracy(nullptr, from) {}
  RectangularBoxAndAccuracy(RectangularBoxAndAccuracy&& from) noexcept
    : RectangularBoxAndAccuracy() {
    *this = ::std::move(from);
  }

  inline RectangularBoxAndAccuracy& operator=(const RectangularBoxAndAccuracy& from) {
    CopyFrom(from);
    return *this;
  }
  inline RectangularBoxAndAccuracy& operator=(RectangularBoxAndAccuracy&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RectangularBoxAndAccuracy& default_instance() {
    return *internal_default_instance();
  }
  enum GeometryCase {
    kCornerVectors = 1,
    kCenterOrientationSize = 2,
    GEOMETRY_NOT_SET = 0,
  };

  static inline const RectangularBoxAndAccuracy* internal_default_instance() {
    return reinterpret_cast<const RectangularBoxAndAccuracy*>(
               &_RectangularBoxAndAccuracy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(RectangularBoxAndAccuracy& a, RectangularBoxAndAccuracy& b) {
    a.Swap(&b);
  }
  inline void Swap(RectangularBoxAndAccuracy* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RectangularBoxAndAccuracy* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RectangularBoxAndAccuracy* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RectangularBoxAndAccuracy>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RectangularBoxAndAccuracy& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RectangularBoxAndAccuracy& from) {
    RectangularBoxAndAccuracy::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RectangularBoxAndAccuracy* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy";
  }
  protected:
  explicit RectangularBoxAndAccuracy(::google::protobuf::Arena* arena);
  RectangularBoxAndAccuracy(::google::protobuf::Arena* arena, const RectangularBoxAndAccuracy& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using CornerVectors = RectangularBoxAndAccuracy_CornerVectors;
  using CenterOrientationSize = RectangularBoxAndAccuracy_CenterOrientationSize;

  // accessors -------------------------------------------------------

  enum : int {
    kExtensionFieldNumber = 15,
    kCornerVectorsFieldNumber = 1,
    kCenterOrientationSizeFieldNumber = 2,
  };
  // repeated .google.protobuf.Any extension = 15;
  int extension_size() const;
  private:
  int _internal_extension_size() const;

  public:
  void clear_extension() ;
  ::google::protobuf::Any* mutable_extension(int index);
  ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >*
      mutable_extension();
  private:
  const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& _internal_extension() const;
  ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* _internal_mutable_extension();
  public:
  const ::google::protobuf::Any& extension(int index) const;
  ::google::protobuf::Any* add_extension();
  const ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >&
      extension() const;
  // .sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors corner_vectors = 1;
  bool has_corner_vectors() const;
  private:
  bool _internal_has_corner_vectors() const;

  public:
  void clear_corner_vectors() ;
  const ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors& corner_vectors() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors* release_corner_vectors();
  ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors* mutable_corner_vectors();
  void set_allocated_corner_vectors(::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors* value);
  void unsafe_arena_set_allocated_corner_vectors(::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors* value);
  ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors* unsafe_arena_release_corner_vectors();

  private:
  const ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors& _internal_corner_vectors() const;
  ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors* _internal_mutable_corner_vectors();

  public:
  // .sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize center_orientation_size = 2;
  bool has_center_orientation_size() const;
  private:
  bool _internal_has_center_orientation_size() const;

  public:
  void clear_center_orientation_size() ;
  const ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize& center_orientation_size() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize* release_center_orientation_size();
  ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize* mutable_center_orientation_size();
  void set_allocated_center_orientation_size(::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize* value);
  void unsafe_arena_set_allocated_center_orientation_size(::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize* value);
  ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize* unsafe_arena_release_center_orientation_size();

  private:
  const ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize& _internal_center_orientation_size() const;
  ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize* _internal_mutable_center_orientation_size();

  public:
  void clear_geometry();
  GeometryCase geometry_case() const;
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy)
 private:
  class _Internal;
  void set_has_corner_vectors();
  void set_has_center_orientation_size();

  inline bool has_geometry() const;
  inline void clear_has_geometry();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 3, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any > extension_;
    union GeometryUnion {
      constexpr GeometryUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors* corner_vectors_;
      ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize* center_orientation_size_;
    } geometry_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto;
};// -------------------------------------------------------------------

class PolylineCorridorAndAccuracy final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.spatial.PolylineCorridorAndAccuracy) */ {
 public:
  inline PolylineCorridorAndAccuracy() : PolylineCorridorAndAccuracy(nullptr) {}
  ~PolylineCorridorAndAccuracy() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PolylineCorridorAndAccuracy(::google::protobuf::internal::ConstantInitialized);

  inline PolylineCorridorAndAccuracy(const PolylineCorridorAndAccuracy& from)
      : PolylineCorridorAndAccuracy(nullptr, from) {}
  PolylineCorridorAndAccuracy(PolylineCorridorAndAccuracy&& from) noexcept
    : PolylineCorridorAndAccuracy() {
    *this = ::std::move(from);
  }

  inline PolylineCorridorAndAccuracy& operator=(const PolylineCorridorAndAccuracy& from) {
    CopyFrom(from);
    return *this;
  }
  inline PolylineCorridorAndAccuracy& operator=(PolylineCorridorAndAccuracy&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PolylineCorridorAndAccuracy& default_instance() {
    return *internal_default_instance();
  }
  static inline const PolylineCorridorAndAccuracy* internal_default_instance() {
    return reinterpret_cast<const PolylineCorridorAndAccuracy*>(
               &_PolylineCorridorAndAccuracy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(PolylineCorridorAndAccuracy& a, PolylineCorridorAndAccuracy& b) {
    a.Swap(&b);
  }
  inline void Swap(PolylineCorridorAndAccuracy* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PolylineCorridorAndAccuracy* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PolylineCorridorAndAccuracy* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PolylineCorridorAndAccuracy>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PolylineCorridorAndAccuracy& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PolylineCorridorAndAccuracy& from) {
    PolylineCorridorAndAccuracy::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PolylineCorridorAndAccuracy* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.types.spatial.PolylineCorridorAndAccuracy";
  }
  protected:
  explicit PolylineCorridorAndAccuracy(::google::protobuf::Arena* arena);
  PolylineCorridorAndAccuracy(::google::protobuf::Arena* arena, const PolylineCorridorAndAccuracy& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExtensionFieldNumber = 15,
    kCenterPolylineAndAccuracyFieldNumber = 1,
    kTotalWidthAndAccuracyFieldNumber = 2,
  };
  // repeated .google.protobuf.Any extension = 15;
  int extension_size() const;
  private:
  int _internal_extension_size() const;

  public:
  void clear_extension() ;
  ::google::protobuf::Any* mutable_extension(int index);
  ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >*
      mutable_extension();
  private:
  const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& _internal_extension() const;
  ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* _internal_mutable_extension();
  public:
  const ::google::protobuf::Any& extension(int index) const;
  ::google::protobuf::Any* add_extension();
  const ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >&
      extension() const;
  // .sensoris.protobuf.types.spatial.PolylineAndAccuracy center_polyline_and_accuracy = 1;
  bool has_center_polyline_and_accuracy() const;
  void clear_center_polyline_and_accuracy() ;
  const ::sensoris::protobuf::types::spatial::PolylineAndAccuracy& center_polyline_and_accuracy() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::spatial::PolylineAndAccuracy* release_center_polyline_and_accuracy();
  ::sensoris::protobuf::types::spatial::PolylineAndAccuracy* mutable_center_polyline_and_accuracy();
  void set_allocated_center_polyline_and_accuracy(::sensoris::protobuf::types::spatial::PolylineAndAccuracy* value);
  void unsafe_arena_set_allocated_center_polyline_and_accuracy(::sensoris::protobuf::types::spatial::PolylineAndAccuracy* value);
  ::sensoris::protobuf::types::spatial::PolylineAndAccuracy* unsafe_arena_release_center_polyline_and_accuracy();

  private:
  const ::sensoris::protobuf::types::spatial::PolylineAndAccuracy& _internal_center_polyline_and_accuracy() const;
  ::sensoris::protobuf::types::spatial::PolylineAndAccuracy* _internal_mutable_center_polyline_and_accuracy();

  public:
  // .sensoris.protobuf.types.base.Int64ValueAndAccuracy total_width_and_accuracy = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_total_width_and_accuracy() const;
  void clear_total_width_and_accuracy() ;
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& total_width_and_accuracy() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* release_total_width_and_accuracy();
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* mutable_total_width_and_accuracy();
  void set_allocated_total_width_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* value);
  void unsafe_arena_set_allocated_total_width_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* value);
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* unsafe_arena_release_total_width_and_accuracy();

  private:
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& _internal_total_width_and_accuracy() const;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* _internal_mutable_total_width_and_accuracy();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.spatial.PolylineCorridorAndAccuracy)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any > extension_;
    ::sensoris::protobuf::types::spatial::PolylineAndAccuracy* center_polyline_and_accuracy_;
    ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* total_width_and_accuracy_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto;
};// -------------------------------------------------------------------

class DirectedPolylineCorridor final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.spatial.DirectedPolylineCorridor) */ {
 public:
  inline DirectedPolylineCorridor() : DirectedPolylineCorridor(nullptr) {}
  ~DirectedPolylineCorridor() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DirectedPolylineCorridor(::google::protobuf::internal::ConstantInitialized);

  inline DirectedPolylineCorridor(const DirectedPolylineCorridor& from)
      : DirectedPolylineCorridor(nullptr, from) {}
  DirectedPolylineCorridor(DirectedPolylineCorridor&& from) noexcept
    : DirectedPolylineCorridor() {
    *this = ::std::move(from);
  }

  inline DirectedPolylineCorridor& operator=(const DirectedPolylineCorridor& from) {
    CopyFrom(from);
    return *this;
  }
  inline DirectedPolylineCorridor& operator=(DirectedPolylineCorridor&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DirectedPolylineCorridor& default_instance() {
    return *internal_default_instance();
  }
  static inline const DirectedPolylineCorridor* internal_default_instance() {
    return reinterpret_cast<const DirectedPolylineCorridor*>(
               &_DirectedPolylineCorridor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(DirectedPolylineCorridor& a, DirectedPolylineCorridor& b) {
    a.Swap(&b);
  }
  inline void Swap(DirectedPolylineCorridor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DirectedPolylineCorridor* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DirectedPolylineCorridor* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DirectedPolylineCorridor>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DirectedPolylineCorridor& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DirectedPolylineCorridor& from) {
    DirectedPolylineCorridor::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DirectedPolylineCorridor* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "sensoris.protobuf.types.spatial.DirectedPolylineCorridor";
  }
  protected:
  explicit DirectedPolylineCorridor(::google::protobuf::Arena* arena);
  DirectedPolylineCorridor(::google::protobuf::Arena* arena, const DirectedPolylineCorridor& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExtensionFieldNumber = 15,
    kPolylineCorridorFieldNumber = 1,
    kIsBidirectionalFieldNumber = 2,
    kHeadingDeviationFromCenterLineFieldNumber = 3,
  };
  // repeated .google.protobuf.Any extension = 15;
  int extension_size() const;
  private:
  int _internal_extension_size() const;

  public:
  void clear_extension() ;
  ::google::protobuf::Any* mutable_extension(int index);
  ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >*
      mutable_extension();
  private:
  const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& _internal_extension() const;
  ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* _internal_mutable_extension();
  public:
  const ::google::protobuf::Any& extension(int index) const;
  ::google::protobuf::Any* add_extension();
  const ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >&
      extension() const;
  // .sensoris.protobuf.types.spatial.PolylineCorridorAndAccuracy polyline_corridor = 1;
  bool has_polyline_corridor() const;
  void clear_polyline_corridor() ;
  const ::sensoris::protobuf::types::spatial::PolylineCorridorAndAccuracy& polyline_corridor() const;
  PROTOBUF_NODISCARD ::sensoris::protobuf::types::spatial::PolylineCorridorAndAccuracy* release_polyline_corridor();
  ::sensoris::protobuf::types::spatial::PolylineCorridorAndAccuracy* mutable_polyline_corridor();
  void set_allocated_polyline_corridor(::sensoris::protobuf::types::spatial::PolylineCorridorAndAccuracy* value);
  void unsafe_arena_set_allocated_polyline_corridor(::sensoris::protobuf::types::spatial::PolylineCorridorAndAccuracy* value);
  ::sensoris::protobuf::types::spatial::PolylineCorridorAndAccuracy* unsafe_arena_release_polyline_corridor();

  private:
  const ::sensoris::protobuf::types::spatial::PolylineCorridorAndAccuracy& _internal_polyline_corridor() const;
  ::sensoris::protobuf::types::spatial::PolylineCorridorAndAccuracy* _internal_mutable_polyline_corridor();

  public:
  // .google.protobuf.BoolValue is_bidirectional = 2;
  bool has_is_bidirectional() const;
  void clear_is_bidirectional() ;
  const ::google::protobuf::BoolValue& is_bidirectional() const;
  PROTOBUF_NODISCARD ::google::protobuf::BoolValue* release_is_bidirectional();
  ::google::protobuf::BoolValue* mutable_is_bidirectional();
  void set_allocated_is_bidirectional(::google::protobuf::BoolValue* value);
  void unsafe_arena_set_allocated_is_bidirectional(::google::protobuf::BoolValue* value);
  ::google::protobuf::BoolValue* unsafe_arena_release_is_bidirectional();

  private:
  const ::google::protobuf::BoolValue& _internal_is_bidirectional() const;
  ::google::protobuf::BoolValue* _internal_mutable_is_bidirectional();

  public:
  // .google.protobuf.Int64Value heading_deviation_from_center_line = 3;
  bool has_heading_deviation_from_center_line() const;
  void clear_heading_deviation_from_center_line() ;
  const ::google::protobuf::Int64Value& heading_deviation_from_center_line() const;
  PROTOBUF_NODISCARD ::google::protobuf::Int64Value* release_heading_deviation_from_center_line();
  ::google::protobuf::Int64Value* mutable_heading_deviation_from_center_line();
  void set_allocated_heading_deviation_from_center_line(::google::protobuf::Int64Value* value);
  void unsafe_arena_set_allocated_heading_deviation_from_center_line(::google::protobuf::Int64Value* value);
  ::google::protobuf::Int64Value* unsafe_arena_release_heading_deviation_from_center_line();

  private:
  const ::google::protobuf::Int64Value& _internal_heading_deviation_from_center_line() const;
  ::google::protobuf::Int64Value* _internal_mutable_heading_deviation_from_center_line();

  public:
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.spatial.DirectedPolylineCorridor)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 4, 4,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any > extension_;
    ::sensoris::protobuf::types::spatial::PolylineCorridorAndAccuracy* polyline_corridor_;
    ::google::protobuf::BoolValue* is_bidirectional_;
    ::google::protobuf::Int64Value* heading_deviation_from_center_line_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// PositionAndAccuracy_Geographic

// .sensoris.protobuf.types.base.Int64Value longitude = 1 [(.sensoris.protobuf.types.base.exponent) = 8];
inline bool PositionAndAccuracy_Geographic::has_longitude() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.longitude_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Int64Value& PositionAndAccuracy_Geographic::_internal_longitude() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::Int64Value* p = _impl_.longitude_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Int64Value&>(::sensoris::protobuf::types::base::_Int64Value_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64Value& PositionAndAccuracy_Geographic::longitude() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic.longitude)
  return _internal_longitude();
}
inline void PositionAndAccuracy_Geographic::unsafe_arena_set_allocated_longitude(::sensoris::protobuf::types::base::Int64Value* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.longitude_);
  }
  _impl_.longitude_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic.longitude)
}
inline ::sensoris::protobuf::types::base::Int64Value* PositionAndAccuracy_Geographic::release_longitude() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Int64Value* released = _impl_.longitude_;
  _impl_.longitude_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::Int64Value* PositionAndAccuracy_Geographic::unsafe_arena_release_longitude() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic.longitude)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Int64Value* temp = _impl_.longitude_;
  _impl_.longitude_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* PositionAndAccuracy_Geographic::_internal_mutable_longitude() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.longitude_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64Value>(GetArena());
    _impl_.longitude_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(p);
  }
  return _impl_.longitude_;
}
inline ::sensoris::protobuf::types::base::Int64Value* PositionAndAccuracy_Geographic::mutable_longitude() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::Int64Value* _msg = _internal_mutable_longitude();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic.longitude)
  return _msg;
}
inline void PositionAndAccuracy_Geographic::set_allocated_longitude(::sensoris::protobuf::types::base::Int64Value* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.longitude_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.longitude_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic.longitude)
}

// .sensoris.protobuf.types.base.Int64Value latitude = 2 [(.sensoris.protobuf.types.base.exponent) = 8];
inline bool PositionAndAccuracy_Geographic::has_latitude() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.latitude_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Int64Value& PositionAndAccuracy_Geographic::_internal_latitude() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::Int64Value* p = _impl_.latitude_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Int64Value&>(::sensoris::protobuf::types::base::_Int64Value_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64Value& PositionAndAccuracy_Geographic::latitude() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic.latitude)
  return _internal_latitude();
}
inline void PositionAndAccuracy_Geographic::unsafe_arena_set_allocated_latitude(::sensoris::protobuf::types::base::Int64Value* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.latitude_);
  }
  _impl_.latitude_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic.latitude)
}
inline ::sensoris::protobuf::types::base::Int64Value* PositionAndAccuracy_Geographic::release_latitude() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::Int64Value* released = _impl_.latitude_;
  _impl_.latitude_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::Int64Value* PositionAndAccuracy_Geographic::unsafe_arena_release_latitude() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic.latitude)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::Int64Value* temp = _impl_.latitude_;
  _impl_.latitude_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* PositionAndAccuracy_Geographic::_internal_mutable_latitude() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.latitude_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64Value>(GetArena());
    _impl_.latitude_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(p);
  }
  return _impl_.latitude_;
}
inline ::sensoris::protobuf::types::base::Int64Value* PositionAndAccuracy_Geographic::mutable_latitude() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::Int64Value* _msg = _internal_mutable_latitude();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic.latitude)
  return _msg;
}
inline void PositionAndAccuracy_Geographic::set_allocated_latitude(::sensoris::protobuf::types::base::Int64Value* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.latitude_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.latitude_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic.latitude)
}

// .sensoris.protobuf.types.base.Int64Value altitude = 3 [(.sensoris.protobuf.types.base.exponent) = 3];
inline bool PositionAndAccuracy_Geographic::has_altitude() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.altitude_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Int64Value& PositionAndAccuracy_Geographic::_internal_altitude() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::Int64Value* p = _impl_.altitude_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Int64Value&>(::sensoris::protobuf::types::base::_Int64Value_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64Value& PositionAndAccuracy_Geographic::altitude() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic.altitude)
  return _internal_altitude();
}
inline void PositionAndAccuracy_Geographic::unsafe_arena_set_allocated_altitude(::sensoris::protobuf::types::base::Int64Value* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.altitude_);
  }
  _impl_.altitude_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic.altitude)
}
inline ::sensoris::protobuf::types::base::Int64Value* PositionAndAccuracy_Geographic::release_altitude() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::types::base::Int64Value* released = _impl_.altitude_;
  _impl_.altitude_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::Int64Value* PositionAndAccuracy_Geographic::unsafe_arena_release_altitude() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic.altitude)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::types::base::Int64Value* temp = _impl_.altitude_;
  _impl_.altitude_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* PositionAndAccuracy_Geographic::_internal_mutable_altitude() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.altitude_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64Value>(GetArena());
    _impl_.altitude_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(p);
  }
  return _impl_.altitude_;
}
inline ::sensoris::protobuf::types::base::Int64Value* PositionAndAccuracy_Geographic::mutable_altitude() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::Int64Value* _msg = _internal_mutable_altitude();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic.altitude)
  return _msg;
}
inline void PositionAndAccuracy_Geographic::set_allocated_altitude(::sensoris::protobuf::types::base::Int64Value* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.altitude_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.altitude_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic.altitude)
}

// -------------------------------------------------------------------

// PositionAndAccuracy_Metric

// .sensoris.protobuf.types.base.Int64Value x = 1 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool PositionAndAccuracy_Metric::has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.x_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Int64Value& PositionAndAccuracy_Metric::_internal_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::Int64Value* p = _impl_.x_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Int64Value&>(::sensoris::protobuf::types::base::_Int64Value_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64Value& PositionAndAccuracy_Metric::x() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric.x)
  return _internal_x();
}
inline void PositionAndAccuracy_Metric::unsafe_arena_set_allocated_x(::sensoris::protobuf::types::base::Int64Value* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.x_);
  }
  _impl_.x_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric.x)
}
inline ::sensoris::protobuf::types::base::Int64Value* PositionAndAccuracy_Metric::release_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Int64Value* released = _impl_.x_;
  _impl_.x_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::Int64Value* PositionAndAccuracy_Metric::unsafe_arena_release_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric.x)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Int64Value* temp = _impl_.x_;
  _impl_.x_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* PositionAndAccuracy_Metric::_internal_mutable_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.x_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64Value>(GetArena());
    _impl_.x_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(p);
  }
  return _impl_.x_;
}
inline ::sensoris::protobuf::types::base::Int64Value* PositionAndAccuracy_Metric::mutable_x() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::Int64Value* _msg = _internal_mutable_x();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric.x)
  return _msg;
}
inline void PositionAndAccuracy_Metric::set_allocated_x(::sensoris::protobuf::types::base::Int64Value* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.x_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.x_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric.x)
}

// .sensoris.protobuf.types.base.Int64Value y = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool PositionAndAccuracy_Metric::has_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.y_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Int64Value& PositionAndAccuracy_Metric::_internal_y() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::Int64Value* p = _impl_.y_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Int64Value&>(::sensoris::protobuf::types::base::_Int64Value_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64Value& PositionAndAccuracy_Metric::y() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric.y)
  return _internal_y();
}
inline void PositionAndAccuracy_Metric::unsafe_arena_set_allocated_y(::sensoris::protobuf::types::base::Int64Value* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.y_);
  }
  _impl_.y_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric.y)
}
inline ::sensoris::protobuf::types::base::Int64Value* PositionAndAccuracy_Metric::release_y() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::Int64Value* released = _impl_.y_;
  _impl_.y_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::Int64Value* PositionAndAccuracy_Metric::unsafe_arena_release_y() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric.y)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::Int64Value* temp = _impl_.y_;
  _impl_.y_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* PositionAndAccuracy_Metric::_internal_mutable_y() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.y_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64Value>(GetArena());
    _impl_.y_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(p);
  }
  return _impl_.y_;
}
inline ::sensoris::protobuf::types::base::Int64Value* PositionAndAccuracy_Metric::mutable_y() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::Int64Value* _msg = _internal_mutable_y();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric.y)
  return _msg;
}
inline void PositionAndAccuracy_Metric::set_allocated_y(::sensoris::protobuf::types::base::Int64Value* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.y_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.y_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric.y)
}

// .sensoris.protobuf.types.base.Int64Value z = 3 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool PositionAndAccuracy_Metric::has_z() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.z_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Int64Value& PositionAndAccuracy_Metric::_internal_z() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::Int64Value* p = _impl_.z_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Int64Value&>(::sensoris::protobuf::types::base::_Int64Value_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64Value& PositionAndAccuracy_Metric::z() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric.z)
  return _internal_z();
}
inline void PositionAndAccuracy_Metric::unsafe_arena_set_allocated_z(::sensoris::protobuf::types::base::Int64Value* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.z_);
  }
  _impl_.z_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric.z)
}
inline ::sensoris::protobuf::types::base::Int64Value* PositionAndAccuracy_Metric::release_z() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::types::base::Int64Value* released = _impl_.z_;
  _impl_.z_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::Int64Value* PositionAndAccuracy_Metric::unsafe_arena_release_z() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric.z)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::types::base::Int64Value* temp = _impl_.z_;
  _impl_.z_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* PositionAndAccuracy_Metric::_internal_mutable_z() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.z_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64Value>(GetArena());
    _impl_.z_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(p);
  }
  return _impl_.z_;
}
inline ::sensoris::protobuf::types::base::Int64Value* PositionAndAccuracy_Metric::mutable_z() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::Int64Value* _msg = _internal_mutable_z();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric.z)
  return _msg;
}
inline void PositionAndAccuracy_Metric::set_allocated_z(::sensoris::protobuf::types::base::Int64Value* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.z_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.z_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric.z)
}

// -------------------------------------------------------------------

// PositionAndAccuracy_HorizontalVerticalStdDev

// .google.protobuf.Int64Value horizontal = 1 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool PositionAndAccuracy_HorizontalVerticalStdDev::has_horizontal() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.horizontal_ != nullptr);
  return value;
}
inline const ::google::protobuf::Int64Value& PositionAndAccuracy_HorizontalVerticalStdDev::_internal_horizontal() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Int64Value* p = _impl_.horizontal_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Int64Value&>(::google::protobuf::_Int64Value_default_instance_);
}
inline const ::google::protobuf::Int64Value& PositionAndAccuracy_HorizontalVerticalStdDev::horizontal() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalVerticalStdDev.horizontal)
  return _internal_horizontal();
}
inline void PositionAndAccuracy_HorizontalVerticalStdDev::unsafe_arena_set_allocated_horizontal(::google::protobuf::Int64Value* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.horizontal_);
  }
  _impl_.horizontal_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalVerticalStdDev.horizontal)
}
inline ::google::protobuf::Int64Value* PositionAndAccuracy_HorizontalVerticalStdDev::release_horizontal() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Int64Value* released = _impl_.horizontal_;
  _impl_.horizontal_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Int64Value* PositionAndAccuracy_HorizontalVerticalStdDev::unsafe_arena_release_horizontal() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalVerticalStdDev.horizontal)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Int64Value* temp = _impl_.horizontal_;
  _impl_.horizontal_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int64Value* PositionAndAccuracy_HorizontalVerticalStdDev::_internal_mutable_horizontal() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.horizontal_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int64Value>(GetArena());
    _impl_.horizontal_ = reinterpret_cast<::google::protobuf::Int64Value*>(p);
  }
  return _impl_.horizontal_;
}
inline ::google::protobuf::Int64Value* PositionAndAccuracy_HorizontalVerticalStdDev::mutable_horizontal() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Int64Value* _msg = _internal_mutable_horizontal();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalVerticalStdDev.horizontal)
  return _msg;
}
inline void PositionAndAccuracy_HorizontalVerticalStdDev::set_allocated_horizontal(::google::protobuf::Int64Value* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.horizontal_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.horizontal_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalVerticalStdDev.horizontal)
}

// .google.protobuf.Int64Value vertical = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool PositionAndAccuracy_HorizontalVerticalStdDev::has_vertical() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.vertical_ != nullptr);
  return value;
}
inline const ::google::protobuf::Int64Value& PositionAndAccuracy_HorizontalVerticalStdDev::_internal_vertical() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Int64Value* p = _impl_.vertical_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Int64Value&>(::google::protobuf::_Int64Value_default_instance_);
}
inline const ::google::protobuf::Int64Value& PositionAndAccuracy_HorizontalVerticalStdDev::vertical() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalVerticalStdDev.vertical)
  return _internal_vertical();
}
inline void PositionAndAccuracy_HorizontalVerticalStdDev::unsafe_arena_set_allocated_vertical(::google::protobuf::Int64Value* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.vertical_);
  }
  _impl_.vertical_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalVerticalStdDev.vertical)
}
inline ::google::protobuf::Int64Value* PositionAndAccuracy_HorizontalVerticalStdDev::release_vertical() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Int64Value* released = _impl_.vertical_;
  _impl_.vertical_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Int64Value* PositionAndAccuracy_HorizontalVerticalStdDev::unsafe_arena_release_vertical() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalVerticalStdDev.vertical)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Int64Value* temp = _impl_.vertical_;
  _impl_.vertical_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int64Value* PositionAndAccuracy_HorizontalVerticalStdDev::_internal_mutable_vertical() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.vertical_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int64Value>(GetArena());
    _impl_.vertical_ = reinterpret_cast<::google::protobuf::Int64Value*>(p);
  }
  return _impl_.vertical_;
}
inline ::google::protobuf::Int64Value* PositionAndAccuracy_HorizontalVerticalStdDev::mutable_vertical() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Int64Value* _msg = _internal_mutable_vertical();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalVerticalStdDev.vertical)
  return _msg;
}
inline void PositionAndAccuracy_HorizontalVerticalStdDev::set_allocated_vertical(::google::protobuf::Int64Value* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.vertical_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.vertical_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalVerticalStdDev.vertical)
}

// -------------------------------------------------------------------

// PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev

// .google.protobuf.Int64Value horizontal_ellipse_major = 1 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::has_horizontal_ellipse_major() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.horizontal_ellipse_major_ != nullptr);
  return value;
}
inline const ::google::protobuf::Int64Value& PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::_internal_horizontal_ellipse_major() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Int64Value* p = _impl_.horizontal_ellipse_major_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Int64Value&>(::google::protobuf::_Int64Value_default_instance_);
}
inline const ::google::protobuf::Int64Value& PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::horizontal_ellipse_major() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev.horizontal_ellipse_major)
  return _internal_horizontal_ellipse_major();
}
inline void PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::unsafe_arena_set_allocated_horizontal_ellipse_major(::google::protobuf::Int64Value* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.horizontal_ellipse_major_);
  }
  _impl_.horizontal_ellipse_major_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev.horizontal_ellipse_major)
}
inline ::google::protobuf::Int64Value* PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::release_horizontal_ellipse_major() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Int64Value* released = _impl_.horizontal_ellipse_major_;
  _impl_.horizontal_ellipse_major_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Int64Value* PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::unsafe_arena_release_horizontal_ellipse_major() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev.horizontal_ellipse_major)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Int64Value* temp = _impl_.horizontal_ellipse_major_;
  _impl_.horizontal_ellipse_major_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int64Value* PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::_internal_mutable_horizontal_ellipse_major() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.horizontal_ellipse_major_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int64Value>(GetArena());
    _impl_.horizontal_ellipse_major_ = reinterpret_cast<::google::protobuf::Int64Value*>(p);
  }
  return _impl_.horizontal_ellipse_major_;
}
inline ::google::protobuf::Int64Value* PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::mutable_horizontal_ellipse_major() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Int64Value* _msg = _internal_mutable_horizontal_ellipse_major();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev.horizontal_ellipse_major)
  return _msg;
}
inline void PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::set_allocated_horizontal_ellipse_major(::google::protobuf::Int64Value* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.horizontal_ellipse_major_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.horizontal_ellipse_major_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev.horizontal_ellipse_major)
}

// .google.protobuf.Int64Value horizontal_ellipse_minor = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::has_horizontal_ellipse_minor() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.horizontal_ellipse_minor_ != nullptr);
  return value;
}
inline const ::google::protobuf::Int64Value& PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::_internal_horizontal_ellipse_minor() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Int64Value* p = _impl_.horizontal_ellipse_minor_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Int64Value&>(::google::protobuf::_Int64Value_default_instance_);
}
inline const ::google::protobuf::Int64Value& PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::horizontal_ellipse_minor() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev.horizontal_ellipse_minor)
  return _internal_horizontal_ellipse_minor();
}
inline void PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::unsafe_arena_set_allocated_horizontal_ellipse_minor(::google::protobuf::Int64Value* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.horizontal_ellipse_minor_);
  }
  _impl_.horizontal_ellipse_minor_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev.horizontal_ellipse_minor)
}
inline ::google::protobuf::Int64Value* PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::release_horizontal_ellipse_minor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Int64Value* released = _impl_.horizontal_ellipse_minor_;
  _impl_.horizontal_ellipse_minor_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Int64Value* PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::unsafe_arena_release_horizontal_ellipse_minor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev.horizontal_ellipse_minor)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Int64Value* temp = _impl_.horizontal_ellipse_minor_;
  _impl_.horizontal_ellipse_minor_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int64Value* PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::_internal_mutable_horizontal_ellipse_minor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.horizontal_ellipse_minor_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int64Value>(GetArena());
    _impl_.horizontal_ellipse_minor_ = reinterpret_cast<::google::protobuf::Int64Value*>(p);
  }
  return _impl_.horizontal_ellipse_minor_;
}
inline ::google::protobuf::Int64Value* PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::mutable_horizontal_ellipse_minor() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Int64Value* _msg = _internal_mutable_horizontal_ellipse_minor();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev.horizontal_ellipse_minor)
  return _msg;
}
inline void PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::set_allocated_horizontal_ellipse_minor(::google::protobuf::Int64Value* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.horizontal_ellipse_minor_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.horizontal_ellipse_minor_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev.horizontal_ellipse_minor)
}

// .google.protobuf.Int64Value horizontal_ellipse_major_heading = 3 [(.sensoris.protobuf.types.base.exponent) = 2];
inline bool PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::has_horizontal_ellipse_major_heading() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.horizontal_ellipse_major_heading_ != nullptr);
  return value;
}
inline const ::google::protobuf::Int64Value& PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::_internal_horizontal_ellipse_major_heading() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Int64Value* p = _impl_.horizontal_ellipse_major_heading_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Int64Value&>(::google::protobuf::_Int64Value_default_instance_);
}
inline const ::google::protobuf::Int64Value& PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::horizontal_ellipse_major_heading() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev.horizontal_ellipse_major_heading)
  return _internal_horizontal_ellipse_major_heading();
}
inline void PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::unsafe_arena_set_allocated_horizontal_ellipse_major_heading(::google::protobuf::Int64Value* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.horizontal_ellipse_major_heading_);
  }
  _impl_.horizontal_ellipse_major_heading_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev.horizontal_ellipse_major_heading)
}
inline ::google::protobuf::Int64Value* PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::release_horizontal_ellipse_major_heading() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Int64Value* released = _impl_.horizontal_ellipse_major_heading_;
  _impl_.horizontal_ellipse_major_heading_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Int64Value* PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::unsafe_arena_release_horizontal_ellipse_major_heading() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev.horizontal_ellipse_major_heading)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Int64Value* temp = _impl_.horizontal_ellipse_major_heading_;
  _impl_.horizontal_ellipse_major_heading_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int64Value* PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::_internal_mutable_horizontal_ellipse_major_heading() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.horizontal_ellipse_major_heading_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int64Value>(GetArena());
    _impl_.horizontal_ellipse_major_heading_ = reinterpret_cast<::google::protobuf::Int64Value*>(p);
  }
  return _impl_.horizontal_ellipse_major_heading_;
}
inline ::google::protobuf::Int64Value* PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::mutable_horizontal_ellipse_major_heading() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Int64Value* _msg = _internal_mutable_horizontal_ellipse_major_heading();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev.horizontal_ellipse_major_heading)
  return _msg;
}
inline void PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::set_allocated_horizontal_ellipse_major_heading(::google::protobuf::Int64Value* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.horizontal_ellipse_major_heading_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.horizontal_ellipse_major_heading_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev.horizontal_ellipse_major_heading)
}

// .google.protobuf.Int64Value vertical = 4 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::has_vertical() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.vertical_ != nullptr);
  return value;
}
inline const ::google::protobuf::Int64Value& PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::_internal_vertical() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Int64Value* p = _impl_.vertical_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Int64Value&>(::google::protobuf::_Int64Value_default_instance_);
}
inline const ::google::protobuf::Int64Value& PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::vertical() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev.vertical)
  return _internal_vertical();
}
inline void PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::unsafe_arena_set_allocated_vertical(::google::protobuf::Int64Value* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.vertical_);
  }
  _impl_.vertical_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev.vertical)
}
inline ::google::protobuf::Int64Value* PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::release_vertical() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::google::protobuf::Int64Value* released = _impl_.vertical_;
  _impl_.vertical_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Int64Value* PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::unsafe_arena_release_vertical() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev.vertical)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::google::protobuf::Int64Value* temp = _impl_.vertical_;
  _impl_.vertical_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int64Value* PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::_internal_mutable_vertical() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.vertical_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int64Value>(GetArena());
    _impl_.vertical_ = reinterpret_cast<::google::protobuf::Int64Value*>(p);
  }
  return _impl_.vertical_;
}
inline ::google::protobuf::Int64Value* PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::mutable_vertical() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Int64Value* _msg = _internal_mutable_vertical();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev.vertical)
  return _msg;
}
inline void PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::set_allocated_vertical(::google::protobuf::Int64Value* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.vertical_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.vertical_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev.vertical)
}

// -------------------------------------------------------------------

// PositionAndAccuracy

// .sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic geographic_wgs84 = 1;
inline bool PositionAndAccuracy::has_geographic_wgs84() const {
  return geographic_metric_case() == kGeographicWgs84;
}
inline bool PositionAndAccuracy::_internal_has_geographic_wgs84() const {
  return geographic_metric_case() == kGeographicWgs84;
}
inline void PositionAndAccuracy::set_has_geographic_wgs84() {
  _impl_._oneof_case_[0] = kGeographicWgs84;
}
inline void PositionAndAccuracy::clear_geographic_wgs84() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (geographic_metric_case() == kGeographicWgs84) {
    if (GetArena() == nullptr) {
      delete _impl_.geographic_metric_.geographic_wgs84_;
    }
    clear_has_geographic_metric();
  }
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic* PositionAndAccuracy::release_geographic_wgs84() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.geographic_wgs84)
  if (geographic_metric_case() == kGeographicWgs84) {
    clear_has_geographic_metric();
    auto* temp = _impl_.geographic_metric_.geographic_wgs84_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.geographic_metric_.geographic_wgs84_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic& PositionAndAccuracy::_internal_geographic_wgs84() const {
  return geographic_metric_case() == kGeographicWgs84 ? *_impl_.geographic_metric_.geographic_wgs84_ : reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic&>(::sensoris::protobuf::types::spatial::_PositionAndAccuracy_Geographic_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic& PositionAndAccuracy::geographic_wgs84() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PositionAndAccuracy.geographic_wgs84)
  return _internal_geographic_wgs84();
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic* PositionAndAccuracy::unsafe_arena_release_geographic_wgs84() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.geographic_wgs84)
  if (geographic_metric_case() == kGeographicWgs84) {
    clear_has_geographic_metric();
    auto* temp = _impl_.geographic_metric_.geographic_wgs84_;
    _impl_.geographic_metric_.geographic_wgs84_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PositionAndAccuracy::unsafe_arena_set_allocated_geographic_wgs84(::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_geographic_metric();
  if (value) {
    set_has_geographic_wgs84();
    _impl_.geographic_metric_.geographic_wgs84_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.geographic_wgs84)
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic* PositionAndAccuracy::_internal_mutable_geographic_wgs84() {
  if (geographic_metric_case() != kGeographicWgs84) {
    clear_geographic_metric();
    set_has_geographic_wgs84();
    _impl_.geographic_metric_.geographic_wgs84_ = CreateMaybeMessage<::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic>(GetArena());
  }
  return _impl_.geographic_metric_.geographic_wgs84_;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic* PositionAndAccuracy::mutable_geographic_wgs84() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic* _msg = _internal_mutable_geographic_wgs84();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PositionAndAccuracy.geographic_wgs84)
  return _msg;
}

// .sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric metric_vehicle = 2;
inline bool PositionAndAccuracy::has_metric_vehicle() const {
  return geographic_metric_case() == kMetricVehicle;
}
inline bool PositionAndAccuracy::_internal_has_metric_vehicle() const {
  return geographic_metric_case() == kMetricVehicle;
}
inline void PositionAndAccuracy::set_has_metric_vehicle() {
  _impl_._oneof_case_[0] = kMetricVehicle;
}
inline void PositionAndAccuracy::clear_metric_vehicle() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (geographic_metric_case() == kMetricVehicle) {
    if (GetArena() == nullptr) {
      delete _impl_.geographic_metric_.metric_vehicle_;
    }
    clear_has_geographic_metric();
  }
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* PositionAndAccuracy::release_metric_vehicle() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.metric_vehicle)
  if (geographic_metric_case() == kMetricVehicle) {
    clear_has_geographic_metric();
    auto* temp = _impl_.geographic_metric_.metric_vehicle_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.geographic_metric_.metric_vehicle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric& PositionAndAccuracy::_internal_metric_vehicle() const {
  return geographic_metric_case() == kMetricVehicle ? *_impl_.geographic_metric_.metric_vehicle_ : reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric&>(::sensoris::protobuf::types::spatial::_PositionAndAccuracy_Metric_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric& PositionAndAccuracy::metric_vehicle() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PositionAndAccuracy.metric_vehicle)
  return _internal_metric_vehicle();
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* PositionAndAccuracy::unsafe_arena_release_metric_vehicle() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.metric_vehicle)
  if (geographic_metric_case() == kMetricVehicle) {
    clear_has_geographic_metric();
    auto* temp = _impl_.geographic_metric_.metric_vehicle_;
    _impl_.geographic_metric_.metric_vehicle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PositionAndAccuracy::unsafe_arena_set_allocated_metric_vehicle(::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_geographic_metric();
  if (value) {
    set_has_metric_vehicle();
    _impl_.geographic_metric_.metric_vehicle_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.metric_vehicle)
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* PositionAndAccuracy::_internal_mutable_metric_vehicle() {
  if (geographic_metric_case() != kMetricVehicle) {
    clear_geographic_metric();
    set_has_metric_vehicle();
    _impl_.geographic_metric_.metric_vehicle_ = CreateMaybeMessage<::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric>(GetArena());
  }
  return _impl_.geographic_metric_.metric_vehicle_;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* PositionAndAccuracy::mutable_metric_vehicle() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* _msg = _internal_mutable_metric_vehicle();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PositionAndAccuracy.metric_vehicle)
  return _msg;
}

// .sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric metric_event_group = 3;
inline bool PositionAndAccuracy::has_metric_event_group() const {
  return geographic_metric_case() == kMetricEventGroup;
}
inline bool PositionAndAccuracy::_internal_has_metric_event_group() const {
  return geographic_metric_case() == kMetricEventGroup;
}
inline void PositionAndAccuracy::set_has_metric_event_group() {
  _impl_._oneof_case_[0] = kMetricEventGroup;
}
inline void PositionAndAccuracy::clear_metric_event_group() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (geographic_metric_case() == kMetricEventGroup) {
    if (GetArena() == nullptr) {
      delete _impl_.geographic_metric_.metric_event_group_;
    }
    clear_has_geographic_metric();
  }
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* PositionAndAccuracy::release_metric_event_group() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.metric_event_group)
  if (geographic_metric_case() == kMetricEventGroup) {
    clear_has_geographic_metric();
    auto* temp = _impl_.geographic_metric_.metric_event_group_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.geographic_metric_.metric_event_group_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric& PositionAndAccuracy::_internal_metric_event_group() const {
  return geographic_metric_case() == kMetricEventGroup ? *_impl_.geographic_metric_.metric_event_group_ : reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric&>(::sensoris::protobuf::types::spatial::_PositionAndAccuracy_Metric_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric& PositionAndAccuracy::metric_event_group() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PositionAndAccuracy.metric_event_group)
  return _internal_metric_event_group();
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* PositionAndAccuracy::unsafe_arena_release_metric_event_group() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.metric_event_group)
  if (geographic_metric_case() == kMetricEventGroup) {
    clear_has_geographic_metric();
    auto* temp = _impl_.geographic_metric_.metric_event_group_;
    _impl_.geographic_metric_.metric_event_group_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PositionAndAccuracy::unsafe_arena_set_allocated_metric_event_group(::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_geographic_metric();
  if (value) {
    set_has_metric_event_group();
    _impl_.geographic_metric_.metric_event_group_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.metric_event_group)
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* PositionAndAccuracy::_internal_mutable_metric_event_group() {
  if (geographic_metric_case() != kMetricEventGroup) {
    clear_geographic_metric();
    set_has_metric_event_group();
    _impl_.geographic_metric_.metric_event_group_ = CreateMaybeMessage<::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric>(GetArena());
  }
  return _impl_.geographic_metric_.metric_event_group_;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* PositionAndAccuracy::mutable_metric_event_group() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* _msg = _internal_mutable_metric_event_group();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PositionAndAccuracy.metric_event_group)
  return _msg;
}

// .sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric metric_ecef = 4;
inline bool PositionAndAccuracy::has_metric_ecef() const {
  return geographic_metric_case() == kMetricEcef;
}
inline bool PositionAndAccuracy::_internal_has_metric_ecef() const {
  return geographic_metric_case() == kMetricEcef;
}
inline void PositionAndAccuracy::set_has_metric_ecef() {
  _impl_._oneof_case_[0] = kMetricEcef;
}
inline void PositionAndAccuracy::clear_metric_ecef() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (geographic_metric_case() == kMetricEcef) {
    if (GetArena() == nullptr) {
      delete _impl_.geographic_metric_.metric_ecef_;
    }
    clear_has_geographic_metric();
  }
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* PositionAndAccuracy::release_metric_ecef() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.metric_ecef)
  if (geographic_metric_case() == kMetricEcef) {
    clear_has_geographic_metric();
    auto* temp = _impl_.geographic_metric_.metric_ecef_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.geographic_metric_.metric_ecef_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric& PositionAndAccuracy::_internal_metric_ecef() const {
  return geographic_metric_case() == kMetricEcef ? *_impl_.geographic_metric_.metric_ecef_ : reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric&>(::sensoris::protobuf::types::spatial::_PositionAndAccuracy_Metric_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric& PositionAndAccuracy::metric_ecef() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PositionAndAccuracy.metric_ecef)
  return _internal_metric_ecef();
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* PositionAndAccuracy::unsafe_arena_release_metric_ecef() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.metric_ecef)
  if (geographic_metric_case() == kMetricEcef) {
    clear_has_geographic_metric();
    auto* temp = _impl_.geographic_metric_.metric_ecef_;
    _impl_.geographic_metric_.metric_ecef_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PositionAndAccuracy::unsafe_arena_set_allocated_metric_ecef(::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_geographic_metric();
  if (value) {
    set_has_metric_ecef();
    _impl_.geographic_metric_.metric_ecef_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.metric_ecef)
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* PositionAndAccuracy::_internal_mutable_metric_ecef() {
  if (geographic_metric_case() != kMetricEcef) {
    clear_geographic_metric();
    set_has_metric_ecef();
    _impl_.geographic_metric_.metric_ecef_ = CreateMaybeMessage<::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric>(GetArena());
  }
  return _impl_.geographic_metric_.metric_ecef_;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* PositionAndAccuracy::mutable_metric_ecef() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* _msg = _internal_mutable_metric_ecef();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PositionAndAccuracy.metric_ecef)
  return _msg;
}

// .google.protobuf.Int64Value combined_std_dev = 5 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool PositionAndAccuracy::has_combined_std_dev() const {
  return accuracy_case() == kCombinedStdDev;
}
inline bool PositionAndAccuracy::_internal_has_combined_std_dev() const {
  return accuracy_case() == kCombinedStdDev;
}
inline void PositionAndAccuracy::set_has_combined_std_dev() {
  _impl_._oneof_case_[1] = kCombinedStdDev;
}
inline ::google::protobuf::Int64Value* PositionAndAccuracy::release_combined_std_dev() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.combined_std_dev)
  if (accuracy_case() == kCombinedStdDev) {
    clear_has_accuracy();
    auto* temp = _impl_.accuracy_.combined_std_dev_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.accuracy_.combined_std_dev_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::protobuf::Int64Value& PositionAndAccuracy::_internal_combined_std_dev() const {
  return accuracy_case() == kCombinedStdDev ? *_impl_.accuracy_.combined_std_dev_ : reinterpret_cast<::google::protobuf::Int64Value&>(::google::protobuf::_Int64Value_default_instance_);
}
inline const ::google::protobuf::Int64Value& PositionAndAccuracy::combined_std_dev() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PositionAndAccuracy.combined_std_dev)
  return _internal_combined_std_dev();
}
inline ::google::protobuf::Int64Value* PositionAndAccuracy::unsafe_arena_release_combined_std_dev() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.combined_std_dev)
  if (accuracy_case() == kCombinedStdDev) {
    clear_has_accuracy();
    auto* temp = _impl_.accuracy_.combined_std_dev_;
    _impl_.accuracy_.combined_std_dev_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PositionAndAccuracy::unsafe_arena_set_allocated_combined_std_dev(::google::protobuf::Int64Value* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_accuracy();
  if (value) {
    set_has_combined_std_dev();
    _impl_.accuracy_.combined_std_dev_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.combined_std_dev)
}
inline ::google::protobuf::Int64Value* PositionAndAccuracy::_internal_mutable_combined_std_dev() {
  if (accuracy_case() != kCombinedStdDev) {
    clear_accuracy();
    set_has_combined_std_dev();
    _impl_.accuracy_.combined_std_dev_ = CreateMaybeMessage<::google::protobuf::Int64Value>(GetArena());
  }
  return _impl_.accuracy_.combined_std_dev_;
}
inline ::google::protobuf::Int64Value* PositionAndAccuracy::mutable_combined_std_dev() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Int64Value* _msg = _internal_mutable_combined_std_dev();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PositionAndAccuracy.combined_std_dev)
  return _msg;
}

// .sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalVerticalStdDev std_dev = 6;
inline bool PositionAndAccuracy::has_std_dev() const {
  return accuracy_case() == kStdDev;
}
inline bool PositionAndAccuracy::_internal_has_std_dev() const {
  return accuracy_case() == kStdDev;
}
inline void PositionAndAccuracy::set_has_std_dev() {
  _impl_._oneof_case_[1] = kStdDev;
}
inline void PositionAndAccuracy::clear_std_dev() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (accuracy_case() == kStdDev) {
    if (GetArena() == nullptr) {
      delete _impl_.accuracy_.std_dev_;
    }
    clear_has_accuracy();
  }
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev* PositionAndAccuracy::release_std_dev() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.std_dev)
  if (accuracy_case() == kStdDev) {
    clear_has_accuracy();
    auto* temp = _impl_.accuracy_.std_dev_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.accuracy_.std_dev_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev& PositionAndAccuracy::_internal_std_dev() const {
  return accuracy_case() == kStdDev ? *_impl_.accuracy_.std_dev_ : reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev&>(::sensoris::protobuf::types::spatial::_PositionAndAccuracy_HorizontalVerticalStdDev_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev& PositionAndAccuracy::std_dev() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PositionAndAccuracy.std_dev)
  return _internal_std_dev();
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev* PositionAndAccuracy::unsafe_arena_release_std_dev() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.std_dev)
  if (accuracy_case() == kStdDev) {
    clear_has_accuracy();
    auto* temp = _impl_.accuracy_.std_dev_;
    _impl_.accuracy_.std_dev_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PositionAndAccuracy::unsafe_arena_set_allocated_std_dev(::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_accuracy();
  if (value) {
    set_has_std_dev();
    _impl_.accuracy_.std_dev_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.std_dev)
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev* PositionAndAccuracy::_internal_mutable_std_dev() {
  if (accuracy_case() != kStdDev) {
    clear_accuracy();
    set_has_std_dev();
    _impl_.accuracy_.std_dev_ = CreateMaybeMessage<::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev>(GetArena());
  }
  return _impl_.accuracy_.std_dev_;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev* PositionAndAccuracy::mutable_std_dev() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev* _msg = _internal_mutable_std_dev();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PositionAndAccuracy.std_dev)
  return _msg;
}

// .sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev horizontal_confidence_ellipse_vertical_std_dev = 7;
inline bool PositionAndAccuracy::has_horizontal_confidence_ellipse_vertical_std_dev() const {
  return accuracy_case() == kHorizontalConfidenceEllipseVerticalStdDev;
}
inline bool PositionAndAccuracy::_internal_has_horizontal_confidence_ellipse_vertical_std_dev() const {
  return accuracy_case() == kHorizontalConfidenceEllipseVerticalStdDev;
}
inline void PositionAndAccuracy::set_has_horizontal_confidence_ellipse_vertical_std_dev() {
  _impl_._oneof_case_[1] = kHorizontalConfidenceEllipseVerticalStdDev;
}
inline void PositionAndAccuracy::clear_horizontal_confidence_ellipse_vertical_std_dev() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (accuracy_case() == kHorizontalConfidenceEllipseVerticalStdDev) {
    if (GetArena() == nullptr) {
      delete _impl_.accuracy_.horizontal_confidence_ellipse_vertical_std_dev_;
    }
    clear_has_accuracy();
  }
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev* PositionAndAccuracy::release_horizontal_confidence_ellipse_vertical_std_dev() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.horizontal_confidence_ellipse_vertical_std_dev)
  if (accuracy_case() == kHorizontalConfidenceEllipseVerticalStdDev) {
    clear_has_accuracy();
    auto* temp = _impl_.accuracy_.horizontal_confidence_ellipse_vertical_std_dev_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.accuracy_.horizontal_confidence_ellipse_vertical_std_dev_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev& PositionAndAccuracy::_internal_horizontal_confidence_ellipse_vertical_std_dev() const {
  return accuracy_case() == kHorizontalConfidenceEllipseVerticalStdDev ? *_impl_.accuracy_.horizontal_confidence_ellipse_vertical_std_dev_ : reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev&>(::sensoris::protobuf::types::spatial::_PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev& PositionAndAccuracy::horizontal_confidence_ellipse_vertical_std_dev() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PositionAndAccuracy.horizontal_confidence_ellipse_vertical_std_dev)
  return _internal_horizontal_confidence_ellipse_vertical_std_dev();
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev* PositionAndAccuracy::unsafe_arena_release_horizontal_confidence_ellipse_vertical_std_dev() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.horizontal_confidence_ellipse_vertical_std_dev)
  if (accuracy_case() == kHorizontalConfidenceEllipseVerticalStdDev) {
    clear_has_accuracy();
    auto* temp = _impl_.accuracy_.horizontal_confidence_ellipse_vertical_std_dev_;
    _impl_.accuracy_.horizontal_confidence_ellipse_vertical_std_dev_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PositionAndAccuracy::unsafe_arena_set_allocated_horizontal_confidence_ellipse_vertical_std_dev(::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_accuracy();
  if (value) {
    set_has_horizontal_confidence_ellipse_vertical_std_dev();
    _impl_.accuracy_.horizontal_confidence_ellipse_vertical_std_dev_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.horizontal_confidence_ellipse_vertical_std_dev)
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev* PositionAndAccuracy::_internal_mutable_horizontal_confidence_ellipse_vertical_std_dev() {
  if (accuracy_case() != kHorizontalConfidenceEllipseVerticalStdDev) {
    clear_accuracy();
    set_has_horizontal_confidence_ellipse_vertical_std_dev();
    _impl_.accuracy_.horizontal_confidence_ellipse_vertical_std_dev_ = CreateMaybeMessage<::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev>(GetArena());
  }
  return _impl_.accuracy_.horizontal_confidence_ellipse_vertical_std_dev_;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev* PositionAndAccuracy::mutable_horizontal_confidence_ellipse_vertical_std_dev() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev* _msg = _internal_mutable_horizontal_confidence_ellipse_vertical_std_dev();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PositionAndAccuracy.horizontal_confidence_ellipse_vertical_std_dev)
  return _msg;
}

// .sensoris.protobuf.types.base.Int64Matrix3x3 covariance = 8 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool PositionAndAccuracy::has_covariance() const {
  return accuracy_case() == kCovariance;
}
inline bool PositionAndAccuracy::_internal_has_covariance() const {
  return accuracy_case() == kCovariance;
}
inline void PositionAndAccuracy::set_has_covariance() {
  _impl_._oneof_case_[1] = kCovariance;
}
inline ::sensoris::protobuf::types::base::Int64Matrix3x3* PositionAndAccuracy::release_covariance() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.covariance)
  if (accuracy_case() == kCovariance) {
    clear_has_accuracy();
    auto* temp = _impl_.accuracy_.covariance_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.accuracy_.covariance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensoris::protobuf::types::base::Int64Matrix3x3& PositionAndAccuracy::_internal_covariance() const {
  return accuracy_case() == kCovariance ? *_impl_.accuracy_.covariance_ : reinterpret_cast<::sensoris::protobuf::types::base::Int64Matrix3x3&>(::sensoris::protobuf::types::base::_Int64Matrix3x3_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64Matrix3x3& PositionAndAccuracy::covariance() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PositionAndAccuracy.covariance)
  return _internal_covariance();
}
inline ::sensoris::protobuf::types::base::Int64Matrix3x3* PositionAndAccuracy::unsafe_arena_release_covariance() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.covariance)
  if (accuracy_case() == kCovariance) {
    clear_has_accuracy();
    auto* temp = _impl_.accuracy_.covariance_;
    _impl_.accuracy_.covariance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PositionAndAccuracy::unsafe_arena_set_allocated_covariance(::sensoris::protobuf::types::base::Int64Matrix3x3* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_accuracy();
  if (value) {
    set_has_covariance();
    _impl_.accuracy_.covariance_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.covariance)
}
inline ::sensoris::protobuf::types::base::Int64Matrix3x3* PositionAndAccuracy::_internal_mutable_covariance() {
  if (accuracy_case() != kCovariance) {
    clear_accuracy();
    set_has_covariance();
    _impl_.accuracy_.covariance_ = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64Matrix3x3>(GetArena());
  }
  return _impl_.accuracy_.covariance_;
}
inline ::sensoris::protobuf::types::base::Int64Matrix3x3* PositionAndAccuracy::mutable_covariance() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::Int64Matrix3x3* _msg = _internal_mutable_covariance();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PositionAndAccuracy.covariance)
  return _msg;
}

// repeated .google.protobuf.Any extension = 15;
inline int PositionAndAccuracy::_internal_extension_size() const {
  return _internal_extension().size();
}
inline int PositionAndAccuracy::extension_size() const {
  return _internal_extension_size();
}
inline ::google::protobuf::Any* PositionAndAccuracy::mutable_extension(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PositionAndAccuracy.extension)
  return _internal_mutable_extension()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* PositionAndAccuracy::mutable_extension()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.types.spatial.PositionAndAccuracy.extension)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_extension();
}
inline const ::google::protobuf::Any& PositionAndAccuracy::extension(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PositionAndAccuracy.extension)
  return _internal_extension().Get(index);
}
inline ::google::protobuf::Any* PositionAndAccuracy::add_extension() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::google::protobuf::Any* _add = _internal_mutable_extension()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.types.spatial.PositionAndAccuracy.extension)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& PositionAndAccuracy::extension() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.types.spatial.PositionAndAccuracy.extension)
  return _internal_extension();
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>&
PositionAndAccuracy::_internal_extension() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.extension_;
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>*
PositionAndAccuracy::_internal_mutable_extension() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.extension_;
}

inline bool PositionAndAccuracy::has_geographic_metric() const {
  return geographic_metric_case() != GEOGRAPHIC_METRIC_NOT_SET;
}
inline void PositionAndAccuracy::clear_has_geographic_metric() {
  _impl_._oneof_case_[0] = GEOGRAPHIC_METRIC_NOT_SET;
}
inline bool PositionAndAccuracy::has_accuracy() const {
  return accuracy_case() != ACCURACY_NOT_SET;
}
inline void PositionAndAccuracy::clear_has_accuracy() {
  _impl_._oneof_case_[1] = ACCURACY_NOT_SET;
}
inline PositionAndAccuracy::GeographicMetricCase PositionAndAccuracy::geographic_metric_case() const {
  return PositionAndAccuracy::GeographicMetricCase(_impl_._oneof_case_[0]);
}
inline PositionAndAccuracy::AccuracyCase PositionAndAccuracy::accuracy_case() const {
  return PositionAndAccuracy::AccuracyCase(_impl_._oneof_case_[1]);
}
// -------------------------------------------------------------------

// PolylineAndAccuracy

// repeated .sensoris.protobuf.types.spatial.PositionAndAccuracy position_and_accuracy = 1;
inline int PolylineAndAccuracy::_internal_position_and_accuracy_size() const {
  return _internal_position_and_accuracy().size();
}
inline int PolylineAndAccuracy::position_and_accuracy_size() const {
  return _internal_position_and_accuracy_size();
}
inline void PolylineAndAccuracy::clear_position_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.position_and_accuracy_.Clear();
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PolylineAndAccuracy::mutable_position_and_accuracy(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PolylineAndAccuracy.position_and_accuracy)
  return _internal_mutable_position_and_accuracy()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::types::spatial::PositionAndAccuracy>* PolylineAndAccuracy::mutable_position_and_accuracy()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.types.spatial.PolylineAndAccuracy.position_and_accuracy)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_position_and_accuracy();
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& PolylineAndAccuracy::position_and_accuracy(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PolylineAndAccuracy.position_and_accuracy)
  return _internal_position_and_accuracy().Get(index);
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PolylineAndAccuracy::add_position_and_accuracy() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* _add = _internal_mutable_position_and_accuracy()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.types.spatial.PolylineAndAccuracy.position_and_accuracy)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::types::spatial::PositionAndAccuracy>& PolylineAndAccuracy::position_and_accuracy() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.types.spatial.PolylineAndAccuracy.position_and_accuracy)
  return _internal_position_and_accuracy();
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::types::spatial::PositionAndAccuracy>&
PolylineAndAccuracy::_internal_position_and_accuracy() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.position_and_accuracy_;
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::types::spatial::PositionAndAccuracy>*
PolylineAndAccuracy::_internal_mutable_position_and_accuracy() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.position_and_accuracy_;
}

// repeated .google.protobuf.Any extension = 15;
inline int PolylineAndAccuracy::_internal_extension_size() const {
  return _internal_extension().size();
}
inline int PolylineAndAccuracy::extension_size() const {
  return _internal_extension_size();
}
inline ::google::protobuf::Any* PolylineAndAccuracy::mutable_extension(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PolylineAndAccuracy.extension)
  return _internal_mutable_extension()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* PolylineAndAccuracy::mutable_extension()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.types.spatial.PolylineAndAccuracy.extension)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_extension();
}
inline const ::google::protobuf::Any& PolylineAndAccuracy::extension(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PolylineAndAccuracy.extension)
  return _internal_extension().Get(index);
}
inline ::google::protobuf::Any* PolylineAndAccuracy::add_extension() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::google::protobuf::Any* _add = _internal_mutable_extension()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.types.spatial.PolylineAndAccuracy.extension)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& PolylineAndAccuracy::extension() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.types.spatial.PolylineAndAccuracy.extension)
  return _internal_extension();
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>&
PolylineAndAccuracy::_internal_extension() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.extension_;
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>*
PolylineAndAccuracy::_internal_mutable_extension() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.extension_;
}

// -------------------------------------------------------------------

// PolylineCorridorAndAccuracy

// .sensoris.protobuf.types.spatial.PolylineAndAccuracy center_polyline_and_accuracy = 1;
inline bool PolylineCorridorAndAccuracy::has_center_polyline_and_accuracy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.center_polyline_and_accuracy_ != nullptr);
  return value;
}
inline void PolylineCorridorAndAccuracy::clear_center_polyline_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.center_polyline_and_accuracy_ != nullptr) _impl_.center_polyline_and_accuracy_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::sensoris::protobuf::types::spatial::PolylineAndAccuracy& PolylineCorridorAndAccuracy::_internal_center_polyline_and_accuracy() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::spatial::PolylineAndAccuracy* p = _impl_.center_polyline_and_accuracy_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::spatial::PolylineAndAccuracy&>(::sensoris::protobuf::types::spatial::_PolylineAndAccuracy_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::PolylineAndAccuracy& PolylineCorridorAndAccuracy::center_polyline_and_accuracy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PolylineCorridorAndAccuracy.center_polyline_and_accuracy)
  return _internal_center_polyline_and_accuracy();
}
inline void PolylineCorridorAndAccuracy::unsafe_arena_set_allocated_center_polyline_and_accuracy(::sensoris::protobuf::types::spatial::PolylineAndAccuracy* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.center_polyline_and_accuracy_);
  }
  _impl_.center_polyline_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::PolylineAndAccuracy*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.PolylineCorridorAndAccuracy.center_polyline_and_accuracy)
}
inline ::sensoris::protobuf::types::spatial::PolylineAndAccuracy* PolylineCorridorAndAccuracy::release_center_polyline_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::spatial::PolylineAndAccuracy* released = _impl_.center_polyline_and_accuracy_;
  _impl_.center_polyline_and_accuracy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::spatial::PolylineAndAccuracy* PolylineCorridorAndAccuracy::unsafe_arena_release_center_polyline_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.PolylineCorridorAndAccuracy.center_polyline_and_accuracy)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::spatial::PolylineAndAccuracy* temp = _impl_.center_polyline_and_accuracy_;
  _impl_.center_polyline_and_accuracy_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::PolylineAndAccuracy* PolylineCorridorAndAccuracy::_internal_mutable_center_polyline_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.center_polyline_and_accuracy_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::spatial::PolylineAndAccuracy>(GetArena());
    _impl_.center_polyline_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::PolylineAndAccuracy*>(p);
  }
  return _impl_.center_polyline_and_accuracy_;
}
inline ::sensoris::protobuf::types::spatial::PolylineAndAccuracy* PolylineCorridorAndAccuracy::mutable_center_polyline_and_accuracy() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::spatial::PolylineAndAccuracy* _msg = _internal_mutable_center_polyline_and_accuracy();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PolylineCorridorAndAccuracy.center_polyline_and_accuracy)
  return _msg;
}
inline void PolylineCorridorAndAccuracy::set_allocated_center_polyline_and_accuracy(::sensoris::protobuf::types::spatial::PolylineAndAccuracy* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::sensoris::protobuf::types::spatial::PolylineAndAccuracy*>(_impl_.center_polyline_and_accuracy_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::sensoris::protobuf::types::spatial::PolylineAndAccuracy*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.center_polyline_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::PolylineAndAccuracy*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.PolylineCorridorAndAccuracy.center_polyline_and_accuracy)
}

// .sensoris.protobuf.types.base.Int64ValueAndAccuracy total_width_and_accuracy = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool PolylineCorridorAndAccuracy::has_total_width_and_accuracy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.total_width_and_accuracy_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& PolylineCorridorAndAccuracy::_internal_total_width_and_accuracy() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* p = _impl_.total_width_and_accuracy_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy&>(::sensoris::protobuf::types::base::_Int64ValueAndAccuracy_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& PolylineCorridorAndAccuracy::total_width_and_accuracy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PolylineCorridorAndAccuracy.total_width_and_accuracy)
  return _internal_total_width_and_accuracy();
}
inline void PolylineCorridorAndAccuracy::unsafe_arena_set_allocated_total_width_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.total_width_and_accuracy_);
  }
  _impl_.total_width_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.PolylineCorridorAndAccuracy.total_width_and_accuracy)
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PolylineCorridorAndAccuracy::release_total_width_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* released = _impl_.total_width_and_accuracy_;
  _impl_.total_width_and_accuracy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PolylineCorridorAndAccuracy::unsafe_arena_release_total_width_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.PolylineCorridorAndAccuracy.total_width_and_accuracy)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* temp = _impl_.total_width_and_accuracy_;
  _impl_.total_width_and_accuracy_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PolylineCorridorAndAccuracy::_internal_mutable_total_width_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.total_width_and_accuracy_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64ValueAndAccuracy>(GetArena());
    _impl_.total_width_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(p);
  }
  return _impl_.total_width_and_accuracy_;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* PolylineCorridorAndAccuracy::mutable_total_width_and_accuracy() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* _msg = _internal_mutable_total_width_and_accuracy();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PolylineCorridorAndAccuracy.total_width_and_accuracy)
  return _msg;
}
inline void PolylineCorridorAndAccuracy::set_allocated_total_width_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.total_width_and_accuracy_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.total_width_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.PolylineCorridorAndAccuracy.total_width_and_accuracy)
}

// repeated .google.protobuf.Any extension = 15;
inline int PolylineCorridorAndAccuracy::_internal_extension_size() const {
  return _internal_extension().size();
}
inline int PolylineCorridorAndAccuracy::extension_size() const {
  return _internal_extension_size();
}
inline ::google::protobuf::Any* PolylineCorridorAndAccuracy::mutable_extension(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PolylineCorridorAndAccuracy.extension)
  return _internal_mutable_extension()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* PolylineCorridorAndAccuracy::mutable_extension()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.types.spatial.PolylineCorridorAndAccuracy.extension)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_extension();
}
inline const ::google::protobuf::Any& PolylineCorridorAndAccuracy::extension(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PolylineCorridorAndAccuracy.extension)
  return _internal_extension().Get(index);
}
inline ::google::protobuf::Any* PolylineCorridorAndAccuracy::add_extension() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::google::protobuf::Any* _add = _internal_mutable_extension()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.types.spatial.PolylineCorridorAndAccuracy.extension)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& PolylineCorridorAndAccuracy::extension() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.types.spatial.PolylineCorridorAndAccuracy.extension)
  return _internal_extension();
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>&
PolylineCorridorAndAccuracy::_internal_extension() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.extension_;
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>*
PolylineCorridorAndAccuracy::_internal_mutable_extension() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.extension_;
}

// -------------------------------------------------------------------

// DirectedPolylineCorridor

// .sensoris.protobuf.types.spatial.PolylineCorridorAndAccuracy polyline_corridor = 1;
inline bool DirectedPolylineCorridor::has_polyline_corridor() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.polyline_corridor_ != nullptr);
  return value;
}
inline void DirectedPolylineCorridor::clear_polyline_corridor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.polyline_corridor_ != nullptr) _impl_.polyline_corridor_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::sensoris::protobuf::types::spatial::PolylineCorridorAndAccuracy& DirectedPolylineCorridor::_internal_polyline_corridor() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::spatial::PolylineCorridorAndAccuracy* p = _impl_.polyline_corridor_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::spatial::PolylineCorridorAndAccuracy&>(::sensoris::protobuf::types::spatial::_PolylineCorridorAndAccuracy_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::PolylineCorridorAndAccuracy& DirectedPolylineCorridor::polyline_corridor() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.DirectedPolylineCorridor.polyline_corridor)
  return _internal_polyline_corridor();
}
inline void DirectedPolylineCorridor::unsafe_arena_set_allocated_polyline_corridor(::sensoris::protobuf::types::spatial::PolylineCorridorAndAccuracy* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.polyline_corridor_);
  }
  _impl_.polyline_corridor_ = reinterpret_cast<::sensoris::protobuf::types::spatial::PolylineCorridorAndAccuracy*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.DirectedPolylineCorridor.polyline_corridor)
}
inline ::sensoris::protobuf::types::spatial::PolylineCorridorAndAccuracy* DirectedPolylineCorridor::release_polyline_corridor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::spatial::PolylineCorridorAndAccuracy* released = _impl_.polyline_corridor_;
  _impl_.polyline_corridor_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::spatial::PolylineCorridorAndAccuracy* DirectedPolylineCorridor::unsafe_arena_release_polyline_corridor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.DirectedPolylineCorridor.polyline_corridor)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::spatial::PolylineCorridorAndAccuracy* temp = _impl_.polyline_corridor_;
  _impl_.polyline_corridor_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::PolylineCorridorAndAccuracy* DirectedPolylineCorridor::_internal_mutable_polyline_corridor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.polyline_corridor_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::spatial::PolylineCorridorAndAccuracy>(GetArena());
    _impl_.polyline_corridor_ = reinterpret_cast<::sensoris::protobuf::types::spatial::PolylineCorridorAndAccuracy*>(p);
  }
  return _impl_.polyline_corridor_;
}
inline ::sensoris::protobuf::types::spatial::PolylineCorridorAndAccuracy* DirectedPolylineCorridor::mutable_polyline_corridor() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::spatial::PolylineCorridorAndAccuracy* _msg = _internal_mutable_polyline_corridor();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.DirectedPolylineCorridor.polyline_corridor)
  return _msg;
}
inline void DirectedPolylineCorridor::set_allocated_polyline_corridor(::sensoris::protobuf::types::spatial::PolylineCorridorAndAccuracy* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::sensoris::protobuf::types::spatial::PolylineCorridorAndAccuracy*>(_impl_.polyline_corridor_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::sensoris::protobuf::types::spatial::PolylineCorridorAndAccuracy*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.polyline_corridor_ = reinterpret_cast<::sensoris::protobuf::types::spatial::PolylineCorridorAndAccuracy*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.DirectedPolylineCorridor.polyline_corridor)
}

// .google.protobuf.BoolValue is_bidirectional = 2;
inline bool DirectedPolylineCorridor::has_is_bidirectional() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.is_bidirectional_ != nullptr);
  return value;
}
inline const ::google::protobuf::BoolValue& DirectedPolylineCorridor::_internal_is_bidirectional() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::BoolValue* p = _impl_.is_bidirectional_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::BoolValue&>(::google::protobuf::_BoolValue_default_instance_);
}
inline const ::google::protobuf::BoolValue& DirectedPolylineCorridor::is_bidirectional() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.DirectedPolylineCorridor.is_bidirectional)
  return _internal_is_bidirectional();
}
inline void DirectedPolylineCorridor::unsafe_arena_set_allocated_is_bidirectional(::google::protobuf::BoolValue* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.is_bidirectional_);
  }
  _impl_.is_bidirectional_ = reinterpret_cast<::google::protobuf::BoolValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.DirectedPolylineCorridor.is_bidirectional)
}
inline ::google::protobuf::BoolValue* DirectedPolylineCorridor::release_is_bidirectional() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::BoolValue* released = _impl_.is_bidirectional_;
  _impl_.is_bidirectional_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::BoolValue* DirectedPolylineCorridor::unsafe_arena_release_is_bidirectional() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.DirectedPolylineCorridor.is_bidirectional)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::BoolValue* temp = _impl_.is_bidirectional_;
  _impl_.is_bidirectional_ = nullptr;
  return temp;
}
inline ::google::protobuf::BoolValue* DirectedPolylineCorridor::_internal_mutable_is_bidirectional() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.is_bidirectional_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::BoolValue>(GetArena());
    _impl_.is_bidirectional_ = reinterpret_cast<::google::protobuf::BoolValue*>(p);
  }
  return _impl_.is_bidirectional_;
}
inline ::google::protobuf::BoolValue* DirectedPolylineCorridor::mutable_is_bidirectional() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::BoolValue* _msg = _internal_mutable_is_bidirectional();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.DirectedPolylineCorridor.is_bidirectional)
  return _msg;
}
inline void DirectedPolylineCorridor::set_allocated_is_bidirectional(::google::protobuf::BoolValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.is_bidirectional_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.is_bidirectional_ = reinterpret_cast<::google::protobuf::BoolValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.DirectedPolylineCorridor.is_bidirectional)
}

// .google.protobuf.Int64Value heading_deviation_from_center_line = 3;
inline bool DirectedPolylineCorridor::has_heading_deviation_from_center_line() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.heading_deviation_from_center_line_ != nullptr);
  return value;
}
inline const ::google::protobuf::Int64Value& DirectedPolylineCorridor::_internal_heading_deviation_from_center_line() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Int64Value* p = _impl_.heading_deviation_from_center_line_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Int64Value&>(::google::protobuf::_Int64Value_default_instance_);
}
inline const ::google::protobuf::Int64Value& DirectedPolylineCorridor::heading_deviation_from_center_line() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.DirectedPolylineCorridor.heading_deviation_from_center_line)
  return _internal_heading_deviation_from_center_line();
}
inline void DirectedPolylineCorridor::unsafe_arena_set_allocated_heading_deviation_from_center_line(::google::protobuf::Int64Value* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.heading_deviation_from_center_line_);
  }
  _impl_.heading_deviation_from_center_line_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.DirectedPolylineCorridor.heading_deviation_from_center_line)
}
inline ::google::protobuf::Int64Value* DirectedPolylineCorridor::release_heading_deviation_from_center_line() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Int64Value* released = _impl_.heading_deviation_from_center_line_;
  _impl_.heading_deviation_from_center_line_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Int64Value* DirectedPolylineCorridor::unsafe_arena_release_heading_deviation_from_center_line() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.DirectedPolylineCorridor.heading_deviation_from_center_line)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Int64Value* temp = _impl_.heading_deviation_from_center_line_;
  _impl_.heading_deviation_from_center_line_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int64Value* DirectedPolylineCorridor::_internal_mutable_heading_deviation_from_center_line() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.heading_deviation_from_center_line_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int64Value>(GetArena());
    _impl_.heading_deviation_from_center_line_ = reinterpret_cast<::google::protobuf::Int64Value*>(p);
  }
  return _impl_.heading_deviation_from_center_line_;
}
inline ::google::protobuf::Int64Value* DirectedPolylineCorridor::mutable_heading_deviation_from_center_line() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Int64Value* _msg = _internal_mutable_heading_deviation_from_center_line();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.DirectedPolylineCorridor.heading_deviation_from_center_line)
  return _msg;
}
inline void DirectedPolylineCorridor::set_allocated_heading_deviation_from_center_line(::google::protobuf::Int64Value* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.heading_deviation_from_center_line_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.heading_deviation_from_center_line_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.DirectedPolylineCorridor.heading_deviation_from_center_line)
}

// repeated .google.protobuf.Any extension = 15;
inline int DirectedPolylineCorridor::_internal_extension_size() const {
  return _internal_extension().size();
}
inline int DirectedPolylineCorridor::extension_size() const {
  return _internal_extension_size();
}
inline ::google::protobuf::Any* DirectedPolylineCorridor::mutable_extension(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.DirectedPolylineCorridor.extension)
  return _internal_mutable_extension()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* DirectedPolylineCorridor::mutable_extension()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.types.spatial.DirectedPolylineCorridor.extension)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_extension();
}
inline const ::google::protobuf::Any& DirectedPolylineCorridor::extension(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.DirectedPolylineCorridor.extension)
  return _internal_extension().Get(index);
}
inline ::google::protobuf::Any* DirectedPolylineCorridor::add_extension() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::google::protobuf::Any* _add = _internal_mutable_extension()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.types.spatial.DirectedPolylineCorridor.extension)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& DirectedPolylineCorridor::extension() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.types.spatial.DirectedPolylineCorridor.extension)
  return _internal_extension();
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>&
DirectedPolylineCorridor::_internal_extension() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.extension_;
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>*
DirectedPolylineCorridor::_internal_mutable_extension() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.extension_;
}

// -------------------------------------------------------------------

// CircleAndAccuracy

// .sensoris.protobuf.types.spatial.PositionAndAccuracy center_position_and_accuracy = 1;
inline bool CircleAndAccuracy::has_center_position_and_accuracy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.center_position_and_accuracy_ != nullptr);
  return value;
}
inline void CircleAndAccuracy::clear_center_position_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.center_position_and_accuracy_ != nullptr) _impl_.center_position_and_accuracy_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& CircleAndAccuracy::_internal_center_position_and_accuracy() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy* p = _impl_.center_position_and_accuracy_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::spatial::PositionAndAccuracy&>(::sensoris::protobuf::types::spatial::_PositionAndAccuracy_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& CircleAndAccuracy::center_position_and_accuracy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.CircleAndAccuracy.center_position_and_accuracy)
  return _internal_center_position_and_accuracy();
}
inline void CircleAndAccuracy::unsafe_arena_set_allocated_center_position_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.center_position_and_accuracy_);
  }
  _impl_.center_position_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.CircleAndAccuracy.center_position_and_accuracy)
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* CircleAndAccuracy::release_center_position_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* released = _impl_.center_position_and_accuracy_;
  _impl_.center_position_and_accuracy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* CircleAndAccuracy::unsafe_arena_release_center_position_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.CircleAndAccuracy.center_position_and_accuracy)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* temp = _impl_.center_position_and_accuracy_;
  _impl_.center_position_and_accuracy_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* CircleAndAccuracy::_internal_mutable_center_position_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.center_position_and_accuracy_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::spatial::PositionAndAccuracy>(GetArena());
    _impl_.center_position_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(p);
  }
  return _impl_.center_position_and_accuracy_;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* CircleAndAccuracy::mutable_center_position_and_accuracy() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* _msg = _internal_mutable_center_position_and_accuracy();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.CircleAndAccuracy.center_position_and_accuracy)
  return _msg;
}
inline void CircleAndAccuracy::set_allocated_center_position_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(_impl_.center_position_and_accuracy_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.center_position_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.CircleAndAccuracy.center_position_and_accuracy)
}

// .sensoris.protobuf.types.base.Int64ValueAndAccuracy radius_and_accuracy = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool CircleAndAccuracy::has_radius_and_accuracy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.radius_and_accuracy_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& CircleAndAccuracy::_internal_radius_and_accuracy() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* p = _impl_.radius_and_accuracy_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy&>(::sensoris::protobuf::types::base::_Int64ValueAndAccuracy_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& CircleAndAccuracy::radius_and_accuracy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.CircleAndAccuracy.radius_and_accuracy)
  return _internal_radius_and_accuracy();
}
inline void CircleAndAccuracy::unsafe_arena_set_allocated_radius_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.radius_and_accuracy_);
  }
  _impl_.radius_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.CircleAndAccuracy.radius_and_accuracy)
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* CircleAndAccuracy::release_radius_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* released = _impl_.radius_and_accuracy_;
  _impl_.radius_and_accuracy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* CircleAndAccuracy::unsafe_arena_release_radius_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.CircleAndAccuracy.radius_and_accuracy)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* temp = _impl_.radius_and_accuracy_;
  _impl_.radius_and_accuracy_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* CircleAndAccuracy::_internal_mutable_radius_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.radius_and_accuracy_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64ValueAndAccuracy>(GetArena());
    _impl_.radius_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(p);
  }
  return _impl_.radius_and_accuracy_;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* CircleAndAccuracy::mutable_radius_and_accuracy() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* _msg = _internal_mutable_radius_and_accuracy();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.CircleAndAccuracy.radius_and_accuracy)
  return _msg;
}
inline void CircleAndAccuracy::set_allocated_radius_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.radius_and_accuracy_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.radius_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.CircleAndAccuracy.radius_and_accuracy)
}

// repeated .google.protobuf.Any extension = 15;
inline int CircleAndAccuracy::_internal_extension_size() const {
  return _internal_extension().size();
}
inline int CircleAndAccuracy::extension_size() const {
  return _internal_extension_size();
}
inline ::google::protobuf::Any* CircleAndAccuracy::mutable_extension(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.CircleAndAccuracy.extension)
  return _internal_mutable_extension()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* CircleAndAccuracy::mutable_extension()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.types.spatial.CircleAndAccuracy.extension)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_extension();
}
inline const ::google::protobuf::Any& CircleAndAccuracy::extension(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.CircleAndAccuracy.extension)
  return _internal_extension().Get(index);
}
inline ::google::protobuf::Any* CircleAndAccuracy::add_extension() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::google::protobuf::Any* _add = _internal_mutable_extension()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.types.spatial.CircleAndAccuracy.extension)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& CircleAndAccuracy::extension() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.types.spatial.CircleAndAccuracy.extension)
  return _internal_extension();
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>&
CircleAndAccuracy::_internal_extension() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.extension_;
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>*
CircleAndAccuracy::_internal_mutable_extension() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.extension_;
}

// -------------------------------------------------------------------

// RectangleAndAccuracy

// .sensoris.protobuf.types.spatial.PositionAndAccuracy minimum_position_and_accuracy = 1;
inline bool RectangleAndAccuracy::has_minimum_position_and_accuracy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.minimum_position_and_accuracy_ != nullptr);
  return value;
}
inline void RectangleAndAccuracy::clear_minimum_position_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.minimum_position_and_accuracy_ != nullptr) _impl_.minimum_position_and_accuracy_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& RectangleAndAccuracy::_internal_minimum_position_and_accuracy() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy* p = _impl_.minimum_position_and_accuracy_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::spatial::PositionAndAccuracy&>(::sensoris::protobuf::types::spatial::_PositionAndAccuracy_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& RectangleAndAccuracy::minimum_position_and_accuracy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RectangleAndAccuracy.minimum_position_and_accuracy)
  return _internal_minimum_position_and_accuracy();
}
inline void RectangleAndAccuracy::unsafe_arena_set_allocated_minimum_position_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.minimum_position_and_accuracy_);
  }
  _impl_.minimum_position_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RectangleAndAccuracy.minimum_position_and_accuracy)
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* RectangleAndAccuracy::release_minimum_position_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* released = _impl_.minimum_position_and_accuracy_;
  _impl_.minimum_position_and_accuracy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* RectangleAndAccuracy::unsafe_arena_release_minimum_position_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RectangleAndAccuracy.minimum_position_and_accuracy)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* temp = _impl_.minimum_position_and_accuracy_;
  _impl_.minimum_position_and_accuracy_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* RectangleAndAccuracy::_internal_mutable_minimum_position_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.minimum_position_and_accuracy_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::spatial::PositionAndAccuracy>(GetArena());
    _impl_.minimum_position_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(p);
  }
  return _impl_.minimum_position_and_accuracy_;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* RectangleAndAccuracy::mutable_minimum_position_and_accuracy() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* _msg = _internal_mutable_minimum_position_and_accuracy();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RectangleAndAccuracy.minimum_position_and_accuracy)
  return _msg;
}
inline void RectangleAndAccuracy::set_allocated_minimum_position_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(_impl_.minimum_position_and_accuracy_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.minimum_position_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RectangleAndAccuracy.minimum_position_and_accuracy)
}

// .sensoris.protobuf.types.spatial.PositionAndAccuracy maximum_position_and_accuracy = 2;
inline bool RectangleAndAccuracy::has_maximum_position_and_accuracy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.maximum_position_and_accuracy_ != nullptr);
  return value;
}
inline void RectangleAndAccuracy::clear_maximum_position_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.maximum_position_and_accuracy_ != nullptr) _impl_.maximum_position_and_accuracy_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& RectangleAndAccuracy::_internal_maximum_position_and_accuracy() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy* p = _impl_.maximum_position_and_accuracy_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::spatial::PositionAndAccuracy&>(::sensoris::protobuf::types::spatial::_PositionAndAccuracy_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& RectangleAndAccuracy::maximum_position_and_accuracy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RectangleAndAccuracy.maximum_position_and_accuracy)
  return _internal_maximum_position_and_accuracy();
}
inline void RectangleAndAccuracy::unsafe_arena_set_allocated_maximum_position_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.maximum_position_and_accuracy_);
  }
  _impl_.maximum_position_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RectangleAndAccuracy.maximum_position_and_accuracy)
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* RectangleAndAccuracy::release_maximum_position_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* released = _impl_.maximum_position_and_accuracy_;
  _impl_.maximum_position_and_accuracy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* RectangleAndAccuracy::unsafe_arena_release_maximum_position_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RectangleAndAccuracy.maximum_position_and_accuracy)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* temp = _impl_.maximum_position_and_accuracy_;
  _impl_.maximum_position_and_accuracy_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* RectangleAndAccuracy::_internal_mutable_maximum_position_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.maximum_position_and_accuracy_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::spatial::PositionAndAccuracy>(GetArena());
    _impl_.maximum_position_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(p);
  }
  return _impl_.maximum_position_and_accuracy_;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* RectangleAndAccuracy::mutable_maximum_position_and_accuracy() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* _msg = _internal_mutable_maximum_position_and_accuracy();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RectangleAndAccuracy.maximum_position_and_accuracy)
  return _msg;
}
inline void RectangleAndAccuracy::set_allocated_maximum_position_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(_impl_.maximum_position_and_accuracy_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.maximum_position_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RectangleAndAccuracy.maximum_position_and_accuracy)
}

// repeated .google.protobuf.Any extension = 15;
inline int RectangleAndAccuracy::_internal_extension_size() const {
  return _internal_extension().size();
}
inline int RectangleAndAccuracy::extension_size() const {
  return _internal_extension_size();
}
inline ::google::protobuf::Any* RectangleAndAccuracy::mutable_extension(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RectangleAndAccuracy.extension)
  return _internal_mutable_extension()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* RectangleAndAccuracy::mutable_extension()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.types.spatial.RectangleAndAccuracy.extension)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_extension();
}
inline const ::google::protobuf::Any& RectangleAndAccuracy::extension(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RectangleAndAccuracy.extension)
  return _internal_extension().Get(index);
}
inline ::google::protobuf::Any* RectangleAndAccuracy::add_extension() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::google::protobuf::Any* _add = _internal_mutable_extension()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.types.spatial.RectangleAndAccuracy.extension)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& RectangleAndAccuracy::extension() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.types.spatial.RectangleAndAccuracy.extension)
  return _internal_extension();
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>&
RectangleAndAccuracy::_internal_extension() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.extension_;
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>*
RectangleAndAccuracy::_internal_mutable_extension() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.extension_;
}

// -------------------------------------------------------------------

// PolygonAndAccuracy

// repeated .sensoris.protobuf.types.spatial.PositionAndAccuracy position_and_accuracy = 1;
inline int PolygonAndAccuracy::_internal_position_and_accuracy_size() const {
  return _internal_position_and_accuracy().size();
}
inline int PolygonAndAccuracy::position_and_accuracy_size() const {
  return _internal_position_and_accuracy_size();
}
inline void PolygonAndAccuracy::clear_position_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.position_and_accuracy_.Clear();
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PolygonAndAccuracy::mutable_position_and_accuracy(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PolygonAndAccuracy.position_and_accuracy)
  return _internal_mutable_position_and_accuracy()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::types::spatial::PositionAndAccuracy>* PolygonAndAccuracy::mutable_position_and_accuracy()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.types.spatial.PolygonAndAccuracy.position_and_accuracy)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_position_and_accuracy();
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& PolygonAndAccuracy::position_and_accuracy(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PolygonAndAccuracy.position_and_accuracy)
  return _internal_position_and_accuracy().Get(index);
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PolygonAndAccuracy::add_position_and_accuracy() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* _add = _internal_mutable_position_and_accuracy()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.types.spatial.PolygonAndAccuracy.position_and_accuracy)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::types::spatial::PositionAndAccuracy>& PolygonAndAccuracy::position_and_accuracy() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.types.spatial.PolygonAndAccuracy.position_and_accuracy)
  return _internal_position_and_accuracy();
}
inline const ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::types::spatial::PositionAndAccuracy>&
PolygonAndAccuracy::_internal_position_and_accuracy() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.position_and_accuracy_;
}
inline ::google::protobuf::RepeatedPtrField<::sensoris::protobuf::types::spatial::PositionAndAccuracy>*
PolygonAndAccuracy::_internal_mutable_position_and_accuracy() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.position_and_accuracy_;
}

// repeated .google.protobuf.Any extension = 15;
inline int PolygonAndAccuracy::_internal_extension_size() const {
  return _internal_extension().size();
}
inline int PolygonAndAccuracy::extension_size() const {
  return _internal_extension_size();
}
inline ::google::protobuf::Any* PolygonAndAccuracy::mutable_extension(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PolygonAndAccuracy.extension)
  return _internal_mutable_extension()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* PolygonAndAccuracy::mutable_extension()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.types.spatial.PolygonAndAccuracy.extension)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_extension();
}
inline const ::google::protobuf::Any& PolygonAndAccuracy::extension(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PolygonAndAccuracy.extension)
  return _internal_extension().Get(index);
}
inline ::google::protobuf::Any* PolygonAndAccuracy::add_extension() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::google::protobuf::Any* _add = _internal_mutable_extension()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.types.spatial.PolygonAndAccuracy.extension)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& PolygonAndAccuracy::extension() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.types.spatial.PolygonAndAccuracy.extension)
  return _internal_extension();
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>&
PolygonAndAccuracy::_internal_extension() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.extension_;
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>*
PolygonAndAccuracy::_internal_mutable_extension() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.extension_;
}

// -------------------------------------------------------------------

// XyzVectorAndAccuracy_StdDev

// .google.protobuf.Int64Value x = 1;
inline bool XyzVectorAndAccuracy_StdDev::has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.x_ != nullptr);
  return value;
}
inline const ::google::protobuf::Int64Value& XyzVectorAndAccuracy_StdDev::_internal_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Int64Value* p = _impl_.x_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Int64Value&>(::google::protobuf::_Int64Value_default_instance_);
}
inline const ::google::protobuf::Int64Value& XyzVectorAndAccuracy_StdDev::x() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev.x)
  return _internal_x();
}
inline void XyzVectorAndAccuracy_StdDev::unsafe_arena_set_allocated_x(::google::protobuf::Int64Value* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.x_);
  }
  _impl_.x_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev.x)
}
inline ::google::protobuf::Int64Value* XyzVectorAndAccuracy_StdDev::release_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Int64Value* released = _impl_.x_;
  _impl_.x_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Int64Value* XyzVectorAndAccuracy_StdDev::unsafe_arena_release_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev.x)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Int64Value* temp = _impl_.x_;
  _impl_.x_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int64Value* XyzVectorAndAccuracy_StdDev::_internal_mutable_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.x_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int64Value>(GetArena());
    _impl_.x_ = reinterpret_cast<::google::protobuf::Int64Value*>(p);
  }
  return _impl_.x_;
}
inline ::google::protobuf::Int64Value* XyzVectorAndAccuracy_StdDev::mutable_x() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Int64Value* _msg = _internal_mutable_x();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev.x)
  return _msg;
}
inline void XyzVectorAndAccuracy_StdDev::set_allocated_x(::google::protobuf::Int64Value* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.x_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.x_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev.x)
}

// .google.protobuf.Int64Value y = 2;
inline bool XyzVectorAndAccuracy_StdDev::has_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.y_ != nullptr);
  return value;
}
inline const ::google::protobuf::Int64Value& XyzVectorAndAccuracy_StdDev::_internal_y() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Int64Value* p = _impl_.y_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Int64Value&>(::google::protobuf::_Int64Value_default_instance_);
}
inline const ::google::protobuf::Int64Value& XyzVectorAndAccuracy_StdDev::y() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev.y)
  return _internal_y();
}
inline void XyzVectorAndAccuracy_StdDev::unsafe_arena_set_allocated_y(::google::protobuf::Int64Value* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.y_);
  }
  _impl_.y_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev.y)
}
inline ::google::protobuf::Int64Value* XyzVectorAndAccuracy_StdDev::release_y() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Int64Value* released = _impl_.y_;
  _impl_.y_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Int64Value* XyzVectorAndAccuracy_StdDev::unsafe_arena_release_y() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev.y)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Int64Value* temp = _impl_.y_;
  _impl_.y_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int64Value* XyzVectorAndAccuracy_StdDev::_internal_mutable_y() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.y_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int64Value>(GetArena());
    _impl_.y_ = reinterpret_cast<::google::protobuf::Int64Value*>(p);
  }
  return _impl_.y_;
}
inline ::google::protobuf::Int64Value* XyzVectorAndAccuracy_StdDev::mutable_y() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Int64Value* _msg = _internal_mutable_y();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev.y)
  return _msg;
}
inline void XyzVectorAndAccuracy_StdDev::set_allocated_y(::google::protobuf::Int64Value* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.y_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.y_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev.y)
}

// .google.protobuf.Int64Value z = 3;
inline bool XyzVectorAndAccuracy_StdDev::has_z() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.z_ != nullptr);
  return value;
}
inline const ::google::protobuf::Int64Value& XyzVectorAndAccuracy_StdDev::_internal_z() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Int64Value* p = _impl_.z_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Int64Value&>(::google::protobuf::_Int64Value_default_instance_);
}
inline const ::google::protobuf::Int64Value& XyzVectorAndAccuracy_StdDev::z() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev.z)
  return _internal_z();
}
inline void XyzVectorAndAccuracy_StdDev::unsafe_arena_set_allocated_z(::google::protobuf::Int64Value* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.z_);
  }
  _impl_.z_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev.z)
}
inline ::google::protobuf::Int64Value* XyzVectorAndAccuracy_StdDev::release_z() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Int64Value* released = _impl_.z_;
  _impl_.z_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Int64Value* XyzVectorAndAccuracy_StdDev::unsafe_arena_release_z() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev.z)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Int64Value* temp = _impl_.z_;
  _impl_.z_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int64Value* XyzVectorAndAccuracy_StdDev::_internal_mutable_z() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.z_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int64Value>(GetArena());
    _impl_.z_ = reinterpret_cast<::google::protobuf::Int64Value*>(p);
  }
  return _impl_.z_;
}
inline ::google::protobuf::Int64Value* XyzVectorAndAccuracy_StdDev::mutable_z() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Int64Value* _msg = _internal_mutable_z();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev.z)
  return _msg;
}
inline void XyzVectorAndAccuracy_StdDev::set_allocated_z(::google::protobuf::Int64Value* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.z_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.z_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev.z)
}

// -------------------------------------------------------------------

// XyzVectorAndAccuracy_Metric

// .sensoris.protobuf.types.base.Int64Value x = 1;
inline bool XyzVectorAndAccuracy_Metric::has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.x_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Int64Value& XyzVectorAndAccuracy_Metric::_internal_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::Int64Value* p = _impl_.x_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Int64Value&>(::sensoris::protobuf::types::base::_Int64Value_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64Value& XyzVectorAndAccuracy_Metric::x() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric.x)
  return _internal_x();
}
inline void XyzVectorAndAccuracy_Metric::unsafe_arena_set_allocated_x(::sensoris::protobuf::types::base::Int64Value* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.x_);
  }
  _impl_.x_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric.x)
}
inline ::sensoris::protobuf::types::base::Int64Value* XyzVectorAndAccuracy_Metric::release_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Int64Value* released = _impl_.x_;
  _impl_.x_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::Int64Value* XyzVectorAndAccuracy_Metric::unsafe_arena_release_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric.x)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Int64Value* temp = _impl_.x_;
  _impl_.x_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* XyzVectorAndAccuracy_Metric::_internal_mutable_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.x_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64Value>(GetArena());
    _impl_.x_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(p);
  }
  return _impl_.x_;
}
inline ::sensoris::protobuf::types::base::Int64Value* XyzVectorAndAccuracy_Metric::mutable_x() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::Int64Value* _msg = _internal_mutable_x();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric.x)
  return _msg;
}
inline void XyzVectorAndAccuracy_Metric::set_allocated_x(::sensoris::protobuf::types::base::Int64Value* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.x_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.x_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric.x)
}

// .sensoris.protobuf.types.base.Int64Value y = 2;
inline bool XyzVectorAndAccuracy_Metric::has_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.y_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Int64Value& XyzVectorAndAccuracy_Metric::_internal_y() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::Int64Value* p = _impl_.y_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Int64Value&>(::sensoris::protobuf::types::base::_Int64Value_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64Value& XyzVectorAndAccuracy_Metric::y() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric.y)
  return _internal_y();
}
inline void XyzVectorAndAccuracy_Metric::unsafe_arena_set_allocated_y(::sensoris::protobuf::types::base::Int64Value* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.y_);
  }
  _impl_.y_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric.y)
}
inline ::sensoris::protobuf::types::base::Int64Value* XyzVectorAndAccuracy_Metric::release_y() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::Int64Value* released = _impl_.y_;
  _impl_.y_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::Int64Value* XyzVectorAndAccuracy_Metric::unsafe_arena_release_y() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric.y)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::Int64Value* temp = _impl_.y_;
  _impl_.y_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* XyzVectorAndAccuracy_Metric::_internal_mutable_y() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.y_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64Value>(GetArena());
    _impl_.y_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(p);
  }
  return _impl_.y_;
}
inline ::sensoris::protobuf::types::base::Int64Value* XyzVectorAndAccuracy_Metric::mutable_y() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::Int64Value* _msg = _internal_mutable_y();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric.y)
  return _msg;
}
inline void XyzVectorAndAccuracy_Metric::set_allocated_y(::sensoris::protobuf::types::base::Int64Value* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.y_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.y_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric.y)
}

// .sensoris.protobuf.types.base.Int64Value z = 3;
inline bool XyzVectorAndAccuracy_Metric::has_z() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.z_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Int64Value& XyzVectorAndAccuracy_Metric::_internal_z() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::Int64Value* p = _impl_.z_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Int64Value&>(::sensoris::protobuf::types::base::_Int64Value_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64Value& XyzVectorAndAccuracy_Metric::z() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric.z)
  return _internal_z();
}
inline void XyzVectorAndAccuracy_Metric::unsafe_arena_set_allocated_z(::sensoris::protobuf::types::base::Int64Value* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.z_);
  }
  _impl_.z_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric.z)
}
inline ::sensoris::protobuf::types::base::Int64Value* XyzVectorAndAccuracy_Metric::release_z() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::types::base::Int64Value* released = _impl_.z_;
  _impl_.z_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::Int64Value* XyzVectorAndAccuracy_Metric::unsafe_arena_release_z() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric.z)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::types::base::Int64Value* temp = _impl_.z_;
  _impl_.z_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* XyzVectorAndAccuracy_Metric::_internal_mutable_z() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.z_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64Value>(GetArena());
    _impl_.z_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(p);
  }
  return _impl_.z_;
}
inline ::sensoris::protobuf::types::base::Int64Value* XyzVectorAndAccuracy_Metric::mutable_z() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::Int64Value* _msg = _internal_mutable_z();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric.z)
  return _msg;
}
inline void XyzVectorAndAccuracy_Metric::set_allocated_z(::sensoris::protobuf::types::base::Int64Value* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.z_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.z_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric.z)
}

// -------------------------------------------------------------------

// XyzVectorAndAccuracy

// .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric metric_vehicle = 1;
inline bool XyzVectorAndAccuracy::has_metric_vehicle() const {
  return geometry_case() == kMetricVehicle;
}
inline bool XyzVectorAndAccuracy::_internal_has_metric_vehicle() const {
  return geometry_case() == kMetricVehicle;
}
inline void XyzVectorAndAccuracy::set_has_metric_vehicle() {
  _impl_._oneof_case_[0] = kMetricVehicle;
}
inline void XyzVectorAndAccuracy::clear_metric_vehicle() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (geometry_case() == kMetricVehicle) {
    if (GetArena() == nullptr) {
      delete _impl_.geometry_.metric_vehicle_;
    }
    clear_has_geometry();
  }
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* XyzVectorAndAccuracy::release_metric_vehicle() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.metric_vehicle)
  if (geometry_case() == kMetricVehicle) {
    clear_has_geometry();
    auto* temp = _impl_.geometry_.metric_vehicle_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.geometry_.metric_vehicle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric& XyzVectorAndAccuracy::_internal_metric_vehicle() const {
  return geometry_case() == kMetricVehicle ? *_impl_.geometry_.metric_vehicle_ : reinterpret_cast<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric&>(::sensoris::protobuf::types::spatial::_XyzVectorAndAccuracy_Metric_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric& XyzVectorAndAccuracy::metric_vehicle() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.metric_vehicle)
  return _internal_metric_vehicle();
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* XyzVectorAndAccuracy::unsafe_arena_release_metric_vehicle() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.metric_vehicle)
  if (geometry_case() == kMetricVehicle) {
    clear_has_geometry();
    auto* temp = _impl_.geometry_.metric_vehicle_;
    _impl_.geometry_.metric_vehicle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void XyzVectorAndAccuracy::unsafe_arena_set_allocated_metric_vehicle(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_geometry();
  if (value) {
    set_has_metric_vehicle();
    _impl_.geometry_.metric_vehicle_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.metric_vehicle)
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* XyzVectorAndAccuracy::_internal_mutable_metric_vehicle() {
  if (geometry_case() != kMetricVehicle) {
    clear_geometry();
    set_has_metric_vehicle();
    _impl_.geometry_.metric_vehicle_ = CreateMaybeMessage<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric>(GetArena());
  }
  return _impl_.geometry_.metric_vehicle_;
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* XyzVectorAndAccuracy::mutable_metric_vehicle() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* _msg = _internal_mutable_metric_vehicle();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.metric_vehicle)
  return _msg;
}

// .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric metric_event_group = 2;
inline bool XyzVectorAndAccuracy::has_metric_event_group() const {
  return geometry_case() == kMetricEventGroup;
}
inline bool XyzVectorAndAccuracy::_internal_has_metric_event_group() const {
  return geometry_case() == kMetricEventGroup;
}
inline void XyzVectorAndAccuracy::set_has_metric_event_group() {
  _impl_._oneof_case_[0] = kMetricEventGroup;
}
inline void XyzVectorAndAccuracy::clear_metric_event_group() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (geometry_case() == kMetricEventGroup) {
    if (GetArena() == nullptr) {
      delete _impl_.geometry_.metric_event_group_;
    }
    clear_has_geometry();
  }
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* XyzVectorAndAccuracy::release_metric_event_group() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.metric_event_group)
  if (geometry_case() == kMetricEventGroup) {
    clear_has_geometry();
    auto* temp = _impl_.geometry_.metric_event_group_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.geometry_.metric_event_group_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric& XyzVectorAndAccuracy::_internal_metric_event_group() const {
  return geometry_case() == kMetricEventGroup ? *_impl_.geometry_.metric_event_group_ : reinterpret_cast<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric&>(::sensoris::protobuf::types::spatial::_XyzVectorAndAccuracy_Metric_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric& XyzVectorAndAccuracy::metric_event_group() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.metric_event_group)
  return _internal_metric_event_group();
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* XyzVectorAndAccuracy::unsafe_arena_release_metric_event_group() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.metric_event_group)
  if (geometry_case() == kMetricEventGroup) {
    clear_has_geometry();
    auto* temp = _impl_.geometry_.metric_event_group_;
    _impl_.geometry_.metric_event_group_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void XyzVectorAndAccuracy::unsafe_arena_set_allocated_metric_event_group(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_geometry();
  if (value) {
    set_has_metric_event_group();
    _impl_.geometry_.metric_event_group_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.metric_event_group)
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* XyzVectorAndAccuracy::_internal_mutable_metric_event_group() {
  if (geometry_case() != kMetricEventGroup) {
    clear_geometry();
    set_has_metric_event_group();
    _impl_.geometry_.metric_event_group_ = CreateMaybeMessage<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric>(GetArena());
  }
  return _impl_.geometry_.metric_event_group_;
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* XyzVectorAndAccuracy::mutable_metric_event_group() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* _msg = _internal_mutable_metric_event_group();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.metric_event_group)
  return _msg;
}

// .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric metric_origin = 3;
inline bool XyzVectorAndAccuracy::has_metric_origin() const {
  return geometry_case() == kMetricOrigin;
}
inline bool XyzVectorAndAccuracy::_internal_has_metric_origin() const {
  return geometry_case() == kMetricOrigin;
}
inline void XyzVectorAndAccuracy::set_has_metric_origin() {
  _impl_._oneof_case_[0] = kMetricOrigin;
}
inline void XyzVectorAndAccuracy::clear_metric_origin() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (geometry_case() == kMetricOrigin) {
    if (GetArena() == nullptr) {
      delete _impl_.geometry_.metric_origin_;
    }
    clear_has_geometry();
  }
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* XyzVectorAndAccuracy::release_metric_origin() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.metric_origin)
  if (geometry_case() == kMetricOrigin) {
    clear_has_geometry();
    auto* temp = _impl_.geometry_.metric_origin_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.geometry_.metric_origin_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric& XyzVectorAndAccuracy::_internal_metric_origin() const {
  return geometry_case() == kMetricOrigin ? *_impl_.geometry_.metric_origin_ : reinterpret_cast<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric&>(::sensoris::protobuf::types::spatial::_XyzVectorAndAccuracy_Metric_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric& XyzVectorAndAccuracy::metric_origin() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.metric_origin)
  return _internal_metric_origin();
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* XyzVectorAndAccuracy::unsafe_arena_release_metric_origin() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.metric_origin)
  if (geometry_case() == kMetricOrigin) {
    clear_has_geometry();
    auto* temp = _impl_.geometry_.metric_origin_;
    _impl_.geometry_.metric_origin_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void XyzVectorAndAccuracy::unsafe_arena_set_allocated_metric_origin(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_geometry();
  if (value) {
    set_has_metric_origin();
    _impl_.geometry_.metric_origin_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.metric_origin)
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* XyzVectorAndAccuracy::_internal_mutable_metric_origin() {
  if (geometry_case() != kMetricOrigin) {
    clear_geometry();
    set_has_metric_origin();
    _impl_.geometry_.metric_origin_ = CreateMaybeMessage<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric>(GetArena());
  }
  return _impl_.geometry_.metric_origin_;
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* XyzVectorAndAccuracy::mutable_metric_origin() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* _msg = _internal_mutable_metric_origin();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.metric_origin)
  return _msg;
}

// .google.protobuf.Int64Value combined_std_dev = 4;
inline bool XyzVectorAndAccuracy::has_combined_std_dev() const {
  return accuracy_case() == kCombinedStdDev;
}
inline bool XyzVectorAndAccuracy::_internal_has_combined_std_dev() const {
  return accuracy_case() == kCombinedStdDev;
}
inline void XyzVectorAndAccuracy::set_has_combined_std_dev() {
  _impl_._oneof_case_[1] = kCombinedStdDev;
}
inline ::google::protobuf::Int64Value* XyzVectorAndAccuracy::release_combined_std_dev() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.combined_std_dev)
  if (accuracy_case() == kCombinedStdDev) {
    clear_has_accuracy();
    auto* temp = _impl_.accuracy_.combined_std_dev_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.accuracy_.combined_std_dev_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::protobuf::Int64Value& XyzVectorAndAccuracy::_internal_combined_std_dev() const {
  return accuracy_case() == kCombinedStdDev ? *_impl_.accuracy_.combined_std_dev_ : reinterpret_cast<::google::protobuf::Int64Value&>(::google::protobuf::_Int64Value_default_instance_);
}
inline const ::google::protobuf::Int64Value& XyzVectorAndAccuracy::combined_std_dev() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.combined_std_dev)
  return _internal_combined_std_dev();
}
inline ::google::protobuf::Int64Value* XyzVectorAndAccuracy::unsafe_arena_release_combined_std_dev() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.combined_std_dev)
  if (accuracy_case() == kCombinedStdDev) {
    clear_has_accuracy();
    auto* temp = _impl_.accuracy_.combined_std_dev_;
    _impl_.accuracy_.combined_std_dev_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void XyzVectorAndAccuracy::unsafe_arena_set_allocated_combined_std_dev(::google::protobuf::Int64Value* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_accuracy();
  if (value) {
    set_has_combined_std_dev();
    _impl_.accuracy_.combined_std_dev_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.combined_std_dev)
}
inline ::google::protobuf::Int64Value* XyzVectorAndAccuracy::_internal_mutable_combined_std_dev() {
  if (accuracy_case() != kCombinedStdDev) {
    clear_accuracy();
    set_has_combined_std_dev();
    _impl_.accuracy_.combined_std_dev_ = CreateMaybeMessage<::google::protobuf::Int64Value>(GetArena());
  }
  return _impl_.accuracy_.combined_std_dev_;
}
inline ::google::protobuf::Int64Value* XyzVectorAndAccuracy::mutable_combined_std_dev() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Int64Value* _msg = _internal_mutable_combined_std_dev();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.combined_std_dev)
  return _msg;
}

// .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev std_dev = 5;
inline bool XyzVectorAndAccuracy::has_std_dev() const {
  return accuracy_case() == kStdDev;
}
inline bool XyzVectorAndAccuracy::_internal_has_std_dev() const {
  return accuracy_case() == kStdDev;
}
inline void XyzVectorAndAccuracy::set_has_std_dev() {
  _impl_._oneof_case_[1] = kStdDev;
}
inline void XyzVectorAndAccuracy::clear_std_dev() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (accuracy_case() == kStdDev) {
    if (GetArena() == nullptr) {
      delete _impl_.accuracy_.std_dev_;
    }
    clear_has_accuracy();
  }
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev* XyzVectorAndAccuracy::release_std_dev() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.std_dev)
  if (accuracy_case() == kStdDev) {
    clear_has_accuracy();
    auto* temp = _impl_.accuracy_.std_dev_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.accuracy_.std_dev_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev& XyzVectorAndAccuracy::_internal_std_dev() const {
  return accuracy_case() == kStdDev ? *_impl_.accuracy_.std_dev_ : reinterpret_cast<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev&>(::sensoris::protobuf::types::spatial::_XyzVectorAndAccuracy_StdDev_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev& XyzVectorAndAccuracy::std_dev() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.std_dev)
  return _internal_std_dev();
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev* XyzVectorAndAccuracy::unsafe_arena_release_std_dev() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.std_dev)
  if (accuracy_case() == kStdDev) {
    clear_has_accuracy();
    auto* temp = _impl_.accuracy_.std_dev_;
    _impl_.accuracy_.std_dev_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void XyzVectorAndAccuracy::unsafe_arena_set_allocated_std_dev(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_accuracy();
  if (value) {
    set_has_std_dev();
    _impl_.accuracy_.std_dev_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.std_dev)
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev* XyzVectorAndAccuracy::_internal_mutable_std_dev() {
  if (accuracy_case() != kStdDev) {
    clear_accuracy();
    set_has_std_dev();
    _impl_.accuracy_.std_dev_ = CreateMaybeMessage<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev>(GetArena());
  }
  return _impl_.accuracy_.std_dev_;
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev* XyzVectorAndAccuracy::mutable_std_dev() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev* _msg = _internal_mutable_std_dev();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.std_dev)
  return _msg;
}

// .sensoris.protobuf.types.base.Int64Matrix3x3 covariance = 6;
inline bool XyzVectorAndAccuracy::has_covariance() const {
  return accuracy_case() == kCovariance;
}
inline bool XyzVectorAndAccuracy::_internal_has_covariance() const {
  return accuracy_case() == kCovariance;
}
inline void XyzVectorAndAccuracy::set_has_covariance() {
  _impl_._oneof_case_[1] = kCovariance;
}
inline ::sensoris::protobuf::types::base::Int64Matrix3x3* XyzVectorAndAccuracy::release_covariance() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.covariance)
  if (accuracy_case() == kCovariance) {
    clear_has_accuracy();
    auto* temp = _impl_.accuracy_.covariance_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.accuracy_.covariance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensoris::protobuf::types::base::Int64Matrix3x3& XyzVectorAndAccuracy::_internal_covariance() const {
  return accuracy_case() == kCovariance ? *_impl_.accuracy_.covariance_ : reinterpret_cast<::sensoris::protobuf::types::base::Int64Matrix3x3&>(::sensoris::protobuf::types::base::_Int64Matrix3x3_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64Matrix3x3& XyzVectorAndAccuracy::covariance() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.covariance)
  return _internal_covariance();
}
inline ::sensoris::protobuf::types::base::Int64Matrix3x3* XyzVectorAndAccuracy::unsafe_arena_release_covariance() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.covariance)
  if (accuracy_case() == kCovariance) {
    clear_has_accuracy();
    auto* temp = _impl_.accuracy_.covariance_;
    _impl_.accuracy_.covariance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void XyzVectorAndAccuracy::unsafe_arena_set_allocated_covariance(::sensoris::protobuf::types::base::Int64Matrix3x3* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_accuracy();
  if (value) {
    set_has_covariance();
    _impl_.accuracy_.covariance_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.covariance)
}
inline ::sensoris::protobuf::types::base::Int64Matrix3x3* XyzVectorAndAccuracy::_internal_mutable_covariance() {
  if (accuracy_case() != kCovariance) {
    clear_accuracy();
    set_has_covariance();
    _impl_.accuracy_.covariance_ = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64Matrix3x3>(GetArena());
  }
  return _impl_.accuracy_.covariance_;
}
inline ::sensoris::protobuf::types::base::Int64Matrix3x3* XyzVectorAndAccuracy::mutable_covariance() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::Int64Matrix3x3* _msg = _internal_mutable_covariance();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.covariance)
  return _msg;
}

// repeated .google.protobuf.Any extension = 15;
inline int XyzVectorAndAccuracy::_internal_extension_size() const {
  return _internal_extension().size();
}
inline int XyzVectorAndAccuracy::extension_size() const {
  return _internal_extension_size();
}
inline ::google::protobuf::Any* XyzVectorAndAccuracy::mutable_extension(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.extension)
  return _internal_mutable_extension()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* XyzVectorAndAccuracy::mutable_extension()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.extension)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_extension();
}
inline const ::google::protobuf::Any& XyzVectorAndAccuracy::extension(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.extension)
  return _internal_extension().Get(index);
}
inline ::google::protobuf::Any* XyzVectorAndAccuracy::add_extension() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::google::protobuf::Any* _add = _internal_mutable_extension()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.extension)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& XyzVectorAndAccuracy::extension() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.extension)
  return _internal_extension();
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>&
XyzVectorAndAccuracy::_internal_extension() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.extension_;
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>*
XyzVectorAndAccuracy::_internal_mutable_extension() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.extension_;
}

inline bool XyzVectorAndAccuracy::has_geometry() const {
  return geometry_case() != GEOMETRY_NOT_SET;
}
inline void XyzVectorAndAccuracy::clear_has_geometry() {
  _impl_._oneof_case_[0] = GEOMETRY_NOT_SET;
}
inline bool XyzVectorAndAccuracy::has_accuracy() const {
  return accuracy_case() != ACCURACY_NOT_SET;
}
inline void XyzVectorAndAccuracy::clear_has_accuracy() {
  _impl_._oneof_case_[1] = ACCURACY_NOT_SET;
}
inline XyzVectorAndAccuracy::GeometryCase XyzVectorAndAccuracy::geometry_case() const {
  return XyzVectorAndAccuracy::GeometryCase(_impl_._oneof_case_[0]);
}
inline XyzVectorAndAccuracy::AccuracyCase XyzVectorAndAccuracy::accuracy_case() const {
  return XyzVectorAndAccuracy::AccuracyCase(_impl_._oneof_case_[1]);
}
// -------------------------------------------------------------------

// RectangularBoxAndAccuracy_CornerVectors

// .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy first_and_accuracy = 1 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool RectangularBoxAndAccuracy_CornerVectors::has_first_and_accuracy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.first_and_accuracy_ != nullptr);
  return value;
}
inline void RectangularBoxAndAccuracy_CornerVectors::clear_first_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.first_and_accuracy_ != nullptr) _impl_.first_and_accuracy_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& RectangularBoxAndAccuracy_CornerVectors::_internal_first_and_accuracy() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* p = _impl_.first_and_accuracy_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy&>(::sensoris::protobuf::types::spatial::_XyzVectorAndAccuracy_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& RectangularBoxAndAccuracy_CornerVectors::first_and_accuracy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors.first_and_accuracy)
  return _internal_first_and_accuracy();
}
inline void RectangularBoxAndAccuracy_CornerVectors::unsafe_arena_set_allocated_first_and_accuracy(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.first_and_accuracy_);
  }
  _impl_.first_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors.first_and_accuracy)
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* RectangularBoxAndAccuracy_CornerVectors::release_first_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* released = _impl_.first_and_accuracy_;
  _impl_.first_and_accuracy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* RectangularBoxAndAccuracy_CornerVectors::unsafe_arena_release_first_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors.first_and_accuracy)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* temp = _impl_.first_and_accuracy_;
  _impl_.first_and_accuracy_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* RectangularBoxAndAccuracy_CornerVectors::_internal_mutable_first_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.first_and_accuracy_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy>(GetArena());
    _impl_.first_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy*>(p);
  }
  return _impl_.first_and_accuracy_;
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* RectangularBoxAndAccuracy_CornerVectors::mutable_first_and_accuracy() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* _msg = _internal_mutable_first_and_accuracy();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors.first_and_accuracy)
  return _msg;
}
inline void RectangularBoxAndAccuracy_CornerVectors::set_allocated_first_and_accuracy(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy*>(_impl_.first_and_accuracy_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.first_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors.first_and_accuracy)
}

// .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy second_and_accuracy = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool RectangularBoxAndAccuracy_CornerVectors::has_second_and_accuracy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.second_and_accuracy_ != nullptr);
  return value;
}
inline void RectangularBoxAndAccuracy_CornerVectors::clear_second_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.second_and_accuracy_ != nullptr) _impl_.second_and_accuracy_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& RectangularBoxAndAccuracy_CornerVectors::_internal_second_and_accuracy() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* p = _impl_.second_and_accuracy_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy&>(::sensoris::protobuf::types::spatial::_XyzVectorAndAccuracy_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& RectangularBoxAndAccuracy_CornerVectors::second_and_accuracy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors.second_and_accuracy)
  return _internal_second_and_accuracy();
}
inline void RectangularBoxAndAccuracy_CornerVectors::unsafe_arena_set_allocated_second_and_accuracy(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.second_and_accuracy_);
  }
  _impl_.second_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors.second_and_accuracy)
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* RectangularBoxAndAccuracy_CornerVectors::release_second_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* released = _impl_.second_and_accuracy_;
  _impl_.second_and_accuracy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* RectangularBoxAndAccuracy_CornerVectors::unsafe_arena_release_second_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors.second_and_accuracy)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* temp = _impl_.second_and_accuracy_;
  _impl_.second_and_accuracy_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* RectangularBoxAndAccuracy_CornerVectors::_internal_mutable_second_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.second_and_accuracy_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy>(GetArena());
    _impl_.second_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy*>(p);
  }
  return _impl_.second_and_accuracy_;
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* RectangularBoxAndAccuracy_CornerVectors::mutable_second_and_accuracy() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* _msg = _internal_mutable_second_and_accuracy();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors.second_and_accuracy)
  return _msg;
}
inline void RectangularBoxAndAccuracy_CornerVectors::set_allocated_second_and_accuracy(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy*>(_impl_.second_and_accuracy_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.second_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors.second_and_accuracy)
}

// .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy third_and_accuracy = 3 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool RectangularBoxAndAccuracy_CornerVectors::has_third_and_accuracy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.third_and_accuracy_ != nullptr);
  return value;
}
inline void RectangularBoxAndAccuracy_CornerVectors::clear_third_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.third_and_accuracy_ != nullptr) _impl_.third_and_accuracy_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& RectangularBoxAndAccuracy_CornerVectors::_internal_third_and_accuracy() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* p = _impl_.third_and_accuracy_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy&>(::sensoris::protobuf::types::spatial::_XyzVectorAndAccuracy_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& RectangularBoxAndAccuracy_CornerVectors::third_and_accuracy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors.third_and_accuracy)
  return _internal_third_and_accuracy();
}
inline void RectangularBoxAndAccuracy_CornerVectors::unsafe_arena_set_allocated_third_and_accuracy(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.third_and_accuracy_);
  }
  _impl_.third_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors.third_and_accuracy)
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* RectangularBoxAndAccuracy_CornerVectors::release_third_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* released = _impl_.third_and_accuracy_;
  _impl_.third_and_accuracy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* RectangularBoxAndAccuracy_CornerVectors::unsafe_arena_release_third_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors.third_and_accuracy)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* temp = _impl_.third_and_accuracy_;
  _impl_.third_and_accuracy_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* RectangularBoxAndAccuracy_CornerVectors::_internal_mutable_third_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.third_and_accuracy_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy>(GetArena());
    _impl_.third_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy*>(p);
  }
  return _impl_.third_and_accuracy_;
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* RectangularBoxAndAccuracy_CornerVectors::mutable_third_and_accuracy() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* _msg = _internal_mutable_third_and_accuracy();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors.third_and_accuracy)
  return _msg;
}
inline void RectangularBoxAndAccuracy_CornerVectors::set_allocated_third_and_accuracy(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy*>(_impl_.third_and_accuracy_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.third_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors.third_and_accuracy)
}

// -------------------------------------------------------------------

// RectangularBoxAndAccuracy_CenterOrientationSize

// .sensoris.protobuf.types.spatial.PositionAndAccuracy center_position_and_accuracy = 1;
inline bool RectangularBoxAndAccuracy_CenterOrientationSize::has_center_position_and_accuracy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.center_position_and_accuracy_ != nullptr);
  return value;
}
inline void RectangularBoxAndAccuracy_CenterOrientationSize::clear_center_position_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.center_position_and_accuracy_ != nullptr) _impl_.center_position_and_accuracy_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& RectangularBoxAndAccuracy_CenterOrientationSize::_internal_center_position_and_accuracy() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy* p = _impl_.center_position_and_accuracy_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::spatial::PositionAndAccuracy&>(::sensoris::protobuf::types::spatial::_PositionAndAccuracy_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& RectangularBoxAndAccuracy_CenterOrientationSize::center_position_and_accuracy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize.center_position_and_accuracy)
  return _internal_center_position_and_accuracy();
}
inline void RectangularBoxAndAccuracy_CenterOrientationSize::unsafe_arena_set_allocated_center_position_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.center_position_and_accuracy_);
  }
  _impl_.center_position_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize.center_position_and_accuracy)
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* RectangularBoxAndAccuracy_CenterOrientationSize::release_center_position_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* released = _impl_.center_position_and_accuracy_;
  _impl_.center_position_and_accuracy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* RectangularBoxAndAccuracy_CenterOrientationSize::unsafe_arena_release_center_position_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize.center_position_and_accuracy)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* temp = _impl_.center_position_and_accuracy_;
  _impl_.center_position_and_accuracy_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* RectangularBoxAndAccuracy_CenterOrientationSize::_internal_mutable_center_position_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.center_position_and_accuracy_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::spatial::PositionAndAccuracy>(GetArena());
    _impl_.center_position_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(p);
  }
  return _impl_.center_position_and_accuracy_;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* RectangularBoxAndAccuracy_CenterOrientationSize::mutable_center_position_and_accuracy() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* _msg = _internal_mutable_center_position_and_accuracy();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize.center_position_and_accuracy)
  return _msg;
}
inline void RectangularBoxAndAccuracy_CenterOrientationSize::set_allocated_center_position_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(_impl_.center_position_and_accuracy_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.center_position_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize.center_position_and_accuracy)
}

// .sensoris.protobuf.types.spatial.RotationAndAccuracy orientation_and_accuracy = 2;
inline bool RectangularBoxAndAccuracy_CenterOrientationSize::has_orientation_and_accuracy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.orientation_and_accuracy_ != nullptr);
  return value;
}
inline void RectangularBoxAndAccuracy_CenterOrientationSize::clear_orientation_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.orientation_and_accuracy_ != nullptr) _impl_.orientation_and_accuracy_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::sensoris::protobuf::types::spatial::RotationAndAccuracy& RectangularBoxAndAccuracy_CenterOrientationSize::_internal_orientation_and_accuracy() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::spatial::RotationAndAccuracy* p = _impl_.orientation_and_accuracy_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::spatial::RotationAndAccuracy&>(::sensoris::protobuf::types::spatial::_RotationAndAccuracy_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::RotationAndAccuracy& RectangularBoxAndAccuracy_CenterOrientationSize::orientation_and_accuracy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize.orientation_and_accuracy)
  return _internal_orientation_and_accuracy();
}
inline void RectangularBoxAndAccuracy_CenterOrientationSize::unsafe_arena_set_allocated_orientation_and_accuracy(::sensoris::protobuf::types::spatial::RotationAndAccuracy* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.orientation_and_accuracy_);
  }
  _impl_.orientation_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::RotationAndAccuracy*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize.orientation_and_accuracy)
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy* RectangularBoxAndAccuracy_CenterOrientationSize::release_orientation_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy* released = _impl_.orientation_and_accuracy_;
  _impl_.orientation_and_accuracy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy* RectangularBoxAndAccuracy_CenterOrientationSize::unsafe_arena_release_orientation_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize.orientation_and_accuracy)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy* temp = _impl_.orientation_and_accuracy_;
  _impl_.orientation_and_accuracy_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy* RectangularBoxAndAccuracy_CenterOrientationSize::_internal_mutable_orientation_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.orientation_and_accuracy_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::spatial::RotationAndAccuracy>(GetArena());
    _impl_.orientation_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::RotationAndAccuracy*>(p);
  }
  return _impl_.orientation_and_accuracy_;
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy* RectangularBoxAndAccuracy_CenterOrientationSize::mutable_orientation_and_accuracy() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy* _msg = _internal_mutable_orientation_and_accuracy();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize.orientation_and_accuracy)
  return _msg;
}
inline void RectangularBoxAndAccuracy_CenterOrientationSize::set_allocated_orientation_and_accuracy(::sensoris::protobuf::types::spatial::RotationAndAccuracy* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::sensoris::protobuf::types::spatial::RotationAndAccuracy*>(_impl_.orientation_and_accuracy_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::sensoris::protobuf::types::spatial::RotationAndAccuracy*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.orientation_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::RotationAndAccuracy*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize.orientation_and_accuracy)
}

// .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy size_and_accuracy = 3 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool RectangularBoxAndAccuracy_CenterOrientationSize::has_size_and_accuracy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.size_and_accuracy_ != nullptr);
  return value;
}
inline void RectangularBoxAndAccuracy_CenterOrientationSize::clear_size_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.size_and_accuracy_ != nullptr) _impl_.size_and_accuracy_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& RectangularBoxAndAccuracy_CenterOrientationSize::_internal_size_and_accuracy() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* p = _impl_.size_and_accuracy_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy&>(::sensoris::protobuf::types::spatial::_XyzVectorAndAccuracy_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& RectangularBoxAndAccuracy_CenterOrientationSize::size_and_accuracy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize.size_and_accuracy)
  return _internal_size_and_accuracy();
}
inline void RectangularBoxAndAccuracy_CenterOrientationSize::unsafe_arena_set_allocated_size_and_accuracy(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.size_and_accuracy_);
  }
  _impl_.size_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize.size_and_accuracy)
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* RectangularBoxAndAccuracy_CenterOrientationSize::release_size_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* released = _impl_.size_and_accuracy_;
  _impl_.size_and_accuracy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* RectangularBoxAndAccuracy_CenterOrientationSize::unsafe_arena_release_size_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize.size_and_accuracy)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* temp = _impl_.size_and_accuracy_;
  _impl_.size_and_accuracy_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* RectangularBoxAndAccuracy_CenterOrientationSize::_internal_mutable_size_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.size_and_accuracy_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy>(GetArena());
    _impl_.size_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy*>(p);
  }
  return _impl_.size_and_accuracy_;
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* RectangularBoxAndAccuracy_CenterOrientationSize::mutable_size_and_accuracy() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* _msg = _internal_mutable_size_and_accuracy();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize.size_and_accuracy)
  return _msg;
}
inline void RectangularBoxAndAccuracy_CenterOrientationSize::set_allocated_size_and_accuracy(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy*>(_impl_.size_and_accuracy_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.size_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize.size_and_accuracy)
}

// -------------------------------------------------------------------

// RectangularBoxAndAccuracy

// .sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors corner_vectors = 1;
inline bool RectangularBoxAndAccuracy::has_corner_vectors() const {
  return geometry_case() == kCornerVectors;
}
inline bool RectangularBoxAndAccuracy::_internal_has_corner_vectors() const {
  return geometry_case() == kCornerVectors;
}
inline void RectangularBoxAndAccuracy::set_has_corner_vectors() {
  _impl_._oneof_case_[0] = kCornerVectors;
}
inline void RectangularBoxAndAccuracy::clear_corner_vectors() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (geometry_case() == kCornerVectors) {
    if (GetArena() == nullptr) {
      delete _impl_.geometry_.corner_vectors_;
    }
    clear_has_geometry();
  }
}
inline ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors* RectangularBoxAndAccuracy::release_corner_vectors() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.corner_vectors)
  if (geometry_case() == kCornerVectors) {
    clear_has_geometry();
    auto* temp = _impl_.geometry_.corner_vectors_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.geometry_.corner_vectors_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors& RectangularBoxAndAccuracy::_internal_corner_vectors() const {
  return geometry_case() == kCornerVectors ? *_impl_.geometry_.corner_vectors_ : reinterpret_cast<::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors&>(::sensoris::protobuf::types::spatial::_RectangularBoxAndAccuracy_CornerVectors_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors& RectangularBoxAndAccuracy::corner_vectors() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.corner_vectors)
  return _internal_corner_vectors();
}
inline ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors* RectangularBoxAndAccuracy::unsafe_arena_release_corner_vectors() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.corner_vectors)
  if (geometry_case() == kCornerVectors) {
    clear_has_geometry();
    auto* temp = _impl_.geometry_.corner_vectors_;
    _impl_.geometry_.corner_vectors_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RectangularBoxAndAccuracy::unsafe_arena_set_allocated_corner_vectors(::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_geometry();
  if (value) {
    set_has_corner_vectors();
    _impl_.geometry_.corner_vectors_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.corner_vectors)
}
inline ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors* RectangularBoxAndAccuracy::_internal_mutable_corner_vectors() {
  if (geometry_case() != kCornerVectors) {
    clear_geometry();
    set_has_corner_vectors();
    _impl_.geometry_.corner_vectors_ = CreateMaybeMessage<::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors>(GetArena());
  }
  return _impl_.geometry_.corner_vectors_;
}
inline ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors* RectangularBoxAndAccuracy::mutable_corner_vectors() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors* _msg = _internal_mutable_corner_vectors();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.corner_vectors)
  return _msg;
}

// .sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize center_orientation_size = 2;
inline bool RectangularBoxAndAccuracy::has_center_orientation_size() const {
  return geometry_case() == kCenterOrientationSize;
}
inline bool RectangularBoxAndAccuracy::_internal_has_center_orientation_size() const {
  return geometry_case() == kCenterOrientationSize;
}
inline void RectangularBoxAndAccuracy::set_has_center_orientation_size() {
  _impl_._oneof_case_[0] = kCenterOrientationSize;
}
inline void RectangularBoxAndAccuracy::clear_center_orientation_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (geometry_case() == kCenterOrientationSize) {
    if (GetArena() == nullptr) {
      delete _impl_.geometry_.center_orientation_size_;
    }
    clear_has_geometry();
  }
}
inline ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize* RectangularBoxAndAccuracy::release_center_orientation_size() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.center_orientation_size)
  if (geometry_case() == kCenterOrientationSize) {
    clear_has_geometry();
    auto* temp = _impl_.geometry_.center_orientation_size_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.geometry_.center_orientation_size_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize& RectangularBoxAndAccuracy::_internal_center_orientation_size() const {
  return geometry_case() == kCenterOrientationSize ? *_impl_.geometry_.center_orientation_size_ : reinterpret_cast<::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize&>(::sensoris::protobuf::types::spatial::_RectangularBoxAndAccuracy_CenterOrientationSize_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize& RectangularBoxAndAccuracy::center_orientation_size() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.center_orientation_size)
  return _internal_center_orientation_size();
}
inline ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize* RectangularBoxAndAccuracy::unsafe_arena_release_center_orientation_size() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.center_orientation_size)
  if (geometry_case() == kCenterOrientationSize) {
    clear_has_geometry();
    auto* temp = _impl_.geometry_.center_orientation_size_;
    _impl_.geometry_.center_orientation_size_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RectangularBoxAndAccuracy::unsafe_arena_set_allocated_center_orientation_size(::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_geometry();
  if (value) {
    set_has_center_orientation_size();
    _impl_.geometry_.center_orientation_size_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.center_orientation_size)
}
inline ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize* RectangularBoxAndAccuracy::_internal_mutable_center_orientation_size() {
  if (geometry_case() != kCenterOrientationSize) {
    clear_geometry();
    set_has_center_orientation_size();
    _impl_.geometry_.center_orientation_size_ = CreateMaybeMessage<::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize>(GetArena());
  }
  return _impl_.geometry_.center_orientation_size_;
}
inline ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize* RectangularBoxAndAccuracy::mutable_center_orientation_size() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize* _msg = _internal_mutable_center_orientation_size();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.center_orientation_size)
  return _msg;
}

// repeated .google.protobuf.Any extension = 15;
inline int RectangularBoxAndAccuracy::_internal_extension_size() const {
  return _internal_extension().size();
}
inline int RectangularBoxAndAccuracy::extension_size() const {
  return _internal_extension_size();
}
inline ::google::protobuf::Any* RectangularBoxAndAccuracy::mutable_extension(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.extension)
  return _internal_mutable_extension()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* RectangularBoxAndAccuracy::mutable_extension()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.extension)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_extension();
}
inline const ::google::protobuf::Any& RectangularBoxAndAccuracy::extension(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.extension)
  return _internal_extension().Get(index);
}
inline ::google::protobuf::Any* RectangularBoxAndAccuracy::add_extension() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::google::protobuf::Any* _add = _internal_mutable_extension()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.extension)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& RectangularBoxAndAccuracy::extension() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.extension)
  return _internal_extension();
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>&
RectangularBoxAndAccuracy::_internal_extension() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.extension_;
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>*
RectangularBoxAndAccuracy::_internal_mutable_extension() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.extension_;
}

inline bool RectangularBoxAndAccuracy::has_geometry() const {
  return geometry_case() != GEOMETRY_NOT_SET;
}
inline void RectangularBoxAndAccuracy::clear_has_geometry() {
  _impl_._oneof_case_[0] = GEOMETRY_NOT_SET;
}
inline RectangularBoxAndAccuracy::GeometryCase RectangularBoxAndAccuracy::geometry_case() const {
  return RectangularBoxAndAccuracy::GeometryCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// RotationAndAccuracy_Euler

// .sensoris.protobuf.types.base.Int64Value yaw = 1 [(.sensoris.protobuf.types.base.exponent) = 2];
inline bool RotationAndAccuracy_Euler::has_yaw() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.yaw_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Int64Value& RotationAndAccuracy_Euler::_internal_yaw() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::Int64Value* p = _impl_.yaw_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Int64Value&>(::sensoris::protobuf::types::base::_Int64Value_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64Value& RotationAndAccuracy_Euler::yaw() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler.yaw)
  return _internal_yaw();
}
inline void RotationAndAccuracy_Euler::unsafe_arena_set_allocated_yaw(::sensoris::protobuf::types::base::Int64Value* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.yaw_);
  }
  _impl_.yaw_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler.yaw)
}
inline ::sensoris::protobuf::types::base::Int64Value* RotationAndAccuracy_Euler::release_yaw() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Int64Value* released = _impl_.yaw_;
  _impl_.yaw_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::Int64Value* RotationAndAccuracy_Euler::unsafe_arena_release_yaw() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler.yaw)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Int64Value* temp = _impl_.yaw_;
  _impl_.yaw_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* RotationAndAccuracy_Euler::_internal_mutable_yaw() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.yaw_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64Value>(GetArena());
    _impl_.yaw_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(p);
  }
  return _impl_.yaw_;
}
inline ::sensoris::protobuf::types::base::Int64Value* RotationAndAccuracy_Euler::mutable_yaw() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::Int64Value* _msg = _internal_mutable_yaw();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler.yaw)
  return _msg;
}
inline void RotationAndAccuracy_Euler::set_allocated_yaw(::sensoris::protobuf::types::base::Int64Value* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.yaw_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.yaw_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler.yaw)
}

// .sensoris.protobuf.types.base.Int64Value pitch = 2 [(.sensoris.protobuf.types.base.exponent) = 2];
inline bool RotationAndAccuracy_Euler::has_pitch() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pitch_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Int64Value& RotationAndAccuracy_Euler::_internal_pitch() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::Int64Value* p = _impl_.pitch_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Int64Value&>(::sensoris::protobuf::types::base::_Int64Value_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64Value& RotationAndAccuracy_Euler::pitch() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler.pitch)
  return _internal_pitch();
}
inline void RotationAndAccuracy_Euler::unsafe_arena_set_allocated_pitch(::sensoris::protobuf::types::base::Int64Value* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pitch_);
  }
  _impl_.pitch_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler.pitch)
}
inline ::sensoris::protobuf::types::base::Int64Value* RotationAndAccuracy_Euler::release_pitch() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::Int64Value* released = _impl_.pitch_;
  _impl_.pitch_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::Int64Value* RotationAndAccuracy_Euler::unsafe_arena_release_pitch() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler.pitch)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::Int64Value* temp = _impl_.pitch_;
  _impl_.pitch_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* RotationAndAccuracy_Euler::_internal_mutable_pitch() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.pitch_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64Value>(GetArena());
    _impl_.pitch_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(p);
  }
  return _impl_.pitch_;
}
inline ::sensoris::protobuf::types::base::Int64Value* RotationAndAccuracy_Euler::mutable_pitch() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::Int64Value* _msg = _internal_mutable_pitch();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler.pitch)
  return _msg;
}
inline void RotationAndAccuracy_Euler::set_allocated_pitch(::sensoris::protobuf::types::base::Int64Value* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pitch_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.pitch_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler.pitch)
}

// .sensoris.protobuf.types.base.Int64Value roll = 3 [(.sensoris.protobuf.types.base.exponent) = 2];
inline bool RotationAndAccuracy_Euler::has_roll() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.roll_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Int64Value& RotationAndAccuracy_Euler::_internal_roll() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::Int64Value* p = _impl_.roll_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Int64Value&>(::sensoris::protobuf::types::base::_Int64Value_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64Value& RotationAndAccuracy_Euler::roll() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler.roll)
  return _internal_roll();
}
inline void RotationAndAccuracy_Euler::unsafe_arena_set_allocated_roll(::sensoris::protobuf::types::base::Int64Value* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.roll_);
  }
  _impl_.roll_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler.roll)
}
inline ::sensoris::protobuf::types::base::Int64Value* RotationAndAccuracy_Euler::release_roll() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::types::base::Int64Value* released = _impl_.roll_;
  _impl_.roll_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::Int64Value* RotationAndAccuracy_Euler::unsafe_arena_release_roll() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler.roll)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::types::base::Int64Value* temp = _impl_.roll_;
  _impl_.roll_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* RotationAndAccuracy_Euler::_internal_mutable_roll() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.roll_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64Value>(GetArena());
    _impl_.roll_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(p);
  }
  return _impl_.roll_;
}
inline ::sensoris::protobuf::types::base::Int64Value* RotationAndAccuracy_Euler::mutable_roll() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::Int64Value* _msg = _internal_mutable_roll();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler.roll)
  return _msg;
}
inline void RotationAndAccuracy_Euler::set_allocated_roll(::sensoris::protobuf::types::base::Int64Value* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.roll_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.roll_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler.roll)
}

// -------------------------------------------------------------------

// RotationAndAccuracy_Quaternion

// .sensoris.protobuf.types.base.Int64Value x = 1 [(.sensoris.protobuf.types.base.exponent) = 3];
inline bool RotationAndAccuracy_Quaternion::has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.x_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Int64Value& RotationAndAccuracy_Quaternion::_internal_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::Int64Value* p = _impl_.x_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Int64Value&>(::sensoris::protobuf::types::base::_Int64Value_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64Value& RotationAndAccuracy_Quaternion::x() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion.x)
  return _internal_x();
}
inline void RotationAndAccuracy_Quaternion::unsafe_arena_set_allocated_x(::sensoris::protobuf::types::base::Int64Value* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.x_);
  }
  _impl_.x_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion.x)
}
inline ::sensoris::protobuf::types::base::Int64Value* RotationAndAccuracy_Quaternion::release_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Int64Value* released = _impl_.x_;
  _impl_.x_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::Int64Value* RotationAndAccuracy_Quaternion::unsafe_arena_release_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion.x)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Int64Value* temp = _impl_.x_;
  _impl_.x_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* RotationAndAccuracy_Quaternion::_internal_mutable_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.x_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64Value>(GetArena());
    _impl_.x_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(p);
  }
  return _impl_.x_;
}
inline ::sensoris::protobuf::types::base::Int64Value* RotationAndAccuracy_Quaternion::mutable_x() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::Int64Value* _msg = _internal_mutable_x();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion.x)
  return _msg;
}
inline void RotationAndAccuracy_Quaternion::set_allocated_x(::sensoris::protobuf::types::base::Int64Value* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.x_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.x_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion.x)
}

// .sensoris.protobuf.types.base.Int64Value y = 2 [(.sensoris.protobuf.types.base.exponent) = 3];
inline bool RotationAndAccuracy_Quaternion::has_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.y_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Int64Value& RotationAndAccuracy_Quaternion::_internal_y() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::Int64Value* p = _impl_.y_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Int64Value&>(::sensoris::protobuf::types::base::_Int64Value_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64Value& RotationAndAccuracy_Quaternion::y() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion.y)
  return _internal_y();
}
inline void RotationAndAccuracy_Quaternion::unsafe_arena_set_allocated_y(::sensoris::protobuf::types::base::Int64Value* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.y_);
  }
  _impl_.y_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion.y)
}
inline ::sensoris::protobuf::types::base::Int64Value* RotationAndAccuracy_Quaternion::release_y() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::Int64Value* released = _impl_.y_;
  _impl_.y_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::Int64Value* RotationAndAccuracy_Quaternion::unsafe_arena_release_y() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion.y)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::Int64Value* temp = _impl_.y_;
  _impl_.y_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* RotationAndAccuracy_Quaternion::_internal_mutable_y() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.y_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64Value>(GetArena());
    _impl_.y_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(p);
  }
  return _impl_.y_;
}
inline ::sensoris::protobuf::types::base::Int64Value* RotationAndAccuracy_Quaternion::mutable_y() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::Int64Value* _msg = _internal_mutable_y();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion.y)
  return _msg;
}
inline void RotationAndAccuracy_Quaternion::set_allocated_y(::sensoris::protobuf::types::base::Int64Value* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.y_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.y_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion.y)
}

// .sensoris.protobuf.types.base.Int64Value z = 3 [(.sensoris.protobuf.types.base.exponent) = 3];
inline bool RotationAndAccuracy_Quaternion::has_z() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.z_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Int64Value& RotationAndAccuracy_Quaternion::_internal_z() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::Int64Value* p = _impl_.z_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Int64Value&>(::sensoris::protobuf::types::base::_Int64Value_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64Value& RotationAndAccuracy_Quaternion::z() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion.z)
  return _internal_z();
}
inline void RotationAndAccuracy_Quaternion::unsafe_arena_set_allocated_z(::sensoris::protobuf::types::base::Int64Value* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.z_);
  }
  _impl_.z_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion.z)
}
inline ::sensoris::protobuf::types::base::Int64Value* RotationAndAccuracy_Quaternion::release_z() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::types::base::Int64Value* released = _impl_.z_;
  _impl_.z_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::Int64Value* RotationAndAccuracy_Quaternion::unsafe_arena_release_z() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion.z)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::types::base::Int64Value* temp = _impl_.z_;
  _impl_.z_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* RotationAndAccuracy_Quaternion::_internal_mutable_z() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.z_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64Value>(GetArena());
    _impl_.z_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(p);
  }
  return _impl_.z_;
}
inline ::sensoris::protobuf::types::base::Int64Value* RotationAndAccuracy_Quaternion::mutable_z() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::Int64Value* _msg = _internal_mutable_z();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion.z)
  return _msg;
}
inline void RotationAndAccuracy_Quaternion::set_allocated_z(::sensoris::protobuf::types::base::Int64Value* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.z_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.z_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion.z)
}

// .sensoris.protobuf.types.base.Int64Value w = 4 [(.sensoris.protobuf.types.base.exponent) = 3];
inline bool RotationAndAccuracy_Quaternion::has_w() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.w_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Int64Value& RotationAndAccuracy_Quaternion::_internal_w() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::Int64Value* p = _impl_.w_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Int64Value&>(::sensoris::protobuf::types::base::_Int64Value_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64Value& RotationAndAccuracy_Quaternion::w() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion.w)
  return _internal_w();
}
inline void RotationAndAccuracy_Quaternion::unsafe_arena_set_allocated_w(::sensoris::protobuf::types::base::Int64Value* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.w_);
  }
  _impl_.w_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion.w)
}
inline ::sensoris::protobuf::types::base::Int64Value* RotationAndAccuracy_Quaternion::release_w() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::sensoris::protobuf::types::base::Int64Value* released = _impl_.w_;
  _impl_.w_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::Int64Value* RotationAndAccuracy_Quaternion::unsafe_arena_release_w() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion.w)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::sensoris::protobuf::types::base::Int64Value* temp = _impl_.w_;
  _impl_.w_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* RotationAndAccuracy_Quaternion::_internal_mutable_w() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.w_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64Value>(GetArena());
    _impl_.w_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(p);
  }
  return _impl_.w_;
}
inline ::sensoris::protobuf::types::base::Int64Value* RotationAndAccuracy_Quaternion::mutable_w() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::Int64Value* _msg = _internal_mutable_w();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion.w)
  return _msg;
}
inline void RotationAndAccuracy_Quaternion::set_allocated_w(::sensoris::protobuf::types::base::Int64Value* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.w_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.w_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion.w)
}

// -------------------------------------------------------------------

// RotationAndAccuracy_StdDev

// .google.protobuf.Int64Value yaw = 1 [(.sensoris.protobuf.types.base.exponent) = 2];
inline bool RotationAndAccuracy_StdDev::has_yaw() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.yaw_ != nullptr);
  return value;
}
inline const ::google::protobuf::Int64Value& RotationAndAccuracy_StdDev::_internal_yaw() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Int64Value* p = _impl_.yaw_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Int64Value&>(::google::protobuf::_Int64Value_default_instance_);
}
inline const ::google::protobuf::Int64Value& RotationAndAccuracy_StdDev::yaw() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev.yaw)
  return _internal_yaw();
}
inline void RotationAndAccuracy_StdDev::unsafe_arena_set_allocated_yaw(::google::protobuf::Int64Value* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.yaw_);
  }
  _impl_.yaw_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev.yaw)
}
inline ::google::protobuf::Int64Value* RotationAndAccuracy_StdDev::release_yaw() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Int64Value* released = _impl_.yaw_;
  _impl_.yaw_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Int64Value* RotationAndAccuracy_StdDev::unsafe_arena_release_yaw() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev.yaw)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Int64Value* temp = _impl_.yaw_;
  _impl_.yaw_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int64Value* RotationAndAccuracy_StdDev::_internal_mutable_yaw() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.yaw_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int64Value>(GetArena());
    _impl_.yaw_ = reinterpret_cast<::google::protobuf::Int64Value*>(p);
  }
  return _impl_.yaw_;
}
inline ::google::protobuf::Int64Value* RotationAndAccuracy_StdDev::mutable_yaw() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Int64Value* _msg = _internal_mutable_yaw();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev.yaw)
  return _msg;
}
inline void RotationAndAccuracy_StdDev::set_allocated_yaw(::google::protobuf::Int64Value* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.yaw_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.yaw_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev.yaw)
}

// .google.protobuf.Int64Value pitch = 2 [(.sensoris.protobuf.types.base.exponent) = 2];
inline bool RotationAndAccuracy_StdDev::has_pitch() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pitch_ != nullptr);
  return value;
}
inline const ::google::protobuf::Int64Value& RotationAndAccuracy_StdDev::_internal_pitch() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Int64Value* p = _impl_.pitch_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Int64Value&>(::google::protobuf::_Int64Value_default_instance_);
}
inline const ::google::protobuf::Int64Value& RotationAndAccuracy_StdDev::pitch() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev.pitch)
  return _internal_pitch();
}
inline void RotationAndAccuracy_StdDev::unsafe_arena_set_allocated_pitch(::google::protobuf::Int64Value* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pitch_);
  }
  _impl_.pitch_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev.pitch)
}
inline ::google::protobuf::Int64Value* RotationAndAccuracy_StdDev::release_pitch() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Int64Value* released = _impl_.pitch_;
  _impl_.pitch_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Int64Value* RotationAndAccuracy_StdDev::unsafe_arena_release_pitch() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev.pitch)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Int64Value* temp = _impl_.pitch_;
  _impl_.pitch_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int64Value* RotationAndAccuracy_StdDev::_internal_mutable_pitch() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.pitch_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int64Value>(GetArena());
    _impl_.pitch_ = reinterpret_cast<::google::protobuf::Int64Value*>(p);
  }
  return _impl_.pitch_;
}
inline ::google::protobuf::Int64Value* RotationAndAccuracy_StdDev::mutable_pitch() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Int64Value* _msg = _internal_mutable_pitch();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev.pitch)
  return _msg;
}
inline void RotationAndAccuracy_StdDev::set_allocated_pitch(::google::protobuf::Int64Value* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pitch_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.pitch_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev.pitch)
}

// .google.protobuf.Int64Value roll = 3 [(.sensoris.protobuf.types.base.exponent) = 2];
inline bool RotationAndAccuracy_StdDev::has_roll() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.roll_ != nullptr);
  return value;
}
inline const ::google::protobuf::Int64Value& RotationAndAccuracy_StdDev::_internal_roll() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Int64Value* p = _impl_.roll_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Int64Value&>(::google::protobuf::_Int64Value_default_instance_);
}
inline const ::google::protobuf::Int64Value& RotationAndAccuracy_StdDev::roll() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev.roll)
  return _internal_roll();
}
inline void RotationAndAccuracy_StdDev::unsafe_arena_set_allocated_roll(::google::protobuf::Int64Value* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.roll_);
  }
  _impl_.roll_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev.roll)
}
inline ::google::protobuf::Int64Value* RotationAndAccuracy_StdDev::release_roll() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Int64Value* released = _impl_.roll_;
  _impl_.roll_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Int64Value* RotationAndAccuracy_StdDev::unsafe_arena_release_roll() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev.roll)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Int64Value* temp = _impl_.roll_;
  _impl_.roll_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int64Value* RotationAndAccuracy_StdDev::_internal_mutable_roll() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.roll_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int64Value>(GetArena());
    _impl_.roll_ = reinterpret_cast<::google::protobuf::Int64Value*>(p);
  }
  return _impl_.roll_;
}
inline ::google::protobuf::Int64Value* RotationAndAccuracy_StdDev::mutable_roll() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Int64Value* _msg = _internal_mutable_roll();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev.roll)
  return _msg;
}
inline void RotationAndAccuracy_StdDev::set_allocated_roll(::google::protobuf::Int64Value* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.roll_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.roll_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev.roll)
}

// -------------------------------------------------------------------

// RotationAndAccuracy

// .sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler euler_vehicle = 1;
inline bool RotationAndAccuracy::has_euler_vehicle() const {
  return euler_quaternion_case() == kEulerVehicle;
}
inline bool RotationAndAccuracy::_internal_has_euler_vehicle() const {
  return euler_quaternion_case() == kEulerVehicle;
}
inline void RotationAndAccuracy::set_has_euler_vehicle() {
  _impl_._oneof_case_[0] = kEulerVehicle;
}
inline void RotationAndAccuracy::clear_euler_vehicle() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (euler_quaternion_case() == kEulerVehicle) {
    if (GetArena() == nullptr) {
      delete _impl_.euler_quaternion_.euler_vehicle_;
    }
    clear_has_euler_quaternion();
  }
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* RotationAndAccuracy::release_euler_vehicle() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.euler_vehicle)
  if (euler_quaternion_case() == kEulerVehicle) {
    clear_has_euler_quaternion();
    auto* temp = _impl_.euler_quaternion_.euler_vehicle_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.euler_quaternion_.euler_vehicle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler& RotationAndAccuracy::_internal_euler_vehicle() const {
  return euler_quaternion_case() == kEulerVehicle ? *_impl_.euler_quaternion_.euler_vehicle_ : reinterpret_cast<::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler&>(::sensoris::protobuf::types::spatial::_RotationAndAccuracy_Euler_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler& RotationAndAccuracy::euler_vehicle() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationAndAccuracy.euler_vehicle)
  return _internal_euler_vehicle();
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* RotationAndAccuracy::unsafe_arena_release_euler_vehicle() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.euler_vehicle)
  if (euler_quaternion_case() == kEulerVehicle) {
    clear_has_euler_quaternion();
    auto* temp = _impl_.euler_quaternion_.euler_vehicle_;
    _impl_.euler_quaternion_.euler_vehicle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RotationAndAccuracy::unsafe_arena_set_allocated_euler_vehicle(::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_euler_quaternion();
  if (value) {
    set_has_euler_vehicle();
    _impl_.euler_quaternion_.euler_vehicle_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.euler_vehicle)
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* RotationAndAccuracy::_internal_mutable_euler_vehicle() {
  if (euler_quaternion_case() != kEulerVehicle) {
    clear_euler_quaternion();
    set_has_euler_vehicle();
    _impl_.euler_quaternion_.euler_vehicle_ = CreateMaybeMessage<::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler>(GetArena());
  }
  return _impl_.euler_quaternion_.euler_vehicle_;
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* RotationAndAccuracy::mutable_euler_vehicle() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* _msg = _internal_mutable_euler_vehicle();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationAndAccuracy.euler_vehicle)
  return _msg;
}

// .sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler euler_event_group = 2;
inline bool RotationAndAccuracy::has_euler_event_group() const {
  return euler_quaternion_case() == kEulerEventGroup;
}
inline bool RotationAndAccuracy::_internal_has_euler_event_group() const {
  return euler_quaternion_case() == kEulerEventGroup;
}
inline void RotationAndAccuracy::set_has_euler_event_group() {
  _impl_._oneof_case_[0] = kEulerEventGroup;
}
inline void RotationAndAccuracy::clear_euler_event_group() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (euler_quaternion_case() == kEulerEventGroup) {
    if (GetArena() == nullptr) {
      delete _impl_.euler_quaternion_.euler_event_group_;
    }
    clear_has_euler_quaternion();
  }
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* RotationAndAccuracy::release_euler_event_group() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.euler_event_group)
  if (euler_quaternion_case() == kEulerEventGroup) {
    clear_has_euler_quaternion();
    auto* temp = _impl_.euler_quaternion_.euler_event_group_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.euler_quaternion_.euler_event_group_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler& RotationAndAccuracy::_internal_euler_event_group() const {
  return euler_quaternion_case() == kEulerEventGroup ? *_impl_.euler_quaternion_.euler_event_group_ : reinterpret_cast<::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler&>(::sensoris::protobuf::types::spatial::_RotationAndAccuracy_Euler_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler& RotationAndAccuracy::euler_event_group() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationAndAccuracy.euler_event_group)
  return _internal_euler_event_group();
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* RotationAndAccuracy::unsafe_arena_release_euler_event_group() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.euler_event_group)
  if (euler_quaternion_case() == kEulerEventGroup) {
    clear_has_euler_quaternion();
    auto* temp = _impl_.euler_quaternion_.euler_event_group_;
    _impl_.euler_quaternion_.euler_event_group_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RotationAndAccuracy::unsafe_arena_set_allocated_euler_event_group(::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_euler_quaternion();
  if (value) {
    set_has_euler_event_group();
    _impl_.euler_quaternion_.euler_event_group_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.euler_event_group)
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* RotationAndAccuracy::_internal_mutable_euler_event_group() {
  if (euler_quaternion_case() != kEulerEventGroup) {
    clear_euler_quaternion();
    set_has_euler_event_group();
    _impl_.euler_quaternion_.euler_event_group_ = CreateMaybeMessage<::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler>(GetArena());
  }
  return _impl_.euler_quaternion_.euler_event_group_;
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* RotationAndAccuracy::mutable_euler_event_group() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* _msg = _internal_mutable_euler_event_group();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationAndAccuracy.euler_event_group)
  return _msg;
}

// .sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion quaternion_vehicle = 3;
inline bool RotationAndAccuracy::has_quaternion_vehicle() const {
  return euler_quaternion_case() == kQuaternionVehicle;
}
inline bool RotationAndAccuracy::_internal_has_quaternion_vehicle() const {
  return euler_quaternion_case() == kQuaternionVehicle;
}
inline void RotationAndAccuracy::set_has_quaternion_vehicle() {
  _impl_._oneof_case_[0] = kQuaternionVehicle;
}
inline void RotationAndAccuracy::clear_quaternion_vehicle() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (euler_quaternion_case() == kQuaternionVehicle) {
    if (GetArena() == nullptr) {
      delete _impl_.euler_quaternion_.quaternion_vehicle_;
    }
    clear_has_euler_quaternion();
  }
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* RotationAndAccuracy::release_quaternion_vehicle() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.quaternion_vehicle)
  if (euler_quaternion_case() == kQuaternionVehicle) {
    clear_has_euler_quaternion();
    auto* temp = _impl_.euler_quaternion_.quaternion_vehicle_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.euler_quaternion_.quaternion_vehicle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion& RotationAndAccuracy::_internal_quaternion_vehicle() const {
  return euler_quaternion_case() == kQuaternionVehicle ? *_impl_.euler_quaternion_.quaternion_vehicle_ : reinterpret_cast<::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion&>(::sensoris::protobuf::types::spatial::_RotationAndAccuracy_Quaternion_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion& RotationAndAccuracy::quaternion_vehicle() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationAndAccuracy.quaternion_vehicle)
  return _internal_quaternion_vehicle();
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* RotationAndAccuracy::unsafe_arena_release_quaternion_vehicle() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.quaternion_vehicle)
  if (euler_quaternion_case() == kQuaternionVehicle) {
    clear_has_euler_quaternion();
    auto* temp = _impl_.euler_quaternion_.quaternion_vehicle_;
    _impl_.euler_quaternion_.quaternion_vehicle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RotationAndAccuracy::unsafe_arena_set_allocated_quaternion_vehicle(::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_euler_quaternion();
  if (value) {
    set_has_quaternion_vehicle();
    _impl_.euler_quaternion_.quaternion_vehicle_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.quaternion_vehicle)
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* RotationAndAccuracy::_internal_mutable_quaternion_vehicle() {
  if (euler_quaternion_case() != kQuaternionVehicle) {
    clear_euler_quaternion();
    set_has_quaternion_vehicle();
    _impl_.euler_quaternion_.quaternion_vehicle_ = CreateMaybeMessage<::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion>(GetArena());
  }
  return _impl_.euler_quaternion_.quaternion_vehicle_;
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* RotationAndAccuracy::mutable_quaternion_vehicle() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* _msg = _internal_mutable_quaternion_vehicle();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationAndAccuracy.quaternion_vehicle)
  return _msg;
}

// .sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion quaternion_event_group = 4;
inline bool RotationAndAccuracy::has_quaternion_event_group() const {
  return euler_quaternion_case() == kQuaternionEventGroup;
}
inline bool RotationAndAccuracy::_internal_has_quaternion_event_group() const {
  return euler_quaternion_case() == kQuaternionEventGroup;
}
inline void RotationAndAccuracy::set_has_quaternion_event_group() {
  _impl_._oneof_case_[0] = kQuaternionEventGroup;
}
inline void RotationAndAccuracy::clear_quaternion_event_group() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (euler_quaternion_case() == kQuaternionEventGroup) {
    if (GetArena() == nullptr) {
      delete _impl_.euler_quaternion_.quaternion_event_group_;
    }
    clear_has_euler_quaternion();
  }
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* RotationAndAccuracy::release_quaternion_event_group() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.quaternion_event_group)
  if (euler_quaternion_case() == kQuaternionEventGroup) {
    clear_has_euler_quaternion();
    auto* temp = _impl_.euler_quaternion_.quaternion_event_group_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.euler_quaternion_.quaternion_event_group_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion& RotationAndAccuracy::_internal_quaternion_event_group() const {
  return euler_quaternion_case() == kQuaternionEventGroup ? *_impl_.euler_quaternion_.quaternion_event_group_ : reinterpret_cast<::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion&>(::sensoris::protobuf::types::spatial::_RotationAndAccuracy_Quaternion_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion& RotationAndAccuracy::quaternion_event_group() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationAndAccuracy.quaternion_event_group)
  return _internal_quaternion_event_group();
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* RotationAndAccuracy::unsafe_arena_release_quaternion_event_group() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.quaternion_event_group)
  if (euler_quaternion_case() == kQuaternionEventGroup) {
    clear_has_euler_quaternion();
    auto* temp = _impl_.euler_quaternion_.quaternion_event_group_;
    _impl_.euler_quaternion_.quaternion_event_group_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RotationAndAccuracy::unsafe_arena_set_allocated_quaternion_event_group(::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_euler_quaternion();
  if (value) {
    set_has_quaternion_event_group();
    _impl_.euler_quaternion_.quaternion_event_group_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.quaternion_event_group)
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* RotationAndAccuracy::_internal_mutable_quaternion_event_group() {
  if (euler_quaternion_case() != kQuaternionEventGroup) {
    clear_euler_quaternion();
    set_has_quaternion_event_group();
    _impl_.euler_quaternion_.quaternion_event_group_ = CreateMaybeMessage<::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion>(GetArena());
  }
  return _impl_.euler_quaternion_.quaternion_event_group_;
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* RotationAndAccuracy::mutable_quaternion_event_group() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* _msg = _internal_mutable_quaternion_event_group();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationAndAccuracy.quaternion_event_group)
  return _msg;
}

// .google.protobuf.Int64Value combined_std_dev = 5 [(.sensoris.protobuf.types.base.exponent) = 2];
inline bool RotationAndAccuracy::has_combined_std_dev() const {
  return accuracy_case() == kCombinedStdDev;
}
inline bool RotationAndAccuracy::_internal_has_combined_std_dev() const {
  return accuracy_case() == kCombinedStdDev;
}
inline void RotationAndAccuracy::set_has_combined_std_dev() {
  _impl_._oneof_case_[1] = kCombinedStdDev;
}
inline ::google::protobuf::Int64Value* RotationAndAccuracy::release_combined_std_dev() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.combined_std_dev)
  if (accuracy_case() == kCombinedStdDev) {
    clear_has_accuracy();
    auto* temp = _impl_.accuracy_.combined_std_dev_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.accuracy_.combined_std_dev_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::protobuf::Int64Value& RotationAndAccuracy::_internal_combined_std_dev() const {
  return accuracy_case() == kCombinedStdDev ? *_impl_.accuracy_.combined_std_dev_ : reinterpret_cast<::google::protobuf::Int64Value&>(::google::protobuf::_Int64Value_default_instance_);
}
inline const ::google::protobuf::Int64Value& RotationAndAccuracy::combined_std_dev() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationAndAccuracy.combined_std_dev)
  return _internal_combined_std_dev();
}
inline ::google::protobuf::Int64Value* RotationAndAccuracy::unsafe_arena_release_combined_std_dev() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.combined_std_dev)
  if (accuracy_case() == kCombinedStdDev) {
    clear_has_accuracy();
    auto* temp = _impl_.accuracy_.combined_std_dev_;
    _impl_.accuracy_.combined_std_dev_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RotationAndAccuracy::unsafe_arena_set_allocated_combined_std_dev(::google::protobuf::Int64Value* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_accuracy();
  if (value) {
    set_has_combined_std_dev();
    _impl_.accuracy_.combined_std_dev_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.combined_std_dev)
}
inline ::google::protobuf::Int64Value* RotationAndAccuracy::_internal_mutable_combined_std_dev() {
  if (accuracy_case() != kCombinedStdDev) {
    clear_accuracy();
    set_has_combined_std_dev();
    _impl_.accuracy_.combined_std_dev_ = CreateMaybeMessage<::google::protobuf::Int64Value>(GetArena());
  }
  return _impl_.accuracy_.combined_std_dev_;
}
inline ::google::protobuf::Int64Value* RotationAndAccuracy::mutable_combined_std_dev() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Int64Value* _msg = _internal_mutable_combined_std_dev();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationAndAccuracy.combined_std_dev)
  return _msg;
}

// .sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev std_dev = 6;
inline bool RotationAndAccuracy::has_std_dev() const {
  return accuracy_case() == kStdDev;
}
inline bool RotationAndAccuracy::_internal_has_std_dev() const {
  return accuracy_case() == kStdDev;
}
inline void RotationAndAccuracy::set_has_std_dev() {
  _impl_._oneof_case_[1] = kStdDev;
}
inline void RotationAndAccuracy::clear_std_dev() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (accuracy_case() == kStdDev) {
    if (GetArena() == nullptr) {
      delete _impl_.accuracy_.std_dev_;
    }
    clear_has_accuracy();
  }
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev* RotationAndAccuracy::release_std_dev() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.std_dev)
  if (accuracy_case() == kStdDev) {
    clear_has_accuracy();
    auto* temp = _impl_.accuracy_.std_dev_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.accuracy_.std_dev_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev& RotationAndAccuracy::_internal_std_dev() const {
  return accuracy_case() == kStdDev ? *_impl_.accuracy_.std_dev_ : reinterpret_cast<::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev&>(::sensoris::protobuf::types::spatial::_RotationAndAccuracy_StdDev_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev& RotationAndAccuracy::std_dev() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationAndAccuracy.std_dev)
  return _internal_std_dev();
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev* RotationAndAccuracy::unsafe_arena_release_std_dev() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.std_dev)
  if (accuracy_case() == kStdDev) {
    clear_has_accuracy();
    auto* temp = _impl_.accuracy_.std_dev_;
    _impl_.accuracy_.std_dev_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RotationAndAccuracy::unsafe_arena_set_allocated_std_dev(::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_accuracy();
  if (value) {
    set_has_std_dev();
    _impl_.accuracy_.std_dev_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.std_dev)
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev* RotationAndAccuracy::_internal_mutable_std_dev() {
  if (accuracy_case() != kStdDev) {
    clear_accuracy();
    set_has_std_dev();
    _impl_.accuracy_.std_dev_ = CreateMaybeMessage<::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev>(GetArena());
  }
  return _impl_.accuracy_.std_dev_;
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev* RotationAndAccuracy::mutable_std_dev() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev* _msg = _internal_mutable_std_dev();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationAndAccuracy.std_dev)
  return _msg;
}

// .sensoris.protobuf.types.base.Int64Matrix3x3 covariance = 7 [(.sensoris.protobuf.types.base.exponent) = 2];
inline bool RotationAndAccuracy::has_covariance() const {
  return accuracy_case() == kCovariance;
}
inline bool RotationAndAccuracy::_internal_has_covariance() const {
  return accuracy_case() == kCovariance;
}
inline void RotationAndAccuracy::set_has_covariance() {
  _impl_._oneof_case_[1] = kCovariance;
}
inline ::sensoris::protobuf::types::base::Int64Matrix3x3* RotationAndAccuracy::release_covariance() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.covariance)
  if (accuracy_case() == kCovariance) {
    clear_has_accuracy();
    auto* temp = _impl_.accuracy_.covariance_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.accuracy_.covariance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensoris::protobuf::types::base::Int64Matrix3x3& RotationAndAccuracy::_internal_covariance() const {
  return accuracy_case() == kCovariance ? *_impl_.accuracy_.covariance_ : reinterpret_cast<::sensoris::protobuf::types::base::Int64Matrix3x3&>(::sensoris::protobuf::types::base::_Int64Matrix3x3_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64Matrix3x3& RotationAndAccuracy::covariance() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationAndAccuracy.covariance)
  return _internal_covariance();
}
inline ::sensoris::protobuf::types::base::Int64Matrix3x3* RotationAndAccuracy::unsafe_arena_release_covariance() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.covariance)
  if (accuracy_case() == kCovariance) {
    clear_has_accuracy();
    auto* temp = _impl_.accuracy_.covariance_;
    _impl_.accuracy_.covariance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RotationAndAccuracy::unsafe_arena_set_allocated_covariance(::sensoris::protobuf::types::base::Int64Matrix3x3* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_accuracy();
  if (value) {
    set_has_covariance();
    _impl_.accuracy_.covariance_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.covariance)
}
inline ::sensoris::protobuf::types::base::Int64Matrix3x3* RotationAndAccuracy::_internal_mutable_covariance() {
  if (accuracy_case() != kCovariance) {
    clear_accuracy();
    set_has_covariance();
    _impl_.accuracy_.covariance_ = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64Matrix3x3>(GetArena());
  }
  return _impl_.accuracy_.covariance_;
}
inline ::sensoris::protobuf::types::base::Int64Matrix3x3* RotationAndAccuracy::mutable_covariance() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::Int64Matrix3x3* _msg = _internal_mutable_covariance();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationAndAccuracy.covariance)
  return _msg;
}

// repeated .google.protobuf.Any extension = 15;
inline int RotationAndAccuracy::_internal_extension_size() const {
  return _internal_extension().size();
}
inline int RotationAndAccuracy::extension_size() const {
  return _internal_extension_size();
}
inline ::google::protobuf::Any* RotationAndAccuracy::mutable_extension(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationAndAccuracy.extension)
  return _internal_mutable_extension()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* RotationAndAccuracy::mutable_extension()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.types.spatial.RotationAndAccuracy.extension)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_extension();
}
inline const ::google::protobuf::Any& RotationAndAccuracy::extension(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationAndAccuracy.extension)
  return _internal_extension().Get(index);
}
inline ::google::protobuf::Any* RotationAndAccuracy::add_extension() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::google::protobuf::Any* _add = _internal_mutable_extension()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.types.spatial.RotationAndAccuracy.extension)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& RotationAndAccuracy::extension() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.types.spatial.RotationAndAccuracy.extension)
  return _internal_extension();
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>&
RotationAndAccuracy::_internal_extension() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.extension_;
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>*
RotationAndAccuracy::_internal_mutable_extension() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.extension_;
}

inline bool RotationAndAccuracy::has_euler_quaternion() const {
  return euler_quaternion_case() != EULER_QUATERNION_NOT_SET;
}
inline void RotationAndAccuracy::clear_has_euler_quaternion() {
  _impl_._oneof_case_[0] = EULER_QUATERNION_NOT_SET;
}
inline bool RotationAndAccuracy::has_accuracy() const {
  return accuracy_case() != ACCURACY_NOT_SET;
}
inline void RotationAndAccuracy::clear_has_accuracy() {
  _impl_._oneof_case_[1] = ACCURACY_NOT_SET;
}
inline RotationAndAccuracy::EulerQuaternionCase RotationAndAccuracy::euler_quaternion_case() const {
  return RotationAndAccuracy::EulerQuaternionCase(_impl_._oneof_case_[0]);
}
inline RotationAndAccuracy::AccuracyCase RotationAndAccuracy::accuracy_case() const {
  return RotationAndAccuracy::AccuracyCase(_impl_._oneof_case_[1]);
}
// -------------------------------------------------------------------

// RotationRateAndAccuracy_StdDev

// .google.protobuf.Int64Value yaw = 1 [(.sensoris.protobuf.types.base.exponent) = 2];
inline bool RotationRateAndAccuracy_StdDev::has_yaw() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.yaw_ != nullptr);
  return value;
}
inline const ::google::protobuf::Int64Value& RotationRateAndAccuracy_StdDev::_internal_yaw() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Int64Value* p = _impl_.yaw_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Int64Value&>(::google::protobuf::_Int64Value_default_instance_);
}
inline const ::google::protobuf::Int64Value& RotationRateAndAccuracy_StdDev::yaw() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev.yaw)
  return _internal_yaw();
}
inline void RotationRateAndAccuracy_StdDev::unsafe_arena_set_allocated_yaw(::google::protobuf::Int64Value* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.yaw_);
  }
  _impl_.yaw_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev.yaw)
}
inline ::google::protobuf::Int64Value* RotationRateAndAccuracy_StdDev::release_yaw() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Int64Value* released = _impl_.yaw_;
  _impl_.yaw_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Int64Value* RotationRateAndAccuracy_StdDev::unsafe_arena_release_yaw() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev.yaw)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Int64Value* temp = _impl_.yaw_;
  _impl_.yaw_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int64Value* RotationRateAndAccuracy_StdDev::_internal_mutable_yaw() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.yaw_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int64Value>(GetArena());
    _impl_.yaw_ = reinterpret_cast<::google::protobuf::Int64Value*>(p);
  }
  return _impl_.yaw_;
}
inline ::google::protobuf::Int64Value* RotationRateAndAccuracy_StdDev::mutable_yaw() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Int64Value* _msg = _internal_mutable_yaw();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev.yaw)
  return _msg;
}
inline void RotationRateAndAccuracy_StdDev::set_allocated_yaw(::google::protobuf::Int64Value* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.yaw_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.yaw_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev.yaw)
}

// .google.protobuf.Int64Value pitch = 2 [(.sensoris.protobuf.types.base.exponent) = 2];
inline bool RotationRateAndAccuracy_StdDev::has_pitch() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pitch_ != nullptr);
  return value;
}
inline const ::google::protobuf::Int64Value& RotationRateAndAccuracy_StdDev::_internal_pitch() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Int64Value* p = _impl_.pitch_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Int64Value&>(::google::protobuf::_Int64Value_default_instance_);
}
inline const ::google::protobuf::Int64Value& RotationRateAndAccuracy_StdDev::pitch() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev.pitch)
  return _internal_pitch();
}
inline void RotationRateAndAccuracy_StdDev::unsafe_arena_set_allocated_pitch(::google::protobuf::Int64Value* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pitch_);
  }
  _impl_.pitch_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev.pitch)
}
inline ::google::protobuf::Int64Value* RotationRateAndAccuracy_StdDev::release_pitch() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Int64Value* released = _impl_.pitch_;
  _impl_.pitch_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Int64Value* RotationRateAndAccuracy_StdDev::unsafe_arena_release_pitch() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev.pitch)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Int64Value* temp = _impl_.pitch_;
  _impl_.pitch_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int64Value* RotationRateAndAccuracy_StdDev::_internal_mutable_pitch() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.pitch_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int64Value>(GetArena());
    _impl_.pitch_ = reinterpret_cast<::google::protobuf::Int64Value*>(p);
  }
  return _impl_.pitch_;
}
inline ::google::protobuf::Int64Value* RotationRateAndAccuracy_StdDev::mutable_pitch() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Int64Value* _msg = _internal_mutable_pitch();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev.pitch)
  return _msg;
}
inline void RotationRateAndAccuracy_StdDev::set_allocated_pitch(::google::protobuf::Int64Value* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pitch_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.pitch_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev.pitch)
}

// .google.protobuf.Int64Value roll = 3 [(.sensoris.protobuf.types.base.exponent) = 2];
inline bool RotationRateAndAccuracy_StdDev::has_roll() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.roll_ != nullptr);
  return value;
}
inline const ::google::protobuf::Int64Value& RotationRateAndAccuracy_StdDev::_internal_roll() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Int64Value* p = _impl_.roll_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Int64Value&>(::google::protobuf::_Int64Value_default_instance_);
}
inline const ::google::protobuf::Int64Value& RotationRateAndAccuracy_StdDev::roll() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev.roll)
  return _internal_roll();
}
inline void RotationRateAndAccuracy_StdDev::unsafe_arena_set_allocated_roll(::google::protobuf::Int64Value* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.roll_);
  }
  _impl_.roll_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev.roll)
}
inline ::google::protobuf::Int64Value* RotationRateAndAccuracy_StdDev::release_roll() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Int64Value* released = _impl_.roll_;
  _impl_.roll_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Int64Value* RotationRateAndAccuracy_StdDev::unsafe_arena_release_roll() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev.roll)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Int64Value* temp = _impl_.roll_;
  _impl_.roll_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int64Value* RotationRateAndAccuracy_StdDev::_internal_mutable_roll() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.roll_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int64Value>(GetArena());
    _impl_.roll_ = reinterpret_cast<::google::protobuf::Int64Value*>(p);
  }
  return _impl_.roll_;
}
inline ::google::protobuf::Int64Value* RotationRateAndAccuracy_StdDev::mutable_roll() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Int64Value* _msg = _internal_mutable_roll();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev.roll)
  return _msg;
}
inline void RotationRateAndAccuracy_StdDev::set_allocated_roll(::google::protobuf::Int64Value* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.roll_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.roll_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev.roll)
}

// -------------------------------------------------------------------

// RotationRateAndAccuracy

// .sensoris.protobuf.types.base.Int64Value yaw = 1 [(.sensoris.protobuf.types.base.exponent) = 2];
inline bool RotationRateAndAccuracy::has_yaw() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.yaw_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Int64Value& RotationRateAndAccuracy::_internal_yaw() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::Int64Value* p = _impl_.yaw_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Int64Value&>(::sensoris::protobuf::types::base::_Int64Value_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64Value& RotationRateAndAccuracy::yaw() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.yaw)
  return _internal_yaw();
}
inline void RotationRateAndAccuracy::unsafe_arena_set_allocated_yaw(::sensoris::protobuf::types::base::Int64Value* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.yaw_);
  }
  _impl_.yaw_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.yaw)
}
inline ::sensoris::protobuf::types::base::Int64Value* RotationRateAndAccuracy::release_yaw() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Int64Value* released = _impl_.yaw_;
  _impl_.yaw_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::Int64Value* RotationRateAndAccuracy::unsafe_arena_release_yaw() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.yaw)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::base::Int64Value* temp = _impl_.yaw_;
  _impl_.yaw_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* RotationRateAndAccuracy::_internal_mutable_yaw() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.yaw_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64Value>(GetArena());
    _impl_.yaw_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(p);
  }
  return _impl_.yaw_;
}
inline ::sensoris::protobuf::types::base::Int64Value* RotationRateAndAccuracy::mutable_yaw() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::Int64Value* _msg = _internal_mutable_yaw();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.yaw)
  return _msg;
}
inline void RotationRateAndAccuracy::set_allocated_yaw(::sensoris::protobuf::types::base::Int64Value* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.yaw_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.yaw_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.yaw)
}

// .sensoris.protobuf.types.base.Int64Value pitch = 2 [(.sensoris.protobuf.types.base.exponent) = 2];
inline bool RotationRateAndAccuracy::has_pitch() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pitch_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Int64Value& RotationRateAndAccuracy::_internal_pitch() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::Int64Value* p = _impl_.pitch_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Int64Value&>(::sensoris::protobuf::types::base::_Int64Value_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64Value& RotationRateAndAccuracy::pitch() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.pitch)
  return _internal_pitch();
}
inline void RotationRateAndAccuracy::unsafe_arena_set_allocated_pitch(::sensoris::protobuf::types::base::Int64Value* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pitch_);
  }
  _impl_.pitch_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.pitch)
}
inline ::sensoris::protobuf::types::base::Int64Value* RotationRateAndAccuracy::release_pitch() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::Int64Value* released = _impl_.pitch_;
  _impl_.pitch_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::Int64Value* RotationRateAndAccuracy::unsafe_arena_release_pitch() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.pitch)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sensoris::protobuf::types::base::Int64Value* temp = _impl_.pitch_;
  _impl_.pitch_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* RotationRateAndAccuracy::_internal_mutable_pitch() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.pitch_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64Value>(GetArena());
    _impl_.pitch_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(p);
  }
  return _impl_.pitch_;
}
inline ::sensoris::protobuf::types::base::Int64Value* RotationRateAndAccuracy::mutable_pitch() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::Int64Value* _msg = _internal_mutable_pitch();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.pitch)
  return _msg;
}
inline void RotationRateAndAccuracy::set_allocated_pitch(::sensoris::protobuf::types::base::Int64Value* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pitch_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.pitch_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.pitch)
}

// .sensoris.protobuf.types.base.Int64Value roll = 3 [(.sensoris.protobuf.types.base.exponent) = 2];
inline bool RotationRateAndAccuracy::has_roll() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.roll_ != nullptr);
  return value;
}
inline const ::sensoris::protobuf::types::base::Int64Value& RotationRateAndAccuracy::_internal_roll() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::base::Int64Value* p = _impl_.roll_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::base::Int64Value&>(::sensoris::protobuf::types::base::_Int64Value_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64Value& RotationRateAndAccuracy::roll() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.roll)
  return _internal_roll();
}
inline void RotationRateAndAccuracy::unsafe_arena_set_allocated_roll(::sensoris::protobuf::types::base::Int64Value* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.roll_);
  }
  _impl_.roll_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.roll)
}
inline ::sensoris::protobuf::types::base::Int64Value* RotationRateAndAccuracy::release_roll() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::types::base::Int64Value* released = _impl_.roll_;
  _impl_.roll_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::base::Int64Value* RotationRateAndAccuracy::unsafe_arena_release_roll() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.roll)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sensoris::protobuf::types::base::Int64Value* temp = _impl_.roll_;
  _impl_.roll_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* RotationRateAndAccuracy::_internal_mutable_roll() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.roll_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64Value>(GetArena());
    _impl_.roll_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(p);
  }
  return _impl_.roll_;
}
inline ::sensoris::protobuf::types::base::Int64Value* RotationRateAndAccuracy::mutable_roll() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::Int64Value* _msg = _internal_mutable_roll();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.roll)
  return _msg;
}
inline void RotationRateAndAccuracy::set_allocated_roll(::sensoris::protobuf::types::base::Int64Value* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.roll_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.roll_ = reinterpret_cast<::sensoris::protobuf::types::base::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.roll)
}

// .google.protobuf.Int64Value combined_std_dev = 4 [(.sensoris.protobuf.types.base.exponent) = 2];
inline bool RotationRateAndAccuracy::has_combined_std_dev() const {
  return accuracy_case() == kCombinedStdDev;
}
inline bool RotationRateAndAccuracy::_internal_has_combined_std_dev() const {
  return accuracy_case() == kCombinedStdDev;
}
inline void RotationRateAndAccuracy::set_has_combined_std_dev() {
  _impl_._oneof_case_[0] = kCombinedStdDev;
}
inline ::google::protobuf::Int64Value* RotationRateAndAccuracy::release_combined_std_dev() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.combined_std_dev)
  if (accuracy_case() == kCombinedStdDev) {
    clear_has_accuracy();
    auto* temp = _impl_.accuracy_.combined_std_dev_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.accuracy_.combined_std_dev_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::protobuf::Int64Value& RotationRateAndAccuracy::_internal_combined_std_dev() const {
  return accuracy_case() == kCombinedStdDev ? *_impl_.accuracy_.combined_std_dev_ : reinterpret_cast<::google::protobuf::Int64Value&>(::google::protobuf::_Int64Value_default_instance_);
}
inline const ::google::protobuf::Int64Value& RotationRateAndAccuracy::combined_std_dev() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.combined_std_dev)
  return _internal_combined_std_dev();
}
inline ::google::protobuf::Int64Value* RotationRateAndAccuracy::unsafe_arena_release_combined_std_dev() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.combined_std_dev)
  if (accuracy_case() == kCombinedStdDev) {
    clear_has_accuracy();
    auto* temp = _impl_.accuracy_.combined_std_dev_;
    _impl_.accuracy_.combined_std_dev_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RotationRateAndAccuracy::unsafe_arena_set_allocated_combined_std_dev(::google::protobuf::Int64Value* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_accuracy();
  if (value) {
    set_has_combined_std_dev();
    _impl_.accuracy_.combined_std_dev_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.combined_std_dev)
}
inline ::google::protobuf::Int64Value* RotationRateAndAccuracy::_internal_mutable_combined_std_dev() {
  if (accuracy_case() != kCombinedStdDev) {
    clear_accuracy();
    set_has_combined_std_dev();
    _impl_.accuracy_.combined_std_dev_ = CreateMaybeMessage<::google::protobuf::Int64Value>(GetArena());
  }
  return _impl_.accuracy_.combined_std_dev_;
}
inline ::google::protobuf::Int64Value* RotationRateAndAccuracy::mutable_combined_std_dev() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Int64Value* _msg = _internal_mutable_combined_std_dev();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.combined_std_dev)
  return _msg;
}

// .sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev std_dev = 5;
inline bool RotationRateAndAccuracy::has_std_dev() const {
  return accuracy_case() == kStdDev;
}
inline bool RotationRateAndAccuracy::_internal_has_std_dev() const {
  return accuracy_case() == kStdDev;
}
inline void RotationRateAndAccuracy::set_has_std_dev() {
  _impl_._oneof_case_[0] = kStdDev;
}
inline void RotationRateAndAccuracy::clear_std_dev() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (accuracy_case() == kStdDev) {
    if (GetArena() == nullptr) {
      delete _impl_.accuracy_.std_dev_;
    }
    clear_has_accuracy();
  }
}
inline ::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev* RotationRateAndAccuracy::release_std_dev() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.std_dev)
  if (accuracy_case() == kStdDev) {
    clear_has_accuracy();
    auto* temp = _impl_.accuracy_.std_dev_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.accuracy_.std_dev_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev& RotationRateAndAccuracy::_internal_std_dev() const {
  return accuracy_case() == kStdDev ? *_impl_.accuracy_.std_dev_ : reinterpret_cast<::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev&>(::sensoris::protobuf::types::spatial::_RotationRateAndAccuracy_StdDev_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev& RotationRateAndAccuracy::std_dev() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.std_dev)
  return _internal_std_dev();
}
inline ::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev* RotationRateAndAccuracy::unsafe_arena_release_std_dev() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.std_dev)
  if (accuracy_case() == kStdDev) {
    clear_has_accuracy();
    auto* temp = _impl_.accuracy_.std_dev_;
    _impl_.accuracy_.std_dev_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RotationRateAndAccuracy::unsafe_arena_set_allocated_std_dev(::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_accuracy();
  if (value) {
    set_has_std_dev();
    _impl_.accuracy_.std_dev_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.std_dev)
}
inline ::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev* RotationRateAndAccuracy::_internal_mutable_std_dev() {
  if (accuracy_case() != kStdDev) {
    clear_accuracy();
    set_has_std_dev();
    _impl_.accuracy_.std_dev_ = CreateMaybeMessage<::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev>(GetArena());
  }
  return _impl_.accuracy_.std_dev_;
}
inline ::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev* RotationRateAndAccuracy::mutable_std_dev() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev* _msg = _internal_mutable_std_dev();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.std_dev)
  return _msg;
}

// .sensoris.protobuf.types.base.Int64Matrix3x3 covariance = 6 [(.sensoris.protobuf.types.base.exponent) = 2];
inline bool RotationRateAndAccuracy::has_covariance() const {
  return accuracy_case() == kCovariance;
}
inline bool RotationRateAndAccuracy::_internal_has_covariance() const {
  return accuracy_case() == kCovariance;
}
inline void RotationRateAndAccuracy::set_has_covariance() {
  _impl_._oneof_case_[0] = kCovariance;
}
inline ::sensoris::protobuf::types::base::Int64Matrix3x3* RotationRateAndAccuracy::release_covariance() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.covariance)
  if (accuracy_case() == kCovariance) {
    clear_has_accuracy();
    auto* temp = _impl_.accuracy_.covariance_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.accuracy_.covariance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensoris::protobuf::types::base::Int64Matrix3x3& RotationRateAndAccuracy::_internal_covariance() const {
  return accuracy_case() == kCovariance ? *_impl_.accuracy_.covariance_ : reinterpret_cast<::sensoris::protobuf::types::base::Int64Matrix3x3&>(::sensoris::protobuf::types::base::_Int64Matrix3x3_default_instance_);
}
inline const ::sensoris::protobuf::types::base::Int64Matrix3x3& RotationRateAndAccuracy::covariance() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.covariance)
  return _internal_covariance();
}
inline ::sensoris::protobuf::types::base::Int64Matrix3x3* RotationRateAndAccuracy::unsafe_arena_release_covariance() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.covariance)
  if (accuracy_case() == kCovariance) {
    clear_has_accuracy();
    auto* temp = _impl_.accuracy_.covariance_;
    _impl_.accuracy_.covariance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RotationRateAndAccuracy::unsafe_arena_set_allocated_covariance(::sensoris::protobuf::types::base::Int64Matrix3x3* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_accuracy();
  if (value) {
    set_has_covariance();
    _impl_.accuracy_.covariance_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.covariance)
}
inline ::sensoris::protobuf::types::base::Int64Matrix3x3* RotationRateAndAccuracy::_internal_mutable_covariance() {
  if (accuracy_case() != kCovariance) {
    clear_accuracy();
    set_has_covariance();
    _impl_.accuracy_.covariance_ = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64Matrix3x3>(GetArena());
  }
  return _impl_.accuracy_.covariance_;
}
inline ::sensoris::protobuf::types::base::Int64Matrix3x3* RotationRateAndAccuracy::mutable_covariance() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::base::Int64Matrix3x3* _msg = _internal_mutable_covariance();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.covariance)
  return _msg;
}

// repeated .google.protobuf.Any extension = 15;
inline int RotationRateAndAccuracy::_internal_extension_size() const {
  return _internal_extension().size();
}
inline int RotationRateAndAccuracy::extension_size() const {
  return _internal_extension_size();
}
inline ::google::protobuf::Any* RotationRateAndAccuracy::mutable_extension(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.extension)
  return _internal_mutable_extension()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* RotationRateAndAccuracy::mutable_extension()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.extension)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_extension();
}
inline const ::google::protobuf::Any& RotationRateAndAccuracy::extension(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.extension)
  return _internal_extension().Get(index);
}
inline ::google::protobuf::Any* RotationRateAndAccuracy::add_extension() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::google::protobuf::Any* _add = _internal_mutable_extension()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.extension)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& RotationRateAndAccuracy::extension() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.extension)
  return _internal_extension();
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>&
RotationRateAndAccuracy::_internal_extension() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.extension_;
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>*
RotationRateAndAccuracy::_internal_mutable_extension() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.extension_;
}

inline bool RotationRateAndAccuracy::has_accuracy() const {
  return accuracy_case() != ACCURACY_NOT_SET;
}
inline void RotationRateAndAccuracy::clear_has_accuracy() {
  _impl_._oneof_case_[0] = ACCURACY_NOT_SET;
}
inline RotationRateAndAccuracy::AccuracyCase RotationRateAndAccuracy::accuracy_case() const {
  return RotationRateAndAccuracy::AccuracyCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// MapLocationReference_TileIdLinkIdOffset

// .google.protobuf.Int64Value tile_id = 1;
inline bool MapLocationReference_TileIdLinkIdOffset::has_tile_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tile_id_ != nullptr);
  return value;
}
inline const ::google::protobuf::Int64Value& MapLocationReference_TileIdLinkIdOffset::_internal_tile_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Int64Value* p = _impl_.tile_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Int64Value&>(::google::protobuf::_Int64Value_default_instance_);
}
inline const ::google::protobuf::Int64Value& MapLocationReference_TileIdLinkIdOffset::tile_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset.tile_id)
  return _internal_tile_id();
}
inline void MapLocationReference_TileIdLinkIdOffset::unsafe_arena_set_allocated_tile_id(::google::protobuf::Int64Value* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.tile_id_);
  }
  _impl_.tile_id_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset.tile_id)
}
inline ::google::protobuf::Int64Value* MapLocationReference_TileIdLinkIdOffset::release_tile_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Int64Value* released = _impl_.tile_id_;
  _impl_.tile_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Int64Value* MapLocationReference_TileIdLinkIdOffset::unsafe_arena_release_tile_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset.tile_id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Int64Value* temp = _impl_.tile_id_;
  _impl_.tile_id_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int64Value* MapLocationReference_TileIdLinkIdOffset::_internal_mutable_tile_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.tile_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int64Value>(GetArena());
    _impl_.tile_id_ = reinterpret_cast<::google::protobuf::Int64Value*>(p);
  }
  return _impl_.tile_id_;
}
inline ::google::protobuf::Int64Value* MapLocationReference_TileIdLinkIdOffset::mutable_tile_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Int64Value* _msg = _internal_mutable_tile_id();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset.tile_id)
  return _msg;
}
inline void MapLocationReference_TileIdLinkIdOffset::set_allocated_tile_id(::google::protobuf::Int64Value* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.tile_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.tile_id_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset.tile_id)
}

// .google.protobuf.Int64Value link_id = 2;
inline bool MapLocationReference_TileIdLinkIdOffset::has_link_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.link_id_ != nullptr);
  return value;
}
inline const ::google::protobuf::Int64Value& MapLocationReference_TileIdLinkIdOffset::_internal_link_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Int64Value* p = _impl_.link_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Int64Value&>(::google::protobuf::_Int64Value_default_instance_);
}
inline const ::google::protobuf::Int64Value& MapLocationReference_TileIdLinkIdOffset::link_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset.link_id)
  return _internal_link_id();
}
inline void MapLocationReference_TileIdLinkIdOffset::unsafe_arena_set_allocated_link_id(::google::protobuf::Int64Value* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.link_id_);
  }
  _impl_.link_id_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset.link_id)
}
inline ::google::protobuf::Int64Value* MapLocationReference_TileIdLinkIdOffset::release_link_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Int64Value* released = _impl_.link_id_;
  _impl_.link_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Int64Value* MapLocationReference_TileIdLinkIdOffset::unsafe_arena_release_link_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset.link_id)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Int64Value* temp = _impl_.link_id_;
  _impl_.link_id_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int64Value* MapLocationReference_TileIdLinkIdOffset::_internal_mutable_link_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.link_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int64Value>(GetArena());
    _impl_.link_id_ = reinterpret_cast<::google::protobuf::Int64Value*>(p);
  }
  return _impl_.link_id_;
}
inline ::google::protobuf::Int64Value* MapLocationReference_TileIdLinkIdOffset::mutable_link_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Int64Value* _msg = _internal_mutable_link_id();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset.link_id)
  return _msg;
}
inline void MapLocationReference_TileIdLinkIdOffset::set_allocated_link_id(::google::protobuf::Int64Value* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.link_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.link_id_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset.link_id)
}

// .google.protobuf.Int64Value offset = 3 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool MapLocationReference_TileIdLinkIdOffset::has_offset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.offset_ != nullptr);
  return value;
}
inline const ::google::protobuf::Int64Value& MapLocationReference_TileIdLinkIdOffset::_internal_offset() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Int64Value* p = _impl_.offset_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Int64Value&>(::google::protobuf::_Int64Value_default_instance_);
}
inline const ::google::protobuf::Int64Value& MapLocationReference_TileIdLinkIdOffset::offset() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset.offset)
  return _internal_offset();
}
inline void MapLocationReference_TileIdLinkIdOffset::unsafe_arena_set_allocated_offset(::google::protobuf::Int64Value* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.offset_);
  }
  _impl_.offset_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset.offset)
}
inline ::google::protobuf::Int64Value* MapLocationReference_TileIdLinkIdOffset::release_offset() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Int64Value* released = _impl_.offset_;
  _impl_.offset_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Int64Value* MapLocationReference_TileIdLinkIdOffset::unsafe_arena_release_offset() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset.offset)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Int64Value* temp = _impl_.offset_;
  _impl_.offset_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int64Value* MapLocationReference_TileIdLinkIdOffset::_internal_mutable_offset() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.offset_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int64Value>(GetArena());
    _impl_.offset_ = reinterpret_cast<::google::protobuf::Int64Value*>(p);
  }
  return _impl_.offset_;
}
inline ::google::protobuf::Int64Value* MapLocationReference_TileIdLinkIdOffset::mutable_offset() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Int64Value* _msg = _internal_mutable_offset();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset.offset)
  return _msg;
}
inline void MapLocationReference_TileIdLinkIdOffset::set_allocated_offset(::google::protobuf::Int64Value* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.offset_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.offset_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset.offset)
}

// repeated .google.protobuf.Any extension = 15;
inline int MapLocationReference_TileIdLinkIdOffset::_internal_extension_size() const {
  return _internal_extension().size();
}
inline int MapLocationReference_TileIdLinkIdOffset::extension_size() const {
  return _internal_extension_size();
}
inline ::google::protobuf::Any* MapLocationReference_TileIdLinkIdOffset::mutable_extension(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset.extension)
  return _internal_mutable_extension()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* MapLocationReference_TileIdLinkIdOffset::mutable_extension()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset.extension)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_extension();
}
inline const ::google::protobuf::Any& MapLocationReference_TileIdLinkIdOffset::extension(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset.extension)
  return _internal_extension().Get(index);
}
inline ::google::protobuf::Any* MapLocationReference_TileIdLinkIdOffset::add_extension() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::google::protobuf::Any* _add = _internal_mutable_extension()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset.extension)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& MapLocationReference_TileIdLinkIdOffset::extension() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset.extension)
  return _internal_extension();
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>&
MapLocationReference_TileIdLinkIdOffset::_internal_extension() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.extension_;
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>*
MapLocationReference_TileIdLinkIdOffset::_internal_mutable_extension() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.extension_;
}

// -------------------------------------------------------------------

// MapLocationReference_TileIdObjectId

// .google.protobuf.Int64Value tile_id = 1;
inline bool MapLocationReference_TileIdObjectId::has_tile_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tile_id_ != nullptr);
  return value;
}
inline const ::google::protobuf::Int64Value& MapLocationReference_TileIdObjectId::_internal_tile_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Int64Value* p = _impl_.tile_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Int64Value&>(::google::protobuf::_Int64Value_default_instance_);
}
inline const ::google::protobuf::Int64Value& MapLocationReference_TileIdObjectId::tile_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId.tile_id)
  return _internal_tile_id();
}
inline void MapLocationReference_TileIdObjectId::unsafe_arena_set_allocated_tile_id(::google::protobuf::Int64Value* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.tile_id_);
  }
  _impl_.tile_id_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId.tile_id)
}
inline ::google::protobuf::Int64Value* MapLocationReference_TileIdObjectId::release_tile_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Int64Value* released = _impl_.tile_id_;
  _impl_.tile_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Int64Value* MapLocationReference_TileIdObjectId::unsafe_arena_release_tile_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId.tile_id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Int64Value* temp = _impl_.tile_id_;
  _impl_.tile_id_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int64Value* MapLocationReference_TileIdObjectId::_internal_mutable_tile_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.tile_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int64Value>(GetArena());
    _impl_.tile_id_ = reinterpret_cast<::google::protobuf::Int64Value*>(p);
  }
  return _impl_.tile_id_;
}
inline ::google::protobuf::Int64Value* MapLocationReference_TileIdObjectId::mutable_tile_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Int64Value* _msg = _internal_mutable_tile_id();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId.tile_id)
  return _msg;
}
inline void MapLocationReference_TileIdObjectId::set_allocated_tile_id(::google::protobuf::Int64Value* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.tile_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.tile_id_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId.tile_id)
}

// .google.protobuf.Int64Value object_id = 2;
inline bool MapLocationReference_TileIdObjectId::has_object_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.object_id_ != nullptr);
  return value;
}
inline const ::google::protobuf::Int64Value& MapLocationReference_TileIdObjectId::_internal_object_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Int64Value* p = _impl_.object_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Int64Value&>(::google::protobuf::_Int64Value_default_instance_);
}
inline const ::google::protobuf::Int64Value& MapLocationReference_TileIdObjectId::object_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId.object_id)
  return _internal_object_id();
}
inline void MapLocationReference_TileIdObjectId::unsafe_arena_set_allocated_object_id(::google::protobuf::Int64Value* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.object_id_);
  }
  _impl_.object_id_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId.object_id)
}
inline ::google::protobuf::Int64Value* MapLocationReference_TileIdObjectId::release_object_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Int64Value* released = _impl_.object_id_;
  _impl_.object_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Int64Value* MapLocationReference_TileIdObjectId::unsafe_arena_release_object_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId.object_id)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Int64Value* temp = _impl_.object_id_;
  _impl_.object_id_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int64Value* MapLocationReference_TileIdObjectId::_internal_mutable_object_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.object_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int64Value>(GetArena());
    _impl_.object_id_ = reinterpret_cast<::google::protobuf::Int64Value*>(p);
  }
  return _impl_.object_id_;
}
inline ::google::protobuf::Int64Value* MapLocationReference_TileIdObjectId::mutable_object_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Int64Value* _msg = _internal_mutable_object_id();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId.object_id)
  return _msg;
}
inline void MapLocationReference_TileIdObjectId::set_allocated_object_id(::google::protobuf::Int64Value* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.object_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.object_id_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId.object_id)
}

// repeated .google.protobuf.Any extension = 15;
inline int MapLocationReference_TileIdObjectId::_internal_extension_size() const {
  return _internal_extension().size();
}
inline int MapLocationReference_TileIdObjectId::extension_size() const {
  return _internal_extension_size();
}
inline ::google::protobuf::Any* MapLocationReference_TileIdObjectId::mutable_extension(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId.extension)
  return _internal_mutable_extension()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* MapLocationReference_TileIdObjectId::mutable_extension()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId.extension)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_extension();
}
inline const ::google::protobuf::Any& MapLocationReference_TileIdObjectId::extension(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId.extension)
  return _internal_extension().Get(index);
}
inline ::google::protobuf::Any* MapLocationReference_TileIdObjectId::add_extension() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::google::protobuf::Any* _add = _internal_mutable_extension()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId.extension)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& MapLocationReference_TileIdObjectId::extension() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId.extension)
  return _internal_extension();
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>&
MapLocationReference_TileIdObjectId::_internal_extension() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.extension_;
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>*
MapLocationReference_TileIdObjectId::_internal_mutable_extension() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.extension_;
}

// -------------------------------------------------------------------

// MapLocationReference

// .sensoris.protobuf.types.spatial.PositionAndAccuracy position_and_accuracy = 1;
inline bool MapLocationReference::has_position_and_accuracy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_and_accuracy_ != nullptr);
  return value;
}
inline void MapLocationReference::clear_position_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.position_and_accuracy_ != nullptr) _impl_.position_and_accuracy_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& MapLocationReference::_internal_position_and_accuracy() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy* p = _impl_.position_and_accuracy_;
  return p != nullptr ? *p : reinterpret_cast<const ::sensoris::protobuf::types::spatial::PositionAndAccuracy&>(::sensoris::protobuf::types::spatial::_PositionAndAccuracy_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& MapLocationReference::position_and_accuracy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.MapLocationReference.position_and_accuracy)
  return _internal_position_and_accuracy();
}
inline void MapLocationReference::unsafe_arena_set_allocated_position_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_and_accuracy_);
  }
  _impl_.position_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.MapLocationReference.position_and_accuracy)
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* MapLocationReference::release_position_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* released = _impl_.position_and_accuracy_;
  _impl_.position_and_accuracy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* MapLocationReference::unsafe_arena_release_position_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.MapLocationReference.position_and_accuracy)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* temp = _impl_.position_and_accuracy_;
  _impl_.position_and_accuracy_ = nullptr;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* MapLocationReference::_internal_mutable_position_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.position_and_accuracy_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::spatial::PositionAndAccuracy>(GetArena());
    _impl_.position_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(p);
  }
  return _impl_.position_and_accuracy_;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* MapLocationReference::mutable_position_and_accuracy() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* _msg = _internal_mutable_position_and_accuracy();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.MapLocationReference.position_and_accuracy)
  return _msg;
}
inline void MapLocationReference::set_allocated_position_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(_impl_.position_and_accuracy_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.position_and_accuracy_ = reinterpret_cast<::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.MapLocationReference.position_and_accuracy)
}

// .google.protobuf.Int64Value z_level = 2;
inline bool MapLocationReference::has_z_level() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.z_level_ != nullptr);
  return value;
}
inline const ::google::protobuf::Int64Value& MapLocationReference::_internal_z_level() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Int64Value* p = _impl_.z_level_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Int64Value&>(::google::protobuf::_Int64Value_default_instance_);
}
inline const ::google::protobuf::Int64Value& MapLocationReference::z_level() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.MapLocationReference.z_level)
  return _internal_z_level();
}
inline void MapLocationReference::unsafe_arena_set_allocated_z_level(::google::protobuf::Int64Value* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.z_level_);
  }
  _impl_.z_level_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.MapLocationReference.z_level)
}
inline ::google::protobuf::Int64Value* MapLocationReference::release_z_level() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Int64Value* released = _impl_.z_level_;
  _impl_.z_level_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Int64Value* MapLocationReference::unsafe_arena_release_z_level() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.MapLocationReference.z_level)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Int64Value* temp = _impl_.z_level_;
  _impl_.z_level_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int64Value* MapLocationReference::_internal_mutable_z_level() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.z_level_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int64Value>(GetArena());
    _impl_.z_level_ = reinterpret_cast<::google::protobuf::Int64Value*>(p);
  }
  return _impl_.z_level_;
}
inline ::google::protobuf::Int64Value* MapLocationReference::mutable_z_level() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Int64Value* _msg = _internal_mutable_z_level();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.MapLocationReference.z_level)
  return _msg;
}
inline void MapLocationReference::set_allocated_z_level(::google::protobuf::Int64Value* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.z_level_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.z_level_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.MapLocationReference.z_level)
}

// .sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset tile_link_offset_reference = 3;
inline bool MapLocationReference::has_tile_link_offset_reference() const {
  return map_based_reference_case() == kTileLinkOffsetReference;
}
inline bool MapLocationReference::_internal_has_tile_link_offset_reference() const {
  return map_based_reference_case() == kTileLinkOffsetReference;
}
inline void MapLocationReference::set_has_tile_link_offset_reference() {
  _impl_._oneof_case_[0] = kTileLinkOffsetReference;
}
inline void MapLocationReference::clear_tile_link_offset_reference() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (map_based_reference_case() == kTileLinkOffsetReference) {
    if (GetArena() == nullptr) {
      delete _impl_.map_based_reference_.tile_link_offset_reference_;
    }
    clear_has_map_based_reference();
  }
}
inline ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset* MapLocationReference::release_tile_link_offset_reference() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.MapLocationReference.tile_link_offset_reference)
  if (map_based_reference_case() == kTileLinkOffsetReference) {
    clear_has_map_based_reference();
    auto* temp = _impl_.map_based_reference_.tile_link_offset_reference_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.map_based_reference_.tile_link_offset_reference_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset& MapLocationReference::_internal_tile_link_offset_reference() const {
  return map_based_reference_case() == kTileLinkOffsetReference ? *_impl_.map_based_reference_.tile_link_offset_reference_ : reinterpret_cast<::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset&>(::sensoris::protobuf::types::spatial::_MapLocationReference_TileIdLinkIdOffset_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset& MapLocationReference::tile_link_offset_reference() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.MapLocationReference.tile_link_offset_reference)
  return _internal_tile_link_offset_reference();
}
inline ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset* MapLocationReference::unsafe_arena_release_tile_link_offset_reference() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.MapLocationReference.tile_link_offset_reference)
  if (map_based_reference_case() == kTileLinkOffsetReference) {
    clear_has_map_based_reference();
    auto* temp = _impl_.map_based_reference_.tile_link_offset_reference_;
    _impl_.map_based_reference_.tile_link_offset_reference_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MapLocationReference::unsafe_arena_set_allocated_tile_link_offset_reference(::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_map_based_reference();
  if (value) {
    set_has_tile_link_offset_reference();
    _impl_.map_based_reference_.tile_link_offset_reference_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.MapLocationReference.tile_link_offset_reference)
}
inline ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset* MapLocationReference::_internal_mutable_tile_link_offset_reference() {
  if (map_based_reference_case() != kTileLinkOffsetReference) {
    clear_map_based_reference();
    set_has_tile_link_offset_reference();
    _impl_.map_based_reference_.tile_link_offset_reference_ = CreateMaybeMessage<::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset>(GetArena());
  }
  return _impl_.map_based_reference_.tile_link_offset_reference_;
}
inline ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset* MapLocationReference::mutable_tile_link_offset_reference() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset* _msg = _internal_mutable_tile_link_offset_reference();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.MapLocationReference.tile_link_offset_reference)
  return _msg;
}

// .sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId map_object_id = 4;
inline bool MapLocationReference::has_map_object_id() const {
  return map_based_reference_case() == kMapObjectId;
}
inline bool MapLocationReference::_internal_has_map_object_id() const {
  return map_based_reference_case() == kMapObjectId;
}
inline void MapLocationReference::set_has_map_object_id() {
  _impl_._oneof_case_[0] = kMapObjectId;
}
inline void MapLocationReference::clear_map_object_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (map_based_reference_case() == kMapObjectId) {
    if (GetArena() == nullptr) {
      delete _impl_.map_based_reference_.map_object_id_;
    }
    clear_has_map_based_reference();
  }
}
inline ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId* MapLocationReference::release_map_object_id() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.MapLocationReference.map_object_id)
  if (map_based_reference_case() == kMapObjectId) {
    clear_has_map_based_reference();
    auto* temp = _impl_.map_based_reference_.map_object_id_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.map_based_reference_.map_object_id_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId& MapLocationReference::_internal_map_object_id() const {
  return map_based_reference_case() == kMapObjectId ? *_impl_.map_based_reference_.map_object_id_ : reinterpret_cast<::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId&>(::sensoris::protobuf::types::spatial::_MapLocationReference_TileIdObjectId_default_instance_);
}
inline const ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId& MapLocationReference::map_object_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.MapLocationReference.map_object_id)
  return _internal_map_object_id();
}
inline ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId* MapLocationReference::unsafe_arena_release_map_object_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.MapLocationReference.map_object_id)
  if (map_based_reference_case() == kMapObjectId) {
    clear_has_map_based_reference();
    auto* temp = _impl_.map_based_reference_.map_object_id_;
    _impl_.map_based_reference_.map_object_id_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MapLocationReference::unsafe_arena_set_allocated_map_object_id(::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_map_based_reference();
  if (value) {
    set_has_map_object_id();
    _impl_.map_based_reference_.map_object_id_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.MapLocationReference.map_object_id)
}
inline ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId* MapLocationReference::_internal_mutable_map_object_id() {
  if (map_based_reference_case() != kMapObjectId) {
    clear_map_based_reference();
    set_has_map_object_id();
    _impl_.map_based_reference_.map_object_id_ = CreateMaybeMessage<::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId>(GetArena());
  }
  return _impl_.map_based_reference_.map_object_id_;
}
inline ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId* MapLocationReference::mutable_map_object_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId* _msg = _internal_mutable_map_object_id();
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.MapLocationReference.map_object_id)
  return _msg;
}

// repeated .google.protobuf.Any extension = 15;
inline int MapLocationReference::_internal_extension_size() const {
  return _internal_extension().size();
}
inline int MapLocationReference::extension_size() const {
  return _internal_extension_size();
}
inline ::google::protobuf::Any* MapLocationReference::mutable_extension(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.MapLocationReference.extension)
  return _internal_mutable_extension()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>* MapLocationReference::mutable_extension()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.types.spatial.MapLocationReference.extension)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_extension();
}
inline const ::google::protobuf::Any& MapLocationReference::extension(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.MapLocationReference.extension)
  return _internal_extension().Get(index);
}
inline ::google::protobuf::Any* MapLocationReference::add_extension() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::google::protobuf::Any* _add = _internal_mutable_extension()->Add();
  // @@protoc_insertion_point(field_add:sensoris.protobuf.types.spatial.MapLocationReference.extension)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>& MapLocationReference::extension() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.types.spatial.MapLocationReference.extension)
  return _internal_extension();
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>&
MapLocationReference::_internal_extension() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.extension_;
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Any>*
MapLocationReference::_internal_mutable_extension() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.extension_;
}

inline bool MapLocationReference::has_map_based_reference() const {
  return map_based_reference_case() != MAP_BASED_REFERENCE_NOT_SET;
}
inline void MapLocationReference::clear_has_map_based_reference() {
  _impl_._oneof_case_[0] = MAP_BASED_REFERENCE_NOT_SET;
}
inline MapLocationReference::MapBasedReferenceCase MapLocationReference::map_based_reference_case() const {
  return MapLocationReference::MapBasedReferenceCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace spatial
}  // namespace types
}  // namespace protobuf
}  // namespace sensoris


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto_2epb_2eh
