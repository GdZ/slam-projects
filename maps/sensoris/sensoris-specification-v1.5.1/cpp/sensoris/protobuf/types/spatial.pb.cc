// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sensoris/protobuf/types/spatial.proto

#include "sensoris/protobuf/types/spatial.pb.h"

#include <algorithm>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/reflection_ops.h"
#include "google/protobuf/wire_format.h"
#include "google/protobuf/generated_message_tctable_impl.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::google::protobuf;
namespace _pbi = ::google::protobuf::internal;
namespace _fl = ::google::protobuf::internal::field_layout;
namespace sensoris {
namespace protobuf {
namespace types {
namespace spatial {

inline constexpr XyzVectorAndAccuracy_StdDev::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        x_{nullptr},
        y_{nullptr},
        z_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR XyzVectorAndAccuracy_StdDev::XyzVectorAndAccuracy_StdDev(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct XyzVectorAndAccuracy_StdDevDefaultTypeInternal {
  PROTOBUF_CONSTEXPR XyzVectorAndAccuracy_StdDevDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~XyzVectorAndAccuracy_StdDevDefaultTypeInternal() {}
  union {
    XyzVectorAndAccuracy_StdDev _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 XyzVectorAndAccuracy_StdDevDefaultTypeInternal _XyzVectorAndAccuracy_StdDev_default_instance_;

inline constexpr RotationRateAndAccuracy_StdDev::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        yaw_{nullptr},
        pitch_{nullptr},
        roll_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR RotationRateAndAccuracy_StdDev::RotationRateAndAccuracy_StdDev(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct RotationRateAndAccuracy_StdDevDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RotationRateAndAccuracy_StdDevDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~RotationRateAndAccuracy_StdDevDefaultTypeInternal() {}
  union {
    RotationRateAndAccuracy_StdDev _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RotationRateAndAccuracy_StdDevDefaultTypeInternal _RotationRateAndAccuracy_StdDev_default_instance_;

inline constexpr RotationAndAccuracy_StdDev::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        yaw_{nullptr},
        pitch_{nullptr},
        roll_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR RotationAndAccuracy_StdDev::RotationAndAccuracy_StdDev(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct RotationAndAccuracy_StdDevDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RotationAndAccuracy_StdDevDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~RotationAndAccuracy_StdDevDefaultTypeInternal() {}
  union {
    RotationAndAccuracy_StdDev _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RotationAndAccuracy_StdDevDefaultTypeInternal _RotationAndAccuracy_StdDev_default_instance_;

inline constexpr PositionAndAccuracy_HorizontalVerticalStdDev::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        horizontal_{nullptr},
        vertical_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR PositionAndAccuracy_HorizontalVerticalStdDev::PositionAndAccuracy_HorizontalVerticalStdDev(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct PositionAndAccuracy_HorizontalVerticalStdDevDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PositionAndAccuracy_HorizontalVerticalStdDevDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PositionAndAccuracy_HorizontalVerticalStdDevDefaultTypeInternal() {}
  union {
    PositionAndAccuracy_HorizontalVerticalStdDev _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PositionAndAccuracy_HorizontalVerticalStdDevDefaultTypeInternal _PositionAndAccuracy_HorizontalVerticalStdDev_default_instance_;

inline constexpr PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        horizontal_ellipse_major_{nullptr},
        horizontal_ellipse_minor_{nullptr},
        horizontal_ellipse_major_heading_{nullptr},
        vertical_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDevDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDevDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDevDefaultTypeInternal() {}
  union {
    PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDevDefaultTypeInternal _PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev_default_instance_;

inline constexpr MapLocationReference_TileIdObjectId::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        extension_{},
        tile_id_{nullptr},
        object_id_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR MapLocationReference_TileIdObjectId::MapLocationReference_TileIdObjectId(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct MapLocationReference_TileIdObjectIdDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MapLocationReference_TileIdObjectIdDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MapLocationReference_TileIdObjectIdDefaultTypeInternal() {}
  union {
    MapLocationReference_TileIdObjectId _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MapLocationReference_TileIdObjectIdDefaultTypeInternal _MapLocationReference_TileIdObjectId_default_instance_;

inline constexpr MapLocationReference_TileIdLinkIdOffset::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        extension_{},
        tile_id_{nullptr},
        link_id_{nullptr},
        offset_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR MapLocationReference_TileIdLinkIdOffset::MapLocationReference_TileIdLinkIdOffset(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct MapLocationReference_TileIdLinkIdOffsetDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MapLocationReference_TileIdLinkIdOffsetDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MapLocationReference_TileIdLinkIdOffsetDefaultTypeInternal() {}
  union {
    MapLocationReference_TileIdLinkIdOffset _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MapLocationReference_TileIdLinkIdOffsetDefaultTypeInternal _MapLocationReference_TileIdLinkIdOffset_default_instance_;

inline constexpr XyzVectorAndAccuracy_Metric::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        x_{nullptr},
        y_{nullptr},
        z_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR XyzVectorAndAccuracy_Metric::XyzVectorAndAccuracy_Metric(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct XyzVectorAndAccuracy_MetricDefaultTypeInternal {
  PROTOBUF_CONSTEXPR XyzVectorAndAccuracy_MetricDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~XyzVectorAndAccuracy_MetricDefaultTypeInternal() {}
  union {
    XyzVectorAndAccuracy_Metric _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 XyzVectorAndAccuracy_MetricDefaultTypeInternal _XyzVectorAndAccuracy_Metric_default_instance_;

inline constexpr RotationRateAndAccuracy::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        extension_{},
        yaw_{nullptr},
        pitch_{nullptr},
        roll_{nullptr},
        accuracy_{},
        _oneof_case_{} {}

template <typename>
PROTOBUF_CONSTEXPR RotationRateAndAccuracy::RotationRateAndAccuracy(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct RotationRateAndAccuracyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RotationRateAndAccuracyDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~RotationRateAndAccuracyDefaultTypeInternal() {}
  union {
    RotationRateAndAccuracy _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RotationRateAndAccuracyDefaultTypeInternal _RotationRateAndAccuracy_default_instance_;

inline constexpr RotationAndAccuracy_Quaternion::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        x_{nullptr},
        y_{nullptr},
        z_{nullptr},
        w_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR RotationAndAccuracy_Quaternion::RotationAndAccuracy_Quaternion(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct RotationAndAccuracy_QuaternionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RotationAndAccuracy_QuaternionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~RotationAndAccuracy_QuaternionDefaultTypeInternal() {}
  union {
    RotationAndAccuracy_Quaternion _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RotationAndAccuracy_QuaternionDefaultTypeInternal _RotationAndAccuracy_Quaternion_default_instance_;

inline constexpr RotationAndAccuracy_Euler::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        yaw_{nullptr},
        pitch_{nullptr},
        roll_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR RotationAndAccuracy_Euler::RotationAndAccuracy_Euler(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct RotationAndAccuracy_EulerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RotationAndAccuracy_EulerDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~RotationAndAccuracy_EulerDefaultTypeInternal() {}
  union {
    RotationAndAccuracy_Euler _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RotationAndAccuracy_EulerDefaultTypeInternal _RotationAndAccuracy_Euler_default_instance_;

inline constexpr PositionAndAccuracy_Metric::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        x_{nullptr},
        y_{nullptr},
        z_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR PositionAndAccuracy_Metric::PositionAndAccuracy_Metric(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct PositionAndAccuracy_MetricDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PositionAndAccuracy_MetricDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PositionAndAccuracy_MetricDefaultTypeInternal() {}
  union {
    PositionAndAccuracy_Metric _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PositionAndAccuracy_MetricDefaultTypeInternal _PositionAndAccuracy_Metric_default_instance_;

inline constexpr PositionAndAccuracy_Geographic::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        longitude_{nullptr},
        latitude_{nullptr},
        altitude_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR PositionAndAccuracy_Geographic::PositionAndAccuracy_Geographic(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct PositionAndAccuracy_GeographicDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PositionAndAccuracy_GeographicDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PositionAndAccuracy_GeographicDefaultTypeInternal() {}
  union {
    PositionAndAccuracy_Geographic _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PositionAndAccuracy_GeographicDefaultTypeInternal _PositionAndAccuracy_Geographic_default_instance_;

inline constexpr XyzVectorAndAccuracy::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : extension_{},
        geometry_{},
        accuracy_{},
        _cached_size_{0},
        _oneof_case_{} {}

template <typename>
PROTOBUF_CONSTEXPR XyzVectorAndAccuracy::XyzVectorAndAccuracy(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct XyzVectorAndAccuracyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR XyzVectorAndAccuracyDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~XyzVectorAndAccuracyDefaultTypeInternal() {}
  union {
    XyzVectorAndAccuracy _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 XyzVectorAndAccuracyDefaultTypeInternal _XyzVectorAndAccuracy_default_instance_;

inline constexpr RotationAndAccuracy::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : extension_{},
        euler_quaternion_{},
        accuracy_{},
        _cached_size_{0},
        _oneof_case_{} {}

template <typename>
PROTOBUF_CONSTEXPR RotationAndAccuracy::RotationAndAccuracy(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct RotationAndAccuracyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RotationAndAccuracyDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~RotationAndAccuracyDefaultTypeInternal() {}
  union {
    RotationAndAccuracy _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RotationAndAccuracyDefaultTypeInternal _RotationAndAccuracy_default_instance_;

inline constexpr PositionAndAccuracy::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : extension_{},
        geographic_metric_{},
        accuracy_{},
        _cached_size_{0},
        _oneof_case_{} {}

template <typename>
PROTOBUF_CONSTEXPR PositionAndAccuracy::PositionAndAccuracy(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct PositionAndAccuracyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PositionAndAccuracyDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PositionAndAccuracyDefaultTypeInternal() {}
  union {
    PositionAndAccuracy _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PositionAndAccuracyDefaultTypeInternal _PositionAndAccuracy_default_instance_;

inline constexpr RectangularBoxAndAccuracy_CornerVectors::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        first_and_accuracy_{nullptr},
        second_and_accuracy_{nullptr},
        third_and_accuracy_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR RectangularBoxAndAccuracy_CornerVectors::RectangularBoxAndAccuracy_CornerVectors(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct RectangularBoxAndAccuracy_CornerVectorsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RectangularBoxAndAccuracy_CornerVectorsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~RectangularBoxAndAccuracy_CornerVectorsDefaultTypeInternal() {}
  union {
    RectangularBoxAndAccuracy_CornerVectors _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RectangularBoxAndAccuracy_CornerVectorsDefaultTypeInternal _RectangularBoxAndAccuracy_CornerVectors_default_instance_;

inline constexpr RectangularBoxAndAccuracy_CenterOrientationSize::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        center_position_and_accuracy_{nullptr},
        orientation_and_accuracy_{nullptr},
        size_and_accuracy_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR RectangularBoxAndAccuracy_CenterOrientationSize::RectangularBoxAndAccuracy_CenterOrientationSize(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct RectangularBoxAndAccuracy_CenterOrientationSizeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RectangularBoxAndAccuracy_CenterOrientationSizeDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~RectangularBoxAndAccuracy_CenterOrientationSizeDefaultTypeInternal() {}
  union {
    RectangularBoxAndAccuracy_CenterOrientationSize _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RectangularBoxAndAccuracy_CenterOrientationSizeDefaultTypeInternal _RectangularBoxAndAccuracy_CenterOrientationSize_default_instance_;

inline constexpr RectangleAndAccuracy::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        extension_{},
        minimum_position_and_accuracy_{nullptr},
        maximum_position_and_accuracy_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR RectangleAndAccuracy::RectangleAndAccuracy(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct RectangleAndAccuracyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RectangleAndAccuracyDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~RectangleAndAccuracyDefaultTypeInternal() {}
  union {
    RectangleAndAccuracy _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RectangleAndAccuracyDefaultTypeInternal _RectangleAndAccuracy_default_instance_;

inline constexpr PolylineAndAccuracy::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : position_and_accuracy_{},
        extension_{},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR PolylineAndAccuracy::PolylineAndAccuracy(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct PolylineAndAccuracyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PolylineAndAccuracyDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PolylineAndAccuracyDefaultTypeInternal() {}
  union {
    PolylineAndAccuracy _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PolylineAndAccuracyDefaultTypeInternal _PolylineAndAccuracy_default_instance_;

inline constexpr PolygonAndAccuracy::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : position_and_accuracy_{},
        extension_{},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR PolygonAndAccuracy::PolygonAndAccuracy(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct PolygonAndAccuracyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PolygonAndAccuracyDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PolygonAndAccuracyDefaultTypeInternal() {}
  union {
    PolygonAndAccuracy _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PolygonAndAccuracyDefaultTypeInternal _PolygonAndAccuracy_default_instance_;

inline constexpr MapLocationReference::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        extension_{},
        position_and_accuracy_{nullptr},
        z_level_{nullptr},
        map_based_reference_{},
        _oneof_case_{} {}

template <typename>
PROTOBUF_CONSTEXPR MapLocationReference::MapLocationReference(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct MapLocationReferenceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MapLocationReferenceDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MapLocationReferenceDefaultTypeInternal() {}
  union {
    MapLocationReference _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MapLocationReferenceDefaultTypeInternal _MapLocationReference_default_instance_;

inline constexpr CircleAndAccuracy::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        extension_{},
        center_position_and_accuracy_{nullptr},
        radius_and_accuracy_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR CircleAndAccuracy::CircleAndAccuracy(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct CircleAndAccuracyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CircleAndAccuracyDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CircleAndAccuracyDefaultTypeInternal() {}
  union {
    CircleAndAccuracy _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CircleAndAccuracyDefaultTypeInternal _CircleAndAccuracy_default_instance_;

inline constexpr RectangularBoxAndAccuracy::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : extension_{},
        geometry_{},
        _cached_size_{0},
        _oneof_case_{} {}

template <typename>
PROTOBUF_CONSTEXPR RectangularBoxAndAccuracy::RectangularBoxAndAccuracy(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct RectangularBoxAndAccuracyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RectangularBoxAndAccuracyDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~RectangularBoxAndAccuracyDefaultTypeInternal() {}
  union {
    RectangularBoxAndAccuracy _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RectangularBoxAndAccuracyDefaultTypeInternal _RectangularBoxAndAccuracy_default_instance_;

inline constexpr PolylineCorridorAndAccuracy::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        extension_{},
        center_polyline_and_accuracy_{nullptr},
        total_width_and_accuracy_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR PolylineCorridorAndAccuracy::PolylineCorridorAndAccuracy(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct PolylineCorridorAndAccuracyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PolylineCorridorAndAccuracyDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PolylineCorridorAndAccuracyDefaultTypeInternal() {}
  union {
    PolylineCorridorAndAccuracy _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PolylineCorridorAndAccuracyDefaultTypeInternal _PolylineCorridorAndAccuracy_default_instance_;

inline constexpr DirectedPolylineCorridor::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        extension_{},
        polyline_corridor_{nullptr},
        is_bidirectional_{nullptr},
        heading_deviation_from_center_line_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR DirectedPolylineCorridor::DirectedPolylineCorridor(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct DirectedPolylineCorridorDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DirectedPolylineCorridorDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DirectedPolylineCorridorDefaultTypeInternal() {}
  union {
    DirectedPolylineCorridor _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DirectedPolylineCorridorDefaultTypeInternal _DirectedPolylineCorridor_default_instance_;
}  // namespace spatial
}  // namespace types
}  // namespace protobuf
}  // namespace sensoris
static ::_pb::Metadata file_level_metadata_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto[26];
static constexpr const ::_pb::EnumDescriptor**
    file_level_enum_descriptors_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto = nullptr;
static constexpr const ::_pb::ServiceDescriptor**
    file_level_service_descriptors_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto = nullptr;
const ::uint32_t TableStruct_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(
    protodesc_cold) = {
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic, _impl_.longitude_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic, _impl_.latitude_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic, _impl_.altitude_),
    0,
    1,
    2,
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric, _impl_.x_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric, _impl_.y_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric, _impl_.z_),
    0,
    1,
    2,
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev, _impl_.horizontal_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev, _impl_.vertical_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev, _impl_.horizontal_ellipse_major_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev, _impl_.horizontal_ellipse_minor_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev, _impl_.horizontal_ellipse_major_heading_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev, _impl_.vertical_),
    0,
    1,
    2,
    3,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::PositionAndAccuracy, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::PositionAndAccuracy, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::PositionAndAccuracy, _impl_.extension_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::PositionAndAccuracy, _impl_.geographic_metric_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::PositionAndAccuracy, _impl_.accuracy_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::PolylineAndAccuracy, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::PolylineAndAccuracy, _impl_.position_and_accuracy_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::PolylineAndAccuracy, _impl_.extension_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::PolylineCorridorAndAccuracy, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::PolylineCorridorAndAccuracy, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::PolylineCorridorAndAccuracy, _impl_.center_polyline_and_accuracy_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::PolylineCorridorAndAccuracy, _impl_.total_width_and_accuracy_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::PolylineCorridorAndAccuracy, _impl_.extension_),
    0,
    1,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::DirectedPolylineCorridor, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::DirectedPolylineCorridor, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::DirectedPolylineCorridor, _impl_.polyline_corridor_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::DirectedPolylineCorridor, _impl_.is_bidirectional_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::DirectedPolylineCorridor, _impl_.heading_deviation_from_center_line_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::DirectedPolylineCorridor, _impl_.extension_),
    0,
    1,
    2,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::CircleAndAccuracy, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::CircleAndAccuracy, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::CircleAndAccuracy, _impl_.center_position_and_accuracy_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::CircleAndAccuracy, _impl_.radius_and_accuracy_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::CircleAndAccuracy, _impl_.extension_),
    0,
    1,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RectangleAndAccuracy, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RectangleAndAccuracy, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RectangleAndAccuracy, _impl_.minimum_position_and_accuracy_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RectangleAndAccuracy, _impl_.maximum_position_and_accuracy_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RectangleAndAccuracy, _impl_.extension_),
    0,
    1,
    ~0u,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::PolygonAndAccuracy, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::PolygonAndAccuracy, _impl_.position_and_accuracy_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::PolygonAndAccuracy, _impl_.extension_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev, _impl_.x_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev, _impl_.y_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev, _impl_.z_),
    0,
    1,
    2,
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric, _impl_.x_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric, _impl_.y_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric, _impl_.z_),
    0,
    1,
    2,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy, _impl_.extension_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy, _impl_.geometry_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy, _impl_.accuracy_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors, _impl_.first_and_accuracy_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors, _impl_.second_and_accuracy_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors, _impl_.third_and_accuracy_),
    0,
    1,
    2,
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize, _impl_.center_position_and_accuracy_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize, _impl_.orientation_and_accuracy_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize, _impl_.size_and_accuracy_),
    0,
    1,
    2,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy, _impl_.extension_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy, _impl_.geometry_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler, _impl_.yaw_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler, _impl_.pitch_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler, _impl_.roll_),
    0,
    1,
    2,
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion, _impl_.x_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion, _impl_.y_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion, _impl_.z_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion, _impl_.w_),
    0,
    1,
    2,
    3,
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev, _impl_.yaw_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev, _impl_.pitch_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev, _impl_.roll_),
    0,
    1,
    2,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RotationAndAccuracy, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RotationAndAccuracy, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RotationAndAccuracy, _impl_.extension_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RotationAndAccuracy, _impl_.euler_quaternion_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RotationAndAccuracy, _impl_.accuracy_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev, _impl_.yaw_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev, _impl_.pitch_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev, _impl_.roll_),
    0,
    1,
    2,
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RotationRateAndAccuracy, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RotationRateAndAccuracy, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RotationRateAndAccuracy, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RotationRateAndAccuracy, _impl_.yaw_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RotationRateAndAccuracy, _impl_.pitch_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RotationRateAndAccuracy, _impl_.roll_),
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RotationRateAndAccuracy, _impl_.extension_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RotationRateAndAccuracy, _impl_.accuracy_),
    0,
    1,
    2,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset, _impl_.tile_id_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset, _impl_.link_id_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset, _impl_.offset_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset, _impl_.extension_),
    0,
    1,
    2,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId, _impl_.tile_id_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId, _impl_.object_id_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId, _impl_.extension_),
    0,
    1,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::MapLocationReference, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::MapLocationReference, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::MapLocationReference, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::MapLocationReference, _impl_.position_and_accuracy_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::MapLocationReference, _impl_.z_level_),
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::MapLocationReference, _impl_.extension_),
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::MapLocationReference, _impl_.map_based_reference_),
    0,
    1,
    ~0u,
    ~0u,
    ~0u,
};

static const ::_pbi::MigrationSchema
    schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
        {0, 11, -1, sizeof(::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic)},
        {14, 25, -1, sizeof(::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric)},
        {28, 38, -1, sizeof(::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev)},
        {40, 52, -1, sizeof(::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev)},
        {56, -1, -1, sizeof(::sensoris::protobuf::types::spatial::PositionAndAccuracy)},
        {75, -1, -1, sizeof(::sensoris::protobuf::types::spatial::PolylineAndAccuracy)},
        {85, 96, -1, sizeof(::sensoris::protobuf::types::spatial::PolylineCorridorAndAccuracy)},
        {99, 111, -1, sizeof(::sensoris::protobuf::types::spatial::DirectedPolylineCorridor)},
        {115, 126, -1, sizeof(::sensoris::protobuf::types::spatial::CircleAndAccuracy)},
        {129, 140, -1, sizeof(::sensoris::protobuf::types::spatial::RectangleAndAccuracy)},
        {143, -1, -1, sizeof(::sensoris::protobuf::types::spatial::PolygonAndAccuracy)},
        {153, 164, -1, sizeof(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev)},
        {167, 178, -1, sizeof(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric)},
        {181, -1, -1, sizeof(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy)},
        {198, 209, -1, sizeof(::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors)},
        {212, 223, -1, sizeof(::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize)},
        {226, -1, -1, sizeof(::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy)},
        {238, 249, -1, sizeof(::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler)},
        {252, 264, -1, sizeof(::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion)},
        {268, 279, -1, sizeof(::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev)},
        {282, -1, -1, sizeof(::sensoris::protobuf::types::spatial::RotationAndAccuracy)},
        {300, 311, -1, sizeof(::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev)},
        {314, 330, -1, sizeof(::sensoris::protobuf::types::spatial::RotationRateAndAccuracy)},
        {337, 349, -1, sizeof(::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset)},
        {353, 364, -1, sizeof(::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId)},
        {367, 381, -1, sizeof(::sensoris::protobuf::types::spatial::MapLocationReference)},
};

static const ::_pb::Message* const file_default_instances[] = {
    &::sensoris::protobuf::types::spatial::_PositionAndAccuracy_Geographic_default_instance_._instance,
    &::sensoris::protobuf::types::spatial::_PositionAndAccuracy_Metric_default_instance_._instance,
    &::sensoris::protobuf::types::spatial::_PositionAndAccuracy_HorizontalVerticalStdDev_default_instance_._instance,
    &::sensoris::protobuf::types::spatial::_PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev_default_instance_._instance,
    &::sensoris::protobuf::types::spatial::_PositionAndAccuracy_default_instance_._instance,
    &::sensoris::protobuf::types::spatial::_PolylineAndAccuracy_default_instance_._instance,
    &::sensoris::protobuf::types::spatial::_PolylineCorridorAndAccuracy_default_instance_._instance,
    &::sensoris::protobuf::types::spatial::_DirectedPolylineCorridor_default_instance_._instance,
    &::sensoris::protobuf::types::spatial::_CircleAndAccuracy_default_instance_._instance,
    &::sensoris::protobuf::types::spatial::_RectangleAndAccuracy_default_instance_._instance,
    &::sensoris::protobuf::types::spatial::_PolygonAndAccuracy_default_instance_._instance,
    &::sensoris::protobuf::types::spatial::_XyzVectorAndAccuracy_StdDev_default_instance_._instance,
    &::sensoris::protobuf::types::spatial::_XyzVectorAndAccuracy_Metric_default_instance_._instance,
    &::sensoris::protobuf::types::spatial::_XyzVectorAndAccuracy_default_instance_._instance,
    &::sensoris::protobuf::types::spatial::_RectangularBoxAndAccuracy_CornerVectors_default_instance_._instance,
    &::sensoris::protobuf::types::spatial::_RectangularBoxAndAccuracy_CenterOrientationSize_default_instance_._instance,
    &::sensoris::protobuf::types::spatial::_RectangularBoxAndAccuracy_default_instance_._instance,
    &::sensoris::protobuf::types::spatial::_RotationAndAccuracy_Euler_default_instance_._instance,
    &::sensoris::protobuf::types::spatial::_RotationAndAccuracy_Quaternion_default_instance_._instance,
    &::sensoris::protobuf::types::spatial::_RotationAndAccuracy_StdDev_default_instance_._instance,
    &::sensoris::protobuf::types::spatial::_RotationAndAccuracy_default_instance_._instance,
    &::sensoris::protobuf::types::spatial::_RotationRateAndAccuracy_StdDev_default_instance_._instance,
    &::sensoris::protobuf::types::spatial::_RotationRateAndAccuracy_default_instance_._instance,
    &::sensoris::protobuf::types::spatial::_MapLocationReference_TileIdLinkIdOffset_default_instance_._instance,
    &::sensoris::protobuf::types::spatial::_MapLocationReference_TileIdObjectId_default_instance_._instance,
    &::sensoris::protobuf::types::spatial::_MapLocationReference_default_instance_._instance,
};
const char descriptor_table_protodef_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
    "\n%sensoris/protobuf/types/spatial.proto\022"
    "\037sensoris.protobuf.types.spatial\032\031google"
    "/protobuf/any.proto\032\036google/protobuf/wra"
    "ppers.proto\032\"sensoris/protobuf/types/bas"
    "e.proto\"\235\r\n\023PositionAndAccuracy\022[\n\020geogr"
    "aphic_wgs84\030\001 \001(\0132\?.sensoris.protobuf.ty"
    "pes.spatial.PositionAndAccuracy.Geograph"
    "icH\000\022U\n\016metric_vehicle\030\002 \001(\0132;.sensoris."
    "protobuf.types.spatial.PositionAndAccura"
    "cy.MetricH\000\022Y\n\022metric_event_group\030\003 \001(\0132"
    ";.sensoris.protobuf.types.spatial.Positi"
    "onAndAccuracy.MetricH\000\022R\n\013metric_ecef\030\004 "
    "\001(\0132;.sensoris.protobuf.types.spatial.Po"
    "sitionAndAccuracy.MetricH\000\022=\n\020combined_s"
    "td_dev\030\005 \001(\0132\033.google.protobuf.Int64Valu"
    "eB\004\210\265\030\000H\001\022`\n\007std_dev\030\006 \001(\0132M.sensoris.pr"
    "otobuf.types.spatial.PositionAndAccuracy"
    ".HorizontalVerticalStdDevH\001\022\230\001\n.horizont"
    "al_confidence_ellipse_vertical_std_dev\030\007"
    " \001(\0132^.sensoris.protobuf.types.spatial.P"
    "ositionAndAccuracy.HorizontalConfidenceE"
    "llipseVerticalStdDevH\001\022H\n\ncovariance\030\010 \001"
    "(\0132,.sensoris.protobuf.types.base.Int64M"
    "atrix3x3B\004\210\265\030\000H\001\022\'\n\textension\030\017 \003(\0132\024.go"
    "ogle.protobuf.Any\032\323\001\n\nGeographic\022A\n\tlong"
    "itude\030\001 \001(\0132(.sensoris.protobuf.types.ba"
    "se.Int64ValueB\004\210\265\030\010\022@\n\010latitude\030\002 \001(\0132(."
    "sensoris.protobuf.types.base.Int64ValueB"
    "\004\210\265\030\010\022@\n\010altitude\030\003 \001(\0132(.sensoris.proto"
    "buf.types.base.Int64ValueB\004\210\265\030\003\032\271\001\n\006Metr"
    "ic\0229\n\001x\030\001 \001(\0132(.sensoris.protobuf.types."
    "base.Int64ValueB\004\210\265\030\000\0229\n\001y\030\002 \001(\0132(.senso"
    "ris.protobuf.types.base.Int64ValueB\004\210\265\030\000"
    "\0229\n\001z\030\003 \001(\0132(.sensoris.protobuf.types.ba"
    "se.Int64ValueB\004\210\265\030\000\032\206\001\n\030HorizontalVertic"
    "alStdDev\0225\n\nhorizontal\030\001 \001(\0132\033.google.pr"
    "otobuf.Int64ValueB\004\210\265\030\000\0223\n\010vertical\030\002 \001("
    "\0132\033.google.protobuf.Int64ValueB\004\210\265\030\000\032\267\002\n"
    ")HorizontalConfidenceEllipseVerticalStdD"
    "ev\022C\n\030horizontal_ellipse_major\030\001 \001(\0132\033.g"
    "oogle.protobuf.Int64ValueB\004\210\265\030\000\022C\n\030horiz"
    "ontal_ellipse_minor\030\002 \001(\0132\033.google.proto"
    "buf.Int64ValueB\004\210\265\030\000\022K\n horizontal_ellip"
    "se_major_heading\030\003 \001(\0132\033.google.protobuf"
    ".Int64ValueB\004\210\265\030\002\0223\n\010vertical\030\004 \001(\0132\033.go"
    "ogle.protobuf.Int64ValueB\004\210\265\030\000B\023\n\021geogra"
    "phic_metricB\n\n\010accuracy\"\223\001\n\023PolylineAndA"
    "ccuracy\022S\n\025position_and_accuracy\030\001 \003(\01324"
    ".sensoris.protobuf.types.spatial.Positio"
    "nAndAccuracy\022\'\n\textension\030\017 \003(\0132\024.google"
    ".protobuf.Any\"\377\001\n\033PolylineCorridorAndAcc"
    "uracy\022Z\n\034center_polyline_and_accuracy\030\001 "
    "\001(\01324.sensoris.protobuf.types.spatial.Po"
    "lylineAndAccuracy\022[\n\030total_width_and_acc"
    "uracy\030\002 \001(\01323.sensoris.protobuf.types.ba"
    "se.Int64ValueAndAccuracyB\004\210\265\030\000\022\'\n\textens"
    "ion\030\017 \003(\0132\024.google.protobuf.Any\"\233\002\n\030Dire"
    "ctedPolylineCorridor\022W\n\021polyline_corrido"
    "r\030\001 \001(\0132<.sensoris.protobuf.types.spatia"
    "l.PolylineCorridorAndAccuracy\0224\n\020is_bidi"
    "rectional\030\002 \001(\0132\032.google.protobuf.BoolVa"
    "lue\022G\n\"heading_deviation_from_center_lin"
    "e\030\003 \001(\0132\033.google.protobuf.Int64Value\022\'\n\t"
    "extension\030\017 \003(\0132\024.google.protobuf.Any\"\360\001"
    "\n\021CircleAndAccuracy\022Z\n\034center_position_a"
    "nd_accuracy\030\001 \001(\01324.sensoris.protobuf.ty"
    "pes.spatial.PositionAndAccuracy\022V\n\023radiu"
    "s_and_accuracy\030\002 \001(\01323.sensoris.protobuf"
    ".types.base.Int64ValueAndAccuracyB\004\210\265\030\000\022"
    "\'\n\textension\030\017 \003(\0132\024.google.protobuf.Any"
    "\"\371\001\n\024RectangleAndAccuracy\022[\n\035minimum_pos"
    "ition_and_accuracy\030\001 \001(\01324.sensoris.prot"
    "obuf.types.spatial.PositionAndAccuracy\022["
    "\n\035maximum_position_and_accuracy\030\002 \001(\01324."
    "sensoris.protobuf.types.spatial.Position"
    "AndAccuracy\022\'\n\textension\030\017 \003(\0132\024.google."
    "protobuf.Any\"\222\001\n\022PolygonAndAccuracy\022S\n\025p"
    "osition_and_accuracy\030\001 \003(\01324.sensoris.pr"
    "otobuf.types.spatial.PositionAndAccuracy"
    "\022\'\n\textension\030\017 \003(\0132\024.google.protobuf.An"
    "y\"\335\006\n\024XyzVectorAndAccuracy\022V\n\016metric_veh"
    "icle\030\001 \001(\0132<.sensoris.protobuf.types.spa"
    "tial.XyzVectorAndAccuracy.MetricH\000\022Z\n\022me"
    "tric_event_group\030\002 \001(\0132<.sensoris.protob"
    "uf.types.spatial.XyzVectorAndAccuracy.Me"
    "tricH\000\022U\n\rmetric_origin\030\003 \001(\0132<.sensoris"
    ".protobuf.types.spatial.XyzVectorAndAccu"
    "racy.MetricH\000\0227\n\020combined_std_dev\030\004 \001(\0132"
    "\033.google.protobuf.Int64ValueH\001\022O\n\007std_de"
    "v\030\005 \001(\0132<.sensoris.protobuf.types.spatia"
    "l.XyzVectorAndAccuracy.StdDevH\001\022B\n\ncovar"
    "iance\030\006 \001(\0132,.sensoris.protobuf.types.ba"
    "se.Int64Matrix3x3H\001\022\'\n\textension\030\017 \003(\0132\024"
    ".google.protobuf.Any\032\200\001\n\006StdDev\022&\n\001x\030\001 \001"
    "(\0132\033.google.protobuf.Int64Value\022&\n\001y\030\002 \001"
    "(\0132\033.google.protobuf.Int64Value\022&\n\001z\030\003 \001"
    "(\0132\033.google.protobuf.Int64Value\032\247\001\n\006Metr"
    "ic\0223\n\001x\030\001 \001(\0132(.sensoris.protobuf.types."
    "base.Int64Value\0223\n\001y\030\002 \001(\0132(.sensoris.pr"
    "otobuf.types.base.Int64Value\0223\n\001z\030\003 \001(\0132"
    "(.sensoris.protobuf.types.base.Int64Valu"
    "eB\n\n\010geometryB\n\n\010accuracy\"\355\006\n\031Rectangula"
    "rBoxAndAccuracy\022b\n\016corner_vectors\030\001 \001(\0132"
    "H.sensoris.protobuf.types.spatial.Rectan"
    "gularBoxAndAccuracy.CornerVectorsH\000\022s\n\027c"
    "enter_orientation_size\030\002 \001(\0132P.sensoris."
    "protobuf.types.spatial.RectangularBoxAnd"
    "Accuracy.CenterOrientationSizeH\000\022\'\n\texte"
    "nsion\030\017 \003(\0132\024.google.protobuf.Any\032\233\002\n\rCo"
    "rnerVectors\022W\n\022first_and_accuracy\030\001 \001(\0132"
    "5.sensoris.protobuf.types.spatial.XyzVec"
    "torAndAccuracyB\004\210\265\030\000\022X\n\023second_and_accur"
    "acy\030\002 \001(\01325.sensoris.protobuf.types.spat"
    "ial.XyzVectorAndAccuracyB\004\210\265\030\000\022W\n\022third_"
    "and_accuracy\030\003 \001(\01325.sensoris.protobuf.t"
    "ypes.spatial.XyzVectorAndAccuracyB\004\210\265\030\000\032"
    "\243\002\n\025CenterOrientationSize\022Z\n\034center_posi"
    "tion_and_accuracy\030\001 \001(\01324.sensoris.proto"
    "buf.types.spatial.PositionAndAccuracy\022V\n"
    "\030orientation_and_accuracy\030\002 \001(\01324.sensor"
    "is.protobuf.types.spatial.RotationAndAcc"
    "uracy\022V\n\021size_and_accuracy\030\003 \001(\01325.senso"
    "ris.protobuf.types.spatial.XyzVectorAndA"
    "ccuracyB\004\210\265\030\000B\n\n\010geometry\"\204\n\n\023RotationAn"
    "dAccuracy\022S\n\reuler_vehicle\030\001 \001(\0132:.senso"
    "ris.protobuf.types.spatial.RotationAndAc"
    "curacy.EulerH\000\022W\n\021euler_event_group\030\002 \001("
    "\0132:.sensoris.protobuf.types.spatial.Rota"
    "tionAndAccuracy.EulerH\000\022]\n\022quaternion_ve"
    "hicle\030\003 \001(\0132\?.sensoris.protobuf.types.sp"
    "atial.RotationAndAccuracy.QuaternionH\000\022a"
    "\n\026quaternion_event_group\030\004 \001(\0132\?.sensori"
    "s.protobuf.types.spatial.RotationAndAccu"
    "racy.QuaternionH\000\022=\n\020combined_std_dev\030\005 "
    "\001(\0132\033.google.protobuf.Int64ValueB\004\210\265\030\002H\001"
    "\022N\n\007std_dev\030\006 \001(\0132;.sensoris.protobuf.ty"
    "pes.spatial.RotationAndAccuracy.StdDevH\001"
    "\022H\n\ncovariance\030\007 \001(\0132,.sensoris.protobuf"
    ".types.base.Int64Matrix3x3B\004\210\265\030\002H\001\022\'\n\tex"
    "tension\030\017 \003(\0132\024.google.protobuf.Any\032\301\001\n\005"
    "Euler\022;\n\003yaw\030\001 \001(\0132(.sensoris.protobuf.t"
    "ypes.base.Int64ValueB\004\210\265\030\002\022=\n\005pitch\030\002 \001("
    "\0132(.sensoris.protobuf.types.base.Int64Va"
    "lueB\004\210\265\030\002\022<\n\004roll\030\003 \001(\0132(.sensoris.proto"
    "buf.types.base.Int64ValueB\004\210\265\030\002\032\370\001\n\nQuat"
    "ernion\0229\n\001x\030\001 \001(\0132(.sensoris.protobuf.ty"
    "pes.base.Int64ValueB\004\210\265\030\003\0229\n\001y\030\002 \001(\0132(.s"
    "ensoris.protobuf.types.base.Int64ValueB\004"
    "\210\265\030\003\0229\n\001z\030\003 \001(\0132(.sensoris.protobuf.type"
    "s.base.Int64ValueB\004\210\265\030\003\0229\n\001w\030\004 \001(\0132(.sen"
    "soris.protobuf.types.base.Int64ValueB\004\210\265"
    "\030\003\032\233\001\n\006StdDev\022.\n\003yaw\030\001 \001(\0132\033.google.prot"
    "obuf.Int64ValueB\004\210\265\030\002\0220\n\005pitch\030\002 \001(\0132\033.g"
    "oogle.protobuf.Int64ValueB\004\210\265\030\002\022/\n\004roll\030"
    "\003 \001(\0132\033.google.protobuf.Int64ValueB\004\210\265\030\002"
    "B\022\n\020euler_quaternionB\n\n\010accuracy\"\203\005\n\027Rot"
    "ationRateAndAccuracy\022;\n\003yaw\030\001 \001(\0132(.sens"
    "oris.protobuf.types.base.Int64ValueB\004\210\265\030"
    "\002\022=\n\005pitch\030\002 \001(\0132(.sensoris.protobuf.typ"
    "es.base.Int64ValueB\004\210\265\030\002\022<\n\004roll\030\003 \001(\0132("
    ".sensoris.protobuf.types.base.Int64Value"
    "B\004\210\265\030\002\022=\n\020combined_std_dev\030\004 \001(\0132\033.googl"
    "e.protobuf.Int64ValueB\004\210\265\030\002H\000\022R\n\007std_dev"
    "\030\005 \001(\0132\?.sensoris.protobuf.types.spatial"
    ".RotationRateAndAccuracy.StdDevH\000\022H\n\ncov"
    "ariance\030\006 \001(\0132,.sensoris.protobuf.types."
    "base.Int64Matrix3x3B\004\210\265\030\002H\000\022\'\n\textension"
    "\030\017 \003(\0132\024.google.protobuf.Any\032\233\001\n\006StdDev\022"
    ".\n\003yaw\030\001 \001(\0132\033.google.protobuf.Int64Valu"
    "eB\004\210\265\030\002\0220\n\005pitch\030\002 \001(\0132\033.google.protobuf"
    ".Int64ValueB\004\210\265\030\002\022/\n\004roll\030\003 \001(\0132\033.google"
    ".protobuf.Int64ValueB\004\210\265\030\002B\n\n\010accuracy\"\221"
    "\006\n\024MapLocationReference\022S\n\025position_and_"
    "accuracy\030\001 \001(\01324.sensoris.protobuf.types"
    ".spatial.PositionAndAccuracy\022,\n\007z_level\030"
    "\002 \001(\0132\033.google.protobuf.Int64Value\022n\n\032ti"
    "le_link_offset_reference\030\003 \001(\0132H.sensori"
    "s.protobuf.types.spatial.MapLocationRefe"
    "rence.TileIdLinkIdOffsetH\000\022]\n\rmap_object"
    "_id\030\004 \001(\0132D.sensoris.protobuf.types.spat"
    "ial.MapLocationReference.TileIdObjectIdH"
    "\000\022\'\n\textension\030\017 \003(\0132\024.google.protobuf.A"
    "ny\032\314\001\n\022TileIdLinkIdOffset\022,\n\007tile_id\030\001 \001"
    "(\0132\033.google.protobuf.Int64Value\022,\n\007link_"
    "id\030\002 \001(\0132\033.google.protobuf.Int64Value\0221\n"
    "\006offset\030\003 \001(\0132\033.google.protobuf.Int64Val"
    "ueB\004\210\265\030\000\022\'\n\textension\030\017 \003(\0132\024.google.pro"
    "tobuf.Any\032\227\001\n\016TileIdObjectId\022,\n\007tile_id\030"
    "\001 \001(\0132\033.google.protobuf.Int64Value\022.\n\tob"
    "ject_id\030\002 \001(\0132\033.google.protobuf.Int64Val"
    "ue\022\'\n\textension\030\017 \003(\0132\024.google.protobuf."
    "AnyB\025\n\023map_based_referenceBa\n\032org.sensor"
    "is.types.spatialB\024SensorisSpatialTypesP\001"
    "Z(sensoris.org/specification/types/spati"
    "al\370\001\001b\006proto3"
};
static const ::_pbi::DescriptorTable* const descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto_deps[3] =
    {
        &::descriptor_table_google_2fprotobuf_2fany_2eproto,
        &::descriptor_table_google_2fprotobuf_2fwrappers_2eproto,
        &::descriptor_table_sensoris_2fprotobuf_2ftypes_2fbase_2eproto,
};
static ::absl::once_flag descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto = {
    false,
    false,
    7773,
    descriptor_table_protodef_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto,
    "sensoris/protobuf/types/spatial.proto",
    &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto_once,
    descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto_deps,
    3,
    26,
    schemas,
    file_default_instances,
    TableStruct_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto::offsets,
    file_level_metadata_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto,
    file_level_enum_descriptors_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto,
    file_level_service_descriptors_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto,
};

// This function exists to be marked as weak.
// It can significantly speed up compilation by breaking up LLVM's SCC
// in the .pb.cc translation units. Large translation units see a
// reduction of more than 35% of walltime for optimized builds. Without
// the weak attribute all the messages in the file, including all the
// vtables and everything they use become part of the same SCC through
// a cycle like:
// GetMetadata -> descriptor table -> default instances ->
//   vtables -> GetMetadata
// By adding a weak function here we break the connection from the
// individual vtables back into the descriptor table.
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto_getter() {
  return &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto;
}
// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2
static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto(&descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto);
namespace sensoris {
namespace protobuf {
namespace types {
namespace spatial {
// ===================================================================

class PositionAndAccuracy_Geographic::_Internal {
 public:
  using HasBits = decltype(std::declval<PositionAndAccuracy_Geographic>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_Geographic, _impl_._has_bits_);
  static const ::sensoris::protobuf::types::base::Int64Value& longitude(const PositionAndAccuracy_Geographic* msg);
  static void set_has_longitude(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::sensoris::protobuf::types::base::Int64Value& latitude(const PositionAndAccuracy_Geographic* msg);
  static void set_has_latitude(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::sensoris::protobuf::types::base::Int64Value& altitude(const PositionAndAccuracy_Geographic* msg);
  static void set_has_altitude(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::sensoris::protobuf::types::base::Int64Value& PositionAndAccuracy_Geographic::_Internal::longitude(const PositionAndAccuracy_Geographic* msg) {
  return *msg->_impl_.longitude_;
}
const ::sensoris::protobuf::types::base::Int64Value& PositionAndAccuracy_Geographic::_Internal::latitude(const PositionAndAccuracy_Geographic* msg) {
  return *msg->_impl_.latitude_;
}
const ::sensoris::protobuf::types::base::Int64Value& PositionAndAccuracy_Geographic::_Internal::altitude(const PositionAndAccuracy_Geographic* msg) {
  return *msg->_impl_.altitude_;
}
void PositionAndAccuracy_Geographic::clear_longitude() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.longitude_ != nullptr) _impl_.longitude_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void PositionAndAccuracy_Geographic::clear_latitude() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.latitude_ != nullptr) _impl_.latitude_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void PositionAndAccuracy_Geographic::clear_altitude() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.altitude_ != nullptr) _impl_.altitude_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
PositionAndAccuracy_Geographic::PositionAndAccuracy_Geographic(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic)
}
inline PROTOBUF_NDEBUG_INLINE PositionAndAccuracy_Geographic::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

PositionAndAccuracy_Geographic::PositionAndAccuracy_Geographic(
    ::google::protobuf::Arena* arena,
    const PositionAndAccuracy_Geographic& from)
    : ::google::protobuf::Message(arena) {
  PositionAndAccuracy_Geographic* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.longitude_ = (cached_has_bits & 0x00000001u)
                ? CreateMaybeMessage<::sensoris::protobuf::types::base::Int64Value>(arena, *from._impl_.longitude_)
                : nullptr;
  _impl_.latitude_ = (cached_has_bits & 0x00000002u)
                ? CreateMaybeMessage<::sensoris::protobuf::types::base::Int64Value>(arena, *from._impl_.latitude_)
                : nullptr;
  _impl_.altitude_ = (cached_has_bits & 0x00000004u)
                ? CreateMaybeMessage<::sensoris::protobuf::types::base::Int64Value>(arena, *from._impl_.altitude_)
                : nullptr;

  // @@protoc_insertion_point(copy_constructor:sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic)
}
inline PROTOBUF_NDEBUG_INLINE PositionAndAccuracy_Geographic::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void PositionAndAccuracy_Geographic::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, longitude_),
           0,
           offsetof(Impl_, altitude_) -
               offsetof(Impl_, longitude_) +
               sizeof(Impl_::altitude_));
}
PositionAndAccuracy_Geographic::~PositionAndAccuracy_Geographic() {
  // @@protoc_insertion_point(destructor:sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void PositionAndAccuracy_Geographic::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  delete _impl_.longitude_;
  delete _impl_.latitude_;
  delete _impl_.altitude_;
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void PositionAndAccuracy_Geographic::Clear() {
// @@protoc_insertion_point(message_clear_start:sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.longitude_ != nullptr);
      _impl_.longitude_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.latitude_ != nullptr);
      _impl_.latitude_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.altitude_ != nullptr);
      _impl_.altitude_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* PositionAndAccuracy_Geographic::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 3, 0, 2> PositionAndAccuracy_Geographic::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_Geographic, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    3,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_PositionAndAccuracy_Geographic_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // .sensoris.protobuf.types.base.Int64Value longitude = 1 [(.sensoris.protobuf.types.base.exponent) = 8];
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_Geographic, _impl_.longitude_)}},
    // .sensoris.protobuf.types.base.Int64Value latitude = 2 [(.sensoris.protobuf.types.base.exponent) = 8];
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 1, PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_Geographic, _impl_.latitude_)}},
    // .sensoris.protobuf.types.base.Int64Value altitude = 3 [(.sensoris.protobuf.types.base.exponent) = 3];
    {::_pbi::TcParser::FastMtS1,
     {26, 2, 2, PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_Geographic, _impl_.altitude_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .sensoris.protobuf.types.base.Int64Value longitude = 1 [(.sensoris.protobuf.types.base.exponent) = 8];
    {PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_Geographic, _impl_.longitude_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.base.Int64Value latitude = 2 [(.sensoris.protobuf.types.base.exponent) = 8];
    {PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_Geographic, _impl_.latitude_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.base.Int64Value altitude = 3 [(.sensoris.protobuf.types.base.exponent) = 3];
    {PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_Geographic, _impl_.altitude_), _Internal::kHasBitsOffset + 2, 2,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::base::Int64Value>()},
    {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::base::Int64Value>()},
    {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::base::Int64Value>()},
  }}, {{
  }},
};

::uint8_t* PositionAndAccuracy_Geographic::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .sensoris.protobuf.types.base.Int64Value longitude = 1 [(.sensoris.protobuf.types.base.exponent) = 8];
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        1, _Internal::longitude(this),
        _Internal::longitude(this).GetCachedSize(), target, stream);
  }

  // .sensoris.protobuf.types.base.Int64Value latitude = 2 [(.sensoris.protobuf.types.base.exponent) = 8];
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, _Internal::latitude(this),
        _Internal::latitude(this).GetCachedSize(), target, stream);
  }

  // .sensoris.protobuf.types.base.Int64Value altitude = 3 [(.sensoris.protobuf.types.base.exponent) = 3];
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        3, _Internal::altitude(this),
        _Internal::altitude(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic)
  return target;
}

::size_t PositionAndAccuracy_Geographic::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // .sensoris.protobuf.types.base.Int64Value longitude = 1 [(.sensoris.protobuf.types.base.exponent) = 8];
    if (cached_has_bits & 0x00000001u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.longitude_);
    }

    // .sensoris.protobuf.types.base.Int64Value latitude = 2 [(.sensoris.protobuf.types.base.exponent) = 8];
    if (cached_has_bits & 0x00000002u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.latitude_);
    }

    // .sensoris.protobuf.types.base.Int64Value altitude = 3 [(.sensoris.protobuf.types.base.exponent) = 3];
    if (cached_has_bits & 0x00000004u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.altitude_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData PositionAndAccuracy_Geographic::_class_data_ = {
    PositionAndAccuracy_Geographic::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* PositionAndAccuracy_Geographic::GetClassData() const {
  return &_class_data_;
}

void PositionAndAccuracy_Geographic::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<PositionAndAccuracy_Geographic*>(&to_msg);
  auto& from = static_cast<const PositionAndAccuracy_Geographic&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_longitude()->::sensoris::protobuf::types::base::Int64Value::MergeFrom(
          from._internal_longitude());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_latitude()->::sensoris::protobuf::types::base::Int64Value::MergeFrom(
          from._internal_latitude());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_altitude()->::sensoris::protobuf::types::base::Int64Value::MergeFrom(
          from._internal_altitude());
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void PositionAndAccuracy_Geographic::CopyFrom(const PositionAndAccuracy_Geographic& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool PositionAndAccuracy_Geographic::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* PositionAndAccuracy_Geographic::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void PositionAndAccuracy_Geographic::InternalSwap(PositionAndAccuracy_Geographic* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_Geographic, _impl_.altitude_)
      + sizeof(PositionAndAccuracy_Geographic::_impl_.altitude_)
      - PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_Geographic, _impl_.longitude_)>(
          reinterpret_cast<char*>(&_impl_.longitude_),
          reinterpret_cast<char*>(&other->_impl_.longitude_));
}

::google::protobuf::Metadata PositionAndAccuracy_Geographic::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto_getter, &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto_once,
      file_level_metadata_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto[0]);
}
// ===================================================================

class PositionAndAccuracy_Metric::_Internal {
 public:
  using HasBits = decltype(std::declval<PositionAndAccuracy_Metric>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_Metric, _impl_._has_bits_);
  static const ::sensoris::protobuf::types::base::Int64Value& x(const PositionAndAccuracy_Metric* msg);
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::sensoris::protobuf::types::base::Int64Value& y(const PositionAndAccuracy_Metric* msg);
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::sensoris::protobuf::types::base::Int64Value& z(const PositionAndAccuracy_Metric* msg);
  static void set_has_z(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::sensoris::protobuf::types::base::Int64Value& PositionAndAccuracy_Metric::_Internal::x(const PositionAndAccuracy_Metric* msg) {
  return *msg->_impl_.x_;
}
const ::sensoris::protobuf::types::base::Int64Value& PositionAndAccuracy_Metric::_Internal::y(const PositionAndAccuracy_Metric* msg) {
  return *msg->_impl_.y_;
}
const ::sensoris::protobuf::types::base::Int64Value& PositionAndAccuracy_Metric::_Internal::z(const PositionAndAccuracy_Metric* msg) {
  return *msg->_impl_.z_;
}
void PositionAndAccuracy_Metric::clear_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.x_ != nullptr) _impl_.x_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void PositionAndAccuracy_Metric::clear_y() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.y_ != nullptr) _impl_.y_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void PositionAndAccuracy_Metric::clear_z() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.z_ != nullptr) _impl_.z_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
PositionAndAccuracy_Metric::PositionAndAccuracy_Metric(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric)
}
inline PROTOBUF_NDEBUG_INLINE PositionAndAccuracy_Metric::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

PositionAndAccuracy_Metric::PositionAndAccuracy_Metric(
    ::google::protobuf::Arena* arena,
    const PositionAndAccuracy_Metric& from)
    : ::google::protobuf::Message(arena) {
  PositionAndAccuracy_Metric* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.x_ = (cached_has_bits & 0x00000001u)
                ? CreateMaybeMessage<::sensoris::protobuf::types::base::Int64Value>(arena, *from._impl_.x_)
                : nullptr;
  _impl_.y_ = (cached_has_bits & 0x00000002u)
                ? CreateMaybeMessage<::sensoris::protobuf::types::base::Int64Value>(arena, *from._impl_.y_)
                : nullptr;
  _impl_.z_ = (cached_has_bits & 0x00000004u)
                ? CreateMaybeMessage<::sensoris::protobuf::types::base::Int64Value>(arena, *from._impl_.z_)
                : nullptr;

  // @@protoc_insertion_point(copy_constructor:sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric)
}
inline PROTOBUF_NDEBUG_INLINE PositionAndAccuracy_Metric::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void PositionAndAccuracy_Metric::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, x_),
           0,
           offsetof(Impl_, z_) -
               offsetof(Impl_, x_) +
               sizeof(Impl_::z_));
}
PositionAndAccuracy_Metric::~PositionAndAccuracy_Metric() {
  // @@protoc_insertion_point(destructor:sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void PositionAndAccuracy_Metric::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  delete _impl_.x_;
  delete _impl_.y_;
  delete _impl_.z_;
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void PositionAndAccuracy_Metric::Clear() {
// @@protoc_insertion_point(message_clear_start:sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.x_ != nullptr);
      _impl_.x_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.y_ != nullptr);
      _impl_.y_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.z_ != nullptr);
      _impl_.z_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* PositionAndAccuracy_Metric::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 3, 0, 2> PositionAndAccuracy_Metric::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_Metric, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    3,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_PositionAndAccuracy_Metric_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // .sensoris.protobuf.types.base.Int64Value x = 1 [(.sensoris.protobuf.types.base.exponent) = 0];
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_Metric, _impl_.x_)}},
    // .sensoris.protobuf.types.base.Int64Value y = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 1, PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_Metric, _impl_.y_)}},
    // .sensoris.protobuf.types.base.Int64Value z = 3 [(.sensoris.protobuf.types.base.exponent) = 0];
    {::_pbi::TcParser::FastMtS1,
     {26, 2, 2, PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_Metric, _impl_.z_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .sensoris.protobuf.types.base.Int64Value x = 1 [(.sensoris.protobuf.types.base.exponent) = 0];
    {PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_Metric, _impl_.x_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.base.Int64Value y = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
    {PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_Metric, _impl_.y_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.base.Int64Value z = 3 [(.sensoris.protobuf.types.base.exponent) = 0];
    {PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_Metric, _impl_.z_), _Internal::kHasBitsOffset + 2, 2,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::base::Int64Value>()},
    {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::base::Int64Value>()},
    {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::base::Int64Value>()},
  }}, {{
  }},
};

::uint8_t* PositionAndAccuracy_Metric::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .sensoris.protobuf.types.base.Int64Value x = 1 [(.sensoris.protobuf.types.base.exponent) = 0];
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        1, _Internal::x(this),
        _Internal::x(this).GetCachedSize(), target, stream);
  }

  // .sensoris.protobuf.types.base.Int64Value y = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, _Internal::y(this),
        _Internal::y(this).GetCachedSize(), target, stream);
  }

  // .sensoris.protobuf.types.base.Int64Value z = 3 [(.sensoris.protobuf.types.base.exponent) = 0];
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        3, _Internal::z(this),
        _Internal::z(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric)
  return target;
}

::size_t PositionAndAccuracy_Metric::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // .sensoris.protobuf.types.base.Int64Value x = 1 [(.sensoris.protobuf.types.base.exponent) = 0];
    if (cached_has_bits & 0x00000001u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.x_);
    }

    // .sensoris.protobuf.types.base.Int64Value y = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
    if (cached_has_bits & 0x00000002u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.y_);
    }

    // .sensoris.protobuf.types.base.Int64Value z = 3 [(.sensoris.protobuf.types.base.exponent) = 0];
    if (cached_has_bits & 0x00000004u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.z_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData PositionAndAccuracy_Metric::_class_data_ = {
    PositionAndAccuracy_Metric::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* PositionAndAccuracy_Metric::GetClassData() const {
  return &_class_data_;
}

void PositionAndAccuracy_Metric::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<PositionAndAccuracy_Metric*>(&to_msg);
  auto& from = static_cast<const PositionAndAccuracy_Metric&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_x()->::sensoris::protobuf::types::base::Int64Value::MergeFrom(
          from._internal_x());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_y()->::sensoris::protobuf::types::base::Int64Value::MergeFrom(
          from._internal_y());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_z()->::sensoris::protobuf::types::base::Int64Value::MergeFrom(
          from._internal_z());
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void PositionAndAccuracy_Metric::CopyFrom(const PositionAndAccuracy_Metric& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool PositionAndAccuracy_Metric::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* PositionAndAccuracy_Metric::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void PositionAndAccuracy_Metric::InternalSwap(PositionAndAccuracy_Metric* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_Metric, _impl_.z_)
      + sizeof(PositionAndAccuracy_Metric::_impl_.z_)
      - PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_Metric, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::google::protobuf::Metadata PositionAndAccuracy_Metric::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto_getter, &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto_once,
      file_level_metadata_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto[1]);
}
// ===================================================================

class PositionAndAccuracy_HorizontalVerticalStdDev::_Internal {
 public:
  using HasBits = decltype(std::declval<PositionAndAccuracy_HorizontalVerticalStdDev>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_HorizontalVerticalStdDev, _impl_._has_bits_);
  static const ::google::protobuf::Int64Value& horizontal(const PositionAndAccuracy_HorizontalVerticalStdDev* msg);
  static void set_has_horizontal(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::google::protobuf::Int64Value& vertical(const PositionAndAccuracy_HorizontalVerticalStdDev* msg);
  static void set_has_vertical(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::google::protobuf::Int64Value& PositionAndAccuracy_HorizontalVerticalStdDev::_Internal::horizontal(const PositionAndAccuracy_HorizontalVerticalStdDev* msg) {
  return *msg->_impl_.horizontal_;
}
const ::google::protobuf::Int64Value& PositionAndAccuracy_HorizontalVerticalStdDev::_Internal::vertical(const PositionAndAccuracy_HorizontalVerticalStdDev* msg) {
  return *msg->_impl_.vertical_;
}
void PositionAndAccuracy_HorizontalVerticalStdDev::clear_horizontal() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.horizontal_ != nullptr) _impl_.horizontal_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void PositionAndAccuracy_HorizontalVerticalStdDev::clear_vertical() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.vertical_ != nullptr) _impl_.vertical_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
PositionAndAccuracy_HorizontalVerticalStdDev::PositionAndAccuracy_HorizontalVerticalStdDev(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalVerticalStdDev)
}
inline PROTOBUF_NDEBUG_INLINE PositionAndAccuracy_HorizontalVerticalStdDev::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

PositionAndAccuracy_HorizontalVerticalStdDev::PositionAndAccuracy_HorizontalVerticalStdDev(
    ::google::protobuf::Arena* arena,
    const PositionAndAccuracy_HorizontalVerticalStdDev& from)
    : ::google::protobuf::Message(arena) {
  PositionAndAccuracy_HorizontalVerticalStdDev* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.horizontal_ = (cached_has_bits & 0x00000001u)
                ? CreateMaybeMessage<::google::protobuf::Int64Value>(arena, *from._impl_.horizontal_)
                : nullptr;
  _impl_.vertical_ = (cached_has_bits & 0x00000002u)
                ? CreateMaybeMessage<::google::protobuf::Int64Value>(arena, *from._impl_.vertical_)
                : nullptr;

  // @@protoc_insertion_point(copy_constructor:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalVerticalStdDev)
}
inline PROTOBUF_NDEBUG_INLINE PositionAndAccuracy_HorizontalVerticalStdDev::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void PositionAndAccuracy_HorizontalVerticalStdDev::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, horizontal_),
           0,
           offsetof(Impl_, vertical_) -
               offsetof(Impl_, horizontal_) +
               sizeof(Impl_::vertical_));
}
PositionAndAccuracy_HorizontalVerticalStdDev::~PositionAndAccuracy_HorizontalVerticalStdDev() {
  // @@protoc_insertion_point(destructor:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalVerticalStdDev)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void PositionAndAccuracy_HorizontalVerticalStdDev::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  delete _impl_.horizontal_;
  delete _impl_.vertical_;
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void PositionAndAccuracy_HorizontalVerticalStdDev::Clear() {
// @@protoc_insertion_point(message_clear_start:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalVerticalStdDev)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.horizontal_ != nullptr);
      _impl_.horizontal_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.vertical_ != nullptr);
      _impl_.vertical_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* PositionAndAccuracy_HorizontalVerticalStdDev::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 2, 0, 2> PositionAndAccuracy_HorizontalVerticalStdDev::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_HorizontalVerticalStdDev, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_PositionAndAccuracy_HorizontalVerticalStdDev_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // .google.protobuf.Int64Value vertical = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 1, PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_HorizontalVerticalStdDev, _impl_.vertical_)}},
    // .google.protobuf.Int64Value horizontal = 1 [(.sensoris.protobuf.types.base.exponent) = 0];
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_HorizontalVerticalStdDev, _impl_.horizontal_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .google.protobuf.Int64Value horizontal = 1 [(.sensoris.protobuf.types.base.exponent) = 0];
    {PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_HorizontalVerticalStdDev, _impl_.horizontal_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .google.protobuf.Int64Value vertical = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
    {PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_HorizontalVerticalStdDev, _impl_.vertical_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::google::protobuf::Int64Value>()},
    {::_pbi::TcParser::GetTable<::google::protobuf::Int64Value>()},
  }}, {{
  }},
};

::uint8_t* PositionAndAccuracy_HorizontalVerticalStdDev::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalVerticalStdDev)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .google.protobuf.Int64Value horizontal = 1 [(.sensoris.protobuf.types.base.exponent) = 0];
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        1, _Internal::horizontal(this),
        _Internal::horizontal(this).GetCachedSize(), target, stream);
  }

  // .google.protobuf.Int64Value vertical = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, _Internal::vertical(this),
        _Internal::vertical(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalVerticalStdDev)
  return target;
}

::size_t PositionAndAccuracy_HorizontalVerticalStdDev::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalVerticalStdDev)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // .google.protobuf.Int64Value horizontal = 1 [(.sensoris.protobuf.types.base.exponent) = 0];
    if (cached_has_bits & 0x00000001u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.horizontal_);
    }

    // .google.protobuf.Int64Value vertical = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
    if (cached_has_bits & 0x00000002u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.vertical_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData PositionAndAccuracy_HorizontalVerticalStdDev::_class_data_ = {
    PositionAndAccuracy_HorizontalVerticalStdDev::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* PositionAndAccuracy_HorizontalVerticalStdDev::GetClassData() const {
  return &_class_data_;
}

void PositionAndAccuracy_HorizontalVerticalStdDev::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<PositionAndAccuracy_HorizontalVerticalStdDev*>(&to_msg);
  auto& from = static_cast<const PositionAndAccuracy_HorizontalVerticalStdDev&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalVerticalStdDev)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_horizontal()->::google::protobuf::Int64Value::MergeFrom(
          from._internal_horizontal());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_vertical()->::google::protobuf::Int64Value::MergeFrom(
          from._internal_vertical());
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void PositionAndAccuracy_HorizontalVerticalStdDev::CopyFrom(const PositionAndAccuracy_HorizontalVerticalStdDev& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalVerticalStdDev)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool PositionAndAccuracy_HorizontalVerticalStdDev::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* PositionAndAccuracy_HorizontalVerticalStdDev::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void PositionAndAccuracy_HorizontalVerticalStdDev::InternalSwap(PositionAndAccuracy_HorizontalVerticalStdDev* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_HorizontalVerticalStdDev, _impl_.vertical_)
      + sizeof(PositionAndAccuracy_HorizontalVerticalStdDev::_impl_.vertical_)
      - PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_HorizontalVerticalStdDev, _impl_.horizontal_)>(
          reinterpret_cast<char*>(&_impl_.horizontal_),
          reinterpret_cast<char*>(&other->_impl_.horizontal_));
}

::google::protobuf::Metadata PositionAndAccuracy_HorizontalVerticalStdDev::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto_getter, &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto_once,
      file_level_metadata_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto[2]);
}
// ===================================================================

class PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::_Internal {
 public:
  using HasBits = decltype(std::declval<PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev, _impl_._has_bits_);
  static const ::google::protobuf::Int64Value& horizontal_ellipse_major(const PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev* msg);
  static void set_has_horizontal_ellipse_major(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::google::protobuf::Int64Value& horizontal_ellipse_minor(const PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev* msg);
  static void set_has_horizontal_ellipse_minor(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::google::protobuf::Int64Value& horizontal_ellipse_major_heading(const PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev* msg);
  static void set_has_horizontal_ellipse_major_heading(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::google::protobuf::Int64Value& vertical(const PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev* msg);
  static void set_has_vertical(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::google::protobuf::Int64Value& PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::_Internal::horizontal_ellipse_major(const PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev* msg) {
  return *msg->_impl_.horizontal_ellipse_major_;
}
const ::google::protobuf::Int64Value& PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::_Internal::horizontal_ellipse_minor(const PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev* msg) {
  return *msg->_impl_.horizontal_ellipse_minor_;
}
const ::google::protobuf::Int64Value& PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::_Internal::horizontal_ellipse_major_heading(const PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev* msg) {
  return *msg->_impl_.horizontal_ellipse_major_heading_;
}
const ::google::protobuf::Int64Value& PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::_Internal::vertical(const PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev* msg) {
  return *msg->_impl_.vertical_;
}
void PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::clear_horizontal_ellipse_major() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.horizontal_ellipse_major_ != nullptr) _impl_.horizontal_ellipse_major_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::clear_horizontal_ellipse_minor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.horizontal_ellipse_minor_ != nullptr) _impl_.horizontal_ellipse_minor_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::clear_horizontal_ellipse_major_heading() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.horizontal_ellipse_major_heading_ != nullptr) _impl_.horizontal_ellipse_major_heading_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::clear_vertical() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.vertical_ != nullptr) _impl_.vertical_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev)
}
inline PROTOBUF_NDEBUG_INLINE PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev(
    ::google::protobuf::Arena* arena,
    const PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev& from)
    : ::google::protobuf::Message(arena) {
  PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.horizontal_ellipse_major_ = (cached_has_bits & 0x00000001u)
                ? CreateMaybeMessage<::google::protobuf::Int64Value>(arena, *from._impl_.horizontal_ellipse_major_)
                : nullptr;
  _impl_.horizontal_ellipse_minor_ = (cached_has_bits & 0x00000002u)
                ? CreateMaybeMessage<::google::protobuf::Int64Value>(arena, *from._impl_.horizontal_ellipse_minor_)
                : nullptr;
  _impl_.horizontal_ellipse_major_heading_ = (cached_has_bits & 0x00000004u)
                ? CreateMaybeMessage<::google::protobuf::Int64Value>(arena, *from._impl_.horizontal_ellipse_major_heading_)
                : nullptr;
  _impl_.vertical_ = (cached_has_bits & 0x00000008u)
                ? CreateMaybeMessage<::google::protobuf::Int64Value>(arena, *from._impl_.vertical_)
                : nullptr;

  // @@protoc_insertion_point(copy_constructor:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev)
}
inline PROTOBUF_NDEBUG_INLINE PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, horizontal_ellipse_major_),
           0,
           offsetof(Impl_, vertical_) -
               offsetof(Impl_, horizontal_ellipse_major_) +
               sizeof(Impl_::vertical_));
}
PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::~PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev() {
  // @@protoc_insertion_point(destructor:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  delete _impl_.horizontal_ellipse_major_;
  delete _impl_.horizontal_ellipse_minor_;
  delete _impl_.horizontal_ellipse_major_heading_;
  delete _impl_.vertical_;
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::Clear() {
// @@protoc_insertion_point(message_clear_start:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.horizontal_ellipse_major_ != nullptr);
      _impl_.horizontal_ellipse_major_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.horizontal_ellipse_minor_ != nullptr);
      _impl_.horizontal_ellipse_minor_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.horizontal_ellipse_major_heading_ != nullptr);
      _impl_.horizontal_ellipse_major_heading_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      ABSL_DCHECK(_impl_.vertical_ != nullptr);
      _impl_.vertical_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 4, 0, 2> PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    4,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // .google.protobuf.Int64Value vertical = 4 [(.sensoris.protobuf.types.base.exponent) = 0];
    {::_pbi::TcParser::FastMtS1,
     {34, 3, 3, PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev, _impl_.vertical_)}},
    // .google.protobuf.Int64Value horizontal_ellipse_major = 1 [(.sensoris.protobuf.types.base.exponent) = 0];
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev, _impl_.horizontal_ellipse_major_)}},
    // .google.protobuf.Int64Value horizontal_ellipse_minor = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 1, PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev, _impl_.horizontal_ellipse_minor_)}},
    // .google.protobuf.Int64Value horizontal_ellipse_major_heading = 3 [(.sensoris.protobuf.types.base.exponent) = 2];
    {::_pbi::TcParser::FastMtS1,
     {26, 2, 2, PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev, _impl_.horizontal_ellipse_major_heading_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .google.protobuf.Int64Value horizontal_ellipse_major = 1 [(.sensoris.protobuf.types.base.exponent) = 0];
    {PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev, _impl_.horizontal_ellipse_major_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .google.protobuf.Int64Value horizontal_ellipse_minor = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
    {PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev, _impl_.horizontal_ellipse_minor_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .google.protobuf.Int64Value horizontal_ellipse_major_heading = 3 [(.sensoris.protobuf.types.base.exponent) = 2];
    {PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev, _impl_.horizontal_ellipse_major_heading_), _Internal::kHasBitsOffset + 2, 2,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .google.protobuf.Int64Value vertical = 4 [(.sensoris.protobuf.types.base.exponent) = 0];
    {PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev, _impl_.vertical_), _Internal::kHasBitsOffset + 3, 3,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::google::protobuf::Int64Value>()},
    {::_pbi::TcParser::GetTable<::google::protobuf::Int64Value>()},
    {::_pbi::TcParser::GetTable<::google::protobuf::Int64Value>()},
    {::_pbi::TcParser::GetTable<::google::protobuf::Int64Value>()},
  }}, {{
  }},
};

::uint8_t* PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .google.protobuf.Int64Value horizontal_ellipse_major = 1 [(.sensoris.protobuf.types.base.exponent) = 0];
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        1, _Internal::horizontal_ellipse_major(this),
        _Internal::horizontal_ellipse_major(this).GetCachedSize(), target, stream);
  }

  // .google.protobuf.Int64Value horizontal_ellipse_minor = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, _Internal::horizontal_ellipse_minor(this),
        _Internal::horizontal_ellipse_minor(this).GetCachedSize(), target, stream);
  }

  // .google.protobuf.Int64Value horizontal_ellipse_major_heading = 3 [(.sensoris.protobuf.types.base.exponent) = 2];
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        3, _Internal::horizontal_ellipse_major_heading(this),
        _Internal::horizontal_ellipse_major_heading(this).GetCachedSize(), target, stream);
  }

  // .google.protobuf.Int64Value vertical = 4 [(.sensoris.protobuf.types.base.exponent) = 0];
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        4, _Internal::vertical(this),
        _Internal::vertical(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev)
  return target;
}

::size_t PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // .google.protobuf.Int64Value horizontal_ellipse_major = 1 [(.sensoris.protobuf.types.base.exponent) = 0];
    if (cached_has_bits & 0x00000001u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.horizontal_ellipse_major_);
    }

    // .google.protobuf.Int64Value horizontal_ellipse_minor = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
    if (cached_has_bits & 0x00000002u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.horizontal_ellipse_minor_);
    }

    // .google.protobuf.Int64Value horizontal_ellipse_major_heading = 3 [(.sensoris.protobuf.types.base.exponent) = 2];
    if (cached_has_bits & 0x00000004u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.horizontal_ellipse_major_heading_);
    }

    // .google.protobuf.Int64Value vertical = 4 [(.sensoris.protobuf.types.base.exponent) = 0];
    if (cached_has_bits & 0x00000008u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.vertical_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::_class_data_ = {
    PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::GetClassData() const {
  return &_class_data_;
}

void PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev*>(&to_msg);
  auto& from = static_cast<const PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_horizontal_ellipse_major()->::google::protobuf::Int64Value::MergeFrom(
          from._internal_horizontal_ellipse_major());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_horizontal_ellipse_minor()->::google::protobuf::Int64Value::MergeFrom(
          from._internal_horizontal_ellipse_minor());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_horizontal_ellipse_major_heading()->::google::protobuf::Int64Value::MergeFrom(
          from._internal_horizontal_ellipse_major_heading());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_vertical()->::google::protobuf::Int64Value::MergeFrom(
          from._internal_vertical());
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::CopyFrom(const PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::InternalSwap(PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev, _impl_.vertical_)
      + sizeof(PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::_impl_.vertical_)
      - PROTOBUF_FIELD_OFFSET(PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev, _impl_.horizontal_ellipse_major_)>(
          reinterpret_cast<char*>(&_impl_.horizontal_ellipse_major_),
          reinterpret_cast<char*>(&other->_impl_.horizontal_ellipse_major_));
}

::google::protobuf::Metadata PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto_getter, &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto_once,
      file_level_metadata_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto[3]);
}
// ===================================================================

class PositionAndAccuracy::_Internal {
 public:
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::PositionAndAccuracy, _impl_._oneof_case_);
  static const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic& geographic_wgs84(const PositionAndAccuracy* msg);
  static const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric& metric_vehicle(const PositionAndAccuracy* msg);
  static const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric& metric_event_group(const PositionAndAccuracy* msg);
  static const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric& metric_ecef(const PositionAndAccuracy* msg);
  static const ::google::protobuf::Int64Value& combined_std_dev(const PositionAndAccuracy* msg);
  static const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev& std_dev(const PositionAndAccuracy* msg);
  static const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev& horizontal_confidence_ellipse_vertical_std_dev(const PositionAndAccuracy* msg);
  static const ::sensoris::protobuf::types::base::Int64Matrix3x3& covariance(const PositionAndAccuracy* msg);
};

const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic& PositionAndAccuracy::_Internal::geographic_wgs84(const PositionAndAccuracy* msg) {
  return *msg->_impl_.geographic_metric_.geographic_wgs84_;
}
const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric& PositionAndAccuracy::_Internal::metric_vehicle(const PositionAndAccuracy* msg) {
  return *msg->_impl_.geographic_metric_.metric_vehicle_;
}
const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric& PositionAndAccuracy::_Internal::metric_event_group(const PositionAndAccuracy* msg) {
  return *msg->_impl_.geographic_metric_.metric_event_group_;
}
const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric& PositionAndAccuracy::_Internal::metric_ecef(const PositionAndAccuracy* msg) {
  return *msg->_impl_.geographic_metric_.metric_ecef_;
}
const ::google::protobuf::Int64Value& PositionAndAccuracy::_Internal::combined_std_dev(const PositionAndAccuracy* msg) {
  return *msg->_impl_.accuracy_.combined_std_dev_;
}
const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev& PositionAndAccuracy::_Internal::std_dev(const PositionAndAccuracy* msg) {
  return *msg->_impl_.accuracy_.std_dev_;
}
const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev& PositionAndAccuracy::_Internal::horizontal_confidence_ellipse_vertical_std_dev(const PositionAndAccuracy* msg) {
  return *msg->_impl_.accuracy_.horizontal_confidence_ellipse_vertical_std_dev_;
}
const ::sensoris::protobuf::types::base::Int64Matrix3x3& PositionAndAccuracy::_Internal::covariance(const PositionAndAccuracy* msg) {
  return *msg->_impl_.accuracy_.covariance_;
}
void PositionAndAccuracy::set_allocated_geographic_wgs84(::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic* geographic_wgs84) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_geographic_metric();
  if (geographic_wgs84) {
    ::google::protobuf::Arena* submessage_arena = geographic_wgs84->GetArena();
    if (message_arena != submessage_arena) {
      geographic_wgs84 = ::google::protobuf::internal::GetOwnedMessage(message_arena, geographic_wgs84, submessage_arena);
    }
    set_has_geographic_wgs84();
    _impl_.geographic_metric_.geographic_wgs84_ = geographic_wgs84;
  }
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.geographic_wgs84)
}
void PositionAndAccuracy::set_allocated_metric_vehicle(::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* metric_vehicle) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_geographic_metric();
  if (metric_vehicle) {
    ::google::protobuf::Arena* submessage_arena = metric_vehicle->GetArena();
    if (message_arena != submessage_arena) {
      metric_vehicle = ::google::protobuf::internal::GetOwnedMessage(message_arena, metric_vehicle, submessage_arena);
    }
    set_has_metric_vehicle();
    _impl_.geographic_metric_.metric_vehicle_ = metric_vehicle;
  }
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.metric_vehicle)
}
void PositionAndAccuracy::set_allocated_metric_event_group(::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* metric_event_group) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_geographic_metric();
  if (metric_event_group) {
    ::google::protobuf::Arena* submessage_arena = metric_event_group->GetArena();
    if (message_arena != submessage_arena) {
      metric_event_group = ::google::protobuf::internal::GetOwnedMessage(message_arena, metric_event_group, submessage_arena);
    }
    set_has_metric_event_group();
    _impl_.geographic_metric_.metric_event_group_ = metric_event_group;
  }
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.metric_event_group)
}
void PositionAndAccuracy::set_allocated_metric_ecef(::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* metric_ecef) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_geographic_metric();
  if (metric_ecef) {
    ::google::protobuf::Arena* submessage_arena = metric_ecef->GetArena();
    if (message_arena != submessage_arena) {
      metric_ecef = ::google::protobuf::internal::GetOwnedMessage(message_arena, metric_ecef, submessage_arena);
    }
    set_has_metric_ecef();
    _impl_.geographic_metric_.metric_ecef_ = metric_ecef;
  }
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.metric_ecef)
}
void PositionAndAccuracy::set_allocated_combined_std_dev(::google::protobuf::Int64Value* combined_std_dev) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_accuracy();
  if (combined_std_dev) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(combined_std_dev)->GetArena();
    if (message_arena != submessage_arena) {
      combined_std_dev = ::google::protobuf::internal::GetOwnedMessage(message_arena, combined_std_dev, submessage_arena);
    }
    set_has_combined_std_dev();
    _impl_.accuracy_.combined_std_dev_ = combined_std_dev;
  }
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.combined_std_dev)
}
void PositionAndAccuracy::clear_combined_std_dev() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (accuracy_case() == kCombinedStdDev) {
    if (GetArena() == nullptr) {
      delete _impl_.accuracy_.combined_std_dev_;
    }
    clear_has_accuracy();
  }
}
void PositionAndAccuracy::set_allocated_std_dev(::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev* std_dev) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_accuracy();
  if (std_dev) {
    ::google::protobuf::Arena* submessage_arena = std_dev->GetArena();
    if (message_arena != submessage_arena) {
      std_dev = ::google::protobuf::internal::GetOwnedMessage(message_arena, std_dev, submessage_arena);
    }
    set_has_std_dev();
    _impl_.accuracy_.std_dev_ = std_dev;
  }
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.std_dev)
}
void PositionAndAccuracy::set_allocated_horizontal_confidence_ellipse_vertical_std_dev(::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev* horizontal_confidence_ellipse_vertical_std_dev) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_accuracy();
  if (horizontal_confidence_ellipse_vertical_std_dev) {
    ::google::protobuf::Arena* submessage_arena = horizontal_confidence_ellipse_vertical_std_dev->GetArena();
    if (message_arena != submessage_arena) {
      horizontal_confidence_ellipse_vertical_std_dev = ::google::protobuf::internal::GetOwnedMessage(message_arena, horizontal_confidence_ellipse_vertical_std_dev, submessage_arena);
    }
    set_has_horizontal_confidence_ellipse_vertical_std_dev();
    _impl_.accuracy_.horizontal_confidence_ellipse_vertical_std_dev_ = horizontal_confidence_ellipse_vertical_std_dev;
  }
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.horizontal_confidence_ellipse_vertical_std_dev)
}
void PositionAndAccuracy::set_allocated_covariance(::sensoris::protobuf::types::base::Int64Matrix3x3* covariance) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_accuracy();
  if (covariance) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(covariance)->GetArena();
    if (message_arena != submessage_arena) {
      covariance = ::google::protobuf::internal::GetOwnedMessage(message_arena, covariance, submessage_arena);
    }
    set_has_covariance();
    _impl_.accuracy_.covariance_ = covariance;
  }
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.covariance)
}
void PositionAndAccuracy::clear_covariance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (accuracy_case() == kCovariance) {
    if (GetArena() == nullptr) {
      delete _impl_.accuracy_.covariance_;
    }
    clear_has_accuracy();
  }
}
void PositionAndAccuracy::clear_extension() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.extension_.Clear();
}
PositionAndAccuracy::PositionAndAccuracy(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:sensoris.protobuf.types.spatial.PositionAndAccuracy)
}
inline PROTOBUF_NDEBUG_INLINE PositionAndAccuracy::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : extension_{visibility, arena, from.extension_},
        geographic_metric_{},
        accuracy_{},
        _cached_size_{0},
        _oneof_case_{from._oneof_case_[0], from._oneof_case_[1]} {}

PositionAndAccuracy::PositionAndAccuracy(
    ::google::protobuf::Arena* arena,
    const PositionAndAccuracy& from)
    : ::google::protobuf::Message(arena) {
  PositionAndAccuracy* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  switch (geographic_metric_case()) {
    case GEOGRAPHIC_METRIC_NOT_SET:
      break;
      case kGeographicWgs84:
        _impl_.geographic_metric_.geographic_wgs84_ = CreateMaybeMessage<::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic>(arena, *from._impl_.geographic_metric_.geographic_wgs84_);
        break;
      case kMetricVehicle:
        _impl_.geographic_metric_.metric_vehicle_ = CreateMaybeMessage<::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric>(arena, *from._impl_.geographic_metric_.metric_vehicle_);
        break;
      case kMetricEventGroup:
        _impl_.geographic_metric_.metric_event_group_ = CreateMaybeMessage<::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric>(arena, *from._impl_.geographic_metric_.metric_event_group_);
        break;
      case kMetricEcef:
        _impl_.geographic_metric_.metric_ecef_ = CreateMaybeMessage<::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric>(arena, *from._impl_.geographic_metric_.metric_ecef_);
        break;
  }
  switch (accuracy_case()) {
    case ACCURACY_NOT_SET:
      break;
      case kCombinedStdDev:
        _impl_.accuracy_.combined_std_dev_ = CreateMaybeMessage<::google::protobuf::Int64Value>(arena, *from._impl_.accuracy_.combined_std_dev_);
        break;
      case kStdDev:
        _impl_.accuracy_.std_dev_ = CreateMaybeMessage<::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev>(arena, *from._impl_.accuracy_.std_dev_);
        break;
      case kHorizontalConfidenceEllipseVerticalStdDev:
        _impl_.accuracy_.horizontal_confidence_ellipse_vertical_std_dev_ = CreateMaybeMessage<::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev>(arena, *from._impl_.accuracy_.horizontal_confidence_ellipse_vertical_std_dev_);
        break;
      case kCovariance:
        _impl_.accuracy_.covariance_ = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64Matrix3x3>(arena, *from._impl_.accuracy_.covariance_);
        break;
  }

  // @@protoc_insertion_point(copy_constructor:sensoris.protobuf.types.spatial.PositionAndAccuracy)
}
inline PROTOBUF_NDEBUG_INLINE PositionAndAccuracy::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : extension_{visibility, arena},
        geographic_metric_{},
        accuracy_{},
        _cached_size_{0},
        _oneof_case_{} {}

inline void PositionAndAccuracy::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
PositionAndAccuracy::~PositionAndAccuracy() {
  // @@protoc_insertion_point(destructor:sensoris.protobuf.types.spatial.PositionAndAccuracy)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void PositionAndAccuracy::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  if (has_geographic_metric()) {
    clear_geographic_metric();
  }
  if (has_accuracy()) {
    clear_accuracy();
  }
  _impl_.~Impl_();
}

void PositionAndAccuracy::clear_geographic_metric() {
// @@protoc_insertion_point(one_of_clear_start:sensoris.protobuf.types.spatial.PositionAndAccuracy)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  switch (geographic_metric_case()) {
    case kGeographicWgs84: {
      if (GetArena() == nullptr) {
        delete _impl_.geographic_metric_.geographic_wgs84_;
      }
      break;
    }
    case kMetricVehicle: {
      if (GetArena() == nullptr) {
        delete _impl_.geographic_metric_.metric_vehicle_;
      }
      break;
    }
    case kMetricEventGroup: {
      if (GetArena() == nullptr) {
        delete _impl_.geographic_metric_.metric_event_group_;
      }
      break;
    }
    case kMetricEcef: {
      if (GetArena() == nullptr) {
        delete _impl_.geographic_metric_.metric_ecef_;
      }
      break;
    }
    case GEOGRAPHIC_METRIC_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = GEOGRAPHIC_METRIC_NOT_SET;
}

void PositionAndAccuracy::clear_accuracy() {
// @@protoc_insertion_point(one_of_clear_start:sensoris.protobuf.types.spatial.PositionAndAccuracy)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  switch (accuracy_case()) {
    case kCombinedStdDev: {
      if (GetArena() == nullptr) {
        delete _impl_.accuracy_.combined_std_dev_;
      }
      break;
    }
    case kStdDev: {
      if (GetArena() == nullptr) {
        delete _impl_.accuracy_.std_dev_;
      }
      break;
    }
    case kHorizontalConfidenceEllipseVerticalStdDev: {
      if (GetArena() == nullptr) {
        delete _impl_.accuracy_.horizontal_confidence_ellipse_vertical_std_dev_;
      }
      break;
    }
    case kCovariance: {
      if (GetArena() == nullptr) {
        delete _impl_.accuracy_.covariance_;
      }
      break;
    }
    case ACCURACY_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[1] = ACCURACY_NOT_SET;
}


PROTOBUF_NOINLINE void PositionAndAccuracy::Clear() {
// @@protoc_insertion_point(message_clear_start:sensoris.protobuf.types.spatial.PositionAndAccuracy)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.extension_.Clear();
  clear_geographic_metric();
  clear_accuracy();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* PositionAndAccuracy::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 9, 9, 0, 2> PositionAndAccuracy::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    15, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294950656,  // skipmap
    offsetof(decltype(_table_), field_entries),
    9,  // num_field_entries
    9,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_PositionAndAccuracy_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // repeated .google.protobuf.Any extension = 15;
    {::_pbi::TcParser::FastMtR1,
     {122, 63, 8, PROTOBUF_FIELD_OFFSET(PositionAndAccuracy, _impl_.extension_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic geographic_wgs84 = 1;
    {PROTOBUF_FIELD_OFFSET(PositionAndAccuracy, _impl_.geographic_metric_.geographic_wgs84_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric metric_vehicle = 2;
    {PROTOBUF_FIELD_OFFSET(PositionAndAccuracy, _impl_.geographic_metric_.metric_vehicle_), _Internal::kOneofCaseOffset + 0, 1,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric metric_event_group = 3;
    {PROTOBUF_FIELD_OFFSET(PositionAndAccuracy, _impl_.geographic_metric_.metric_event_group_), _Internal::kOneofCaseOffset + 0, 2,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric metric_ecef = 4;
    {PROTOBUF_FIELD_OFFSET(PositionAndAccuracy, _impl_.geographic_metric_.metric_ecef_), _Internal::kOneofCaseOffset + 0, 3,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .google.protobuf.Int64Value combined_std_dev = 5 [(.sensoris.protobuf.types.base.exponent) = 0];
    {PROTOBUF_FIELD_OFFSET(PositionAndAccuracy, _impl_.accuracy_.combined_std_dev_), _Internal::kOneofCaseOffset + 4, 4,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalVerticalStdDev std_dev = 6;
    {PROTOBUF_FIELD_OFFSET(PositionAndAccuracy, _impl_.accuracy_.std_dev_), _Internal::kOneofCaseOffset + 4, 5,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev horizontal_confidence_ellipse_vertical_std_dev = 7;
    {PROTOBUF_FIELD_OFFSET(PositionAndAccuracy, _impl_.accuracy_.horizontal_confidence_ellipse_vertical_std_dev_), _Internal::kOneofCaseOffset + 4, 6,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.base.Int64Matrix3x3 covariance = 8 [(.sensoris.protobuf.types.base.exponent) = 0];
    {PROTOBUF_FIELD_OFFSET(PositionAndAccuracy, _impl_.accuracy_.covariance_), _Internal::kOneofCaseOffset + 4, 7,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .google.protobuf.Any extension = 15;
    {PROTOBUF_FIELD_OFFSET(PositionAndAccuracy, _impl_.extension_), 0, 8,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic>()},
    {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric>()},
    {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric>()},
    {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric>()},
    {::_pbi::TcParser::GetTable<::google::protobuf::Int64Value>()},
    {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev>()},
    {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev>()},
    {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::base::Int64Matrix3x3>()},
    {::_pbi::TcParser::GetTable<::google::protobuf::Any>()},
  }}, {{
  }},
};

::uint8_t* PositionAndAccuracy::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sensoris.protobuf.types.spatial.PositionAndAccuracy)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  switch (geographic_metric_case()) {
    case kGeographicWgs84: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          1, _Internal::geographic_wgs84(this),
          _Internal::geographic_wgs84(this).GetCachedSize(), target, stream);
      break;
    }
    case kMetricVehicle: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          2, _Internal::metric_vehicle(this),
          _Internal::metric_vehicle(this).GetCachedSize(), target, stream);
      break;
    }
    case kMetricEventGroup: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          3, _Internal::metric_event_group(this),
          _Internal::metric_event_group(this).GetCachedSize(), target, stream);
      break;
    }
    case kMetricEcef: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          4, _Internal::metric_ecef(this),
          _Internal::metric_ecef(this).GetCachedSize(), target, stream);
      break;
    }
    default:
      break;
  }
  switch (accuracy_case()) {
    case kCombinedStdDev: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          5, _Internal::combined_std_dev(this),
          _Internal::combined_std_dev(this).GetCachedSize(), target, stream);
      break;
    }
    case kStdDev: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          6, _Internal::std_dev(this),
          _Internal::std_dev(this).GetCachedSize(), target, stream);
      break;
    }
    case kHorizontalConfidenceEllipseVerticalStdDev: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          7, _Internal::horizontal_confidence_ellipse_vertical_std_dev(this),
          _Internal::horizontal_confidence_ellipse_vertical_std_dev(this).GetCachedSize(), target, stream);
      break;
    }
    case kCovariance: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          8, _Internal::covariance(this),
          _Internal::covariance(this).GetCachedSize(), target, stream);
      break;
    }
    default:
      break;
  }
  // repeated .google.protobuf.Any extension = 15;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_extension_size()); i < n; i++) {
    const auto& repfield = this->_internal_extension().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(15, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sensoris.protobuf.types.spatial.PositionAndAccuracy)
  return target;
}

::size_t PositionAndAccuracy::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sensoris.protobuf.types.spatial.PositionAndAccuracy)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .google.protobuf.Any extension = 15;
  total_size += 1UL * this->_internal_extension_size();
  for (const auto& msg : this->_internal_extension()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  switch (geographic_metric_case()) {
    // .sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic geographic_wgs84 = 1;
    case kGeographicWgs84: {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.geographic_metric_.geographic_wgs84_);
      break;
    }
    // .sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric metric_vehicle = 2;
    case kMetricVehicle: {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.geographic_metric_.metric_vehicle_);
      break;
    }
    // .sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric metric_event_group = 3;
    case kMetricEventGroup: {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.geographic_metric_.metric_event_group_);
      break;
    }
    // .sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric metric_ecef = 4;
    case kMetricEcef: {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.geographic_metric_.metric_ecef_);
      break;
    }
    case GEOGRAPHIC_METRIC_NOT_SET: {
      break;
    }
  }
  switch (accuracy_case()) {
    // .google.protobuf.Int64Value combined_std_dev = 5 [(.sensoris.protobuf.types.base.exponent) = 0];
    case kCombinedStdDev: {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.accuracy_.combined_std_dev_);
      break;
    }
    // .sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalVerticalStdDev std_dev = 6;
    case kStdDev: {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.accuracy_.std_dev_);
      break;
    }
    // .sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev horizontal_confidence_ellipse_vertical_std_dev = 7;
    case kHorizontalConfidenceEllipseVerticalStdDev: {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.accuracy_.horizontal_confidence_ellipse_vertical_std_dev_);
      break;
    }
    // .sensoris.protobuf.types.base.Int64Matrix3x3 covariance = 8 [(.sensoris.protobuf.types.base.exponent) = 0];
    case kCovariance: {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.accuracy_.covariance_);
      break;
    }
    case ACCURACY_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData PositionAndAccuracy::_class_data_ = {
    PositionAndAccuracy::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* PositionAndAccuracy::GetClassData() const {
  return &_class_data_;
}

void PositionAndAccuracy::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<PositionAndAccuracy*>(&to_msg);
  auto& from = static_cast<const PositionAndAccuracy&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:sensoris.protobuf.types.spatial.PositionAndAccuracy)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_extension()->MergeFrom(
      from._internal_extension());
  switch (from.geographic_metric_case()) {
    case kGeographicWgs84: {
      _this->_internal_mutable_geographic_wgs84()->::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic::MergeFrom(
          from._internal_geographic_wgs84());
      break;
    }
    case kMetricVehicle: {
      _this->_internal_mutable_metric_vehicle()->::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric::MergeFrom(
          from._internal_metric_vehicle());
      break;
    }
    case kMetricEventGroup: {
      _this->_internal_mutable_metric_event_group()->::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric::MergeFrom(
          from._internal_metric_event_group());
      break;
    }
    case kMetricEcef: {
      _this->_internal_mutable_metric_ecef()->::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric::MergeFrom(
          from._internal_metric_ecef());
      break;
    }
    case GEOGRAPHIC_METRIC_NOT_SET: {
      break;
    }
  }
  switch (from.accuracy_case()) {
    case kCombinedStdDev: {
      _this->_internal_mutable_combined_std_dev()->::google::protobuf::Int64Value::MergeFrom(
          from._internal_combined_std_dev());
      break;
    }
    case kStdDev: {
      _this->_internal_mutable_std_dev()->::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev::MergeFrom(
          from._internal_std_dev());
      break;
    }
    case kHorizontalConfidenceEllipseVerticalStdDev: {
      _this->_internal_mutable_horizontal_confidence_ellipse_vertical_std_dev()->::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::MergeFrom(
          from._internal_horizontal_confidence_ellipse_vertical_std_dev());
      break;
    }
    case kCovariance: {
      _this->_internal_mutable_covariance()->::sensoris::protobuf::types::base::Int64Matrix3x3::MergeFrom(
          from._internal_covariance());
      break;
    }
    case ACCURACY_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void PositionAndAccuracy::CopyFrom(const PositionAndAccuracy& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sensoris.protobuf.types.spatial.PositionAndAccuracy)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool PositionAndAccuracy::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* PositionAndAccuracy::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void PositionAndAccuracy::InternalSwap(PositionAndAccuracy* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.extension_.InternalSwap(&other->_impl_.extension_);
  swap(_impl_.geographic_metric_, other->_impl_.geographic_metric_);
  swap(_impl_.accuracy_, other->_impl_.accuracy_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
  swap(_impl_._oneof_case_[1], other->_impl_._oneof_case_[1]);
}

::google::protobuf::Metadata PositionAndAccuracy::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto_getter, &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto_once,
      file_level_metadata_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto[4]);
}
// ===================================================================

class PolylineAndAccuracy::_Internal {
 public:
};

void PolylineAndAccuracy::clear_extension() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.extension_.Clear();
}
PolylineAndAccuracy::PolylineAndAccuracy(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:sensoris.protobuf.types.spatial.PolylineAndAccuracy)
}
inline PROTOBUF_NDEBUG_INLINE PolylineAndAccuracy::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : position_and_accuracy_{visibility, arena, from.position_and_accuracy_},
        extension_{visibility, arena, from.extension_},
        _cached_size_{0} {}

PolylineAndAccuracy::PolylineAndAccuracy(
    ::google::protobuf::Arena* arena,
    const PolylineAndAccuracy& from)
    : ::google::protobuf::Message(arena) {
  PolylineAndAccuracy* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);

  // @@protoc_insertion_point(copy_constructor:sensoris.protobuf.types.spatial.PolylineAndAccuracy)
}
inline PROTOBUF_NDEBUG_INLINE PolylineAndAccuracy::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : position_and_accuracy_{visibility, arena},
        extension_{visibility, arena},
        _cached_size_{0} {}

inline void PolylineAndAccuracy::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
PolylineAndAccuracy::~PolylineAndAccuracy() {
  // @@protoc_insertion_point(destructor:sensoris.protobuf.types.spatial.PolylineAndAccuracy)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void PolylineAndAccuracy::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void PolylineAndAccuracy::Clear() {
// @@protoc_insertion_point(message_clear_start:sensoris.protobuf.types.spatial.PolylineAndAccuracy)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.position_and_accuracy_.Clear();
  _impl_.extension_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* PolylineAndAccuracy::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 2, 2, 0, 2> PolylineAndAccuracy::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    15, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294950910,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_PolylineAndAccuracy_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // repeated .sensoris.protobuf.types.spatial.PositionAndAccuracy position_and_accuracy = 1;
    {::_pbi::TcParser::FastMtR1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(PolylineAndAccuracy, _impl_.position_and_accuracy_)}},
    {::_pbi::TcParser::MiniParse, {}},
    // repeated .google.protobuf.Any extension = 15;
    {::_pbi::TcParser::FastMtR1,
     {122, 63, 1, PROTOBUF_FIELD_OFFSET(PolylineAndAccuracy, _impl_.extension_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated .sensoris.protobuf.types.spatial.PositionAndAccuracy position_and_accuracy = 1;
    {PROTOBUF_FIELD_OFFSET(PolylineAndAccuracy, _impl_.position_and_accuracy_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .google.protobuf.Any extension = 15;
    {PROTOBUF_FIELD_OFFSET(PolylineAndAccuracy, _impl_.extension_), 0, 1,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::PositionAndAccuracy>()},
    {::_pbi::TcParser::GetTable<::google::protobuf::Any>()},
  }}, {{
  }},
};

::uint8_t* PolylineAndAccuracy::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sensoris.protobuf.types.spatial.PolylineAndAccuracy)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // repeated .sensoris.protobuf.types.spatial.PositionAndAccuracy position_and_accuracy = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_position_and_accuracy_size()); i < n; i++) {
    const auto& repfield = this->_internal_position_and_accuracy().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .google.protobuf.Any extension = 15;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_extension_size()); i < n; i++) {
    const auto& repfield = this->_internal_extension().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(15, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sensoris.protobuf.types.spatial.PolylineAndAccuracy)
  return target;
}

::size_t PolylineAndAccuracy::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sensoris.protobuf.types.spatial.PolylineAndAccuracy)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .sensoris.protobuf.types.spatial.PositionAndAccuracy position_and_accuracy = 1;
  total_size += 1UL * this->_internal_position_and_accuracy_size();
  for (const auto& msg : this->_internal_position_and_accuracy()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated .google.protobuf.Any extension = 15;
  total_size += 1UL * this->_internal_extension_size();
  for (const auto& msg : this->_internal_extension()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData PolylineAndAccuracy::_class_data_ = {
    PolylineAndAccuracy::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* PolylineAndAccuracy::GetClassData() const {
  return &_class_data_;
}

void PolylineAndAccuracy::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<PolylineAndAccuracy*>(&to_msg);
  auto& from = static_cast<const PolylineAndAccuracy&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:sensoris.protobuf.types.spatial.PolylineAndAccuracy)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_position_and_accuracy()->MergeFrom(
      from._internal_position_and_accuracy());
  _this->_internal_mutable_extension()->MergeFrom(
      from._internal_extension());
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void PolylineAndAccuracy::CopyFrom(const PolylineAndAccuracy& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sensoris.protobuf.types.spatial.PolylineAndAccuracy)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool PolylineAndAccuracy::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* PolylineAndAccuracy::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void PolylineAndAccuracy::InternalSwap(PolylineAndAccuracy* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.position_and_accuracy_.InternalSwap(&other->_impl_.position_and_accuracy_);
  _impl_.extension_.InternalSwap(&other->_impl_.extension_);
}

::google::protobuf::Metadata PolylineAndAccuracy::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto_getter, &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto_once,
      file_level_metadata_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto[5]);
}
// ===================================================================

class PolylineCorridorAndAccuracy::_Internal {
 public:
  using HasBits = decltype(std::declval<PolylineCorridorAndAccuracy>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(PolylineCorridorAndAccuracy, _impl_._has_bits_);
  static const ::sensoris::protobuf::types::spatial::PolylineAndAccuracy& center_polyline_and_accuracy(const PolylineCorridorAndAccuracy* msg);
  static void set_has_center_polyline_and_accuracy(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& total_width_and_accuracy(const PolylineCorridorAndAccuracy* msg);
  static void set_has_total_width_and_accuracy(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::sensoris::protobuf::types::spatial::PolylineAndAccuracy& PolylineCorridorAndAccuracy::_Internal::center_polyline_and_accuracy(const PolylineCorridorAndAccuracy* msg) {
  return *msg->_impl_.center_polyline_and_accuracy_;
}
const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& PolylineCorridorAndAccuracy::_Internal::total_width_and_accuracy(const PolylineCorridorAndAccuracy* msg) {
  return *msg->_impl_.total_width_and_accuracy_;
}
void PolylineCorridorAndAccuracy::clear_total_width_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.total_width_and_accuracy_ != nullptr) _impl_.total_width_and_accuracy_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void PolylineCorridorAndAccuracy::clear_extension() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.extension_.Clear();
}
PolylineCorridorAndAccuracy::PolylineCorridorAndAccuracy(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:sensoris.protobuf.types.spatial.PolylineCorridorAndAccuracy)
}
inline PROTOBUF_NDEBUG_INLINE PolylineCorridorAndAccuracy::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        extension_{visibility, arena, from.extension_} {}

PolylineCorridorAndAccuracy::PolylineCorridorAndAccuracy(
    ::google::protobuf::Arena* arena,
    const PolylineCorridorAndAccuracy& from)
    : ::google::protobuf::Message(arena) {
  PolylineCorridorAndAccuracy* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.center_polyline_and_accuracy_ = (cached_has_bits & 0x00000001u)
                ? CreateMaybeMessage<::sensoris::protobuf::types::spatial::PolylineAndAccuracy>(arena, *from._impl_.center_polyline_and_accuracy_)
                : nullptr;
  _impl_.total_width_and_accuracy_ = (cached_has_bits & 0x00000002u)
                ? CreateMaybeMessage<::sensoris::protobuf::types::base::Int64ValueAndAccuracy>(arena, *from._impl_.total_width_and_accuracy_)
                : nullptr;

  // @@protoc_insertion_point(copy_constructor:sensoris.protobuf.types.spatial.PolylineCorridorAndAccuracy)
}
inline PROTOBUF_NDEBUG_INLINE PolylineCorridorAndAccuracy::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        extension_{visibility, arena} {}

inline void PolylineCorridorAndAccuracy::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, center_polyline_and_accuracy_),
           0,
           offsetof(Impl_, total_width_and_accuracy_) -
               offsetof(Impl_, center_polyline_and_accuracy_) +
               sizeof(Impl_::total_width_and_accuracy_));
}
PolylineCorridorAndAccuracy::~PolylineCorridorAndAccuracy() {
  // @@protoc_insertion_point(destructor:sensoris.protobuf.types.spatial.PolylineCorridorAndAccuracy)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void PolylineCorridorAndAccuracy::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  delete _impl_.center_polyline_and_accuracy_;
  delete _impl_.total_width_and_accuracy_;
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void PolylineCorridorAndAccuracy::Clear() {
// @@protoc_insertion_point(message_clear_start:sensoris.protobuf.types.spatial.PolylineCorridorAndAccuracy)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.extension_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.center_polyline_and_accuracy_ != nullptr);
      _impl_.center_polyline_and_accuracy_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.total_width_and_accuracy_ != nullptr);
      _impl_.total_width_and_accuracy_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* PolylineCorridorAndAccuracy::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 3, 0, 2> PolylineCorridorAndAccuracy::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(PolylineCorridorAndAccuracy, _impl_._has_bits_),
    0, // no _extensions_
    15, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294950908,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    3,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_PolylineCorridorAndAccuracy_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // .sensoris.protobuf.types.spatial.PolylineAndAccuracy center_polyline_and_accuracy = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(PolylineCorridorAndAccuracy, _impl_.center_polyline_and_accuracy_)}},
    // .sensoris.protobuf.types.base.Int64ValueAndAccuracy total_width_and_accuracy = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 1, PROTOBUF_FIELD_OFFSET(PolylineCorridorAndAccuracy, _impl_.total_width_and_accuracy_)}},
    // repeated .google.protobuf.Any extension = 15;
    {::_pbi::TcParser::FastMtR1,
     {122, 63, 2, PROTOBUF_FIELD_OFFSET(PolylineCorridorAndAccuracy, _impl_.extension_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .sensoris.protobuf.types.spatial.PolylineAndAccuracy center_polyline_and_accuracy = 1;
    {PROTOBUF_FIELD_OFFSET(PolylineCorridorAndAccuracy, _impl_.center_polyline_and_accuracy_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.base.Int64ValueAndAccuracy total_width_and_accuracy = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
    {PROTOBUF_FIELD_OFFSET(PolylineCorridorAndAccuracy, _impl_.total_width_and_accuracy_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .google.protobuf.Any extension = 15;
    {PROTOBUF_FIELD_OFFSET(PolylineCorridorAndAccuracy, _impl_.extension_), -1, 2,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::PolylineAndAccuracy>()},
    {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::base::Int64ValueAndAccuracy>()},
    {::_pbi::TcParser::GetTable<::google::protobuf::Any>()},
  }}, {{
  }},
};

::uint8_t* PolylineCorridorAndAccuracy::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sensoris.protobuf.types.spatial.PolylineCorridorAndAccuracy)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .sensoris.protobuf.types.spatial.PolylineAndAccuracy center_polyline_and_accuracy = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        1, _Internal::center_polyline_and_accuracy(this),
        _Internal::center_polyline_and_accuracy(this).GetCachedSize(), target, stream);
  }

  // .sensoris.protobuf.types.base.Int64ValueAndAccuracy total_width_and_accuracy = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, _Internal::total_width_and_accuracy(this),
        _Internal::total_width_and_accuracy(this).GetCachedSize(), target, stream);
  }

  // repeated .google.protobuf.Any extension = 15;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_extension_size()); i < n; i++) {
    const auto& repfield = this->_internal_extension().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(15, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sensoris.protobuf.types.spatial.PolylineCorridorAndAccuracy)
  return target;
}

::size_t PolylineCorridorAndAccuracy::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sensoris.protobuf.types.spatial.PolylineCorridorAndAccuracy)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .google.protobuf.Any extension = 15;
  total_size += 1UL * this->_internal_extension_size();
  for (const auto& msg : this->_internal_extension()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // .sensoris.protobuf.types.spatial.PolylineAndAccuracy center_polyline_and_accuracy = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.center_polyline_and_accuracy_);
    }

    // .sensoris.protobuf.types.base.Int64ValueAndAccuracy total_width_and_accuracy = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
    if (cached_has_bits & 0x00000002u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.total_width_and_accuracy_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData PolylineCorridorAndAccuracy::_class_data_ = {
    PolylineCorridorAndAccuracy::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* PolylineCorridorAndAccuracy::GetClassData() const {
  return &_class_data_;
}

void PolylineCorridorAndAccuracy::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<PolylineCorridorAndAccuracy*>(&to_msg);
  auto& from = static_cast<const PolylineCorridorAndAccuracy&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:sensoris.protobuf.types.spatial.PolylineCorridorAndAccuracy)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_extension()->MergeFrom(
      from._internal_extension());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_center_polyline_and_accuracy()->::sensoris::protobuf::types::spatial::PolylineAndAccuracy::MergeFrom(
          from._internal_center_polyline_and_accuracy());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_total_width_and_accuracy()->::sensoris::protobuf::types::base::Int64ValueAndAccuracy::MergeFrom(
          from._internal_total_width_and_accuracy());
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void PolylineCorridorAndAccuracy::CopyFrom(const PolylineCorridorAndAccuracy& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sensoris.protobuf.types.spatial.PolylineCorridorAndAccuracy)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool PolylineCorridorAndAccuracy::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* PolylineCorridorAndAccuracy::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void PolylineCorridorAndAccuracy::InternalSwap(PolylineCorridorAndAccuracy* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.extension_.InternalSwap(&other->_impl_.extension_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PolylineCorridorAndAccuracy, _impl_.total_width_and_accuracy_)
      + sizeof(PolylineCorridorAndAccuracy::_impl_.total_width_and_accuracy_)
      - PROTOBUF_FIELD_OFFSET(PolylineCorridorAndAccuracy, _impl_.center_polyline_and_accuracy_)>(
          reinterpret_cast<char*>(&_impl_.center_polyline_and_accuracy_),
          reinterpret_cast<char*>(&other->_impl_.center_polyline_and_accuracy_));
}

::google::protobuf::Metadata PolylineCorridorAndAccuracy::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto_getter, &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto_once,
      file_level_metadata_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto[6]);
}
// ===================================================================

class DirectedPolylineCorridor::_Internal {
 public:
  using HasBits = decltype(std::declval<DirectedPolylineCorridor>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(DirectedPolylineCorridor, _impl_._has_bits_);
  static const ::sensoris::protobuf::types::spatial::PolylineCorridorAndAccuracy& polyline_corridor(const DirectedPolylineCorridor* msg);
  static void set_has_polyline_corridor(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::google::protobuf::BoolValue& is_bidirectional(const DirectedPolylineCorridor* msg);
  static void set_has_is_bidirectional(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::google::protobuf::Int64Value& heading_deviation_from_center_line(const DirectedPolylineCorridor* msg);
  static void set_has_heading_deviation_from_center_line(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::sensoris::protobuf::types::spatial::PolylineCorridorAndAccuracy& DirectedPolylineCorridor::_Internal::polyline_corridor(const DirectedPolylineCorridor* msg) {
  return *msg->_impl_.polyline_corridor_;
}
const ::google::protobuf::BoolValue& DirectedPolylineCorridor::_Internal::is_bidirectional(const DirectedPolylineCorridor* msg) {
  return *msg->_impl_.is_bidirectional_;
}
const ::google::protobuf::Int64Value& DirectedPolylineCorridor::_Internal::heading_deviation_from_center_line(const DirectedPolylineCorridor* msg) {
  return *msg->_impl_.heading_deviation_from_center_line_;
}
void DirectedPolylineCorridor::clear_is_bidirectional() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.is_bidirectional_ != nullptr) _impl_.is_bidirectional_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void DirectedPolylineCorridor::clear_heading_deviation_from_center_line() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.heading_deviation_from_center_line_ != nullptr) _impl_.heading_deviation_from_center_line_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void DirectedPolylineCorridor::clear_extension() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.extension_.Clear();
}
DirectedPolylineCorridor::DirectedPolylineCorridor(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:sensoris.protobuf.types.spatial.DirectedPolylineCorridor)
}
inline PROTOBUF_NDEBUG_INLINE DirectedPolylineCorridor::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        extension_{visibility, arena, from.extension_} {}

DirectedPolylineCorridor::DirectedPolylineCorridor(
    ::google::protobuf::Arena* arena,
    const DirectedPolylineCorridor& from)
    : ::google::protobuf::Message(arena) {
  DirectedPolylineCorridor* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.polyline_corridor_ = (cached_has_bits & 0x00000001u)
                ? CreateMaybeMessage<::sensoris::protobuf::types::spatial::PolylineCorridorAndAccuracy>(arena, *from._impl_.polyline_corridor_)
                : nullptr;
  _impl_.is_bidirectional_ = (cached_has_bits & 0x00000002u)
                ? CreateMaybeMessage<::google::protobuf::BoolValue>(arena, *from._impl_.is_bidirectional_)
                : nullptr;
  _impl_.heading_deviation_from_center_line_ = (cached_has_bits & 0x00000004u)
                ? CreateMaybeMessage<::google::protobuf::Int64Value>(arena, *from._impl_.heading_deviation_from_center_line_)
                : nullptr;

  // @@protoc_insertion_point(copy_constructor:sensoris.protobuf.types.spatial.DirectedPolylineCorridor)
}
inline PROTOBUF_NDEBUG_INLINE DirectedPolylineCorridor::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        extension_{visibility, arena} {}

inline void DirectedPolylineCorridor::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, polyline_corridor_),
           0,
           offsetof(Impl_, heading_deviation_from_center_line_) -
               offsetof(Impl_, polyline_corridor_) +
               sizeof(Impl_::heading_deviation_from_center_line_));
}
DirectedPolylineCorridor::~DirectedPolylineCorridor() {
  // @@protoc_insertion_point(destructor:sensoris.protobuf.types.spatial.DirectedPolylineCorridor)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void DirectedPolylineCorridor::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  delete _impl_.polyline_corridor_;
  delete _impl_.is_bidirectional_;
  delete _impl_.heading_deviation_from_center_line_;
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void DirectedPolylineCorridor::Clear() {
// @@protoc_insertion_point(message_clear_start:sensoris.protobuf.types.spatial.DirectedPolylineCorridor)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.extension_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.polyline_corridor_ != nullptr);
      _impl_.polyline_corridor_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.is_bidirectional_ != nullptr);
      _impl_.is_bidirectional_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.heading_deviation_from_center_line_ != nullptr);
      _impl_.heading_deviation_from_center_line_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* DirectedPolylineCorridor::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 4, 4, 0, 2> DirectedPolylineCorridor::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(DirectedPolylineCorridor, _impl_._has_bits_),
    0, // no _extensions_
    15, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294950904,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    4,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_DirectedPolylineCorridor_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // .sensoris.protobuf.types.spatial.PolylineCorridorAndAccuracy polyline_corridor = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(DirectedPolylineCorridor, _impl_.polyline_corridor_)}},
    // .google.protobuf.BoolValue is_bidirectional = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 1, PROTOBUF_FIELD_OFFSET(DirectedPolylineCorridor, _impl_.is_bidirectional_)}},
    // .google.protobuf.Int64Value heading_deviation_from_center_line = 3;
    {::_pbi::TcParser::FastMtS1,
     {26, 2, 2, PROTOBUF_FIELD_OFFSET(DirectedPolylineCorridor, _impl_.heading_deviation_from_center_line_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    // repeated .google.protobuf.Any extension = 15;
    {::_pbi::TcParser::FastMtR1,
     {122, 63, 3, PROTOBUF_FIELD_OFFSET(DirectedPolylineCorridor, _impl_.extension_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .sensoris.protobuf.types.spatial.PolylineCorridorAndAccuracy polyline_corridor = 1;
    {PROTOBUF_FIELD_OFFSET(DirectedPolylineCorridor, _impl_.polyline_corridor_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .google.protobuf.BoolValue is_bidirectional = 2;
    {PROTOBUF_FIELD_OFFSET(DirectedPolylineCorridor, _impl_.is_bidirectional_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .google.protobuf.Int64Value heading_deviation_from_center_line = 3;
    {PROTOBUF_FIELD_OFFSET(DirectedPolylineCorridor, _impl_.heading_deviation_from_center_line_), _Internal::kHasBitsOffset + 2, 2,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .google.protobuf.Any extension = 15;
    {PROTOBUF_FIELD_OFFSET(DirectedPolylineCorridor, _impl_.extension_), -1, 3,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::PolylineCorridorAndAccuracy>()},
    {::_pbi::TcParser::GetTable<::google::protobuf::BoolValue>()},
    {::_pbi::TcParser::GetTable<::google::protobuf::Int64Value>()},
    {::_pbi::TcParser::GetTable<::google::protobuf::Any>()},
  }}, {{
  }},
};

::uint8_t* DirectedPolylineCorridor::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sensoris.protobuf.types.spatial.DirectedPolylineCorridor)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .sensoris.protobuf.types.spatial.PolylineCorridorAndAccuracy polyline_corridor = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        1, _Internal::polyline_corridor(this),
        _Internal::polyline_corridor(this).GetCachedSize(), target, stream);
  }

  // .google.protobuf.BoolValue is_bidirectional = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, _Internal::is_bidirectional(this),
        _Internal::is_bidirectional(this).GetCachedSize(), target, stream);
  }

  // .google.protobuf.Int64Value heading_deviation_from_center_line = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        3, _Internal::heading_deviation_from_center_line(this),
        _Internal::heading_deviation_from_center_line(this).GetCachedSize(), target, stream);
  }

  // repeated .google.protobuf.Any extension = 15;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_extension_size()); i < n; i++) {
    const auto& repfield = this->_internal_extension().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(15, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sensoris.protobuf.types.spatial.DirectedPolylineCorridor)
  return target;
}

::size_t DirectedPolylineCorridor::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sensoris.protobuf.types.spatial.DirectedPolylineCorridor)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .google.protobuf.Any extension = 15;
  total_size += 1UL * this->_internal_extension_size();
  for (const auto& msg : this->_internal_extension()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // .sensoris.protobuf.types.spatial.PolylineCorridorAndAccuracy polyline_corridor = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.polyline_corridor_);
    }

    // .google.protobuf.BoolValue is_bidirectional = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.is_bidirectional_);
    }

    // .google.protobuf.Int64Value heading_deviation_from_center_line = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.heading_deviation_from_center_line_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData DirectedPolylineCorridor::_class_data_ = {
    DirectedPolylineCorridor::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* DirectedPolylineCorridor::GetClassData() const {
  return &_class_data_;
}

void DirectedPolylineCorridor::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<DirectedPolylineCorridor*>(&to_msg);
  auto& from = static_cast<const DirectedPolylineCorridor&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:sensoris.protobuf.types.spatial.DirectedPolylineCorridor)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_extension()->MergeFrom(
      from._internal_extension());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_polyline_corridor()->::sensoris::protobuf::types::spatial::PolylineCorridorAndAccuracy::MergeFrom(
          from._internal_polyline_corridor());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_is_bidirectional()->::google::protobuf::BoolValue::MergeFrom(
          from._internal_is_bidirectional());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_heading_deviation_from_center_line()->::google::protobuf::Int64Value::MergeFrom(
          from._internal_heading_deviation_from_center_line());
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void DirectedPolylineCorridor::CopyFrom(const DirectedPolylineCorridor& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sensoris.protobuf.types.spatial.DirectedPolylineCorridor)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool DirectedPolylineCorridor::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* DirectedPolylineCorridor::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void DirectedPolylineCorridor::InternalSwap(DirectedPolylineCorridor* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.extension_.InternalSwap(&other->_impl_.extension_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DirectedPolylineCorridor, _impl_.heading_deviation_from_center_line_)
      + sizeof(DirectedPolylineCorridor::_impl_.heading_deviation_from_center_line_)
      - PROTOBUF_FIELD_OFFSET(DirectedPolylineCorridor, _impl_.polyline_corridor_)>(
          reinterpret_cast<char*>(&_impl_.polyline_corridor_),
          reinterpret_cast<char*>(&other->_impl_.polyline_corridor_));
}

::google::protobuf::Metadata DirectedPolylineCorridor::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto_getter, &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto_once,
      file_level_metadata_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto[7]);
}
// ===================================================================

class CircleAndAccuracy::_Internal {
 public:
  using HasBits = decltype(std::declval<CircleAndAccuracy>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CircleAndAccuracy, _impl_._has_bits_);
  static const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& center_position_and_accuracy(const CircleAndAccuracy* msg);
  static void set_has_center_position_and_accuracy(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& radius_and_accuracy(const CircleAndAccuracy* msg);
  static void set_has_radius_and_accuracy(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& CircleAndAccuracy::_Internal::center_position_and_accuracy(const CircleAndAccuracy* msg) {
  return *msg->_impl_.center_position_and_accuracy_;
}
const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& CircleAndAccuracy::_Internal::radius_and_accuracy(const CircleAndAccuracy* msg) {
  return *msg->_impl_.radius_and_accuracy_;
}
void CircleAndAccuracy::clear_radius_and_accuracy() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.radius_and_accuracy_ != nullptr) _impl_.radius_and_accuracy_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CircleAndAccuracy::clear_extension() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.extension_.Clear();
}
CircleAndAccuracy::CircleAndAccuracy(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:sensoris.protobuf.types.spatial.CircleAndAccuracy)
}
inline PROTOBUF_NDEBUG_INLINE CircleAndAccuracy::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        extension_{visibility, arena, from.extension_} {}

CircleAndAccuracy::CircleAndAccuracy(
    ::google::protobuf::Arena* arena,
    const CircleAndAccuracy& from)
    : ::google::protobuf::Message(arena) {
  CircleAndAccuracy* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.center_position_and_accuracy_ = (cached_has_bits & 0x00000001u)
                ? CreateMaybeMessage<::sensoris::protobuf::types::spatial::PositionAndAccuracy>(arena, *from._impl_.center_position_and_accuracy_)
                : nullptr;
  _impl_.radius_and_accuracy_ = (cached_has_bits & 0x00000002u)
                ? CreateMaybeMessage<::sensoris::protobuf::types::base::Int64ValueAndAccuracy>(arena, *from._impl_.radius_and_accuracy_)
                : nullptr;

  // @@protoc_insertion_point(copy_constructor:sensoris.protobuf.types.spatial.CircleAndAccuracy)
}
inline PROTOBUF_NDEBUG_INLINE CircleAndAccuracy::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        extension_{visibility, arena} {}

inline void CircleAndAccuracy::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, center_position_and_accuracy_),
           0,
           offsetof(Impl_, radius_and_accuracy_) -
               offsetof(Impl_, center_position_and_accuracy_) +
               sizeof(Impl_::radius_and_accuracy_));
}
CircleAndAccuracy::~CircleAndAccuracy() {
  // @@protoc_insertion_point(destructor:sensoris.protobuf.types.spatial.CircleAndAccuracy)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void CircleAndAccuracy::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  delete _impl_.center_position_and_accuracy_;
  delete _impl_.radius_and_accuracy_;
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void CircleAndAccuracy::Clear() {
// @@protoc_insertion_point(message_clear_start:sensoris.protobuf.types.spatial.CircleAndAccuracy)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.extension_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.center_position_and_accuracy_ != nullptr);
      _impl_.center_position_and_accuracy_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.radius_and_accuracy_ != nullptr);
      _impl_.radius_and_accuracy_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* CircleAndAccuracy::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 3, 0, 2> CircleAndAccuracy::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CircleAndAccuracy, _impl_._has_bits_),
    0, // no _extensions_
    15, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294950908,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    3,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_CircleAndAccuracy_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // .sensoris.protobuf.types.spatial.PositionAndAccuracy center_position_and_accuracy = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(CircleAndAccuracy, _impl_.center_position_and_accuracy_)}},
    // .sensoris.protobuf.types.base.Int64ValueAndAccuracy radius_and_accuracy = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 1, PROTOBUF_FIELD_OFFSET(CircleAndAccuracy, _impl_.radius_and_accuracy_)}},
    // repeated .google.protobuf.Any extension = 15;
    {::_pbi::TcParser::FastMtR1,
     {122, 63, 2, PROTOBUF_FIELD_OFFSET(CircleAndAccuracy, _impl_.extension_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .sensoris.protobuf.types.spatial.PositionAndAccuracy center_position_and_accuracy = 1;
    {PROTOBUF_FIELD_OFFSET(CircleAndAccuracy, _impl_.center_position_and_accuracy_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.base.Int64ValueAndAccuracy radius_and_accuracy = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
    {PROTOBUF_FIELD_OFFSET(CircleAndAccuracy, _impl_.radius_and_accuracy_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .google.protobuf.Any extension = 15;
    {PROTOBUF_FIELD_OFFSET(CircleAndAccuracy, _impl_.extension_), -1, 2,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::PositionAndAccuracy>()},
    {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::base::Int64ValueAndAccuracy>()},
    {::_pbi::TcParser::GetTable<::google::protobuf::Any>()},
  }}, {{
  }},
};

::uint8_t* CircleAndAccuracy::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sensoris.protobuf.types.spatial.CircleAndAccuracy)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .sensoris.protobuf.types.spatial.PositionAndAccuracy center_position_and_accuracy = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        1, _Internal::center_position_and_accuracy(this),
        _Internal::center_position_and_accuracy(this).GetCachedSize(), target, stream);
  }

  // .sensoris.protobuf.types.base.Int64ValueAndAccuracy radius_and_accuracy = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, _Internal::radius_and_accuracy(this),
        _Internal::radius_and_accuracy(this).GetCachedSize(), target, stream);
  }

  // repeated .google.protobuf.Any extension = 15;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_extension_size()); i < n; i++) {
    const auto& repfield = this->_internal_extension().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(15, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sensoris.protobuf.types.spatial.CircleAndAccuracy)
  return target;
}

::size_t CircleAndAccuracy::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sensoris.protobuf.types.spatial.CircleAndAccuracy)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .google.protobuf.Any extension = 15;
  total_size += 1UL * this->_internal_extension_size();
  for (const auto& msg : this->_internal_extension()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // .sensoris.protobuf.types.spatial.PositionAndAccuracy center_position_and_accuracy = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.center_position_and_accuracy_);
    }

    // .sensoris.protobuf.types.base.Int64ValueAndAccuracy radius_and_accuracy = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
    if (cached_has_bits & 0x00000002u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.radius_and_accuracy_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData CircleAndAccuracy::_class_data_ = {
    CircleAndAccuracy::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* CircleAndAccuracy::GetClassData() const {
  return &_class_data_;
}

void CircleAndAccuracy::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<CircleAndAccuracy*>(&to_msg);
  auto& from = static_cast<const CircleAndAccuracy&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:sensoris.protobuf.types.spatial.CircleAndAccuracy)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_extension()->MergeFrom(
      from._internal_extension());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_center_position_and_accuracy()->::sensoris::protobuf::types::spatial::PositionAndAccuracy::MergeFrom(
          from._internal_center_position_and_accuracy());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_radius_and_accuracy()->::sensoris::protobuf::types::base::Int64ValueAndAccuracy::MergeFrom(
          from._internal_radius_and_accuracy());
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void CircleAndAccuracy::CopyFrom(const CircleAndAccuracy& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sensoris.protobuf.types.spatial.CircleAndAccuracy)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CircleAndAccuracy::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* CircleAndAccuracy::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void CircleAndAccuracy::InternalSwap(CircleAndAccuracy* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.extension_.InternalSwap(&other->_impl_.extension_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CircleAndAccuracy, _impl_.radius_and_accuracy_)
      + sizeof(CircleAndAccuracy::_impl_.radius_and_accuracy_)
      - PROTOBUF_FIELD_OFFSET(CircleAndAccuracy, _impl_.center_position_and_accuracy_)>(
          reinterpret_cast<char*>(&_impl_.center_position_and_accuracy_),
          reinterpret_cast<char*>(&other->_impl_.center_position_and_accuracy_));
}

::google::protobuf::Metadata CircleAndAccuracy::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto_getter, &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto_once,
      file_level_metadata_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto[8]);
}
// ===================================================================

class RectangleAndAccuracy::_Internal {
 public:
  using HasBits = decltype(std::declval<RectangleAndAccuracy>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(RectangleAndAccuracy, _impl_._has_bits_);
  static const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& minimum_position_and_accuracy(const RectangleAndAccuracy* msg);
  static void set_has_minimum_position_and_accuracy(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& maximum_position_and_accuracy(const RectangleAndAccuracy* msg);
  static void set_has_maximum_position_and_accuracy(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& RectangleAndAccuracy::_Internal::minimum_position_and_accuracy(const RectangleAndAccuracy* msg) {
  return *msg->_impl_.minimum_position_and_accuracy_;
}
const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& RectangleAndAccuracy::_Internal::maximum_position_and_accuracy(const RectangleAndAccuracy* msg) {
  return *msg->_impl_.maximum_position_and_accuracy_;
}
void RectangleAndAccuracy::clear_extension() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.extension_.Clear();
}
RectangleAndAccuracy::RectangleAndAccuracy(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:sensoris.protobuf.types.spatial.RectangleAndAccuracy)
}
inline PROTOBUF_NDEBUG_INLINE RectangleAndAccuracy::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        extension_{visibility, arena, from.extension_} {}

RectangleAndAccuracy::RectangleAndAccuracy(
    ::google::protobuf::Arena* arena,
    const RectangleAndAccuracy& from)
    : ::google::protobuf::Message(arena) {
  RectangleAndAccuracy* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.minimum_position_and_accuracy_ = (cached_has_bits & 0x00000001u)
                ? CreateMaybeMessage<::sensoris::protobuf::types::spatial::PositionAndAccuracy>(arena, *from._impl_.minimum_position_and_accuracy_)
                : nullptr;
  _impl_.maximum_position_and_accuracy_ = (cached_has_bits & 0x00000002u)
                ? CreateMaybeMessage<::sensoris::protobuf::types::spatial::PositionAndAccuracy>(arena, *from._impl_.maximum_position_and_accuracy_)
                : nullptr;

  // @@protoc_insertion_point(copy_constructor:sensoris.protobuf.types.spatial.RectangleAndAccuracy)
}
inline PROTOBUF_NDEBUG_INLINE RectangleAndAccuracy::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        extension_{visibility, arena} {}

inline void RectangleAndAccuracy::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, minimum_position_and_accuracy_),
           0,
           offsetof(Impl_, maximum_position_and_accuracy_) -
               offsetof(Impl_, minimum_position_and_accuracy_) +
               sizeof(Impl_::maximum_position_and_accuracy_));
}
RectangleAndAccuracy::~RectangleAndAccuracy() {
  // @@protoc_insertion_point(destructor:sensoris.protobuf.types.spatial.RectangleAndAccuracy)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void RectangleAndAccuracy::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  delete _impl_.minimum_position_and_accuracy_;
  delete _impl_.maximum_position_and_accuracy_;
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void RectangleAndAccuracy::Clear() {
// @@protoc_insertion_point(message_clear_start:sensoris.protobuf.types.spatial.RectangleAndAccuracy)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.extension_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.minimum_position_and_accuracy_ != nullptr);
      _impl_.minimum_position_and_accuracy_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.maximum_position_and_accuracy_ != nullptr);
      _impl_.maximum_position_and_accuracy_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* RectangleAndAccuracy::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 3, 0, 2> RectangleAndAccuracy::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(RectangleAndAccuracy, _impl_._has_bits_),
    0, // no _extensions_
    15, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294950908,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    3,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_RectangleAndAccuracy_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // .sensoris.protobuf.types.spatial.PositionAndAccuracy minimum_position_and_accuracy = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(RectangleAndAccuracy, _impl_.minimum_position_and_accuracy_)}},
    // .sensoris.protobuf.types.spatial.PositionAndAccuracy maximum_position_and_accuracy = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 1, PROTOBUF_FIELD_OFFSET(RectangleAndAccuracy, _impl_.maximum_position_and_accuracy_)}},
    // repeated .google.protobuf.Any extension = 15;
    {::_pbi::TcParser::FastMtR1,
     {122, 63, 2, PROTOBUF_FIELD_OFFSET(RectangleAndAccuracy, _impl_.extension_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .sensoris.protobuf.types.spatial.PositionAndAccuracy minimum_position_and_accuracy = 1;
    {PROTOBUF_FIELD_OFFSET(RectangleAndAccuracy, _impl_.minimum_position_and_accuracy_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.spatial.PositionAndAccuracy maximum_position_and_accuracy = 2;
    {PROTOBUF_FIELD_OFFSET(RectangleAndAccuracy, _impl_.maximum_position_and_accuracy_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .google.protobuf.Any extension = 15;
    {PROTOBUF_FIELD_OFFSET(RectangleAndAccuracy, _impl_.extension_), -1, 2,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::PositionAndAccuracy>()},
    {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::PositionAndAccuracy>()},
    {::_pbi::TcParser::GetTable<::google::protobuf::Any>()},
  }}, {{
  }},
};

::uint8_t* RectangleAndAccuracy::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sensoris.protobuf.types.spatial.RectangleAndAccuracy)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .sensoris.protobuf.types.spatial.PositionAndAccuracy minimum_position_and_accuracy = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        1, _Internal::minimum_position_and_accuracy(this),
        _Internal::minimum_position_and_accuracy(this).GetCachedSize(), target, stream);
  }

  // .sensoris.protobuf.types.spatial.PositionAndAccuracy maximum_position_and_accuracy = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, _Internal::maximum_position_and_accuracy(this),
        _Internal::maximum_position_and_accuracy(this).GetCachedSize(), target, stream);
  }

  // repeated .google.protobuf.Any extension = 15;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_extension_size()); i < n; i++) {
    const auto& repfield = this->_internal_extension().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(15, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sensoris.protobuf.types.spatial.RectangleAndAccuracy)
  return target;
}

::size_t RectangleAndAccuracy::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sensoris.protobuf.types.spatial.RectangleAndAccuracy)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .google.protobuf.Any extension = 15;
  total_size += 1UL * this->_internal_extension_size();
  for (const auto& msg : this->_internal_extension()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // .sensoris.protobuf.types.spatial.PositionAndAccuracy minimum_position_and_accuracy = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.minimum_position_and_accuracy_);
    }

    // .sensoris.protobuf.types.spatial.PositionAndAccuracy maximum_position_and_accuracy = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.maximum_position_and_accuracy_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData RectangleAndAccuracy::_class_data_ = {
    RectangleAndAccuracy::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* RectangleAndAccuracy::GetClassData() const {
  return &_class_data_;
}

void RectangleAndAccuracy::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<RectangleAndAccuracy*>(&to_msg);
  auto& from = static_cast<const RectangleAndAccuracy&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:sensoris.protobuf.types.spatial.RectangleAndAccuracy)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_extension()->MergeFrom(
      from._internal_extension());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_minimum_position_and_accuracy()->::sensoris::protobuf::types::spatial::PositionAndAccuracy::MergeFrom(
          from._internal_minimum_position_and_accuracy());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_maximum_position_and_accuracy()->::sensoris::protobuf::types::spatial::PositionAndAccuracy::MergeFrom(
          from._internal_maximum_position_and_accuracy());
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void RectangleAndAccuracy::CopyFrom(const RectangleAndAccuracy& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sensoris.protobuf.types.spatial.RectangleAndAccuracy)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool RectangleAndAccuracy::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* RectangleAndAccuracy::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void RectangleAndAccuracy::InternalSwap(RectangleAndAccuracy* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.extension_.InternalSwap(&other->_impl_.extension_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RectangleAndAccuracy, _impl_.maximum_position_and_accuracy_)
      + sizeof(RectangleAndAccuracy::_impl_.maximum_position_and_accuracy_)
      - PROTOBUF_FIELD_OFFSET(RectangleAndAccuracy, _impl_.minimum_position_and_accuracy_)>(
          reinterpret_cast<char*>(&_impl_.minimum_position_and_accuracy_),
          reinterpret_cast<char*>(&other->_impl_.minimum_position_and_accuracy_));
}

::google::protobuf::Metadata RectangleAndAccuracy::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto_getter, &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto_once,
      file_level_metadata_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto[9]);
}
// ===================================================================

class PolygonAndAccuracy::_Internal {
 public:
};

void PolygonAndAccuracy::clear_extension() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.extension_.Clear();
}
PolygonAndAccuracy::PolygonAndAccuracy(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:sensoris.protobuf.types.spatial.PolygonAndAccuracy)
}
inline PROTOBUF_NDEBUG_INLINE PolygonAndAccuracy::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : position_and_accuracy_{visibility, arena, from.position_and_accuracy_},
        extension_{visibility, arena, from.extension_},
        _cached_size_{0} {}

PolygonAndAccuracy::PolygonAndAccuracy(
    ::google::protobuf::Arena* arena,
    const PolygonAndAccuracy& from)
    : ::google::protobuf::Message(arena) {
  PolygonAndAccuracy* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);

  // @@protoc_insertion_point(copy_constructor:sensoris.protobuf.types.spatial.PolygonAndAccuracy)
}
inline PROTOBUF_NDEBUG_INLINE PolygonAndAccuracy::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : position_and_accuracy_{visibility, arena},
        extension_{visibility, arena},
        _cached_size_{0} {}

inline void PolygonAndAccuracy::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
PolygonAndAccuracy::~PolygonAndAccuracy() {
  // @@protoc_insertion_point(destructor:sensoris.protobuf.types.spatial.PolygonAndAccuracy)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void PolygonAndAccuracy::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void PolygonAndAccuracy::Clear() {
// @@protoc_insertion_point(message_clear_start:sensoris.protobuf.types.spatial.PolygonAndAccuracy)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.position_and_accuracy_.Clear();
  _impl_.extension_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* PolygonAndAccuracy::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 2, 2, 0, 2> PolygonAndAccuracy::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    15, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294950910,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_PolygonAndAccuracy_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // repeated .sensoris.protobuf.types.spatial.PositionAndAccuracy position_and_accuracy = 1;
    {::_pbi::TcParser::FastMtR1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(PolygonAndAccuracy, _impl_.position_and_accuracy_)}},
    {::_pbi::TcParser::MiniParse, {}},
    // repeated .google.protobuf.Any extension = 15;
    {::_pbi::TcParser::FastMtR1,
     {122, 63, 1, PROTOBUF_FIELD_OFFSET(PolygonAndAccuracy, _impl_.extension_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated .sensoris.protobuf.types.spatial.PositionAndAccuracy position_and_accuracy = 1;
    {PROTOBUF_FIELD_OFFSET(PolygonAndAccuracy, _impl_.position_and_accuracy_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .google.protobuf.Any extension = 15;
    {PROTOBUF_FIELD_OFFSET(PolygonAndAccuracy, _impl_.extension_), 0, 1,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::PositionAndAccuracy>()},
    {::_pbi::TcParser::GetTable<::google::protobuf::Any>()},
  }}, {{
  }},
};

::uint8_t* PolygonAndAccuracy::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sensoris.protobuf.types.spatial.PolygonAndAccuracy)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // repeated .sensoris.protobuf.types.spatial.PositionAndAccuracy position_and_accuracy = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_position_and_accuracy_size()); i < n; i++) {
    const auto& repfield = this->_internal_position_and_accuracy().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .google.protobuf.Any extension = 15;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_extension_size()); i < n; i++) {
    const auto& repfield = this->_internal_extension().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(15, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sensoris.protobuf.types.spatial.PolygonAndAccuracy)
  return target;
}

::size_t PolygonAndAccuracy::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sensoris.protobuf.types.spatial.PolygonAndAccuracy)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .sensoris.protobuf.types.spatial.PositionAndAccuracy position_and_accuracy = 1;
  total_size += 1UL * this->_internal_position_and_accuracy_size();
  for (const auto& msg : this->_internal_position_and_accuracy()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated .google.protobuf.Any extension = 15;
  total_size += 1UL * this->_internal_extension_size();
  for (const auto& msg : this->_internal_extension()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData PolygonAndAccuracy::_class_data_ = {
    PolygonAndAccuracy::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* PolygonAndAccuracy::GetClassData() const {
  return &_class_data_;
}

void PolygonAndAccuracy::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<PolygonAndAccuracy*>(&to_msg);
  auto& from = static_cast<const PolygonAndAccuracy&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:sensoris.protobuf.types.spatial.PolygonAndAccuracy)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_position_and_accuracy()->MergeFrom(
      from._internal_position_and_accuracy());
  _this->_internal_mutable_extension()->MergeFrom(
      from._internal_extension());
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void PolygonAndAccuracy::CopyFrom(const PolygonAndAccuracy& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sensoris.protobuf.types.spatial.PolygonAndAccuracy)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool PolygonAndAccuracy::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* PolygonAndAccuracy::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void PolygonAndAccuracy::InternalSwap(PolygonAndAccuracy* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.position_and_accuracy_.InternalSwap(&other->_impl_.position_and_accuracy_);
  _impl_.extension_.InternalSwap(&other->_impl_.extension_);
}

::google::protobuf::Metadata PolygonAndAccuracy::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto_getter, &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto_once,
      file_level_metadata_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto[10]);
}
// ===================================================================

class XyzVectorAndAccuracy_StdDev::_Internal {
 public:
  using HasBits = decltype(std::declval<XyzVectorAndAccuracy_StdDev>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(XyzVectorAndAccuracy_StdDev, _impl_._has_bits_);
  static const ::google::protobuf::Int64Value& x(const XyzVectorAndAccuracy_StdDev* msg);
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::google::protobuf::Int64Value& y(const XyzVectorAndAccuracy_StdDev* msg);
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::google::protobuf::Int64Value& z(const XyzVectorAndAccuracy_StdDev* msg);
  static void set_has_z(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::google::protobuf::Int64Value& XyzVectorAndAccuracy_StdDev::_Internal::x(const XyzVectorAndAccuracy_StdDev* msg) {
  return *msg->_impl_.x_;
}
const ::google::protobuf::Int64Value& XyzVectorAndAccuracy_StdDev::_Internal::y(const XyzVectorAndAccuracy_StdDev* msg) {
  return *msg->_impl_.y_;
}
const ::google::protobuf::Int64Value& XyzVectorAndAccuracy_StdDev::_Internal::z(const XyzVectorAndAccuracy_StdDev* msg) {
  return *msg->_impl_.z_;
}
void XyzVectorAndAccuracy_StdDev::clear_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.x_ != nullptr) _impl_.x_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void XyzVectorAndAccuracy_StdDev::clear_y() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.y_ != nullptr) _impl_.y_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void XyzVectorAndAccuracy_StdDev::clear_z() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.z_ != nullptr) _impl_.z_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
XyzVectorAndAccuracy_StdDev::XyzVectorAndAccuracy_StdDev(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev)
}
inline PROTOBUF_NDEBUG_INLINE XyzVectorAndAccuracy_StdDev::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

XyzVectorAndAccuracy_StdDev::XyzVectorAndAccuracy_StdDev(
    ::google::protobuf::Arena* arena,
    const XyzVectorAndAccuracy_StdDev& from)
    : ::google::protobuf::Message(arena) {
  XyzVectorAndAccuracy_StdDev* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.x_ = (cached_has_bits & 0x00000001u)
                ? CreateMaybeMessage<::google::protobuf::Int64Value>(arena, *from._impl_.x_)
                : nullptr;
  _impl_.y_ = (cached_has_bits & 0x00000002u)
                ? CreateMaybeMessage<::google::protobuf::Int64Value>(arena, *from._impl_.y_)
                : nullptr;
  _impl_.z_ = (cached_has_bits & 0x00000004u)
                ? CreateMaybeMessage<::google::protobuf::Int64Value>(arena, *from._impl_.z_)
                : nullptr;

  // @@protoc_insertion_point(copy_constructor:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev)
}
inline PROTOBUF_NDEBUG_INLINE XyzVectorAndAccuracy_StdDev::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void XyzVectorAndAccuracy_StdDev::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, x_),
           0,
           offsetof(Impl_, z_) -
               offsetof(Impl_, x_) +
               sizeof(Impl_::z_));
}
XyzVectorAndAccuracy_StdDev::~XyzVectorAndAccuracy_StdDev() {
  // @@protoc_insertion_point(destructor:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void XyzVectorAndAccuracy_StdDev::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  delete _impl_.x_;
  delete _impl_.y_;
  delete _impl_.z_;
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void XyzVectorAndAccuracy_StdDev::Clear() {
// @@protoc_insertion_point(message_clear_start:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.x_ != nullptr);
      _impl_.x_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.y_ != nullptr);
      _impl_.y_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.z_ != nullptr);
      _impl_.z_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* XyzVectorAndAccuracy_StdDev::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 3, 0, 2> XyzVectorAndAccuracy_StdDev::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(XyzVectorAndAccuracy_StdDev, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    3,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_XyzVectorAndAccuracy_StdDev_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // .google.protobuf.Int64Value x = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(XyzVectorAndAccuracy_StdDev, _impl_.x_)}},
    // .google.protobuf.Int64Value y = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 1, PROTOBUF_FIELD_OFFSET(XyzVectorAndAccuracy_StdDev, _impl_.y_)}},
    // .google.protobuf.Int64Value z = 3;
    {::_pbi::TcParser::FastMtS1,
     {26, 2, 2, PROTOBUF_FIELD_OFFSET(XyzVectorAndAccuracy_StdDev, _impl_.z_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .google.protobuf.Int64Value x = 1;
    {PROTOBUF_FIELD_OFFSET(XyzVectorAndAccuracy_StdDev, _impl_.x_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .google.protobuf.Int64Value y = 2;
    {PROTOBUF_FIELD_OFFSET(XyzVectorAndAccuracy_StdDev, _impl_.y_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .google.protobuf.Int64Value z = 3;
    {PROTOBUF_FIELD_OFFSET(XyzVectorAndAccuracy_StdDev, _impl_.z_), _Internal::kHasBitsOffset + 2, 2,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::google::protobuf::Int64Value>()},
    {::_pbi::TcParser::GetTable<::google::protobuf::Int64Value>()},
    {::_pbi::TcParser::GetTable<::google::protobuf::Int64Value>()},
  }}, {{
  }},
};

::uint8_t* XyzVectorAndAccuracy_StdDev::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .google.protobuf.Int64Value x = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        1, _Internal::x(this),
        _Internal::x(this).GetCachedSize(), target, stream);
  }

  // .google.protobuf.Int64Value y = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, _Internal::y(this),
        _Internal::y(this).GetCachedSize(), target, stream);
  }

  // .google.protobuf.Int64Value z = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        3, _Internal::z(this),
        _Internal::z(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev)
  return target;
}

::size_t XyzVectorAndAccuracy_StdDev::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // .google.protobuf.Int64Value x = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.x_);
    }

    // .google.protobuf.Int64Value y = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.y_);
    }

    // .google.protobuf.Int64Value z = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.z_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData XyzVectorAndAccuracy_StdDev::_class_data_ = {
    XyzVectorAndAccuracy_StdDev::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* XyzVectorAndAccuracy_StdDev::GetClassData() const {
  return &_class_data_;
}

void XyzVectorAndAccuracy_StdDev::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<XyzVectorAndAccuracy_StdDev*>(&to_msg);
  auto& from = static_cast<const XyzVectorAndAccuracy_StdDev&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_x()->::google::protobuf::Int64Value::MergeFrom(
          from._internal_x());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_y()->::google::protobuf::Int64Value::MergeFrom(
          from._internal_y());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_z()->::google::protobuf::Int64Value::MergeFrom(
          from._internal_z());
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void XyzVectorAndAccuracy_StdDev::CopyFrom(const XyzVectorAndAccuracy_StdDev& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool XyzVectorAndAccuracy_StdDev::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* XyzVectorAndAccuracy_StdDev::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void XyzVectorAndAccuracy_StdDev::InternalSwap(XyzVectorAndAccuracy_StdDev* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(XyzVectorAndAccuracy_StdDev, _impl_.z_)
      + sizeof(XyzVectorAndAccuracy_StdDev::_impl_.z_)
      - PROTOBUF_FIELD_OFFSET(XyzVectorAndAccuracy_StdDev, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::google::protobuf::Metadata XyzVectorAndAccuracy_StdDev::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto_getter, &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto_once,
      file_level_metadata_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto[11]);
}
// ===================================================================

class XyzVectorAndAccuracy_Metric::_Internal {
 public:
  using HasBits = decltype(std::declval<XyzVectorAndAccuracy_Metric>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(XyzVectorAndAccuracy_Metric, _impl_._has_bits_);
  static const ::sensoris::protobuf::types::base::Int64Value& x(const XyzVectorAndAccuracy_Metric* msg);
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::sensoris::protobuf::types::base::Int64Value& y(const XyzVectorAndAccuracy_Metric* msg);
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::sensoris::protobuf::types::base::Int64Value& z(const XyzVectorAndAccuracy_Metric* msg);
  static void set_has_z(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::sensoris::protobuf::types::base::Int64Value& XyzVectorAndAccuracy_Metric::_Internal::x(const XyzVectorAndAccuracy_Metric* msg) {
  return *msg->_impl_.x_;
}
const ::sensoris::protobuf::types::base::Int64Value& XyzVectorAndAccuracy_Metric::_Internal::y(const XyzVectorAndAccuracy_Metric* msg) {
  return *msg->_impl_.y_;
}
const ::sensoris::protobuf::types::base::Int64Value& XyzVectorAndAccuracy_Metric::_Internal::z(const XyzVectorAndAccuracy_Metric* msg) {
  return *msg->_impl_.z_;
}
void XyzVectorAndAccuracy_Metric::clear_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.x_ != nullptr) _impl_.x_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void XyzVectorAndAccuracy_Metric::clear_y() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.y_ != nullptr) _impl_.y_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void XyzVectorAndAccuracy_Metric::clear_z() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.z_ != nullptr) _impl_.z_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
XyzVectorAndAccuracy_Metric::XyzVectorAndAccuracy_Metric(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric)
}
inline PROTOBUF_NDEBUG_INLINE XyzVectorAndAccuracy_Metric::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

XyzVectorAndAccuracy_Metric::XyzVectorAndAccuracy_Metric(
    ::google::protobuf::Arena* arena,
    const XyzVectorAndAccuracy_Metric& from)
    : ::google::protobuf::Message(arena) {
  XyzVectorAndAccuracy_Metric* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.x_ = (cached_has_bits & 0x00000001u)
                ? CreateMaybeMessage<::sensoris::protobuf::types::base::Int64Value>(arena, *from._impl_.x_)
                : nullptr;
  _impl_.y_ = (cached_has_bits & 0x00000002u)
                ? CreateMaybeMessage<::sensoris::protobuf::types::base::Int64Value>(arena, *from._impl_.y_)
                : nullptr;
  _impl_.z_ = (cached_has_bits & 0x00000004u)
                ? CreateMaybeMessage<::sensoris::protobuf::types::base::Int64Value>(arena, *from._impl_.z_)
                : nullptr;

  // @@protoc_insertion_point(copy_constructor:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric)
}
inline PROTOBUF_NDEBUG_INLINE XyzVectorAndAccuracy_Metric::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void XyzVectorAndAccuracy_Metric::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, x_),
           0,
           offsetof(Impl_, z_) -
               offsetof(Impl_, x_) +
               sizeof(Impl_::z_));
}
XyzVectorAndAccuracy_Metric::~XyzVectorAndAccuracy_Metric() {
  // @@protoc_insertion_point(destructor:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void XyzVectorAndAccuracy_Metric::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  delete _impl_.x_;
  delete _impl_.y_;
  delete _impl_.z_;
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void XyzVectorAndAccuracy_Metric::Clear() {
// @@protoc_insertion_point(message_clear_start:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.x_ != nullptr);
      _impl_.x_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.y_ != nullptr);
      _impl_.y_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.z_ != nullptr);
      _impl_.z_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* XyzVectorAndAccuracy_Metric::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 3, 0, 2> XyzVectorAndAccuracy_Metric::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(XyzVectorAndAccuracy_Metric, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    3,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_XyzVectorAndAccuracy_Metric_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // .sensoris.protobuf.types.base.Int64Value x = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(XyzVectorAndAccuracy_Metric, _impl_.x_)}},
    // .sensoris.protobuf.types.base.Int64Value y = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 1, PROTOBUF_FIELD_OFFSET(XyzVectorAndAccuracy_Metric, _impl_.y_)}},
    // .sensoris.protobuf.types.base.Int64Value z = 3;
    {::_pbi::TcParser::FastMtS1,
     {26, 2, 2, PROTOBUF_FIELD_OFFSET(XyzVectorAndAccuracy_Metric, _impl_.z_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .sensoris.protobuf.types.base.Int64Value x = 1;
    {PROTOBUF_FIELD_OFFSET(XyzVectorAndAccuracy_Metric, _impl_.x_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.base.Int64Value y = 2;
    {PROTOBUF_FIELD_OFFSET(XyzVectorAndAccuracy_Metric, _impl_.y_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.base.Int64Value z = 3;
    {PROTOBUF_FIELD_OFFSET(XyzVectorAndAccuracy_Metric, _impl_.z_), _Internal::kHasBitsOffset + 2, 2,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::base::Int64Value>()},
    {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::base::Int64Value>()},
    {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::base::Int64Value>()},
  }}, {{
  }},
};

::uint8_t* XyzVectorAndAccuracy_Metric::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .sensoris.protobuf.types.base.Int64Value x = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        1, _Internal::x(this),
        _Internal::x(this).GetCachedSize(), target, stream);
  }

  // .sensoris.protobuf.types.base.Int64Value y = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, _Internal::y(this),
        _Internal::y(this).GetCachedSize(), target, stream);
  }

  // .sensoris.protobuf.types.base.Int64Value z = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        3, _Internal::z(this),
        _Internal::z(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric)
  return target;
}

::size_t XyzVectorAndAccuracy_Metric::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // .sensoris.protobuf.types.base.Int64Value x = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.x_);
    }

    // .sensoris.protobuf.types.base.Int64Value y = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.y_);
    }

    // .sensoris.protobuf.types.base.Int64Value z = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.z_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData XyzVectorAndAccuracy_Metric::_class_data_ = {
    XyzVectorAndAccuracy_Metric::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* XyzVectorAndAccuracy_Metric::GetClassData() const {
  return &_class_data_;
}

void XyzVectorAndAccuracy_Metric::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<XyzVectorAndAccuracy_Metric*>(&to_msg);
  auto& from = static_cast<const XyzVectorAndAccuracy_Metric&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_x()->::sensoris::protobuf::types::base::Int64Value::MergeFrom(
          from._internal_x());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_y()->::sensoris::protobuf::types::base::Int64Value::MergeFrom(
          from._internal_y());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_z()->::sensoris::protobuf::types::base::Int64Value::MergeFrom(
          from._internal_z());
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void XyzVectorAndAccuracy_Metric::CopyFrom(const XyzVectorAndAccuracy_Metric& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool XyzVectorAndAccuracy_Metric::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* XyzVectorAndAccuracy_Metric::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void XyzVectorAndAccuracy_Metric::InternalSwap(XyzVectorAndAccuracy_Metric* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(XyzVectorAndAccuracy_Metric, _impl_.z_)
      + sizeof(XyzVectorAndAccuracy_Metric::_impl_.z_)
      - PROTOBUF_FIELD_OFFSET(XyzVectorAndAccuracy_Metric, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::google::protobuf::Metadata XyzVectorAndAccuracy_Metric::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto_getter, &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto_once,
      file_level_metadata_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto[12]);
}
// ===================================================================

class XyzVectorAndAccuracy::_Internal {
 public:
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy, _impl_._oneof_case_);
  static const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric& metric_vehicle(const XyzVectorAndAccuracy* msg);
  static const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric& metric_event_group(const XyzVectorAndAccuracy* msg);
  static const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric& metric_origin(const XyzVectorAndAccuracy* msg);
  static const ::google::protobuf::Int64Value& combined_std_dev(const XyzVectorAndAccuracy* msg);
  static const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev& std_dev(const XyzVectorAndAccuracy* msg);
  static const ::sensoris::protobuf::types::base::Int64Matrix3x3& covariance(const XyzVectorAndAccuracy* msg);
};

const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric& XyzVectorAndAccuracy::_Internal::metric_vehicle(const XyzVectorAndAccuracy* msg) {
  return *msg->_impl_.geometry_.metric_vehicle_;
}
const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric& XyzVectorAndAccuracy::_Internal::metric_event_group(const XyzVectorAndAccuracy* msg) {
  return *msg->_impl_.geometry_.metric_event_group_;
}
const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric& XyzVectorAndAccuracy::_Internal::metric_origin(const XyzVectorAndAccuracy* msg) {
  return *msg->_impl_.geometry_.metric_origin_;
}
const ::google::protobuf::Int64Value& XyzVectorAndAccuracy::_Internal::combined_std_dev(const XyzVectorAndAccuracy* msg) {
  return *msg->_impl_.accuracy_.combined_std_dev_;
}
const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev& XyzVectorAndAccuracy::_Internal::std_dev(const XyzVectorAndAccuracy* msg) {
  return *msg->_impl_.accuracy_.std_dev_;
}
const ::sensoris::protobuf::types::base::Int64Matrix3x3& XyzVectorAndAccuracy::_Internal::covariance(const XyzVectorAndAccuracy* msg) {
  return *msg->_impl_.accuracy_.covariance_;
}
void XyzVectorAndAccuracy::set_allocated_metric_vehicle(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* metric_vehicle) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_geometry();
  if (metric_vehicle) {
    ::google::protobuf::Arena* submessage_arena = metric_vehicle->GetArena();
    if (message_arena != submessage_arena) {
      metric_vehicle = ::google::protobuf::internal::GetOwnedMessage(message_arena, metric_vehicle, submessage_arena);
    }
    set_has_metric_vehicle();
    _impl_.geometry_.metric_vehicle_ = metric_vehicle;
  }
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.metric_vehicle)
}
void XyzVectorAndAccuracy::set_allocated_metric_event_group(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* metric_event_group) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_geometry();
  if (metric_event_group) {
    ::google::protobuf::Arena* submessage_arena = metric_event_group->GetArena();
    if (message_arena != submessage_arena) {
      metric_event_group = ::google::protobuf::internal::GetOwnedMessage(message_arena, metric_event_group, submessage_arena);
    }
    set_has_metric_event_group();
    _impl_.geometry_.metric_event_group_ = metric_event_group;
  }
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.metric_event_group)
}
void XyzVectorAndAccuracy::set_allocated_metric_origin(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* metric_origin) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_geometry();
  if (metric_origin) {
    ::google::protobuf::Arena* submessage_arena = metric_origin->GetArena();
    if (message_arena != submessage_arena) {
      metric_origin = ::google::protobuf::internal::GetOwnedMessage(message_arena, metric_origin, submessage_arena);
    }
    set_has_metric_origin();
    _impl_.geometry_.metric_origin_ = metric_origin;
  }
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.metric_origin)
}
void XyzVectorAndAccuracy::set_allocated_combined_std_dev(::google::protobuf::Int64Value* combined_std_dev) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_accuracy();
  if (combined_std_dev) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(combined_std_dev)->GetArena();
    if (message_arena != submessage_arena) {
      combined_std_dev = ::google::protobuf::internal::GetOwnedMessage(message_arena, combined_std_dev, submessage_arena);
    }
    set_has_combined_std_dev();
    _impl_.accuracy_.combined_std_dev_ = combined_std_dev;
  }
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.combined_std_dev)
}
void XyzVectorAndAccuracy::clear_combined_std_dev() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (accuracy_case() == kCombinedStdDev) {
    if (GetArena() == nullptr) {
      delete _impl_.accuracy_.combined_std_dev_;
    }
    clear_has_accuracy();
  }
}
void XyzVectorAndAccuracy::set_allocated_std_dev(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev* std_dev) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_accuracy();
  if (std_dev) {
    ::google::protobuf::Arena* submessage_arena = std_dev->GetArena();
    if (message_arena != submessage_arena) {
      std_dev = ::google::protobuf::internal::GetOwnedMessage(message_arena, std_dev, submessage_arena);
    }
    set_has_std_dev();
    _impl_.accuracy_.std_dev_ = std_dev;
  }
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.std_dev)
}
void XyzVectorAndAccuracy::set_allocated_covariance(::sensoris::protobuf::types::base::Int64Matrix3x3* covariance) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_accuracy();
  if (covariance) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(covariance)->GetArena();
    if (message_arena != submessage_arena) {
      covariance = ::google::protobuf::internal::GetOwnedMessage(message_arena, covariance, submessage_arena);
    }
    set_has_covariance();
    _impl_.accuracy_.covariance_ = covariance;
  }
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.covariance)
}
void XyzVectorAndAccuracy::clear_covariance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (accuracy_case() == kCovariance) {
    if (GetArena() == nullptr) {
      delete _impl_.accuracy_.covariance_;
    }
    clear_has_accuracy();
  }
}
void XyzVectorAndAccuracy::clear_extension() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.extension_.Clear();
}
XyzVectorAndAccuracy::XyzVectorAndAccuracy(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy)
}
inline PROTOBUF_NDEBUG_INLINE XyzVectorAndAccuracy::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : extension_{visibility, arena, from.extension_},
        geometry_{},
        accuracy_{},
        _cached_size_{0},
        _oneof_case_{from._oneof_case_[0], from._oneof_case_[1]} {}

XyzVectorAndAccuracy::XyzVectorAndAccuracy(
    ::google::protobuf::Arena* arena,
    const XyzVectorAndAccuracy& from)
    : ::google::protobuf::Message(arena) {
  XyzVectorAndAccuracy* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  switch (geometry_case()) {
    case GEOMETRY_NOT_SET:
      break;
      case kMetricVehicle:
        _impl_.geometry_.metric_vehicle_ = CreateMaybeMessage<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric>(arena, *from._impl_.geometry_.metric_vehicle_);
        break;
      case kMetricEventGroup:
        _impl_.geometry_.metric_event_group_ = CreateMaybeMessage<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric>(arena, *from._impl_.geometry_.metric_event_group_);
        break;
      case kMetricOrigin:
        _impl_.geometry_.metric_origin_ = CreateMaybeMessage<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric>(arena, *from._impl_.geometry_.metric_origin_);
        break;
  }
  switch (accuracy_case()) {
    case ACCURACY_NOT_SET:
      break;
      case kCombinedStdDev:
        _impl_.accuracy_.combined_std_dev_ = CreateMaybeMessage<::google::protobuf::Int64Value>(arena, *from._impl_.accuracy_.combined_std_dev_);
        break;
      case kStdDev:
        _impl_.accuracy_.std_dev_ = CreateMaybeMessage<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev>(arena, *from._impl_.accuracy_.std_dev_);
        break;
      case kCovariance:
        _impl_.accuracy_.covariance_ = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64Matrix3x3>(arena, *from._impl_.accuracy_.covariance_);
        break;
  }

  // @@protoc_insertion_point(copy_constructor:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy)
}
inline PROTOBUF_NDEBUG_INLINE XyzVectorAndAccuracy::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : extension_{visibility, arena},
        geometry_{},
        accuracy_{},
        _cached_size_{0},
        _oneof_case_{} {}

inline void XyzVectorAndAccuracy::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
XyzVectorAndAccuracy::~XyzVectorAndAccuracy() {
  // @@protoc_insertion_point(destructor:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void XyzVectorAndAccuracy::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  if (has_geometry()) {
    clear_geometry();
  }
  if (has_accuracy()) {
    clear_accuracy();
  }
  _impl_.~Impl_();
}

void XyzVectorAndAccuracy::clear_geometry() {
// @@protoc_insertion_point(one_of_clear_start:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  switch (geometry_case()) {
    case kMetricVehicle: {
      if (GetArena() == nullptr) {
        delete _impl_.geometry_.metric_vehicle_;
      }
      break;
    }
    case kMetricEventGroup: {
      if (GetArena() == nullptr) {
        delete _impl_.geometry_.metric_event_group_;
      }
      break;
    }
    case kMetricOrigin: {
      if (GetArena() == nullptr) {
        delete _impl_.geometry_.metric_origin_;
      }
      break;
    }
    case GEOMETRY_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = GEOMETRY_NOT_SET;
}

void XyzVectorAndAccuracy::clear_accuracy() {
// @@protoc_insertion_point(one_of_clear_start:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  switch (accuracy_case()) {
    case kCombinedStdDev: {
      if (GetArena() == nullptr) {
        delete _impl_.accuracy_.combined_std_dev_;
      }
      break;
    }
    case kStdDev: {
      if (GetArena() == nullptr) {
        delete _impl_.accuracy_.std_dev_;
      }
      break;
    }
    case kCovariance: {
      if (GetArena() == nullptr) {
        delete _impl_.accuracy_.covariance_;
      }
      break;
    }
    case ACCURACY_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[1] = ACCURACY_NOT_SET;
}


PROTOBUF_NOINLINE void XyzVectorAndAccuracy::Clear() {
// @@protoc_insertion_point(message_clear_start:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.extension_.Clear();
  clear_geometry();
  clear_accuracy();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* XyzVectorAndAccuracy::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 7, 7, 0, 2> XyzVectorAndAccuracy::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    15, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294950848,  // skipmap
    offsetof(decltype(_table_), field_entries),
    7,  // num_field_entries
    7,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_XyzVectorAndAccuracy_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // repeated .google.protobuf.Any extension = 15;
    {::_pbi::TcParser::FastMtR1,
     {122, 63, 6, PROTOBUF_FIELD_OFFSET(XyzVectorAndAccuracy, _impl_.extension_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric metric_vehicle = 1;
    {PROTOBUF_FIELD_OFFSET(XyzVectorAndAccuracy, _impl_.geometry_.metric_vehicle_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric metric_event_group = 2;
    {PROTOBUF_FIELD_OFFSET(XyzVectorAndAccuracy, _impl_.geometry_.metric_event_group_), _Internal::kOneofCaseOffset + 0, 1,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric metric_origin = 3;
    {PROTOBUF_FIELD_OFFSET(XyzVectorAndAccuracy, _impl_.geometry_.metric_origin_), _Internal::kOneofCaseOffset + 0, 2,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .google.protobuf.Int64Value combined_std_dev = 4;
    {PROTOBUF_FIELD_OFFSET(XyzVectorAndAccuracy, _impl_.accuracy_.combined_std_dev_), _Internal::kOneofCaseOffset + 4, 3,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev std_dev = 5;
    {PROTOBUF_FIELD_OFFSET(XyzVectorAndAccuracy, _impl_.accuracy_.std_dev_), _Internal::kOneofCaseOffset + 4, 4,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.base.Int64Matrix3x3 covariance = 6;
    {PROTOBUF_FIELD_OFFSET(XyzVectorAndAccuracy, _impl_.accuracy_.covariance_), _Internal::kOneofCaseOffset + 4, 5,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .google.protobuf.Any extension = 15;
    {PROTOBUF_FIELD_OFFSET(XyzVectorAndAccuracy, _impl_.extension_), 0, 6,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric>()},
    {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric>()},
    {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric>()},
    {::_pbi::TcParser::GetTable<::google::protobuf::Int64Value>()},
    {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev>()},
    {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::base::Int64Matrix3x3>()},
    {::_pbi::TcParser::GetTable<::google::protobuf::Any>()},
  }}, {{
  }},
};

::uint8_t* XyzVectorAndAccuracy::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  switch (geometry_case()) {
    case kMetricVehicle: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          1, _Internal::metric_vehicle(this),
          _Internal::metric_vehicle(this).GetCachedSize(), target, stream);
      break;
    }
    case kMetricEventGroup: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          2, _Internal::metric_event_group(this),
          _Internal::metric_event_group(this).GetCachedSize(), target, stream);
      break;
    }
    case kMetricOrigin: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          3, _Internal::metric_origin(this),
          _Internal::metric_origin(this).GetCachedSize(), target, stream);
      break;
    }
    default:
      break;
  }
  switch (accuracy_case()) {
    case kCombinedStdDev: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          4, _Internal::combined_std_dev(this),
          _Internal::combined_std_dev(this).GetCachedSize(), target, stream);
      break;
    }
    case kStdDev: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          5, _Internal::std_dev(this),
          _Internal::std_dev(this).GetCachedSize(), target, stream);
      break;
    }
    case kCovariance: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          6, _Internal::covariance(this),
          _Internal::covariance(this).GetCachedSize(), target, stream);
      break;
    }
    default:
      break;
  }
  // repeated .google.protobuf.Any extension = 15;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_extension_size()); i < n; i++) {
    const auto& repfield = this->_internal_extension().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(15, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy)
  return target;
}

::size_t XyzVectorAndAccuracy::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .google.protobuf.Any extension = 15;
  total_size += 1UL * this->_internal_extension_size();
  for (const auto& msg : this->_internal_extension()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  switch (geometry_case()) {
    // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric metric_vehicle = 1;
    case kMetricVehicle: {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.geometry_.metric_vehicle_);
      break;
    }
    // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric metric_event_group = 2;
    case kMetricEventGroup: {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.geometry_.metric_event_group_);
      break;
    }
    // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric metric_origin = 3;
    case kMetricOrigin: {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.geometry_.metric_origin_);
      break;
    }
    case GEOMETRY_NOT_SET: {
      break;
    }
  }
  switch (accuracy_case()) {
    // .google.protobuf.Int64Value combined_std_dev = 4;
    case kCombinedStdDev: {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.accuracy_.combined_std_dev_);
      break;
    }
    // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev std_dev = 5;
    case kStdDev: {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.accuracy_.std_dev_);
      break;
    }
    // .sensoris.protobuf.types.base.Int64Matrix3x3 covariance = 6;
    case kCovariance: {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.accuracy_.covariance_);
      break;
    }
    case ACCURACY_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData XyzVectorAndAccuracy::_class_data_ = {
    XyzVectorAndAccuracy::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* XyzVectorAndAccuracy::GetClassData() const {
  return &_class_data_;
}

void XyzVectorAndAccuracy::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<XyzVectorAndAccuracy*>(&to_msg);
  auto& from = static_cast<const XyzVectorAndAccuracy&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_extension()->MergeFrom(
      from._internal_extension());
  switch (from.geometry_case()) {
    case kMetricVehicle: {
      _this->_internal_mutable_metric_vehicle()->::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric::MergeFrom(
          from._internal_metric_vehicle());
      break;
    }
    case kMetricEventGroup: {
      _this->_internal_mutable_metric_event_group()->::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric::MergeFrom(
          from._internal_metric_event_group());
      break;
    }
    case kMetricOrigin: {
      _this->_internal_mutable_metric_origin()->::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric::MergeFrom(
          from._internal_metric_origin());
      break;
    }
    case GEOMETRY_NOT_SET: {
      break;
    }
  }
  switch (from.accuracy_case()) {
    case kCombinedStdDev: {
      _this->_internal_mutable_combined_std_dev()->::google::protobuf::Int64Value::MergeFrom(
          from._internal_combined_std_dev());
      break;
    }
    case kStdDev: {
      _this->_internal_mutable_std_dev()->::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev::MergeFrom(
          from._internal_std_dev());
      break;
    }
    case kCovariance: {
      _this->_internal_mutable_covariance()->::sensoris::protobuf::types::base::Int64Matrix3x3::MergeFrom(
          from._internal_covariance());
      break;
    }
    case ACCURACY_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void XyzVectorAndAccuracy::CopyFrom(const XyzVectorAndAccuracy& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool XyzVectorAndAccuracy::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* XyzVectorAndAccuracy::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void XyzVectorAndAccuracy::InternalSwap(XyzVectorAndAccuracy* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.extension_.InternalSwap(&other->_impl_.extension_);
  swap(_impl_.geometry_, other->_impl_.geometry_);
  swap(_impl_.accuracy_, other->_impl_.accuracy_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
  swap(_impl_._oneof_case_[1], other->_impl_._oneof_case_[1]);
}

::google::protobuf::Metadata XyzVectorAndAccuracy::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto_getter, &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto_once,
      file_level_metadata_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto[13]);
}
// ===================================================================

class RectangularBoxAndAccuracy_CornerVectors::_Internal {
 public:
  using HasBits = decltype(std::declval<RectangularBoxAndAccuracy_CornerVectors>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(RectangularBoxAndAccuracy_CornerVectors, _impl_._has_bits_);
  static const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& first_and_accuracy(const RectangularBoxAndAccuracy_CornerVectors* msg);
  static void set_has_first_and_accuracy(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& second_and_accuracy(const RectangularBoxAndAccuracy_CornerVectors* msg);
  static void set_has_second_and_accuracy(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& third_and_accuracy(const RectangularBoxAndAccuracy_CornerVectors* msg);
  static void set_has_third_and_accuracy(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& RectangularBoxAndAccuracy_CornerVectors::_Internal::first_and_accuracy(const RectangularBoxAndAccuracy_CornerVectors* msg) {
  return *msg->_impl_.first_and_accuracy_;
}
const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& RectangularBoxAndAccuracy_CornerVectors::_Internal::second_and_accuracy(const RectangularBoxAndAccuracy_CornerVectors* msg) {
  return *msg->_impl_.second_and_accuracy_;
}
const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& RectangularBoxAndAccuracy_CornerVectors::_Internal::third_and_accuracy(const RectangularBoxAndAccuracy_CornerVectors* msg) {
  return *msg->_impl_.third_and_accuracy_;
}
RectangularBoxAndAccuracy_CornerVectors::RectangularBoxAndAccuracy_CornerVectors(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors)
}
inline PROTOBUF_NDEBUG_INLINE RectangularBoxAndAccuracy_CornerVectors::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

RectangularBoxAndAccuracy_CornerVectors::RectangularBoxAndAccuracy_CornerVectors(
    ::google::protobuf::Arena* arena,
    const RectangularBoxAndAccuracy_CornerVectors& from)
    : ::google::protobuf::Message(arena) {
  RectangularBoxAndAccuracy_CornerVectors* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.first_and_accuracy_ = (cached_has_bits & 0x00000001u)
                ? CreateMaybeMessage<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy>(arena, *from._impl_.first_and_accuracy_)
                : nullptr;
  _impl_.second_and_accuracy_ = (cached_has_bits & 0x00000002u)
                ? CreateMaybeMessage<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy>(arena, *from._impl_.second_and_accuracy_)
                : nullptr;
  _impl_.third_and_accuracy_ = (cached_has_bits & 0x00000004u)
                ? CreateMaybeMessage<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy>(arena, *from._impl_.third_and_accuracy_)
                : nullptr;

  // @@protoc_insertion_point(copy_constructor:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors)
}
inline PROTOBUF_NDEBUG_INLINE RectangularBoxAndAccuracy_CornerVectors::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void RectangularBoxAndAccuracy_CornerVectors::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, first_and_accuracy_),
           0,
           offsetof(Impl_, third_and_accuracy_) -
               offsetof(Impl_, first_and_accuracy_) +
               sizeof(Impl_::third_and_accuracy_));
}
RectangularBoxAndAccuracy_CornerVectors::~RectangularBoxAndAccuracy_CornerVectors() {
  // @@protoc_insertion_point(destructor:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void RectangularBoxAndAccuracy_CornerVectors::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  delete _impl_.first_and_accuracy_;
  delete _impl_.second_and_accuracy_;
  delete _impl_.third_and_accuracy_;
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void RectangularBoxAndAccuracy_CornerVectors::Clear() {
// @@protoc_insertion_point(message_clear_start:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.first_and_accuracy_ != nullptr);
      _impl_.first_and_accuracy_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.second_and_accuracy_ != nullptr);
      _impl_.second_and_accuracy_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.third_and_accuracy_ != nullptr);
      _impl_.third_and_accuracy_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* RectangularBoxAndAccuracy_CornerVectors::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 3, 0, 2> RectangularBoxAndAccuracy_CornerVectors::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(RectangularBoxAndAccuracy_CornerVectors, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    3,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_RectangularBoxAndAccuracy_CornerVectors_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy first_and_accuracy = 1 [(.sensoris.protobuf.types.base.exponent) = 0];
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(RectangularBoxAndAccuracy_CornerVectors, _impl_.first_and_accuracy_)}},
    // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy second_and_accuracy = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 1, PROTOBUF_FIELD_OFFSET(RectangularBoxAndAccuracy_CornerVectors, _impl_.second_and_accuracy_)}},
    // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy third_and_accuracy = 3 [(.sensoris.protobuf.types.base.exponent) = 0];
    {::_pbi::TcParser::FastMtS1,
     {26, 2, 2, PROTOBUF_FIELD_OFFSET(RectangularBoxAndAccuracy_CornerVectors, _impl_.third_and_accuracy_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy first_and_accuracy = 1 [(.sensoris.protobuf.types.base.exponent) = 0];
    {PROTOBUF_FIELD_OFFSET(RectangularBoxAndAccuracy_CornerVectors, _impl_.first_and_accuracy_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy second_and_accuracy = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
    {PROTOBUF_FIELD_OFFSET(RectangularBoxAndAccuracy_CornerVectors, _impl_.second_and_accuracy_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy third_and_accuracy = 3 [(.sensoris.protobuf.types.base.exponent) = 0];
    {PROTOBUF_FIELD_OFFSET(RectangularBoxAndAccuracy_CornerVectors, _impl_.third_and_accuracy_), _Internal::kHasBitsOffset + 2, 2,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy>()},
    {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy>()},
    {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy>()},
  }}, {{
  }},
};

::uint8_t* RectangularBoxAndAccuracy_CornerVectors::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy first_and_accuracy = 1 [(.sensoris.protobuf.types.base.exponent) = 0];
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        1, _Internal::first_and_accuracy(this),
        _Internal::first_and_accuracy(this).GetCachedSize(), target, stream);
  }

  // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy second_and_accuracy = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, _Internal::second_and_accuracy(this),
        _Internal::second_and_accuracy(this).GetCachedSize(), target, stream);
  }

  // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy third_and_accuracy = 3 [(.sensoris.protobuf.types.base.exponent) = 0];
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        3, _Internal::third_and_accuracy(this),
        _Internal::third_and_accuracy(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors)
  return target;
}

::size_t RectangularBoxAndAccuracy_CornerVectors::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy first_and_accuracy = 1 [(.sensoris.protobuf.types.base.exponent) = 0];
    if (cached_has_bits & 0x00000001u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.first_and_accuracy_);
    }

    // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy second_and_accuracy = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
    if (cached_has_bits & 0x00000002u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.second_and_accuracy_);
    }

    // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy third_and_accuracy = 3 [(.sensoris.protobuf.types.base.exponent) = 0];
    if (cached_has_bits & 0x00000004u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.third_and_accuracy_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData RectangularBoxAndAccuracy_CornerVectors::_class_data_ = {
    RectangularBoxAndAccuracy_CornerVectors::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* RectangularBoxAndAccuracy_CornerVectors::GetClassData() const {
  return &_class_data_;
}

void RectangularBoxAndAccuracy_CornerVectors::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<RectangularBoxAndAccuracy_CornerVectors*>(&to_msg);
  auto& from = static_cast<const RectangularBoxAndAccuracy_CornerVectors&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_first_and_accuracy()->::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy::MergeFrom(
          from._internal_first_and_accuracy());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_second_and_accuracy()->::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy::MergeFrom(
          from._internal_second_and_accuracy());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_third_and_accuracy()->::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy::MergeFrom(
          from._internal_third_and_accuracy());
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void RectangularBoxAndAccuracy_CornerVectors::CopyFrom(const RectangularBoxAndAccuracy_CornerVectors& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool RectangularBoxAndAccuracy_CornerVectors::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* RectangularBoxAndAccuracy_CornerVectors::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void RectangularBoxAndAccuracy_CornerVectors::InternalSwap(RectangularBoxAndAccuracy_CornerVectors* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RectangularBoxAndAccuracy_CornerVectors, _impl_.third_and_accuracy_)
      + sizeof(RectangularBoxAndAccuracy_CornerVectors::_impl_.third_and_accuracy_)
      - PROTOBUF_FIELD_OFFSET(RectangularBoxAndAccuracy_CornerVectors, _impl_.first_and_accuracy_)>(
          reinterpret_cast<char*>(&_impl_.first_and_accuracy_),
          reinterpret_cast<char*>(&other->_impl_.first_and_accuracy_));
}

::google::protobuf::Metadata RectangularBoxAndAccuracy_CornerVectors::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto_getter, &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto_once,
      file_level_metadata_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto[14]);
}
// ===================================================================

class RectangularBoxAndAccuracy_CenterOrientationSize::_Internal {
 public:
  using HasBits = decltype(std::declval<RectangularBoxAndAccuracy_CenterOrientationSize>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(RectangularBoxAndAccuracy_CenterOrientationSize, _impl_._has_bits_);
  static const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& center_position_and_accuracy(const RectangularBoxAndAccuracy_CenterOrientationSize* msg);
  static void set_has_center_position_and_accuracy(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::sensoris::protobuf::types::spatial::RotationAndAccuracy& orientation_and_accuracy(const RectangularBoxAndAccuracy_CenterOrientationSize* msg);
  static void set_has_orientation_and_accuracy(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& size_and_accuracy(const RectangularBoxAndAccuracy_CenterOrientationSize* msg);
  static void set_has_size_and_accuracy(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& RectangularBoxAndAccuracy_CenterOrientationSize::_Internal::center_position_and_accuracy(const RectangularBoxAndAccuracy_CenterOrientationSize* msg) {
  return *msg->_impl_.center_position_and_accuracy_;
}
const ::sensoris::protobuf::types::spatial::RotationAndAccuracy& RectangularBoxAndAccuracy_CenterOrientationSize::_Internal::orientation_and_accuracy(const RectangularBoxAndAccuracy_CenterOrientationSize* msg) {
  return *msg->_impl_.orientation_and_accuracy_;
}
const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& RectangularBoxAndAccuracy_CenterOrientationSize::_Internal::size_and_accuracy(const RectangularBoxAndAccuracy_CenterOrientationSize* msg) {
  return *msg->_impl_.size_and_accuracy_;
}
RectangularBoxAndAccuracy_CenterOrientationSize::RectangularBoxAndAccuracy_CenterOrientationSize(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize)
}
inline PROTOBUF_NDEBUG_INLINE RectangularBoxAndAccuracy_CenterOrientationSize::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

RectangularBoxAndAccuracy_CenterOrientationSize::RectangularBoxAndAccuracy_CenterOrientationSize(
    ::google::protobuf::Arena* arena,
    const RectangularBoxAndAccuracy_CenterOrientationSize& from)
    : ::google::protobuf::Message(arena) {
  RectangularBoxAndAccuracy_CenterOrientationSize* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.center_position_and_accuracy_ = (cached_has_bits & 0x00000001u)
                ? CreateMaybeMessage<::sensoris::protobuf::types::spatial::PositionAndAccuracy>(arena, *from._impl_.center_position_and_accuracy_)
                : nullptr;
  _impl_.orientation_and_accuracy_ = (cached_has_bits & 0x00000002u)
                ? CreateMaybeMessage<::sensoris::protobuf::types::spatial::RotationAndAccuracy>(arena, *from._impl_.orientation_and_accuracy_)
                : nullptr;
  _impl_.size_and_accuracy_ = (cached_has_bits & 0x00000004u)
                ? CreateMaybeMessage<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy>(arena, *from._impl_.size_and_accuracy_)
                : nullptr;

  // @@protoc_insertion_point(copy_constructor:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize)
}
inline PROTOBUF_NDEBUG_INLINE RectangularBoxAndAccuracy_CenterOrientationSize::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void RectangularBoxAndAccuracy_CenterOrientationSize::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, center_position_and_accuracy_),
           0,
           offsetof(Impl_, size_and_accuracy_) -
               offsetof(Impl_, center_position_and_accuracy_) +
               sizeof(Impl_::size_and_accuracy_));
}
RectangularBoxAndAccuracy_CenterOrientationSize::~RectangularBoxAndAccuracy_CenterOrientationSize() {
  // @@protoc_insertion_point(destructor:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void RectangularBoxAndAccuracy_CenterOrientationSize::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  delete _impl_.center_position_and_accuracy_;
  delete _impl_.orientation_and_accuracy_;
  delete _impl_.size_and_accuracy_;
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void RectangularBoxAndAccuracy_CenterOrientationSize::Clear() {
// @@protoc_insertion_point(message_clear_start:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.center_position_and_accuracy_ != nullptr);
      _impl_.center_position_and_accuracy_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.orientation_and_accuracy_ != nullptr);
      _impl_.orientation_and_accuracy_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.size_and_accuracy_ != nullptr);
      _impl_.size_and_accuracy_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* RectangularBoxAndAccuracy_CenterOrientationSize::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 3, 0, 2> RectangularBoxAndAccuracy_CenterOrientationSize::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(RectangularBoxAndAccuracy_CenterOrientationSize, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    3,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_RectangularBoxAndAccuracy_CenterOrientationSize_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // .sensoris.protobuf.types.spatial.PositionAndAccuracy center_position_and_accuracy = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(RectangularBoxAndAccuracy_CenterOrientationSize, _impl_.center_position_and_accuracy_)}},
    // .sensoris.protobuf.types.spatial.RotationAndAccuracy orientation_and_accuracy = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 1, PROTOBUF_FIELD_OFFSET(RectangularBoxAndAccuracy_CenterOrientationSize, _impl_.orientation_and_accuracy_)}},
    // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy size_and_accuracy = 3 [(.sensoris.protobuf.types.base.exponent) = 0];
    {::_pbi::TcParser::FastMtS1,
     {26, 2, 2, PROTOBUF_FIELD_OFFSET(RectangularBoxAndAccuracy_CenterOrientationSize, _impl_.size_and_accuracy_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .sensoris.protobuf.types.spatial.PositionAndAccuracy center_position_and_accuracy = 1;
    {PROTOBUF_FIELD_OFFSET(RectangularBoxAndAccuracy_CenterOrientationSize, _impl_.center_position_and_accuracy_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.spatial.RotationAndAccuracy orientation_and_accuracy = 2;
    {PROTOBUF_FIELD_OFFSET(RectangularBoxAndAccuracy_CenterOrientationSize, _impl_.orientation_and_accuracy_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy size_and_accuracy = 3 [(.sensoris.protobuf.types.base.exponent) = 0];
    {PROTOBUF_FIELD_OFFSET(RectangularBoxAndAccuracy_CenterOrientationSize, _impl_.size_and_accuracy_), _Internal::kHasBitsOffset + 2, 2,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::PositionAndAccuracy>()},
    {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::RotationAndAccuracy>()},
    {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy>()},
  }}, {{
  }},
};

::uint8_t* RectangularBoxAndAccuracy_CenterOrientationSize::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .sensoris.protobuf.types.spatial.PositionAndAccuracy center_position_and_accuracy = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        1, _Internal::center_position_and_accuracy(this),
        _Internal::center_position_and_accuracy(this).GetCachedSize(), target, stream);
  }

  // .sensoris.protobuf.types.spatial.RotationAndAccuracy orientation_and_accuracy = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, _Internal::orientation_and_accuracy(this),
        _Internal::orientation_and_accuracy(this).GetCachedSize(), target, stream);
  }

  // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy size_and_accuracy = 3 [(.sensoris.protobuf.types.base.exponent) = 0];
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        3, _Internal::size_and_accuracy(this),
        _Internal::size_and_accuracy(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize)
  return target;
}

::size_t RectangularBoxAndAccuracy_CenterOrientationSize::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // .sensoris.protobuf.types.spatial.PositionAndAccuracy center_position_and_accuracy = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.center_position_and_accuracy_);
    }

    // .sensoris.protobuf.types.spatial.RotationAndAccuracy orientation_and_accuracy = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.orientation_and_accuracy_);
    }

    // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy size_and_accuracy = 3 [(.sensoris.protobuf.types.base.exponent) = 0];
    if (cached_has_bits & 0x00000004u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.size_and_accuracy_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData RectangularBoxAndAccuracy_CenterOrientationSize::_class_data_ = {
    RectangularBoxAndAccuracy_CenterOrientationSize::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* RectangularBoxAndAccuracy_CenterOrientationSize::GetClassData() const {
  return &_class_data_;
}

void RectangularBoxAndAccuracy_CenterOrientationSize::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<RectangularBoxAndAccuracy_CenterOrientationSize*>(&to_msg);
  auto& from = static_cast<const RectangularBoxAndAccuracy_CenterOrientationSize&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_center_position_and_accuracy()->::sensoris::protobuf::types::spatial::PositionAndAccuracy::MergeFrom(
          from._internal_center_position_and_accuracy());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_orientation_and_accuracy()->::sensoris::protobuf::types::spatial::RotationAndAccuracy::MergeFrom(
          from._internal_orientation_and_accuracy());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_size_and_accuracy()->::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy::MergeFrom(
          from._internal_size_and_accuracy());
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void RectangularBoxAndAccuracy_CenterOrientationSize::CopyFrom(const RectangularBoxAndAccuracy_CenterOrientationSize& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool RectangularBoxAndAccuracy_CenterOrientationSize::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* RectangularBoxAndAccuracy_CenterOrientationSize::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void RectangularBoxAndAccuracy_CenterOrientationSize::InternalSwap(RectangularBoxAndAccuracy_CenterOrientationSize* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RectangularBoxAndAccuracy_CenterOrientationSize, _impl_.size_and_accuracy_)
      + sizeof(RectangularBoxAndAccuracy_CenterOrientationSize::_impl_.size_and_accuracy_)
      - PROTOBUF_FIELD_OFFSET(RectangularBoxAndAccuracy_CenterOrientationSize, _impl_.center_position_and_accuracy_)>(
          reinterpret_cast<char*>(&_impl_.center_position_and_accuracy_),
          reinterpret_cast<char*>(&other->_impl_.center_position_and_accuracy_));
}

::google::protobuf::Metadata RectangularBoxAndAccuracy_CenterOrientationSize::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto_getter, &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto_once,
      file_level_metadata_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto[15]);
}
// ===================================================================

class RectangularBoxAndAccuracy::_Internal {
 public:
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy, _impl_._oneof_case_);
  static const ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors& corner_vectors(const RectangularBoxAndAccuracy* msg);
  static const ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize& center_orientation_size(const RectangularBoxAndAccuracy* msg);
};

const ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors& RectangularBoxAndAccuracy::_Internal::corner_vectors(const RectangularBoxAndAccuracy* msg) {
  return *msg->_impl_.geometry_.corner_vectors_;
}
const ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize& RectangularBoxAndAccuracy::_Internal::center_orientation_size(const RectangularBoxAndAccuracy* msg) {
  return *msg->_impl_.geometry_.center_orientation_size_;
}
void RectangularBoxAndAccuracy::set_allocated_corner_vectors(::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors* corner_vectors) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_geometry();
  if (corner_vectors) {
    ::google::protobuf::Arena* submessage_arena = corner_vectors->GetArena();
    if (message_arena != submessage_arena) {
      corner_vectors = ::google::protobuf::internal::GetOwnedMessage(message_arena, corner_vectors, submessage_arena);
    }
    set_has_corner_vectors();
    _impl_.geometry_.corner_vectors_ = corner_vectors;
  }
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.corner_vectors)
}
void RectangularBoxAndAccuracy::set_allocated_center_orientation_size(::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize* center_orientation_size) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_geometry();
  if (center_orientation_size) {
    ::google::protobuf::Arena* submessage_arena = center_orientation_size->GetArena();
    if (message_arena != submessage_arena) {
      center_orientation_size = ::google::protobuf::internal::GetOwnedMessage(message_arena, center_orientation_size, submessage_arena);
    }
    set_has_center_orientation_size();
    _impl_.geometry_.center_orientation_size_ = center_orientation_size;
  }
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.center_orientation_size)
}
void RectangularBoxAndAccuracy::clear_extension() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.extension_.Clear();
}
RectangularBoxAndAccuracy::RectangularBoxAndAccuracy(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy)
}
inline PROTOBUF_NDEBUG_INLINE RectangularBoxAndAccuracy::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : extension_{visibility, arena, from.extension_},
        geometry_{},
        _cached_size_{0},
        _oneof_case_{from._oneof_case_[0]} {}

RectangularBoxAndAccuracy::RectangularBoxAndAccuracy(
    ::google::protobuf::Arena* arena,
    const RectangularBoxAndAccuracy& from)
    : ::google::protobuf::Message(arena) {
  RectangularBoxAndAccuracy* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  switch (geometry_case()) {
    case GEOMETRY_NOT_SET:
      break;
      case kCornerVectors:
        _impl_.geometry_.corner_vectors_ = CreateMaybeMessage<::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors>(arena, *from._impl_.geometry_.corner_vectors_);
        break;
      case kCenterOrientationSize:
        _impl_.geometry_.center_orientation_size_ = CreateMaybeMessage<::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize>(arena, *from._impl_.geometry_.center_orientation_size_);
        break;
  }

  // @@protoc_insertion_point(copy_constructor:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy)
}
inline PROTOBUF_NDEBUG_INLINE RectangularBoxAndAccuracy::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : extension_{visibility, arena},
        geometry_{},
        _cached_size_{0},
        _oneof_case_{} {}

inline void RectangularBoxAndAccuracy::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
RectangularBoxAndAccuracy::~RectangularBoxAndAccuracy() {
  // @@protoc_insertion_point(destructor:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void RectangularBoxAndAccuracy::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  if (has_geometry()) {
    clear_geometry();
  }
  _impl_.~Impl_();
}

void RectangularBoxAndAccuracy::clear_geometry() {
// @@protoc_insertion_point(one_of_clear_start:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  switch (geometry_case()) {
    case kCornerVectors: {
      if (GetArena() == nullptr) {
        delete _impl_.geometry_.corner_vectors_;
      }
      break;
    }
    case kCenterOrientationSize: {
      if (GetArena() == nullptr) {
        delete _impl_.geometry_.center_orientation_size_;
      }
      break;
    }
    case GEOMETRY_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = GEOMETRY_NOT_SET;
}


PROTOBUF_NOINLINE void RectangularBoxAndAccuracy::Clear() {
// @@protoc_insertion_point(message_clear_start:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.extension_.Clear();
  clear_geometry();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* RectangularBoxAndAccuracy::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 3, 3, 0, 2> RectangularBoxAndAccuracy::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    15, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294950908,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    3,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_RectangularBoxAndAccuracy_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // repeated .google.protobuf.Any extension = 15;
    {::_pbi::TcParser::FastMtR1,
     {122, 63, 2, PROTOBUF_FIELD_OFFSET(RectangularBoxAndAccuracy, _impl_.extension_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors corner_vectors = 1;
    {PROTOBUF_FIELD_OFFSET(RectangularBoxAndAccuracy, _impl_.geometry_.corner_vectors_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize center_orientation_size = 2;
    {PROTOBUF_FIELD_OFFSET(RectangularBoxAndAccuracy, _impl_.geometry_.center_orientation_size_), _Internal::kOneofCaseOffset + 0, 1,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .google.protobuf.Any extension = 15;
    {PROTOBUF_FIELD_OFFSET(RectangularBoxAndAccuracy, _impl_.extension_), 0, 2,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors>()},
    {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize>()},
    {::_pbi::TcParser::GetTable<::google::protobuf::Any>()},
  }}, {{
  }},
};

::uint8_t* RectangularBoxAndAccuracy::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  switch (geometry_case()) {
    case kCornerVectors: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          1, _Internal::corner_vectors(this),
          _Internal::corner_vectors(this).GetCachedSize(), target, stream);
      break;
    }
    case kCenterOrientationSize: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          2, _Internal::center_orientation_size(this),
          _Internal::center_orientation_size(this).GetCachedSize(), target, stream);
      break;
    }
    default:
      break;
  }
  // repeated .google.protobuf.Any extension = 15;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_extension_size()); i < n; i++) {
    const auto& repfield = this->_internal_extension().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(15, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy)
  return target;
}

::size_t RectangularBoxAndAccuracy::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .google.protobuf.Any extension = 15;
  total_size += 1UL * this->_internal_extension_size();
  for (const auto& msg : this->_internal_extension()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  switch (geometry_case()) {
    // .sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors corner_vectors = 1;
    case kCornerVectors: {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.geometry_.corner_vectors_);
      break;
    }
    // .sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize center_orientation_size = 2;
    case kCenterOrientationSize: {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.geometry_.center_orientation_size_);
      break;
    }
    case GEOMETRY_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData RectangularBoxAndAccuracy::_class_data_ = {
    RectangularBoxAndAccuracy::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* RectangularBoxAndAccuracy::GetClassData() const {
  return &_class_data_;
}

void RectangularBoxAndAccuracy::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<RectangularBoxAndAccuracy*>(&to_msg);
  auto& from = static_cast<const RectangularBoxAndAccuracy&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_extension()->MergeFrom(
      from._internal_extension());
  switch (from.geometry_case()) {
    case kCornerVectors: {
      _this->_internal_mutable_corner_vectors()->::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors::MergeFrom(
          from._internal_corner_vectors());
      break;
    }
    case kCenterOrientationSize: {
      _this->_internal_mutable_center_orientation_size()->::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize::MergeFrom(
          from._internal_center_orientation_size());
      break;
    }
    case GEOMETRY_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void RectangularBoxAndAccuracy::CopyFrom(const RectangularBoxAndAccuracy& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool RectangularBoxAndAccuracy::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* RectangularBoxAndAccuracy::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void RectangularBoxAndAccuracy::InternalSwap(RectangularBoxAndAccuracy* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.extension_.InternalSwap(&other->_impl_.extension_);
  swap(_impl_.geometry_, other->_impl_.geometry_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::google::protobuf::Metadata RectangularBoxAndAccuracy::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto_getter, &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto_once,
      file_level_metadata_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto[16]);
}
// ===================================================================

class RotationAndAccuracy_Euler::_Internal {
 public:
  using HasBits = decltype(std::declval<RotationAndAccuracy_Euler>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(RotationAndAccuracy_Euler, _impl_._has_bits_);
  static const ::sensoris::protobuf::types::base::Int64Value& yaw(const RotationAndAccuracy_Euler* msg);
  static void set_has_yaw(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::sensoris::protobuf::types::base::Int64Value& pitch(const RotationAndAccuracy_Euler* msg);
  static void set_has_pitch(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::sensoris::protobuf::types::base::Int64Value& roll(const RotationAndAccuracy_Euler* msg);
  static void set_has_roll(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::sensoris::protobuf::types::base::Int64Value& RotationAndAccuracy_Euler::_Internal::yaw(const RotationAndAccuracy_Euler* msg) {
  return *msg->_impl_.yaw_;
}
const ::sensoris::protobuf::types::base::Int64Value& RotationAndAccuracy_Euler::_Internal::pitch(const RotationAndAccuracy_Euler* msg) {
  return *msg->_impl_.pitch_;
}
const ::sensoris::protobuf::types::base::Int64Value& RotationAndAccuracy_Euler::_Internal::roll(const RotationAndAccuracy_Euler* msg) {
  return *msg->_impl_.roll_;
}
void RotationAndAccuracy_Euler::clear_yaw() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.yaw_ != nullptr) _impl_.yaw_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void RotationAndAccuracy_Euler::clear_pitch() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.pitch_ != nullptr) _impl_.pitch_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void RotationAndAccuracy_Euler::clear_roll() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.roll_ != nullptr) _impl_.roll_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
RotationAndAccuracy_Euler::RotationAndAccuracy_Euler(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler)
}
inline PROTOBUF_NDEBUG_INLINE RotationAndAccuracy_Euler::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

RotationAndAccuracy_Euler::RotationAndAccuracy_Euler(
    ::google::protobuf::Arena* arena,
    const RotationAndAccuracy_Euler& from)
    : ::google::protobuf::Message(arena) {
  RotationAndAccuracy_Euler* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.yaw_ = (cached_has_bits & 0x00000001u)
                ? CreateMaybeMessage<::sensoris::protobuf::types::base::Int64Value>(arena, *from._impl_.yaw_)
                : nullptr;
  _impl_.pitch_ = (cached_has_bits & 0x00000002u)
                ? CreateMaybeMessage<::sensoris::protobuf::types::base::Int64Value>(arena, *from._impl_.pitch_)
                : nullptr;
  _impl_.roll_ = (cached_has_bits & 0x00000004u)
                ? CreateMaybeMessage<::sensoris::protobuf::types::base::Int64Value>(arena, *from._impl_.roll_)
                : nullptr;

  // @@protoc_insertion_point(copy_constructor:sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler)
}
inline PROTOBUF_NDEBUG_INLINE RotationAndAccuracy_Euler::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void RotationAndAccuracy_Euler::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, yaw_),
           0,
           offsetof(Impl_, roll_) -
               offsetof(Impl_, yaw_) +
               sizeof(Impl_::roll_));
}
RotationAndAccuracy_Euler::~RotationAndAccuracy_Euler() {
  // @@protoc_insertion_point(destructor:sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void RotationAndAccuracy_Euler::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  delete _impl_.yaw_;
  delete _impl_.pitch_;
  delete _impl_.roll_;
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void RotationAndAccuracy_Euler::Clear() {
// @@protoc_insertion_point(message_clear_start:sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.yaw_ != nullptr);
      _impl_.yaw_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.pitch_ != nullptr);
      _impl_.pitch_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.roll_ != nullptr);
      _impl_.roll_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* RotationAndAccuracy_Euler::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 3, 0, 2> RotationAndAccuracy_Euler::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(RotationAndAccuracy_Euler, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    3,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_RotationAndAccuracy_Euler_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // .sensoris.protobuf.types.base.Int64Value yaw = 1 [(.sensoris.protobuf.types.base.exponent) = 2];
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(RotationAndAccuracy_Euler, _impl_.yaw_)}},
    // .sensoris.protobuf.types.base.Int64Value pitch = 2 [(.sensoris.protobuf.types.base.exponent) = 2];
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 1, PROTOBUF_FIELD_OFFSET(RotationAndAccuracy_Euler, _impl_.pitch_)}},
    // .sensoris.protobuf.types.base.Int64Value roll = 3 [(.sensoris.protobuf.types.base.exponent) = 2];
    {::_pbi::TcParser::FastMtS1,
     {26, 2, 2, PROTOBUF_FIELD_OFFSET(RotationAndAccuracy_Euler, _impl_.roll_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .sensoris.protobuf.types.base.Int64Value yaw = 1 [(.sensoris.protobuf.types.base.exponent) = 2];
    {PROTOBUF_FIELD_OFFSET(RotationAndAccuracy_Euler, _impl_.yaw_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.base.Int64Value pitch = 2 [(.sensoris.protobuf.types.base.exponent) = 2];
    {PROTOBUF_FIELD_OFFSET(RotationAndAccuracy_Euler, _impl_.pitch_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.base.Int64Value roll = 3 [(.sensoris.protobuf.types.base.exponent) = 2];
    {PROTOBUF_FIELD_OFFSET(RotationAndAccuracy_Euler, _impl_.roll_), _Internal::kHasBitsOffset + 2, 2,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::base::Int64Value>()},
    {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::base::Int64Value>()},
    {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::base::Int64Value>()},
  }}, {{
  }},
};

::uint8_t* RotationAndAccuracy_Euler::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .sensoris.protobuf.types.base.Int64Value yaw = 1 [(.sensoris.protobuf.types.base.exponent) = 2];
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        1, _Internal::yaw(this),
        _Internal::yaw(this).GetCachedSize(), target, stream);
  }

  // .sensoris.protobuf.types.base.Int64Value pitch = 2 [(.sensoris.protobuf.types.base.exponent) = 2];
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, _Internal::pitch(this),
        _Internal::pitch(this).GetCachedSize(), target, stream);
  }

  // .sensoris.protobuf.types.base.Int64Value roll = 3 [(.sensoris.protobuf.types.base.exponent) = 2];
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        3, _Internal::roll(this),
        _Internal::roll(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler)
  return target;
}

::size_t RotationAndAccuracy_Euler::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // .sensoris.protobuf.types.base.Int64Value yaw = 1 [(.sensoris.protobuf.types.base.exponent) = 2];
    if (cached_has_bits & 0x00000001u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.yaw_);
    }

    // .sensoris.protobuf.types.base.Int64Value pitch = 2 [(.sensoris.protobuf.types.base.exponent) = 2];
    if (cached_has_bits & 0x00000002u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.pitch_);
    }

    // .sensoris.protobuf.types.base.Int64Value roll = 3 [(.sensoris.protobuf.types.base.exponent) = 2];
    if (cached_has_bits & 0x00000004u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.roll_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData RotationAndAccuracy_Euler::_class_data_ = {
    RotationAndAccuracy_Euler::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* RotationAndAccuracy_Euler::GetClassData() const {
  return &_class_data_;
}

void RotationAndAccuracy_Euler::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<RotationAndAccuracy_Euler*>(&to_msg);
  auto& from = static_cast<const RotationAndAccuracy_Euler&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_yaw()->::sensoris::protobuf::types::base::Int64Value::MergeFrom(
          from._internal_yaw());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_pitch()->::sensoris::protobuf::types::base::Int64Value::MergeFrom(
          from._internal_pitch());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_roll()->::sensoris::protobuf::types::base::Int64Value::MergeFrom(
          from._internal_roll());
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void RotationAndAccuracy_Euler::CopyFrom(const RotationAndAccuracy_Euler& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool RotationAndAccuracy_Euler::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* RotationAndAccuracy_Euler::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void RotationAndAccuracy_Euler::InternalSwap(RotationAndAccuracy_Euler* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RotationAndAccuracy_Euler, _impl_.roll_)
      + sizeof(RotationAndAccuracy_Euler::_impl_.roll_)
      - PROTOBUF_FIELD_OFFSET(RotationAndAccuracy_Euler, _impl_.yaw_)>(
          reinterpret_cast<char*>(&_impl_.yaw_),
          reinterpret_cast<char*>(&other->_impl_.yaw_));
}

::google::protobuf::Metadata RotationAndAccuracy_Euler::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto_getter, &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto_once,
      file_level_metadata_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto[17]);
}
// ===================================================================

class RotationAndAccuracy_Quaternion::_Internal {
 public:
  using HasBits = decltype(std::declval<RotationAndAccuracy_Quaternion>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(RotationAndAccuracy_Quaternion, _impl_._has_bits_);
  static const ::sensoris::protobuf::types::base::Int64Value& x(const RotationAndAccuracy_Quaternion* msg);
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::sensoris::protobuf::types::base::Int64Value& y(const RotationAndAccuracy_Quaternion* msg);
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::sensoris::protobuf::types::base::Int64Value& z(const RotationAndAccuracy_Quaternion* msg);
  static void set_has_z(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::sensoris::protobuf::types::base::Int64Value& w(const RotationAndAccuracy_Quaternion* msg);
  static void set_has_w(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::sensoris::protobuf::types::base::Int64Value& RotationAndAccuracy_Quaternion::_Internal::x(const RotationAndAccuracy_Quaternion* msg) {
  return *msg->_impl_.x_;
}
const ::sensoris::protobuf::types::base::Int64Value& RotationAndAccuracy_Quaternion::_Internal::y(const RotationAndAccuracy_Quaternion* msg) {
  return *msg->_impl_.y_;
}
const ::sensoris::protobuf::types::base::Int64Value& RotationAndAccuracy_Quaternion::_Internal::z(const RotationAndAccuracy_Quaternion* msg) {
  return *msg->_impl_.z_;
}
const ::sensoris::protobuf::types::base::Int64Value& RotationAndAccuracy_Quaternion::_Internal::w(const RotationAndAccuracy_Quaternion* msg) {
  return *msg->_impl_.w_;
}
void RotationAndAccuracy_Quaternion::clear_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.x_ != nullptr) _impl_.x_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void RotationAndAccuracy_Quaternion::clear_y() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.y_ != nullptr) _impl_.y_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void RotationAndAccuracy_Quaternion::clear_z() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.z_ != nullptr) _impl_.z_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void RotationAndAccuracy_Quaternion::clear_w() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.w_ != nullptr) _impl_.w_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
RotationAndAccuracy_Quaternion::RotationAndAccuracy_Quaternion(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion)
}
inline PROTOBUF_NDEBUG_INLINE RotationAndAccuracy_Quaternion::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

RotationAndAccuracy_Quaternion::RotationAndAccuracy_Quaternion(
    ::google::protobuf::Arena* arena,
    const RotationAndAccuracy_Quaternion& from)
    : ::google::protobuf::Message(arena) {
  RotationAndAccuracy_Quaternion* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.x_ = (cached_has_bits & 0x00000001u)
                ? CreateMaybeMessage<::sensoris::protobuf::types::base::Int64Value>(arena, *from._impl_.x_)
                : nullptr;
  _impl_.y_ = (cached_has_bits & 0x00000002u)
                ? CreateMaybeMessage<::sensoris::protobuf::types::base::Int64Value>(arena, *from._impl_.y_)
                : nullptr;
  _impl_.z_ = (cached_has_bits & 0x00000004u)
                ? CreateMaybeMessage<::sensoris::protobuf::types::base::Int64Value>(arena, *from._impl_.z_)
                : nullptr;
  _impl_.w_ = (cached_has_bits & 0x00000008u)
                ? CreateMaybeMessage<::sensoris::protobuf::types::base::Int64Value>(arena, *from._impl_.w_)
                : nullptr;

  // @@protoc_insertion_point(copy_constructor:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion)
}
inline PROTOBUF_NDEBUG_INLINE RotationAndAccuracy_Quaternion::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void RotationAndAccuracy_Quaternion::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, x_),
           0,
           offsetof(Impl_, w_) -
               offsetof(Impl_, x_) +
               sizeof(Impl_::w_));
}
RotationAndAccuracy_Quaternion::~RotationAndAccuracy_Quaternion() {
  // @@protoc_insertion_point(destructor:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void RotationAndAccuracy_Quaternion::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  delete _impl_.x_;
  delete _impl_.y_;
  delete _impl_.z_;
  delete _impl_.w_;
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void RotationAndAccuracy_Quaternion::Clear() {
// @@protoc_insertion_point(message_clear_start:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.x_ != nullptr);
      _impl_.x_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.y_ != nullptr);
      _impl_.y_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.z_ != nullptr);
      _impl_.z_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      ABSL_DCHECK(_impl_.w_ != nullptr);
      _impl_.w_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* RotationAndAccuracy_Quaternion::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 4, 0, 2> RotationAndAccuracy_Quaternion::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(RotationAndAccuracy_Quaternion, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    4,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_RotationAndAccuracy_Quaternion_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // .sensoris.protobuf.types.base.Int64Value w = 4 [(.sensoris.protobuf.types.base.exponent) = 3];
    {::_pbi::TcParser::FastMtS1,
     {34, 3, 3, PROTOBUF_FIELD_OFFSET(RotationAndAccuracy_Quaternion, _impl_.w_)}},
    // .sensoris.protobuf.types.base.Int64Value x = 1 [(.sensoris.protobuf.types.base.exponent) = 3];
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(RotationAndAccuracy_Quaternion, _impl_.x_)}},
    // .sensoris.protobuf.types.base.Int64Value y = 2 [(.sensoris.protobuf.types.base.exponent) = 3];
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 1, PROTOBUF_FIELD_OFFSET(RotationAndAccuracy_Quaternion, _impl_.y_)}},
    // .sensoris.protobuf.types.base.Int64Value z = 3 [(.sensoris.protobuf.types.base.exponent) = 3];
    {::_pbi::TcParser::FastMtS1,
     {26, 2, 2, PROTOBUF_FIELD_OFFSET(RotationAndAccuracy_Quaternion, _impl_.z_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .sensoris.protobuf.types.base.Int64Value x = 1 [(.sensoris.protobuf.types.base.exponent) = 3];
    {PROTOBUF_FIELD_OFFSET(RotationAndAccuracy_Quaternion, _impl_.x_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.base.Int64Value y = 2 [(.sensoris.protobuf.types.base.exponent) = 3];
    {PROTOBUF_FIELD_OFFSET(RotationAndAccuracy_Quaternion, _impl_.y_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.base.Int64Value z = 3 [(.sensoris.protobuf.types.base.exponent) = 3];
    {PROTOBUF_FIELD_OFFSET(RotationAndAccuracy_Quaternion, _impl_.z_), _Internal::kHasBitsOffset + 2, 2,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.base.Int64Value w = 4 [(.sensoris.protobuf.types.base.exponent) = 3];
    {PROTOBUF_FIELD_OFFSET(RotationAndAccuracy_Quaternion, _impl_.w_), _Internal::kHasBitsOffset + 3, 3,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::base::Int64Value>()},
    {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::base::Int64Value>()},
    {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::base::Int64Value>()},
    {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::base::Int64Value>()},
  }}, {{
  }},
};

::uint8_t* RotationAndAccuracy_Quaternion::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .sensoris.protobuf.types.base.Int64Value x = 1 [(.sensoris.protobuf.types.base.exponent) = 3];
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        1, _Internal::x(this),
        _Internal::x(this).GetCachedSize(), target, stream);
  }

  // .sensoris.protobuf.types.base.Int64Value y = 2 [(.sensoris.protobuf.types.base.exponent) = 3];
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, _Internal::y(this),
        _Internal::y(this).GetCachedSize(), target, stream);
  }

  // .sensoris.protobuf.types.base.Int64Value z = 3 [(.sensoris.protobuf.types.base.exponent) = 3];
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        3, _Internal::z(this),
        _Internal::z(this).GetCachedSize(), target, stream);
  }

  // .sensoris.protobuf.types.base.Int64Value w = 4 [(.sensoris.protobuf.types.base.exponent) = 3];
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        4, _Internal::w(this),
        _Internal::w(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion)
  return target;
}

::size_t RotationAndAccuracy_Quaternion::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // .sensoris.protobuf.types.base.Int64Value x = 1 [(.sensoris.protobuf.types.base.exponent) = 3];
    if (cached_has_bits & 0x00000001u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.x_);
    }

    // .sensoris.protobuf.types.base.Int64Value y = 2 [(.sensoris.protobuf.types.base.exponent) = 3];
    if (cached_has_bits & 0x00000002u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.y_);
    }

    // .sensoris.protobuf.types.base.Int64Value z = 3 [(.sensoris.protobuf.types.base.exponent) = 3];
    if (cached_has_bits & 0x00000004u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.z_);
    }

    // .sensoris.protobuf.types.base.Int64Value w = 4 [(.sensoris.protobuf.types.base.exponent) = 3];
    if (cached_has_bits & 0x00000008u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.w_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData RotationAndAccuracy_Quaternion::_class_data_ = {
    RotationAndAccuracy_Quaternion::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* RotationAndAccuracy_Quaternion::GetClassData() const {
  return &_class_data_;
}

void RotationAndAccuracy_Quaternion::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<RotationAndAccuracy_Quaternion*>(&to_msg);
  auto& from = static_cast<const RotationAndAccuracy_Quaternion&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_x()->::sensoris::protobuf::types::base::Int64Value::MergeFrom(
          from._internal_x());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_y()->::sensoris::protobuf::types::base::Int64Value::MergeFrom(
          from._internal_y());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_z()->::sensoris::protobuf::types::base::Int64Value::MergeFrom(
          from._internal_z());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_w()->::sensoris::protobuf::types::base::Int64Value::MergeFrom(
          from._internal_w());
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void RotationAndAccuracy_Quaternion::CopyFrom(const RotationAndAccuracy_Quaternion& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool RotationAndAccuracy_Quaternion::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* RotationAndAccuracy_Quaternion::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void RotationAndAccuracy_Quaternion::InternalSwap(RotationAndAccuracy_Quaternion* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RotationAndAccuracy_Quaternion, _impl_.w_)
      + sizeof(RotationAndAccuracy_Quaternion::_impl_.w_)
      - PROTOBUF_FIELD_OFFSET(RotationAndAccuracy_Quaternion, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::google::protobuf::Metadata RotationAndAccuracy_Quaternion::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto_getter, &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto_once,
      file_level_metadata_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto[18]);
}
// ===================================================================

class RotationAndAccuracy_StdDev::_Internal {
 public:
  using HasBits = decltype(std::declval<RotationAndAccuracy_StdDev>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(RotationAndAccuracy_StdDev, _impl_._has_bits_);
  static const ::google::protobuf::Int64Value& yaw(const RotationAndAccuracy_StdDev* msg);
  static void set_has_yaw(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::google::protobuf::Int64Value& pitch(const RotationAndAccuracy_StdDev* msg);
  static void set_has_pitch(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::google::protobuf::Int64Value& roll(const RotationAndAccuracy_StdDev* msg);
  static void set_has_roll(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::google::protobuf::Int64Value& RotationAndAccuracy_StdDev::_Internal::yaw(const RotationAndAccuracy_StdDev* msg) {
  return *msg->_impl_.yaw_;
}
const ::google::protobuf::Int64Value& RotationAndAccuracy_StdDev::_Internal::pitch(const RotationAndAccuracy_StdDev* msg) {
  return *msg->_impl_.pitch_;
}
const ::google::protobuf::Int64Value& RotationAndAccuracy_StdDev::_Internal::roll(const RotationAndAccuracy_StdDev* msg) {
  return *msg->_impl_.roll_;
}
void RotationAndAccuracy_StdDev::clear_yaw() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.yaw_ != nullptr) _impl_.yaw_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void RotationAndAccuracy_StdDev::clear_pitch() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.pitch_ != nullptr) _impl_.pitch_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void RotationAndAccuracy_StdDev::clear_roll() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.roll_ != nullptr) _impl_.roll_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
RotationAndAccuracy_StdDev::RotationAndAccuracy_StdDev(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev)
}
inline PROTOBUF_NDEBUG_INLINE RotationAndAccuracy_StdDev::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

RotationAndAccuracy_StdDev::RotationAndAccuracy_StdDev(
    ::google::protobuf::Arena* arena,
    const RotationAndAccuracy_StdDev& from)
    : ::google::protobuf::Message(arena) {
  RotationAndAccuracy_StdDev* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.yaw_ = (cached_has_bits & 0x00000001u)
                ? CreateMaybeMessage<::google::protobuf::Int64Value>(arena, *from._impl_.yaw_)
                : nullptr;
  _impl_.pitch_ = (cached_has_bits & 0x00000002u)
                ? CreateMaybeMessage<::google::protobuf::Int64Value>(arena, *from._impl_.pitch_)
                : nullptr;
  _impl_.roll_ = (cached_has_bits & 0x00000004u)
                ? CreateMaybeMessage<::google::protobuf::Int64Value>(arena, *from._impl_.roll_)
                : nullptr;

  // @@protoc_insertion_point(copy_constructor:sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev)
}
inline PROTOBUF_NDEBUG_INLINE RotationAndAccuracy_StdDev::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void RotationAndAccuracy_StdDev::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, yaw_),
           0,
           offsetof(Impl_, roll_) -
               offsetof(Impl_, yaw_) +
               sizeof(Impl_::roll_));
}
RotationAndAccuracy_StdDev::~RotationAndAccuracy_StdDev() {
  // @@protoc_insertion_point(destructor:sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void RotationAndAccuracy_StdDev::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  delete _impl_.yaw_;
  delete _impl_.pitch_;
  delete _impl_.roll_;
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void RotationAndAccuracy_StdDev::Clear() {
// @@protoc_insertion_point(message_clear_start:sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.yaw_ != nullptr);
      _impl_.yaw_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.pitch_ != nullptr);
      _impl_.pitch_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.roll_ != nullptr);
      _impl_.roll_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* RotationAndAccuracy_StdDev::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 3, 0, 2> RotationAndAccuracy_StdDev::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(RotationAndAccuracy_StdDev, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    3,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_RotationAndAccuracy_StdDev_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // .google.protobuf.Int64Value yaw = 1 [(.sensoris.protobuf.types.base.exponent) = 2];
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(RotationAndAccuracy_StdDev, _impl_.yaw_)}},
    // .google.protobuf.Int64Value pitch = 2 [(.sensoris.protobuf.types.base.exponent) = 2];
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 1, PROTOBUF_FIELD_OFFSET(RotationAndAccuracy_StdDev, _impl_.pitch_)}},
    // .google.protobuf.Int64Value roll = 3 [(.sensoris.protobuf.types.base.exponent) = 2];
    {::_pbi::TcParser::FastMtS1,
     {26, 2, 2, PROTOBUF_FIELD_OFFSET(RotationAndAccuracy_StdDev, _impl_.roll_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .google.protobuf.Int64Value yaw = 1 [(.sensoris.protobuf.types.base.exponent) = 2];
    {PROTOBUF_FIELD_OFFSET(RotationAndAccuracy_StdDev, _impl_.yaw_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .google.protobuf.Int64Value pitch = 2 [(.sensoris.protobuf.types.base.exponent) = 2];
    {PROTOBUF_FIELD_OFFSET(RotationAndAccuracy_StdDev, _impl_.pitch_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .google.protobuf.Int64Value roll = 3 [(.sensoris.protobuf.types.base.exponent) = 2];
    {PROTOBUF_FIELD_OFFSET(RotationAndAccuracy_StdDev, _impl_.roll_), _Internal::kHasBitsOffset + 2, 2,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::google::protobuf::Int64Value>()},
    {::_pbi::TcParser::GetTable<::google::protobuf::Int64Value>()},
    {::_pbi::TcParser::GetTable<::google::protobuf::Int64Value>()},
  }}, {{
  }},
};

::uint8_t* RotationAndAccuracy_StdDev::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .google.protobuf.Int64Value yaw = 1 [(.sensoris.protobuf.types.base.exponent) = 2];
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        1, _Internal::yaw(this),
        _Internal::yaw(this).GetCachedSize(), target, stream);
  }

  // .google.protobuf.Int64Value pitch = 2 [(.sensoris.protobuf.types.base.exponent) = 2];
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, _Internal::pitch(this),
        _Internal::pitch(this).GetCachedSize(), target, stream);
  }

  // .google.protobuf.Int64Value roll = 3 [(.sensoris.protobuf.types.base.exponent) = 2];
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        3, _Internal::roll(this),
        _Internal::roll(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev)
  return target;
}

::size_t RotationAndAccuracy_StdDev::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // .google.protobuf.Int64Value yaw = 1 [(.sensoris.protobuf.types.base.exponent) = 2];
    if (cached_has_bits & 0x00000001u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.yaw_);
    }

    // .google.protobuf.Int64Value pitch = 2 [(.sensoris.protobuf.types.base.exponent) = 2];
    if (cached_has_bits & 0x00000002u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.pitch_);
    }

    // .google.protobuf.Int64Value roll = 3 [(.sensoris.protobuf.types.base.exponent) = 2];
    if (cached_has_bits & 0x00000004u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.roll_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData RotationAndAccuracy_StdDev::_class_data_ = {
    RotationAndAccuracy_StdDev::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* RotationAndAccuracy_StdDev::GetClassData() const {
  return &_class_data_;
}

void RotationAndAccuracy_StdDev::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<RotationAndAccuracy_StdDev*>(&to_msg);
  auto& from = static_cast<const RotationAndAccuracy_StdDev&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_yaw()->::google::protobuf::Int64Value::MergeFrom(
          from._internal_yaw());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_pitch()->::google::protobuf::Int64Value::MergeFrom(
          from._internal_pitch());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_roll()->::google::protobuf::Int64Value::MergeFrom(
          from._internal_roll());
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void RotationAndAccuracy_StdDev::CopyFrom(const RotationAndAccuracy_StdDev& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool RotationAndAccuracy_StdDev::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* RotationAndAccuracy_StdDev::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void RotationAndAccuracy_StdDev::InternalSwap(RotationAndAccuracy_StdDev* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RotationAndAccuracy_StdDev, _impl_.roll_)
      + sizeof(RotationAndAccuracy_StdDev::_impl_.roll_)
      - PROTOBUF_FIELD_OFFSET(RotationAndAccuracy_StdDev, _impl_.yaw_)>(
          reinterpret_cast<char*>(&_impl_.yaw_),
          reinterpret_cast<char*>(&other->_impl_.yaw_));
}

::google::protobuf::Metadata RotationAndAccuracy_StdDev::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto_getter, &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto_once,
      file_level_metadata_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto[19]);
}
// ===================================================================

class RotationAndAccuracy::_Internal {
 public:
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RotationAndAccuracy, _impl_._oneof_case_);
  static const ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler& euler_vehicle(const RotationAndAccuracy* msg);
  static const ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler& euler_event_group(const RotationAndAccuracy* msg);
  static const ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion& quaternion_vehicle(const RotationAndAccuracy* msg);
  static const ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion& quaternion_event_group(const RotationAndAccuracy* msg);
  static const ::google::protobuf::Int64Value& combined_std_dev(const RotationAndAccuracy* msg);
  static const ::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev& std_dev(const RotationAndAccuracy* msg);
  static const ::sensoris::protobuf::types::base::Int64Matrix3x3& covariance(const RotationAndAccuracy* msg);
};

const ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler& RotationAndAccuracy::_Internal::euler_vehicle(const RotationAndAccuracy* msg) {
  return *msg->_impl_.euler_quaternion_.euler_vehicle_;
}
const ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler& RotationAndAccuracy::_Internal::euler_event_group(const RotationAndAccuracy* msg) {
  return *msg->_impl_.euler_quaternion_.euler_event_group_;
}
const ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion& RotationAndAccuracy::_Internal::quaternion_vehicle(const RotationAndAccuracy* msg) {
  return *msg->_impl_.euler_quaternion_.quaternion_vehicle_;
}
const ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion& RotationAndAccuracy::_Internal::quaternion_event_group(const RotationAndAccuracy* msg) {
  return *msg->_impl_.euler_quaternion_.quaternion_event_group_;
}
const ::google::protobuf::Int64Value& RotationAndAccuracy::_Internal::combined_std_dev(const RotationAndAccuracy* msg) {
  return *msg->_impl_.accuracy_.combined_std_dev_;
}
const ::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev& RotationAndAccuracy::_Internal::std_dev(const RotationAndAccuracy* msg) {
  return *msg->_impl_.accuracy_.std_dev_;
}
const ::sensoris::protobuf::types::base::Int64Matrix3x3& RotationAndAccuracy::_Internal::covariance(const RotationAndAccuracy* msg) {
  return *msg->_impl_.accuracy_.covariance_;
}
void RotationAndAccuracy::set_allocated_euler_vehicle(::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* euler_vehicle) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_euler_quaternion();
  if (euler_vehicle) {
    ::google::protobuf::Arena* submessage_arena = euler_vehicle->GetArena();
    if (message_arena != submessage_arena) {
      euler_vehicle = ::google::protobuf::internal::GetOwnedMessage(message_arena, euler_vehicle, submessage_arena);
    }
    set_has_euler_vehicle();
    _impl_.euler_quaternion_.euler_vehicle_ = euler_vehicle;
  }
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.euler_vehicle)
}
void RotationAndAccuracy::set_allocated_euler_event_group(::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* euler_event_group) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_euler_quaternion();
  if (euler_event_group) {
    ::google::protobuf::Arena* submessage_arena = euler_event_group->GetArena();
    if (message_arena != submessage_arena) {
      euler_event_group = ::google::protobuf::internal::GetOwnedMessage(message_arena, euler_event_group, submessage_arena);
    }
    set_has_euler_event_group();
    _impl_.euler_quaternion_.euler_event_group_ = euler_event_group;
  }
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.euler_event_group)
}
void RotationAndAccuracy::set_allocated_quaternion_vehicle(::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* quaternion_vehicle) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_euler_quaternion();
  if (quaternion_vehicle) {
    ::google::protobuf::Arena* submessage_arena = quaternion_vehicle->GetArena();
    if (message_arena != submessage_arena) {
      quaternion_vehicle = ::google::protobuf::internal::GetOwnedMessage(message_arena, quaternion_vehicle, submessage_arena);
    }
    set_has_quaternion_vehicle();
    _impl_.euler_quaternion_.quaternion_vehicle_ = quaternion_vehicle;
  }
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.quaternion_vehicle)
}
void RotationAndAccuracy::set_allocated_quaternion_event_group(::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* quaternion_event_group) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_euler_quaternion();
  if (quaternion_event_group) {
    ::google::protobuf::Arena* submessage_arena = quaternion_event_group->GetArena();
    if (message_arena != submessage_arena) {
      quaternion_event_group = ::google::protobuf::internal::GetOwnedMessage(message_arena, quaternion_event_group, submessage_arena);
    }
    set_has_quaternion_event_group();
    _impl_.euler_quaternion_.quaternion_event_group_ = quaternion_event_group;
  }
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.quaternion_event_group)
}
void RotationAndAccuracy::set_allocated_combined_std_dev(::google::protobuf::Int64Value* combined_std_dev) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_accuracy();
  if (combined_std_dev) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(combined_std_dev)->GetArena();
    if (message_arena != submessage_arena) {
      combined_std_dev = ::google::protobuf::internal::GetOwnedMessage(message_arena, combined_std_dev, submessage_arena);
    }
    set_has_combined_std_dev();
    _impl_.accuracy_.combined_std_dev_ = combined_std_dev;
  }
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.combined_std_dev)
}
void RotationAndAccuracy::clear_combined_std_dev() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (accuracy_case() == kCombinedStdDev) {
    if (GetArena() == nullptr) {
      delete _impl_.accuracy_.combined_std_dev_;
    }
    clear_has_accuracy();
  }
}
void RotationAndAccuracy::set_allocated_std_dev(::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev* std_dev) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_accuracy();
  if (std_dev) {
    ::google::protobuf::Arena* submessage_arena = std_dev->GetArena();
    if (message_arena != submessage_arena) {
      std_dev = ::google::protobuf::internal::GetOwnedMessage(message_arena, std_dev, submessage_arena);
    }
    set_has_std_dev();
    _impl_.accuracy_.std_dev_ = std_dev;
  }
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.std_dev)
}
void RotationAndAccuracy::set_allocated_covariance(::sensoris::protobuf::types::base::Int64Matrix3x3* covariance) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_accuracy();
  if (covariance) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(covariance)->GetArena();
    if (message_arena != submessage_arena) {
      covariance = ::google::protobuf::internal::GetOwnedMessage(message_arena, covariance, submessage_arena);
    }
    set_has_covariance();
    _impl_.accuracy_.covariance_ = covariance;
  }
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.covariance)
}
void RotationAndAccuracy::clear_covariance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (accuracy_case() == kCovariance) {
    if (GetArena() == nullptr) {
      delete _impl_.accuracy_.covariance_;
    }
    clear_has_accuracy();
  }
}
void RotationAndAccuracy::clear_extension() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.extension_.Clear();
}
RotationAndAccuracy::RotationAndAccuracy(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:sensoris.protobuf.types.spatial.RotationAndAccuracy)
}
inline PROTOBUF_NDEBUG_INLINE RotationAndAccuracy::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : extension_{visibility, arena, from.extension_},
        euler_quaternion_{},
        accuracy_{},
        _cached_size_{0},
        _oneof_case_{from._oneof_case_[0], from._oneof_case_[1]} {}

RotationAndAccuracy::RotationAndAccuracy(
    ::google::protobuf::Arena* arena,
    const RotationAndAccuracy& from)
    : ::google::protobuf::Message(arena) {
  RotationAndAccuracy* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  switch (euler_quaternion_case()) {
    case EULER_QUATERNION_NOT_SET:
      break;
      case kEulerVehicle:
        _impl_.euler_quaternion_.euler_vehicle_ = CreateMaybeMessage<::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler>(arena, *from._impl_.euler_quaternion_.euler_vehicle_);
        break;
      case kEulerEventGroup:
        _impl_.euler_quaternion_.euler_event_group_ = CreateMaybeMessage<::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler>(arena, *from._impl_.euler_quaternion_.euler_event_group_);
        break;
      case kQuaternionVehicle:
        _impl_.euler_quaternion_.quaternion_vehicle_ = CreateMaybeMessage<::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion>(arena, *from._impl_.euler_quaternion_.quaternion_vehicle_);
        break;
      case kQuaternionEventGroup:
        _impl_.euler_quaternion_.quaternion_event_group_ = CreateMaybeMessage<::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion>(arena, *from._impl_.euler_quaternion_.quaternion_event_group_);
        break;
  }
  switch (accuracy_case()) {
    case ACCURACY_NOT_SET:
      break;
      case kCombinedStdDev:
        _impl_.accuracy_.combined_std_dev_ = CreateMaybeMessage<::google::protobuf::Int64Value>(arena, *from._impl_.accuracy_.combined_std_dev_);
        break;
      case kStdDev:
        _impl_.accuracy_.std_dev_ = CreateMaybeMessage<::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev>(arena, *from._impl_.accuracy_.std_dev_);
        break;
      case kCovariance:
        _impl_.accuracy_.covariance_ = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64Matrix3x3>(arena, *from._impl_.accuracy_.covariance_);
        break;
  }

  // @@protoc_insertion_point(copy_constructor:sensoris.protobuf.types.spatial.RotationAndAccuracy)
}
inline PROTOBUF_NDEBUG_INLINE RotationAndAccuracy::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : extension_{visibility, arena},
        euler_quaternion_{},
        accuracy_{},
        _cached_size_{0},
        _oneof_case_{} {}

inline void RotationAndAccuracy::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
RotationAndAccuracy::~RotationAndAccuracy() {
  // @@protoc_insertion_point(destructor:sensoris.protobuf.types.spatial.RotationAndAccuracy)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void RotationAndAccuracy::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  if (has_euler_quaternion()) {
    clear_euler_quaternion();
  }
  if (has_accuracy()) {
    clear_accuracy();
  }
  _impl_.~Impl_();
}

void RotationAndAccuracy::clear_euler_quaternion() {
// @@protoc_insertion_point(one_of_clear_start:sensoris.protobuf.types.spatial.RotationAndAccuracy)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  switch (euler_quaternion_case()) {
    case kEulerVehicle: {
      if (GetArena() == nullptr) {
        delete _impl_.euler_quaternion_.euler_vehicle_;
      }
      break;
    }
    case kEulerEventGroup: {
      if (GetArena() == nullptr) {
        delete _impl_.euler_quaternion_.euler_event_group_;
      }
      break;
    }
    case kQuaternionVehicle: {
      if (GetArena() == nullptr) {
        delete _impl_.euler_quaternion_.quaternion_vehicle_;
      }
      break;
    }
    case kQuaternionEventGroup: {
      if (GetArena() == nullptr) {
        delete _impl_.euler_quaternion_.quaternion_event_group_;
      }
      break;
    }
    case EULER_QUATERNION_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = EULER_QUATERNION_NOT_SET;
}

void RotationAndAccuracy::clear_accuracy() {
// @@protoc_insertion_point(one_of_clear_start:sensoris.protobuf.types.spatial.RotationAndAccuracy)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  switch (accuracy_case()) {
    case kCombinedStdDev: {
      if (GetArena() == nullptr) {
        delete _impl_.accuracy_.combined_std_dev_;
      }
      break;
    }
    case kStdDev: {
      if (GetArena() == nullptr) {
        delete _impl_.accuracy_.std_dev_;
      }
      break;
    }
    case kCovariance: {
      if (GetArena() == nullptr) {
        delete _impl_.accuracy_.covariance_;
      }
      break;
    }
    case ACCURACY_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[1] = ACCURACY_NOT_SET;
}


PROTOBUF_NOINLINE void RotationAndAccuracy::Clear() {
// @@protoc_insertion_point(message_clear_start:sensoris.protobuf.types.spatial.RotationAndAccuracy)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.extension_.Clear();
  clear_euler_quaternion();
  clear_accuracy();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* RotationAndAccuracy::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 8, 8, 0, 2> RotationAndAccuracy::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    15, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294950784,  // skipmap
    offsetof(decltype(_table_), field_entries),
    8,  // num_field_entries
    8,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_RotationAndAccuracy_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // repeated .google.protobuf.Any extension = 15;
    {::_pbi::TcParser::FastMtR1,
     {122, 63, 7, PROTOBUF_FIELD_OFFSET(RotationAndAccuracy, _impl_.extension_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler euler_vehicle = 1;
    {PROTOBUF_FIELD_OFFSET(RotationAndAccuracy, _impl_.euler_quaternion_.euler_vehicle_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler euler_event_group = 2;
    {PROTOBUF_FIELD_OFFSET(RotationAndAccuracy, _impl_.euler_quaternion_.euler_event_group_), _Internal::kOneofCaseOffset + 0, 1,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion quaternion_vehicle = 3;
    {PROTOBUF_FIELD_OFFSET(RotationAndAccuracy, _impl_.euler_quaternion_.quaternion_vehicle_), _Internal::kOneofCaseOffset + 0, 2,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion quaternion_event_group = 4;
    {PROTOBUF_FIELD_OFFSET(RotationAndAccuracy, _impl_.euler_quaternion_.quaternion_event_group_), _Internal::kOneofCaseOffset + 0, 3,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .google.protobuf.Int64Value combined_std_dev = 5 [(.sensoris.protobuf.types.base.exponent) = 2];
    {PROTOBUF_FIELD_OFFSET(RotationAndAccuracy, _impl_.accuracy_.combined_std_dev_), _Internal::kOneofCaseOffset + 4, 4,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev std_dev = 6;
    {PROTOBUF_FIELD_OFFSET(RotationAndAccuracy, _impl_.accuracy_.std_dev_), _Internal::kOneofCaseOffset + 4, 5,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.base.Int64Matrix3x3 covariance = 7 [(.sensoris.protobuf.types.base.exponent) = 2];
    {PROTOBUF_FIELD_OFFSET(RotationAndAccuracy, _impl_.accuracy_.covariance_), _Internal::kOneofCaseOffset + 4, 6,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .google.protobuf.Any extension = 15;
    {PROTOBUF_FIELD_OFFSET(RotationAndAccuracy, _impl_.extension_), 0, 7,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler>()},
    {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler>()},
    {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion>()},
    {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion>()},
    {::_pbi::TcParser::GetTable<::google::protobuf::Int64Value>()},
    {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev>()},
    {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::base::Int64Matrix3x3>()},
    {::_pbi::TcParser::GetTable<::google::protobuf::Any>()},
  }}, {{
  }},
};

::uint8_t* RotationAndAccuracy::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sensoris.protobuf.types.spatial.RotationAndAccuracy)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  switch (euler_quaternion_case()) {
    case kEulerVehicle: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          1, _Internal::euler_vehicle(this),
          _Internal::euler_vehicle(this).GetCachedSize(), target, stream);
      break;
    }
    case kEulerEventGroup: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          2, _Internal::euler_event_group(this),
          _Internal::euler_event_group(this).GetCachedSize(), target, stream);
      break;
    }
    case kQuaternionVehicle: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          3, _Internal::quaternion_vehicle(this),
          _Internal::quaternion_vehicle(this).GetCachedSize(), target, stream);
      break;
    }
    case kQuaternionEventGroup: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          4, _Internal::quaternion_event_group(this),
          _Internal::quaternion_event_group(this).GetCachedSize(), target, stream);
      break;
    }
    default:
      break;
  }
  switch (accuracy_case()) {
    case kCombinedStdDev: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          5, _Internal::combined_std_dev(this),
          _Internal::combined_std_dev(this).GetCachedSize(), target, stream);
      break;
    }
    case kStdDev: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          6, _Internal::std_dev(this),
          _Internal::std_dev(this).GetCachedSize(), target, stream);
      break;
    }
    case kCovariance: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          7, _Internal::covariance(this),
          _Internal::covariance(this).GetCachedSize(), target, stream);
      break;
    }
    default:
      break;
  }
  // repeated .google.protobuf.Any extension = 15;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_extension_size()); i < n; i++) {
    const auto& repfield = this->_internal_extension().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(15, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sensoris.protobuf.types.spatial.RotationAndAccuracy)
  return target;
}

::size_t RotationAndAccuracy::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sensoris.protobuf.types.spatial.RotationAndAccuracy)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .google.protobuf.Any extension = 15;
  total_size += 1UL * this->_internal_extension_size();
  for (const auto& msg : this->_internal_extension()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  switch (euler_quaternion_case()) {
    // .sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler euler_vehicle = 1;
    case kEulerVehicle: {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.euler_quaternion_.euler_vehicle_);
      break;
    }
    // .sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler euler_event_group = 2;
    case kEulerEventGroup: {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.euler_quaternion_.euler_event_group_);
      break;
    }
    // .sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion quaternion_vehicle = 3;
    case kQuaternionVehicle: {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.euler_quaternion_.quaternion_vehicle_);
      break;
    }
    // .sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion quaternion_event_group = 4;
    case kQuaternionEventGroup: {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.euler_quaternion_.quaternion_event_group_);
      break;
    }
    case EULER_QUATERNION_NOT_SET: {
      break;
    }
  }
  switch (accuracy_case()) {
    // .google.protobuf.Int64Value combined_std_dev = 5 [(.sensoris.protobuf.types.base.exponent) = 2];
    case kCombinedStdDev: {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.accuracy_.combined_std_dev_);
      break;
    }
    // .sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev std_dev = 6;
    case kStdDev: {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.accuracy_.std_dev_);
      break;
    }
    // .sensoris.protobuf.types.base.Int64Matrix3x3 covariance = 7 [(.sensoris.protobuf.types.base.exponent) = 2];
    case kCovariance: {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.accuracy_.covariance_);
      break;
    }
    case ACCURACY_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData RotationAndAccuracy::_class_data_ = {
    RotationAndAccuracy::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* RotationAndAccuracy::GetClassData() const {
  return &_class_data_;
}

void RotationAndAccuracy::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<RotationAndAccuracy*>(&to_msg);
  auto& from = static_cast<const RotationAndAccuracy&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:sensoris.protobuf.types.spatial.RotationAndAccuracy)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_extension()->MergeFrom(
      from._internal_extension());
  switch (from.euler_quaternion_case()) {
    case kEulerVehicle: {
      _this->_internal_mutable_euler_vehicle()->::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler::MergeFrom(
          from._internal_euler_vehicle());
      break;
    }
    case kEulerEventGroup: {
      _this->_internal_mutable_euler_event_group()->::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler::MergeFrom(
          from._internal_euler_event_group());
      break;
    }
    case kQuaternionVehicle: {
      _this->_internal_mutable_quaternion_vehicle()->::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion::MergeFrom(
          from._internal_quaternion_vehicle());
      break;
    }
    case kQuaternionEventGroup: {
      _this->_internal_mutable_quaternion_event_group()->::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion::MergeFrom(
          from._internal_quaternion_event_group());
      break;
    }
    case EULER_QUATERNION_NOT_SET: {
      break;
    }
  }
  switch (from.accuracy_case()) {
    case kCombinedStdDev: {
      _this->_internal_mutable_combined_std_dev()->::google::protobuf::Int64Value::MergeFrom(
          from._internal_combined_std_dev());
      break;
    }
    case kStdDev: {
      _this->_internal_mutable_std_dev()->::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev::MergeFrom(
          from._internal_std_dev());
      break;
    }
    case kCovariance: {
      _this->_internal_mutable_covariance()->::sensoris::protobuf::types::base::Int64Matrix3x3::MergeFrom(
          from._internal_covariance());
      break;
    }
    case ACCURACY_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void RotationAndAccuracy::CopyFrom(const RotationAndAccuracy& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sensoris.protobuf.types.spatial.RotationAndAccuracy)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool RotationAndAccuracy::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* RotationAndAccuracy::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void RotationAndAccuracy::InternalSwap(RotationAndAccuracy* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.extension_.InternalSwap(&other->_impl_.extension_);
  swap(_impl_.euler_quaternion_, other->_impl_.euler_quaternion_);
  swap(_impl_.accuracy_, other->_impl_.accuracy_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
  swap(_impl_._oneof_case_[1], other->_impl_._oneof_case_[1]);
}

::google::protobuf::Metadata RotationAndAccuracy::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto_getter, &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto_once,
      file_level_metadata_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto[20]);
}
// ===================================================================

class RotationRateAndAccuracy_StdDev::_Internal {
 public:
  using HasBits = decltype(std::declval<RotationRateAndAccuracy_StdDev>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(RotationRateAndAccuracy_StdDev, _impl_._has_bits_);
  static const ::google::protobuf::Int64Value& yaw(const RotationRateAndAccuracy_StdDev* msg);
  static void set_has_yaw(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::google::protobuf::Int64Value& pitch(const RotationRateAndAccuracy_StdDev* msg);
  static void set_has_pitch(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::google::protobuf::Int64Value& roll(const RotationRateAndAccuracy_StdDev* msg);
  static void set_has_roll(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::google::protobuf::Int64Value& RotationRateAndAccuracy_StdDev::_Internal::yaw(const RotationRateAndAccuracy_StdDev* msg) {
  return *msg->_impl_.yaw_;
}
const ::google::protobuf::Int64Value& RotationRateAndAccuracy_StdDev::_Internal::pitch(const RotationRateAndAccuracy_StdDev* msg) {
  return *msg->_impl_.pitch_;
}
const ::google::protobuf::Int64Value& RotationRateAndAccuracy_StdDev::_Internal::roll(const RotationRateAndAccuracy_StdDev* msg) {
  return *msg->_impl_.roll_;
}
void RotationRateAndAccuracy_StdDev::clear_yaw() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.yaw_ != nullptr) _impl_.yaw_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void RotationRateAndAccuracy_StdDev::clear_pitch() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.pitch_ != nullptr) _impl_.pitch_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void RotationRateAndAccuracy_StdDev::clear_roll() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.roll_ != nullptr) _impl_.roll_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
RotationRateAndAccuracy_StdDev::RotationRateAndAccuracy_StdDev(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev)
}
inline PROTOBUF_NDEBUG_INLINE RotationRateAndAccuracy_StdDev::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

RotationRateAndAccuracy_StdDev::RotationRateAndAccuracy_StdDev(
    ::google::protobuf::Arena* arena,
    const RotationRateAndAccuracy_StdDev& from)
    : ::google::protobuf::Message(arena) {
  RotationRateAndAccuracy_StdDev* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.yaw_ = (cached_has_bits & 0x00000001u)
                ? CreateMaybeMessage<::google::protobuf::Int64Value>(arena, *from._impl_.yaw_)
                : nullptr;
  _impl_.pitch_ = (cached_has_bits & 0x00000002u)
                ? CreateMaybeMessage<::google::protobuf::Int64Value>(arena, *from._impl_.pitch_)
                : nullptr;
  _impl_.roll_ = (cached_has_bits & 0x00000004u)
                ? CreateMaybeMessage<::google::protobuf::Int64Value>(arena, *from._impl_.roll_)
                : nullptr;

  // @@protoc_insertion_point(copy_constructor:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev)
}
inline PROTOBUF_NDEBUG_INLINE RotationRateAndAccuracy_StdDev::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void RotationRateAndAccuracy_StdDev::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, yaw_),
           0,
           offsetof(Impl_, roll_) -
               offsetof(Impl_, yaw_) +
               sizeof(Impl_::roll_));
}
RotationRateAndAccuracy_StdDev::~RotationRateAndAccuracy_StdDev() {
  // @@protoc_insertion_point(destructor:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void RotationRateAndAccuracy_StdDev::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  delete _impl_.yaw_;
  delete _impl_.pitch_;
  delete _impl_.roll_;
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void RotationRateAndAccuracy_StdDev::Clear() {
// @@protoc_insertion_point(message_clear_start:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.yaw_ != nullptr);
      _impl_.yaw_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.pitch_ != nullptr);
      _impl_.pitch_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.roll_ != nullptr);
      _impl_.roll_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* RotationRateAndAccuracy_StdDev::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 3, 0, 2> RotationRateAndAccuracy_StdDev::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(RotationRateAndAccuracy_StdDev, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    3,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_RotationRateAndAccuracy_StdDev_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // .google.protobuf.Int64Value yaw = 1 [(.sensoris.protobuf.types.base.exponent) = 2];
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(RotationRateAndAccuracy_StdDev, _impl_.yaw_)}},
    // .google.protobuf.Int64Value pitch = 2 [(.sensoris.protobuf.types.base.exponent) = 2];
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 1, PROTOBUF_FIELD_OFFSET(RotationRateAndAccuracy_StdDev, _impl_.pitch_)}},
    // .google.protobuf.Int64Value roll = 3 [(.sensoris.protobuf.types.base.exponent) = 2];
    {::_pbi::TcParser::FastMtS1,
     {26, 2, 2, PROTOBUF_FIELD_OFFSET(RotationRateAndAccuracy_StdDev, _impl_.roll_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .google.protobuf.Int64Value yaw = 1 [(.sensoris.protobuf.types.base.exponent) = 2];
    {PROTOBUF_FIELD_OFFSET(RotationRateAndAccuracy_StdDev, _impl_.yaw_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .google.protobuf.Int64Value pitch = 2 [(.sensoris.protobuf.types.base.exponent) = 2];
    {PROTOBUF_FIELD_OFFSET(RotationRateAndAccuracy_StdDev, _impl_.pitch_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .google.protobuf.Int64Value roll = 3 [(.sensoris.protobuf.types.base.exponent) = 2];
    {PROTOBUF_FIELD_OFFSET(RotationRateAndAccuracy_StdDev, _impl_.roll_), _Internal::kHasBitsOffset + 2, 2,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::google::protobuf::Int64Value>()},
    {::_pbi::TcParser::GetTable<::google::protobuf::Int64Value>()},
    {::_pbi::TcParser::GetTable<::google::protobuf::Int64Value>()},
  }}, {{
  }},
};

::uint8_t* RotationRateAndAccuracy_StdDev::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .google.protobuf.Int64Value yaw = 1 [(.sensoris.protobuf.types.base.exponent) = 2];
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        1, _Internal::yaw(this),
        _Internal::yaw(this).GetCachedSize(), target, stream);
  }

  // .google.protobuf.Int64Value pitch = 2 [(.sensoris.protobuf.types.base.exponent) = 2];
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, _Internal::pitch(this),
        _Internal::pitch(this).GetCachedSize(), target, stream);
  }

  // .google.protobuf.Int64Value roll = 3 [(.sensoris.protobuf.types.base.exponent) = 2];
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        3, _Internal::roll(this),
        _Internal::roll(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev)
  return target;
}

::size_t RotationRateAndAccuracy_StdDev::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // .google.protobuf.Int64Value yaw = 1 [(.sensoris.protobuf.types.base.exponent) = 2];
    if (cached_has_bits & 0x00000001u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.yaw_);
    }

    // .google.protobuf.Int64Value pitch = 2 [(.sensoris.protobuf.types.base.exponent) = 2];
    if (cached_has_bits & 0x00000002u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.pitch_);
    }

    // .google.protobuf.Int64Value roll = 3 [(.sensoris.protobuf.types.base.exponent) = 2];
    if (cached_has_bits & 0x00000004u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.roll_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData RotationRateAndAccuracy_StdDev::_class_data_ = {
    RotationRateAndAccuracy_StdDev::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* RotationRateAndAccuracy_StdDev::GetClassData() const {
  return &_class_data_;
}

void RotationRateAndAccuracy_StdDev::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<RotationRateAndAccuracy_StdDev*>(&to_msg);
  auto& from = static_cast<const RotationRateAndAccuracy_StdDev&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_yaw()->::google::protobuf::Int64Value::MergeFrom(
          from._internal_yaw());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_pitch()->::google::protobuf::Int64Value::MergeFrom(
          from._internal_pitch());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_roll()->::google::protobuf::Int64Value::MergeFrom(
          from._internal_roll());
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void RotationRateAndAccuracy_StdDev::CopyFrom(const RotationRateAndAccuracy_StdDev& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool RotationRateAndAccuracy_StdDev::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* RotationRateAndAccuracy_StdDev::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void RotationRateAndAccuracy_StdDev::InternalSwap(RotationRateAndAccuracy_StdDev* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RotationRateAndAccuracy_StdDev, _impl_.roll_)
      + sizeof(RotationRateAndAccuracy_StdDev::_impl_.roll_)
      - PROTOBUF_FIELD_OFFSET(RotationRateAndAccuracy_StdDev, _impl_.yaw_)>(
          reinterpret_cast<char*>(&_impl_.yaw_),
          reinterpret_cast<char*>(&other->_impl_.yaw_));
}

::google::protobuf::Metadata RotationRateAndAccuracy_StdDev::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto_getter, &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto_once,
      file_level_metadata_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto[21]);
}
// ===================================================================

class RotationRateAndAccuracy::_Internal {
 public:
  using HasBits = decltype(std::declval<RotationRateAndAccuracy>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(RotationRateAndAccuracy, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::RotationRateAndAccuracy, _impl_._oneof_case_);
  static const ::sensoris::protobuf::types::base::Int64Value& yaw(const RotationRateAndAccuracy* msg);
  static void set_has_yaw(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::sensoris::protobuf::types::base::Int64Value& pitch(const RotationRateAndAccuracy* msg);
  static void set_has_pitch(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::sensoris::protobuf::types::base::Int64Value& roll(const RotationRateAndAccuracy* msg);
  static void set_has_roll(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::google::protobuf::Int64Value& combined_std_dev(const RotationRateAndAccuracy* msg);
  static const ::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev& std_dev(const RotationRateAndAccuracy* msg);
  static const ::sensoris::protobuf::types::base::Int64Matrix3x3& covariance(const RotationRateAndAccuracy* msg);
};

const ::sensoris::protobuf::types::base::Int64Value& RotationRateAndAccuracy::_Internal::yaw(const RotationRateAndAccuracy* msg) {
  return *msg->_impl_.yaw_;
}
const ::sensoris::protobuf::types::base::Int64Value& RotationRateAndAccuracy::_Internal::pitch(const RotationRateAndAccuracy* msg) {
  return *msg->_impl_.pitch_;
}
const ::sensoris::protobuf::types::base::Int64Value& RotationRateAndAccuracy::_Internal::roll(const RotationRateAndAccuracy* msg) {
  return *msg->_impl_.roll_;
}
const ::google::protobuf::Int64Value& RotationRateAndAccuracy::_Internal::combined_std_dev(const RotationRateAndAccuracy* msg) {
  return *msg->_impl_.accuracy_.combined_std_dev_;
}
const ::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev& RotationRateAndAccuracy::_Internal::std_dev(const RotationRateAndAccuracy* msg) {
  return *msg->_impl_.accuracy_.std_dev_;
}
const ::sensoris::protobuf::types::base::Int64Matrix3x3& RotationRateAndAccuracy::_Internal::covariance(const RotationRateAndAccuracy* msg) {
  return *msg->_impl_.accuracy_.covariance_;
}
void RotationRateAndAccuracy::clear_yaw() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.yaw_ != nullptr) _impl_.yaw_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void RotationRateAndAccuracy::clear_pitch() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.pitch_ != nullptr) _impl_.pitch_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void RotationRateAndAccuracy::clear_roll() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.roll_ != nullptr) _impl_.roll_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void RotationRateAndAccuracy::set_allocated_combined_std_dev(::google::protobuf::Int64Value* combined_std_dev) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_accuracy();
  if (combined_std_dev) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(combined_std_dev)->GetArena();
    if (message_arena != submessage_arena) {
      combined_std_dev = ::google::protobuf::internal::GetOwnedMessage(message_arena, combined_std_dev, submessage_arena);
    }
    set_has_combined_std_dev();
    _impl_.accuracy_.combined_std_dev_ = combined_std_dev;
  }
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.combined_std_dev)
}
void RotationRateAndAccuracy::clear_combined_std_dev() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (accuracy_case() == kCombinedStdDev) {
    if (GetArena() == nullptr) {
      delete _impl_.accuracy_.combined_std_dev_;
    }
    clear_has_accuracy();
  }
}
void RotationRateAndAccuracy::set_allocated_std_dev(::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev* std_dev) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_accuracy();
  if (std_dev) {
    ::google::protobuf::Arena* submessage_arena = std_dev->GetArena();
    if (message_arena != submessage_arena) {
      std_dev = ::google::protobuf::internal::GetOwnedMessage(message_arena, std_dev, submessage_arena);
    }
    set_has_std_dev();
    _impl_.accuracy_.std_dev_ = std_dev;
  }
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.std_dev)
}
void RotationRateAndAccuracy::set_allocated_covariance(::sensoris::protobuf::types::base::Int64Matrix3x3* covariance) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_accuracy();
  if (covariance) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(covariance)->GetArena();
    if (message_arena != submessage_arena) {
      covariance = ::google::protobuf::internal::GetOwnedMessage(message_arena, covariance, submessage_arena);
    }
    set_has_covariance();
    _impl_.accuracy_.covariance_ = covariance;
  }
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.covariance)
}
void RotationRateAndAccuracy::clear_covariance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (accuracy_case() == kCovariance) {
    if (GetArena() == nullptr) {
      delete _impl_.accuracy_.covariance_;
    }
    clear_has_accuracy();
  }
}
void RotationRateAndAccuracy::clear_extension() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.extension_.Clear();
}
RotationRateAndAccuracy::RotationRateAndAccuracy(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:sensoris.protobuf.types.spatial.RotationRateAndAccuracy)
}
inline PROTOBUF_NDEBUG_INLINE RotationRateAndAccuracy::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        extension_{visibility, arena, from.extension_},
        accuracy_{},
        _oneof_case_{from._oneof_case_[0]} {}

RotationRateAndAccuracy::RotationRateAndAccuracy(
    ::google::protobuf::Arena* arena,
    const RotationRateAndAccuracy& from)
    : ::google::protobuf::Message(arena) {
  RotationRateAndAccuracy* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.yaw_ = (cached_has_bits & 0x00000001u)
                ? CreateMaybeMessage<::sensoris::protobuf::types::base::Int64Value>(arena, *from._impl_.yaw_)
                : nullptr;
  _impl_.pitch_ = (cached_has_bits & 0x00000002u)
                ? CreateMaybeMessage<::sensoris::protobuf::types::base::Int64Value>(arena, *from._impl_.pitch_)
                : nullptr;
  _impl_.roll_ = (cached_has_bits & 0x00000004u)
                ? CreateMaybeMessage<::sensoris::protobuf::types::base::Int64Value>(arena, *from._impl_.roll_)
                : nullptr;
  switch (accuracy_case()) {
    case ACCURACY_NOT_SET:
      break;
      case kCombinedStdDev:
        _impl_.accuracy_.combined_std_dev_ = CreateMaybeMessage<::google::protobuf::Int64Value>(arena, *from._impl_.accuracy_.combined_std_dev_);
        break;
      case kStdDev:
        _impl_.accuracy_.std_dev_ = CreateMaybeMessage<::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev>(arena, *from._impl_.accuracy_.std_dev_);
        break;
      case kCovariance:
        _impl_.accuracy_.covariance_ = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64Matrix3x3>(arena, *from._impl_.accuracy_.covariance_);
        break;
  }

  // @@protoc_insertion_point(copy_constructor:sensoris.protobuf.types.spatial.RotationRateAndAccuracy)
}
inline PROTOBUF_NDEBUG_INLINE RotationRateAndAccuracy::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        extension_{visibility, arena},
        accuracy_{},
        _oneof_case_{} {}

inline void RotationRateAndAccuracy::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, yaw_),
           0,
           offsetof(Impl_, roll_) -
               offsetof(Impl_, yaw_) +
               sizeof(Impl_::roll_));
}
RotationRateAndAccuracy::~RotationRateAndAccuracy() {
  // @@protoc_insertion_point(destructor:sensoris.protobuf.types.spatial.RotationRateAndAccuracy)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void RotationRateAndAccuracy::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  delete _impl_.yaw_;
  delete _impl_.pitch_;
  delete _impl_.roll_;
  if (has_accuracy()) {
    clear_accuracy();
  }
  _impl_.~Impl_();
}

void RotationRateAndAccuracy::clear_accuracy() {
// @@protoc_insertion_point(one_of_clear_start:sensoris.protobuf.types.spatial.RotationRateAndAccuracy)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  switch (accuracy_case()) {
    case kCombinedStdDev: {
      if (GetArena() == nullptr) {
        delete _impl_.accuracy_.combined_std_dev_;
      }
      break;
    }
    case kStdDev: {
      if (GetArena() == nullptr) {
        delete _impl_.accuracy_.std_dev_;
      }
      break;
    }
    case kCovariance: {
      if (GetArena() == nullptr) {
        delete _impl_.accuracy_.covariance_;
      }
      break;
    }
    case ACCURACY_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = ACCURACY_NOT_SET;
}


PROTOBUF_NOINLINE void RotationRateAndAccuracy::Clear() {
// @@protoc_insertion_point(message_clear_start:sensoris.protobuf.types.spatial.RotationRateAndAccuracy)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.extension_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.yaw_ != nullptr);
      _impl_.yaw_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.pitch_ != nullptr);
      _impl_.pitch_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.roll_ != nullptr);
      _impl_.roll_->Clear();
    }
  }
  clear_accuracy();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* RotationRateAndAccuracy::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 7, 7, 0, 2> RotationRateAndAccuracy::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(RotationRateAndAccuracy, _impl_._has_bits_),
    0, // no _extensions_
    15, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294950848,  // skipmap
    offsetof(decltype(_table_), field_entries),
    7,  // num_field_entries
    7,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_RotationRateAndAccuracy_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // .sensoris.protobuf.types.base.Int64Value yaw = 1 [(.sensoris.protobuf.types.base.exponent) = 2];
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(RotationRateAndAccuracy, _impl_.yaw_)}},
    // .sensoris.protobuf.types.base.Int64Value pitch = 2 [(.sensoris.protobuf.types.base.exponent) = 2];
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 1, PROTOBUF_FIELD_OFFSET(RotationRateAndAccuracy, _impl_.pitch_)}},
    // .sensoris.protobuf.types.base.Int64Value roll = 3 [(.sensoris.protobuf.types.base.exponent) = 2];
    {::_pbi::TcParser::FastMtS1,
     {26, 2, 2, PROTOBUF_FIELD_OFFSET(RotationRateAndAccuracy, _impl_.roll_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    // repeated .google.protobuf.Any extension = 15;
    {::_pbi::TcParser::FastMtR1,
     {122, 63, 6, PROTOBUF_FIELD_OFFSET(RotationRateAndAccuracy, _impl_.extension_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .sensoris.protobuf.types.base.Int64Value yaw = 1 [(.sensoris.protobuf.types.base.exponent) = 2];
    {PROTOBUF_FIELD_OFFSET(RotationRateAndAccuracy, _impl_.yaw_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.base.Int64Value pitch = 2 [(.sensoris.protobuf.types.base.exponent) = 2];
    {PROTOBUF_FIELD_OFFSET(RotationRateAndAccuracy, _impl_.pitch_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.base.Int64Value roll = 3 [(.sensoris.protobuf.types.base.exponent) = 2];
    {PROTOBUF_FIELD_OFFSET(RotationRateAndAccuracy, _impl_.roll_), _Internal::kHasBitsOffset + 2, 2,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .google.protobuf.Int64Value combined_std_dev = 4 [(.sensoris.protobuf.types.base.exponent) = 2];
    {PROTOBUF_FIELD_OFFSET(RotationRateAndAccuracy, _impl_.accuracy_.combined_std_dev_), _Internal::kOneofCaseOffset + 0, 3,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev std_dev = 5;
    {PROTOBUF_FIELD_OFFSET(RotationRateAndAccuracy, _impl_.accuracy_.std_dev_), _Internal::kOneofCaseOffset + 0, 4,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.base.Int64Matrix3x3 covariance = 6 [(.sensoris.protobuf.types.base.exponent) = 2];
    {PROTOBUF_FIELD_OFFSET(RotationRateAndAccuracy, _impl_.accuracy_.covariance_), _Internal::kOneofCaseOffset + 0, 5,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .google.protobuf.Any extension = 15;
    {PROTOBUF_FIELD_OFFSET(RotationRateAndAccuracy, _impl_.extension_), -1, 6,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::base::Int64Value>()},
    {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::base::Int64Value>()},
    {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::base::Int64Value>()},
    {::_pbi::TcParser::GetTable<::google::protobuf::Int64Value>()},
    {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev>()},
    {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::base::Int64Matrix3x3>()},
    {::_pbi::TcParser::GetTable<::google::protobuf::Any>()},
  }}, {{
  }},
};

::uint8_t* RotationRateAndAccuracy::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sensoris.protobuf.types.spatial.RotationRateAndAccuracy)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .sensoris.protobuf.types.base.Int64Value yaw = 1 [(.sensoris.protobuf.types.base.exponent) = 2];
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        1, _Internal::yaw(this),
        _Internal::yaw(this).GetCachedSize(), target, stream);
  }

  // .sensoris.protobuf.types.base.Int64Value pitch = 2 [(.sensoris.protobuf.types.base.exponent) = 2];
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, _Internal::pitch(this),
        _Internal::pitch(this).GetCachedSize(), target, stream);
  }

  // .sensoris.protobuf.types.base.Int64Value roll = 3 [(.sensoris.protobuf.types.base.exponent) = 2];
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        3, _Internal::roll(this),
        _Internal::roll(this).GetCachedSize(), target, stream);
  }

  switch (accuracy_case()) {
    case kCombinedStdDev: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          4, _Internal::combined_std_dev(this),
          _Internal::combined_std_dev(this).GetCachedSize(), target, stream);
      break;
    }
    case kStdDev: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          5, _Internal::std_dev(this),
          _Internal::std_dev(this).GetCachedSize(), target, stream);
      break;
    }
    case kCovariance: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          6, _Internal::covariance(this),
          _Internal::covariance(this).GetCachedSize(), target, stream);
      break;
    }
    default:
      break;
  }
  // repeated .google.protobuf.Any extension = 15;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_extension_size()); i < n; i++) {
    const auto& repfield = this->_internal_extension().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(15, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sensoris.protobuf.types.spatial.RotationRateAndAccuracy)
  return target;
}

::size_t RotationRateAndAccuracy::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sensoris.protobuf.types.spatial.RotationRateAndAccuracy)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .google.protobuf.Any extension = 15;
  total_size += 1UL * this->_internal_extension_size();
  for (const auto& msg : this->_internal_extension()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // .sensoris.protobuf.types.base.Int64Value yaw = 1 [(.sensoris.protobuf.types.base.exponent) = 2];
    if (cached_has_bits & 0x00000001u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.yaw_);
    }

    // .sensoris.protobuf.types.base.Int64Value pitch = 2 [(.sensoris.protobuf.types.base.exponent) = 2];
    if (cached_has_bits & 0x00000002u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.pitch_);
    }

    // .sensoris.protobuf.types.base.Int64Value roll = 3 [(.sensoris.protobuf.types.base.exponent) = 2];
    if (cached_has_bits & 0x00000004u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.roll_);
    }

  }
  switch (accuracy_case()) {
    // .google.protobuf.Int64Value combined_std_dev = 4 [(.sensoris.protobuf.types.base.exponent) = 2];
    case kCombinedStdDev: {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.accuracy_.combined_std_dev_);
      break;
    }
    // .sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev std_dev = 5;
    case kStdDev: {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.accuracy_.std_dev_);
      break;
    }
    // .sensoris.protobuf.types.base.Int64Matrix3x3 covariance = 6 [(.sensoris.protobuf.types.base.exponent) = 2];
    case kCovariance: {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.accuracy_.covariance_);
      break;
    }
    case ACCURACY_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData RotationRateAndAccuracy::_class_data_ = {
    RotationRateAndAccuracy::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* RotationRateAndAccuracy::GetClassData() const {
  return &_class_data_;
}

void RotationRateAndAccuracy::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<RotationRateAndAccuracy*>(&to_msg);
  auto& from = static_cast<const RotationRateAndAccuracy&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:sensoris.protobuf.types.spatial.RotationRateAndAccuracy)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_extension()->MergeFrom(
      from._internal_extension());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_yaw()->::sensoris::protobuf::types::base::Int64Value::MergeFrom(
          from._internal_yaw());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_pitch()->::sensoris::protobuf::types::base::Int64Value::MergeFrom(
          from._internal_pitch());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_roll()->::sensoris::protobuf::types::base::Int64Value::MergeFrom(
          from._internal_roll());
    }
  }
  switch (from.accuracy_case()) {
    case kCombinedStdDev: {
      _this->_internal_mutable_combined_std_dev()->::google::protobuf::Int64Value::MergeFrom(
          from._internal_combined_std_dev());
      break;
    }
    case kStdDev: {
      _this->_internal_mutable_std_dev()->::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev::MergeFrom(
          from._internal_std_dev());
      break;
    }
    case kCovariance: {
      _this->_internal_mutable_covariance()->::sensoris::protobuf::types::base::Int64Matrix3x3::MergeFrom(
          from._internal_covariance());
      break;
    }
    case ACCURACY_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void RotationRateAndAccuracy::CopyFrom(const RotationRateAndAccuracy& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sensoris.protobuf.types.spatial.RotationRateAndAccuracy)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool RotationRateAndAccuracy::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* RotationRateAndAccuracy::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void RotationRateAndAccuracy::InternalSwap(RotationRateAndAccuracy* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.extension_.InternalSwap(&other->_impl_.extension_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RotationRateAndAccuracy, _impl_.roll_)
      + sizeof(RotationRateAndAccuracy::_impl_.roll_)
      - PROTOBUF_FIELD_OFFSET(RotationRateAndAccuracy, _impl_.yaw_)>(
          reinterpret_cast<char*>(&_impl_.yaw_),
          reinterpret_cast<char*>(&other->_impl_.yaw_));
  swap(_impl_.accuracy_, other->_impl_.accuracy_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::google::protobuf::Metadata RotationRateAndAccuracy::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto_getter, &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto_once,
      file_level_metadata_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto[22]);
}
// ===================================================================

class MapLocationReference_TileIdLinkIdOffset::_Internal {
 public:
  using HasBits = decltype(std::declval<MapLocationReference_TileIdLinkIdOffset>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(MapLocationReference_TileIdLinkIdOffset, _impl_._has_bits_);
  static const ::google::protobuf::Int64Value& tile_id(const MapLocationReference_TileIdLinkIdOffset* msg);
  static void set_has_tile_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::google::protobuf::Int64Value& link_id(const MapLocationReference_TileIdLinkIdOffset* msg);
  static void set_has_link_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::google::protobuf::Int64Value& offset(const MapLocationReference_TileIdLinkIdOffset* msg);
  static void set_has_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::google::protobuf::Int64Value& MapLocationReference_TileIdLinkIdOffset::_Internal::tile_id(const MapLocationReference_TileIdLinkIdOffset* msg) {
  return *msg->_impl_.tile_id_;
}
const ::google::protobuf::Int64Value& MapLocationReference_TileIdLinkIdOffset::_Internal::link_id(const MapLocationReference_TileIdLinkIdOffset* msg) {
  return *msg->_impl_.link_id_;
}
const ::google::protobuf::Int64Value& MapLocationReference_TileIdLinkIdOffset::_Internal::offset(const MapLocationReference_TileIdLinkIdOffset* msg) {
  return *msg->_impl_.offset_;
}
void MapLocationReference_TileIdLinkIdOffset::clear_tile_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.tile_id_ != nullptr) _impl_.tile_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void MapLocationReference_TileIdLinkIdOffset::clear_link_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.link_id_ != nullptr) _impl_.link_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void MapLocationReference_TileIdLinkIdOffset::clear_offset() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.offset_ != nullptr) _impl_.offset_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void MapLocationReference_TileIdLinkIdOffset::clear_extension() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.extension_.Clear();
}
MapLocationReference_TileIdLinkIdOffset::MapLocationReference_TileIdLinkIdOffset(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset)
}
inline PROTOBUF_NDEBUG_INLINE MapLocationReference_TileIdLinkIdOffset::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        extension_{visibility, arena, from.extension_} {}

MapLocationReference_TileIdLinkIdOffset::MapLocationReference_TileIdLinkIdOffset(
    ::google::protobuf::Arena* arena,
    const MapLocationReference_TileIdLinkIdOffset& from)
    : ::google::protobuf::Message(arena) {
  MapLocationReference_TileIdLinkIdOffset* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.tile_id_ = (cached_has_bits & 0x00000001u)
                ? CreateMaybeMessage<::google::protobuf::Int64Value>(arena, *from._impl_.tile_id_)
                : nullptr;
  _impl_.link_id_ = (cached_has_bits & 0x00000002u)
                ? CreateMaybeMessage<::google::protobuf::Int64Value>(arena, *from._impl_.link_id_)
                : nullptr;
  _impl_.offset_ = (cached_has_bits & 0x00000004u)
                ? CreateMaybeMessage<::google::protobuf::Int64Value>(arena, *from._impl_.offset_)
                : nullptr;

  // @@protoc_insertion_point(copy_constructor:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset)
}
inline PROTOBUF_NDEBUG_INLINE MapLocationReference_TileIdLinkIdOffset::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        extension_{visibility, arena} {}

inline void MapLocationReference_TileIdLinkIdOffset::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, tile_id_),
           0,
           offsetof(Impl_, offset_) -
               offsetof(Impl_, tile_id_) +
               sizeof(Impl_::offset_));
}
MapLocationReference_TileIdLinkIdOffset::~MapLocationReference_TileIdLinkIdOffset() {
  // @@protoc_insertion_point(destructor:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void MapLocationReference_TileIdLinkIdOffset::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  delete _impl_.tile_id_;
  delete _impl_.link_id_;
  delete _impl_.offset_;
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void MapLocationReference_TileIdLinkIdOffset::Clear() {
// @@protoc_insertion_point(message_clear_start:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.extension_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.tile_id_ != nullptr);
      _impl_.tile_id_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.link_id_ != nullptr);
      _impl_.link_id_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.offset_ != nullptr);
      _impl_.offset_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* MapLocationReference_TileIdLinkIdOffset::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 4, 4, 0, 2> MapLocationReference_TileIdLinkIdOffset::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(MapLocationReference_TileIdLinkIdOffset, _impl_._has_bits_),
    0, // no _extensions_
    15, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294950904,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    4,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_MapLocationReference_TileIdLinkIdOffset_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // .google.protobuf.Int64Value tile_id = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(MapLocationReference_TileIdLinkIdOffset, _impl_.tile_id_)}},
    // .google.protobuf.Int64Value link_id = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 1, PROTOBUF_FIELD_OFFSET(MapLocationReference_TileIdLinkIdOffset, _impl_.link_id_)}},
    // .google.protobuf.Int64Value offset = 3 [(.sensoris.protobuf.types.base.exponent) = 0];
    {::_pbi::TcParser::FastMtS1,
     {26, 2, 2, PROTOBUF_FIELD_OFFSET(MapLocationReference_TileIdLinkIdOffset, _impl_.offset_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    // repeated .google.protobuf.Any extension = 15;
    {::_pbi::TcParser::FastMtR1,
     {122, 63, 3, PROTOBUF_FIELD_OFFSET(MapLocationReference_TileIdLinkIdOffset, _impl_.extension_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .google.protobuf.Int64Value tile_id = 1;
    {PROTOBUF_FIELD_OFFSET(MapLocationReference_TileIdLinkIdOffset, _impl_.tile_id_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .google.protobuf.Int64Value link_id = 2;
    {PROTOBUF_FIELD_OFFSET(MapLocationReference_TileIdLinkIdOffset, _impl_.link_id_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .google.protobuf.Int64Value offset = 3 [(.sensoris.protobuf.types.base.exponent) = 0];
    {PROTOBUF_FIELD_OFFSET(MapLocationReference_TileIdLinkIdOffset, _impl_.offset_), _Internal::kHasBitsOffset + 2, 2,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .google.protobuf.Any extension = 15;
    {PROTOBUF_FIELD_OFFSET(MapLocationReference_TileIdLinkIdOffset, _impl_.extension_), -1, 3,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::google::protobuf::Int64Value>()},
    {::_pbi::TcParser::GetTable<::google::protobuf::Int64Value>()},
    {::_pbi::TcParser::GetTable<::google::protobuf::Int64Value>()},
    {::_pbi::TcParser::GetTable<::google::protobuf::Any>()},
  }}, {{
  }},
};

::uint8_t* MapLocationReference_TileIdLinkIdOffset::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .google.protobuf.Int64Value tile_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        1, _Internal::tile_id(this),
        _Internal::tile_id(this).GetCachedSize(), target, stream);
  }

  // .google.protobuf.Int64Value link_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, _Internal::link_id(this),
        _Internal::link_id(this).GetCachedSize(), target, stream);
  }

  // .google.protobuf.Int64Value offset = 3 [(.sensoris.protobuf.types.base.exponent) = 0];
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        3, _Internal::offset(this),
        _Internal::offset(this).GetCachedSize(), target, stream);
  }

  // repeated .google.protobuf.Any extension = 15;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_extension_size()); i < n; i++) {
    const auto& repfield = this->_internal_extension().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(15, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset)
  return target;
}

::size_t MapLocationReference_TileIdLinkIdOffset::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .google.protobuf.Any extension = 15;
  total_size += 1UL * this->_internal_extension_size();
  for (const auto& msg : this->_internal_extension()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // .google.protobuf.Int64Value tile_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.tile_id_);
    }

    // .google.protobuf.Int64Value link_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.link_id_);
    }

    // .google.protobuf.Int64Value offset = 3 [(.sensoris.protobuf.types.base.exponent) = 0];
    if (cached_has_bits & 0x00000004u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.offset_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData MapLocationReference_TileIdLinkIdOffset::_class_data_ = {
    MapLocationReference_TileIdLinkIdOffset::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* MapLocationReference_TileIdLinkIdOffset::GetClassData() const {
  return &_class_data_;
}

void MapLocationReference_TileIdLinkIdOffset::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<MapLocationReference_TileIdLinkIdOffset*>(&to_msg);
  auto& from = static_cast<const MapLocationReference_TileIdLinkIdOffset&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_extension()->MergeFrom(
      from._internal_extension());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_tile_id()->::google::protobuf::Int64Value::MergeFrom(
          from._internal_tile_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_link_id()->::google::protobuf::Int64Value::MergeFrom(
          from._internal_link_id());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_offset()->::google::protobuf::Int64Value::MergeFrom(
          from._internal_offset());
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void MapLocationReference_TileIdLinkIdOffset::CopyFrom(const MapLocationReference_TileIdLinkIdOffset& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool MapLocationReference_TileIdLinkIdOffset::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* MapLocationReference_TileIdLinkIdOffset::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void MapLocationReference_TileIdLinkIdOffset::InternalSwap(MapLocationReference_TileIdLinkIdOffset* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.extension_.InternalSwap(&other->_impl_.extension_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MapLocationReference_TileIdLinkIdOffset, _impl_.offset_)
      + sizeof(MapLocationReference_TileIdLinkIdOffset::_impl_.offset_)
      - PROTOBUF_FIELD_OFFSET(MapLocationReference_TileIdLinkIdOffset, _impl_.tile_id_)>(
          reinterpret_cast<char*>(&_impl_.tile_id_),
          reinterpret_cast<char*>(&other->_impl_.tile_id_));
}

::google::protobuf::Metadata MapLocationReference_TileIdLinkIdOffset::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto_getter, &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto_once,
      file_level_metadata_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto[23]);
}
// ===================================================================

class MapLocationReference_TileIdObjectId::_Internal {
 public:
  using HasBits = decltype(std::declval<MapLocationReference_TileIdObjectId>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(MapLocationReference_TileIdObjectId, _impl_._has_bits_);
  static const ::google::protobuf::Int64Value& tile_id(const MapLocationReference_TileIdObjectId* msg);
  static void set_has_tile_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::google::protobuf::Int64Value& object_id(const MapLocationReference_TileIdObjectId* msg);
  static void set_has_object_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::google::protobuf::Int64Value& MapLocationReference_TileIdObjectId::_Internal::tile_id(const MapLocationReference_TileIdObjectId* msg) {
  return *msg->_impl_.tile_id_;
}
const ::google::protobuf::Int64Value& MapLocationReference_TileIdObjectId::_Internal::object_id(const MapLocationReference_TileIdObjectId* msg) {
  return *msg->_impl_.object_id_;
}
void MapLocationReference_TileIdObjectId::clear_tile_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.tile_id_ != nullptr) _impl_.tile_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void MapLocationReference_TileIdObjectId::clear_object_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.object_id_ != nullptr) _impl_.object_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void MapLocationReference_TileIdObjectId::clear_extension() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.extension_.Clear();
}
MapLocationReference_TileIdObjectId::MapLocationReference_TileIdObjectId(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId)
}
inline PROTOBUF_NDEBUG_INLINE MapLocationReference_TileIdObjectId::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        extension_{visibility, arena, from.extension_} {}

MapLocationReference_TileIdObjectId::MapLocationReference_TileIdObjectId(
    ::google::protobuf::Arena* arena,
    const MapLocationReference_TileIdObjectId& from)
    : ::google::protobuf::Message(arena) {
  MapLocationReference_TileIdObjectId* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.tile_id_ = (cached_has_bits & 0x00000001u)
                ? CreateMaybeMessage<::google::protobuf::Int64Value>(arena, *from._impl_.tile_id_)
                : nullptr;
  _impl_.object_id_ = (cached_has_bits & 0x00000002u)
                ? CreateMaybeMessage<::google::protobuf::Int64Value>(arena, *from._impl_.object_id_)
                : nullptr;

  // @@protoc_insertion_point(copy_constructor:sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId)
}
inline PROTOBUF_NDEBUG_INLINE MapLocationReference_TileIdObjectId::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        extension_{visibility, arena} {}

inline void MapLocationReference_TileIdObjectId::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, tile_id_),
           0,
           offsetof(Impl_, object_id_) -
               offsetof(Impl_, tile_id_) +
               sizeof(Impl_::object_id_));
}
MapLocationReference_TileIdObjectId::~MapLocationReference_TileIdObjectId() {
  // @@protoc_insertion_point(destructor:sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void MapLocationReference_TileIdObjectId::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  delete _impl_.tile_id_;
  delete _impl_.object_id_;
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void MapLocationReference_TileIdObjectId::Clear() {
// @@protoc_insertion_point(message_clear_start:sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.extension_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.tile_id_ != nullptr);
      _impl_.tile_id_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.object_id_ != nullptr);
      _impl_.object_id_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* MapLocationReference_TileIdObjectId::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 3, 0, 2> MapLocationReference_TileIdObjectId::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(MapLocationReference_TileIdObjectId, _impl_._has_bits_),
    0, // no _extensions_
    15, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294950908,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    3,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_MapLocationReference_TileIdObjectId_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // .google.protobuf.Int64Value tile_id = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(MapLocationReference_TileIdObjectId, _impl_.tile_id_)}},
    // .google.protobuf.Int64Value object_id = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 1, PROTOBUF_FIELD_OFFSET(MapLocationReference_TileIdObjectId, _impl_.object_id_)}},
    // repeated .google.protobuf.Any extension = 15;
    {::_pbi::TcParser::FastMtR1,
     {122, 63, 2, PROTOBUF_FIELD_OFFSET(MapLocationReference_TileIdObjectId, _impl_.extension_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .google.protobuf.Int64Value tile_id = 1;
    {PROTOBUF_FIELD_OFFSET(MapLocationReference_TileIdObjectId, _impl_.tile_id_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .google.protobuf.Int64Value object_id = 2;
    {PROTOBUF_FIELD_OFFSET(MapLocationReference_TileIdObjectId, _impl_.object_id_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .google.protobuf.Any extension = 15;
    {PROTOBUF_FIELD_OFFSET(MapLocationReference_TileIdObjectId, _impl_.extension_), -1, 2,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::google::protobuf::Int64Value>()},
    {::_pbi::TcParser::GetTable<::google::protobuf::Int64Value>()},
    {::_pbi::TcParser::GetTable<::google::protobuf::Any>()},
  }}, {{
  }},
};

::uint8_t* MapLocationReference_TileIdObjectId::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .google.protobuf.Int64Value tile_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        1, _Internal::tile_id(this),
        _Internal::tile_id(this).GetCachedSize(), target, stream);
  }

  // .google.protobuf.Int64Value object_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, _Internal::object_id(this),
        _Internal::object_id(this).GetCachedSize(), target, stream);
  }

  // repeated .google.protobuf.Any extension = 15;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_extension_size()); i < n; i++) {
    const auto& repfield = this->_internal_extension().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(15, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId)
  return target;
}

::size_t MapLocationReference_TileIdObjectId::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .google.protobuf.Any extension = 15;
  total_size += 1UL * this->_internal_extension_size();
  for (const auto& msg : this->_internal_extension()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // .google.protobuf.Int64Value tile_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.tile_id_);
    }

    // .google.protobuf.Int64Value object_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.object_id_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData MapLocationReference_TileIdObjectId::_class_data_ = {
    MapLocationReference_TileIdObjectId::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* MapLocationReference_TileIdObjectId::GetClassData() const {
  return &_class_data_;
}

void MapLocationReference_TileIdObjectId::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<MapLocationReference_TileIdObjectId*>(&to_msg);
  auto& from = static_cast<const MapLocationReference_TileIdObjectId&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_extension()->MergeFrom(
      from._internal_extension());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_tile_id()->::google::protobuf::Int64Value::MergeFrom(
          from._internal_tile_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_object_id()->::google::protobuf::Int64Value::MergeFrom(
          from._internal_object_id());
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void MapLocationReference_TileIdObjectId::CopyFrom(const MapLocationReference_TileIdObjectId& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool MapLocationReference_TileIdObjectId::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* MapLocationReference_TileIdObjectId::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void MapLocationReference_TileIdObjectId::InternalSwap(MapLocationReference_TileIdObjectId* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.extension_.InternalSwap(&other->_impl_.extension_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MapLocationReference_TileIdObjectId, _impl_.object_id_)
      + sizeof(MapLocationReference_TileIdObjectId::_impl_.object_id_)
      - PROTOBUF_FIELD_OFFSET(MapLocationReference_TileIdObjectId, _impl_.tile_id_)>(
          reinterpret_cast<char*>(&_impl_.tile_id_),
          reinterpret_cast<char*>(&other->_impl_.tile_id_));
}

::google::protobuf::Metadata MapLocationReference_TileIdObjectId::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto_getter, &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto_once,
      file_level_metadata_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto[24]);
}
// ===================================================================

class MapLocationReference::_Internal {
 public:
  using HasBits = decltype(std::declval<MapLocationReference>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(MapLocationReference, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::sensoris::protobuf::types::spatial::MapLocationReference, _impl_._oneof_case_);
  static const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& position_and_accuracy(const MapLocationReference* msg);
  static void set_has_position_and_accuracy(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::google::protobuf::Int64Value& z_level(const MapLocationReference* msg);
  static void set_has_z_level(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset& tile_link_offset_reference(const MapLocationReference* msg);
  static const ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId& map_object_id(const MapLocationReference* msg);
};

const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& MapLocationReference::_Internal::position_and_accuracy(const MapLocationReference* msg) {
  return *msg->_impl_.position_and_accuracy_;
}
const ::google::protobuf::Int64Value& MapLocationReference::_Internal::z_level(const MapLocationReference* msg) {
  return *msg->_impl_.z_level_;
}
const ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset& MapLocationReference::_Internal::tile_link_offset_reference(const MapLocationReference* msg) {
  return *msg->_impl_.map_based_reference_.tile_link_offset_reference_;
}
const ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId& MapLocationReference::_Internal::map_object_id(const MapLocationReference* msg) {
  return *msg->_impl_.map_based_reference_.map_object_id_;
}
void MapLocationReference::clear_z_level() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.z_level_ != nullptr) _impl_.z_level_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void MapLocationReference::set_allocated_tile_link_offset_reference(::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset* tile_link_offset_reference) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_map_based_reference();
  if (tile_link_offset_reference) {
    ::google::protobuf::Arena* submessage_arena = tile_link_offset_reference->GetArena();
    if (message_arena != submessage_arena) {
      tile_link_offset_reference = ::google::protobuf::internal::GetOwnedMessage(message_arena, tile_link_offset_reference, submessage_arena);
    }
    set_has_tile_link_offset_reference();
    _impl_.map_based_reference_.tile_link_offset_reference_ = tile_link_offset_reference;
  }
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.MapLocationReference.tile_link_offset_reference)
}
void MapLocationReference::set_allocated_map_object_id(::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId* map_object_id) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_map_based_reference();
  if (map_object_id) {
    ::google::protobuf::Arena* submessage_arena = map_object_id->GetArena();
    if (message_arena != submessage_arena) {
      map_object_id = ::google::protobuf::internal::GetOwnedMessage(message_arena, map_object_id, submessage_arena);
    }
    set_has_map_object_id();
    _impl_.map_based_reference_.map_object_id_ = map_object_id;
  }
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.MapLocationReference.map_object_id)
}
void MapLocationReference::clear_extension() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.extension_.Clear();
}
MapLocationReference::MapLocationReference(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:sensoris.protobuf.types.spatial.MapLocationReference)
}
inline PROTOBUF_NDEBUG_INLINE MapLocationReference::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        extension_{visibility, arena, from.extension_},
        map_based_reference_{},
        _oneof_case_{from._oneof_case_[0]} {}

MapLocationReference::MapLocationReference(
    ::google::protobuf::Arena* arena,
    const MapLocationReference& from)
    : ::google::protobuf::Message(arena) {
  MapLocationReference* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.position_and_accuracy_ = (cached_has_bits & 0x00000001u)
                ? CreateMaybeMessage<::sensoris::protobuf::types::spatial::PositionAndAccuracy>(arena, *from._impl_.position_and_accuracy_)
                : nullptr;
  _impl_.z_level_ = (cached_has_bits & 0x00000002u)
                ? CreateMaybeMessage<::google::protobuf::Int64Value>(arena, *from._impl_.z_level_)
                : nullptr;
  switch (map_based_reference_case()) {
    case MAP_BASED_REFERENCE_NOT_SET:
      break;
      case kTileLinkOffsetReference:
        _impl_.map_based_reference_.tile_link_offset_reference_ = CreateMaybeMessage<::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset>(arena, *from._impl_.map_based_reference_.tile_link_offset_reference_);
        break;
      case kMapObjectId:
        _impl_.map_based_reference_.map_object_id_ = CreateMaybeMessage<::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId>(arena, *from._impl_.map_based_reference_.map_object_id_);
        break;
  }

  // @@protoc_insertion_point(copy_constructor:sensoris.protobuf.types.spatial.MapLocationReference)
}
inline PROTOBUF_NDEBUG_INLINE MapLocationReference::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        extension_{visibility, arena},
        map_based_reference_{},
        _oneof_case_{} {}

inline void MapLocationReference::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, position_and_accuracy_),
           0,
           offsetof(Impl_, z_level_) -
               offsetof(Impl_, position_and_accuracy_) +
               sizeof(Impl_::z_level_));
}
MapLocationReference::~MapLocationReference() {
  // @@protoc_insertion_point(destructor:sensoris.protobuf.types.spatial.MapLocationReference)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void MapLocationReference::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  delete _impl_.position_and_accuracy_;
  delete _impl_.z_level_;
  if (has_map_based_reference()) {
    clear_map_based_reference();
  }
  _impl_.~Impl_();
}

void MapLocationReference::clear_map_based_reference() {
// @@protoc_insertion_point(one_of_clear_start:sensoris.protobuf.types.spatial.MapLocationReference)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  switch (map_based_reference_case()) {
    case kTileLinkOffsetReference: {
      if (GetArena() == nullptr) {
        delete _impl_.map_based_reference_.tile_link_offset_reference_;
      }
      break;
    }
    case kMapObjectId: {
      if (GetArena() == nullptr) {
        delete _impl_.map_based_reference_.map_object_id_;
      }
      break;
    }
    case MAP_BASED_REFERENCE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = MAP_BASED_REFERENCE_NOT_SET;
}


PROTOBUF_NOINLINE void MapLocationReference::Clear() {
// @@protoc_insertion_point(message_clear_start:sensoris.protobuf.types.spatial.MapLocationReference)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.extension_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.position_and_accuracy_ != nullptr);
      _impl_.position_and_accuracy_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.z_level_ != nullptr);
      _impl_.z_level_->Clear();
    }
  }
  clear_map_based_reference();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* MapLocationReference::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 5, 5, 0, 2> MapLocationReference::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(MapLocationReference, _impl_._has_bits_),
    0, // no _extensions_
    15, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294950896,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    5,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_MapLocationReference_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // .sensoris.protobuf.types.spatial.PositionAndAccuracy position_and_accuracy = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(MapLocationReference, _impl_.position_and_accuracy_)}},
    // .google.protobuf.Int64Value z_level = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 1, PROTOBUF_FIELD_OFFSET(MapLocationReference, _impl_.z_level_)}},
    // repeated .google.protobuf.Any extension = 15;
    {::_pbi::TcParser::FastMtR1,
     {122, 63, 4, PROTOBUF_FIELD_OFFSET(MapLocationReference, _impl_.extension_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .sensoris.protobuf.types.spatial.PositionAndAccuracy position_and_accuracy = 1;
    {PROTOBUF_FIELD_OFFSET(MapLocationReference, _impl_.position_and_accuracy_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .google.protobuf.Int64Value z_level = 2;
    {PROTOBUF_FIELD_OFFSET(MapLocationReference, _impl_.z_level_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset tile_link_offset_reference = 3;
    {PROTOBUF_FIELD_OFFSET(MapLocationReference, _impl_.map_based_reference_.tile_link_offset_reference_), _Internal::kOneofCaseOffset + 0, 2,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId map_object_id = 4;
    {PROTOBUF_FIELD_OFFSET(MapLocationReference, _impl_.map_based_reference_.map_object_id_), _Internal::kOneofCaseOffset + 0, 3,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .google.protobuf.Any extension = 15;
    {PROTOBUF_FIELD_OFFSET(MapLocationReference, _impl_.extension_), -1, 4,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::PositionAndAccuracy>()},
    {::_pbi::TcParser::GetTable<::google::protobuf::Int64Value>()},
    {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset>()},
    {::_pbi::TcParser::GetTable<::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId>()},
    {::_pbi::TcParser::GetTable<::google::protobuf::Any>()},
  }}, {{
  }},
};

::uint8_t* MapLocationReference::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sensoris.protobuf.types.spatial.MapLocationReference)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .sensoris.protobuf.types.spatial.PositionAndAccuracy position_and_accuracy = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        1, _Internal::position_and_accuracy(this),
        _Internal::position_and_accuracy(this).GetCachedSize(), target, stream);
  }

  // .google.protobuf.Int64Value z_level = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, _Internal::z_level(this),
        _Internal::z_level(this).GetCachedSize(), target, stream);
  }

  switch (map_based_reference_case()) {
    case kTileLinkOffsetReference: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          3, _Internal::tile_link_offset_reference(this),
          _Internal::tile_link_offset_reference(this).GetCachedSize(), target, stream);
      break;
    }
    case kMapObjectId: {
      target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
          4, _Internal::map_object_id(this),
          _Internal::map_object_id(this).GetCachedSize(), target, stream);
      break;
    }
    default:
      break;
  }
  // repeated .google.protobuf.Any extension = 15;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_extension_size()); i < n; i++) {
    const auto& repfield = this->_internal_extension().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(15, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sensoris.protobuf.types.spatial.MapLocationReference)
  return target;
}

::size_t MapLocationReference::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sensoris.protobuf.types.spatial.MapLocationReference)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .google.protobuf.Any extension = 15;
  total_size += 1UL * this->_internal_extension_size();
  for (const auto& msg : this->_internal_extension()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // .sensoris.protobuf.types.spatial.PositionAndAccuracy position_and_accuracy = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.position_and_accuracy_);
    }

    // .google.protobuf.Int64Value z_level = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.z_level_);
    }

  }
  switch (map_based_reference_case()) {
    // .sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset tile_link_offset_reference = 3;
    case kTileLinkOffsetReference: {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.map_based_reference_.tile_link_offset_reference_);
      break;
    }
    // .sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId map_object_id = 4;
    case kMapObjectId: {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.map_based_reference_.map_object_id_);
      break;
    }
    case MAP_BASED_REFERENCE_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData MapLocationReference::_class_data_ = {
    MapLocationReference::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* MapLocationReference::GetClassData() const {
  return &_class_data_;
}

void MapLocationReference::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<MapLocationReference*>(&to_msg);
  auto& from = static_cast<const MapLocationReference&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:sensoris.protobuf.types.spatial.MapLocationReference)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_extension()->MergeFrom(
      from._internal_extension());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_position_and_accuracy()->::sensoris::protobuf::types::spatial::PositionAndAccuracy::MergeFrom(
          from._internal_position_and_accuracy());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_z_level()->::google::protobuf::Int64Value::MergeFrom(
          from._internal_z_level());
    }
  }
  switch (from.map_based_reference_case()) {
    case kTileLinkOffsetReference: {
      _this->_internal_mutable_tile_link_offset_reference()->::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset::MergeFrom(
          from._internal_tile_link_offset_reference());
      break;
    }
    case kMapObjectId: {
      _this->_internal_mutable_map_object_id()->::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId::MergeFrom(
          from._internal_map_object_id());
      break;
    }
    case MAP_BASED_REFERENCE_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void MapLocationReference::CopyFrom(const MapLocationReference& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sensoris.protobuf.types.spatial.MapLocationReference)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool MapLocationReference::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* MapLocationReference::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void MapLocationReference::InternalSwap(MapLocationReference* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.extension_.InternalSwap(&other->_impl_.extension_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MapLocationReference, _impl_.z_level_)
      + sizeof(MapLocationReference::_impl_.z_level_)
      - PROTOBUF_FIELD_OFFSET(MapLocationReference, _impl_.position_and_accuracy_)>(
          reinterpret_cast<char*>(&_impl_.position_and_accuracy_),
          reinterpret_cast<char*>(&other->_impl_.position_and_accuracy_));
  swap(_impl_.map_based_reference_, other->_impl_.map_based_reference_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::google::protobuf::Metadata MapLocationReference::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto_getter, &descriptor_table_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto_once,
      file_level_metadata_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto[25]);
}
// @@protoc_insertion_point(namespace_scope)
}  // namespace spatial
}  // namespace types
}  // namespace protobuf
}  // namespace sensoris
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google
// @@protoc_insertion_point(global_scope)
#include "google/protobuf/port_undef.inc"
